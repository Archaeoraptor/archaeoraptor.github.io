<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>止息&#39;幻想乡</title>
  
  <subtitle>风雪夜归人</subtitle>
  <link href="https://zhangjk98.xyz/atom.xml" rel="self"/>
  
  <link href="https://zhangjk98.xyz/"/>
  <updated>2024-02-04T05:57:25.000Z</updated>
  <id>https://zhangjk98.xyz/</id>
  
  <author>
    <name>zhixi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用patchelf更改可执行文件的动态库和glibc版本</title>
    <link href="https://zhangjk98.xyz/patchelf/"/>
    <id>https://zhangjk98.xyz/patchelf/</id>
    <published>2024-02-04T05:57:25.000Z</published>
    <updated>2024-02-04T05:57:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>有时有一些比较无奈的场景，比如glibc版本太低了跑不起来。又或者动态库找的路径或者版本不对。这个时候我们就可以利用patchelf修改，以免重新编译。</p><span id="more"></span><h2 id="patchelf"><a href="#patchelf" class="headerlink" title="patchelf"></a>patchelf</h2><p>patchelf是一个很好用的工具，可以用来编辑rpath，也可以用来指定glibc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S patchelf</span><br></pre></td></tr></table></figure><p>然后会下载到libs目录下面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">~/codes/blog master !1 ❯ patchelf --<span class="built_in">help</span>                                                                                            7s</span><br><span class="line">syntax: patchelf</span><br><span class="line">  [--set-interpreter FILENAME] 指定ld</span><br><span class="line">  [--page-size SIZE] 指定页大小</span><br><span class="line">  [--print-interpreter]</span><br><span class="line">  [--print-os-abi]              Prints <span class="string">&#x27;EI_OSABI&#x27;</span> field of ELF header</span><br><span class="line">  [--set-os-abi ABI]            Sets <span class="string">&#x27;EI_OSABI&#x27;</span> field of ELF header to ABI.</span><br><span class="line">  [--print-soname]              Prints <span class="string">&#x27;DT_SONAME&#x27;</span> entry of .dynamic section. Raises an error <span class="keyword">if</span> DT_SONAME doesn<span class="string">&#x27;t exist</span></span><br><span class="line"><span class="string">  [--set-soname SONAME]         Sets &#x27;</span>DT_SONAME<span class="string">&#x27; entry to SONAME. 设置DT_SONAME</span></span><br><span class="line"><span class="string">  [--set-rpath RPATH]   指定rpath</span></span><br><span class="line"><span class="string">  [--add-rpath RPATH]</span></span><br><span class="line"><span class="string">  [--remove-rpath]</span></span><br><span class="line"><span class="string">  [--shrink-rpath]</span></span><br><span class="line"><span class="string">  [--allowed-rpath-prefixes PREFIXES]           With &#x27;</span>--shrink-rpath<span class="string">&#x27;, reject rpath entries not starting with the allowed prefix</span></span><br><span class="line"><span class="string">  [--print-rpath]</span></span><br><span class="line"><span class="string">  [--force-rpath]</span></span><br><span class="line"><span class="string">  [--add-needed LIBRARY] </span></span><br><span class="line"><span class="string">  [--remove-needed LIBRARY]</span></span><br><span class="line"><span class="string">  [--replace-needed LIBRARY NEW_LIBRARY]</span></span><br><span class="line"><span class="string">  [--print-needed]</span></span><br><span class="line"><span class="string">  [--no-default-lib]</span></span><br><span class="line"><span class="string">  [--no-sort]           Do not sort program+section headers; useful for debugging patchelf.</span></span><br><span class="line"><span class="string">  [--clear-symbol-version SYMBOL]</span></span><br><span class="line"><span class="string">  [--add-debug-tag]</span></span><br><span class="line"><span class="string">  [--print-execstack]           Prints whether the object requests an executable stack</span></span><br><span class="line"><span class="string">  [--clear-execstack]</span></span><br><span class="line"><span class="string">  [--set-execstack]</span></span><br><span class="line"><span class="string">  [--rename-dynamic-symbols NAME_MAP_FILE]      Renames dynamic symbols. The map file should contain two symbols (old_name new_name) per line</span></span><br><span class="line"><span class="string">  [--output FILE]</span></span><br><span class="line"><span class="string">  [--debug]</span></span><br><span class="line"><span class="string">  [--version]</span></span><br><span class="line"><span class="string">  FILENAME...</span></span><br></pre></td></tr></table></figure><p>需要patch的glibc和动态库可以下载glibc-all-in-one，或者从aur装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/matrix1001/glibc-all-in-one</span><br><span class="line">python update-list</span><br><span class="line"><span class="built_in">cat</span> list</span><br><span class="line"><span class="comment"># 下载对应版本的链接器</span></span><br><span class="line"><span class="comment"># ubuntu18可能需要下载zstd</span></span><br><span class="line"><span class="comment"># apt install zstd</span></span><br><span class="line">./download 2.38-3ubuntu1_amd64</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>例子：vscode 1.86的remote要求glibc 2.28及以上，于是在各种祖传老服务器就连不上了。<br>vscode这帮人乐死我了，他们甚至不愿意在breaking changes之前发个警告，不愧是win10更新蓝屏搞到怨声载道的巨硬。  </p><p>要知道一周之前就有人发issue讨论这个问题：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzIwMzk2Nw==">https://github.com/microsoft/vscode/issues/203967<i class="fa fa-external-link-alt"></i></span> 结果官方给出的方案就是手动下载一个portable版本，用老版本</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC92c2NvZGUvaXNzdWVzLzIwMzk2Nw==">https://github.com/microsoft/vscode/issues/203967<i class="fa fa-external-link-alt"></i></span> 于是更新之后果不其然被骂惨了</p><p>当然你也可以给祖传服务器升级glibc，不过glibc这么重要的依赖，祖宗之法不可变。当然是想办法改改vscode了，这个时候再次轮到patchelf</p><p>首先移除<code>.vscode-server</code>，然后用vscode remote重新连接一遍。</p><p>然后用patchelf修改vscode server需要的node，使用自己下载的glibc的链接器, 并替换rpath</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf --set-interpreter ./glibc-all-in-one/libs/2.38-3ubuntu1_amd64/ld-linux-x86-64.so.2 --set-rpath ./glibc-all-in-one/libs/2.38-3ubuntu1_amd64/:./mygcc/lib64 --force-rpath ~/.vscode-server/bin/05047486b6df5eb8d44b2ecd70ea3bdf775fd937/node</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有时有一些比较无奈的场景，比如glibc版本太低了跑不起来。又或者动态库找的路径或者版本不对。这个时候我们就可以利用patchelf修改，以免重新编译。&lt;/p&gt;</summary>
    
    
    
    
    <category term="patchelf" scheme="https://zhangjk98.xyz/tags/patchelf/"/>
    
  </entry>
  
  <entry>
    <title>C++返回值类型后置</title>
    <link href="https://zhangjk98.xyz/type-anastrophe/"/>
    <id>https://zhangjk98.xyz/type-anastrophe/</id>
    <published>2024-01-09T02:59:10.000Z</published>
    <updated>2024-01-09T02:59:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>不喜欢倒装吗你们</p><span id="more"></span><p>类型后置的语言一般长这样，比如go，函数的返回值类型是放在后面的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mul</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rust也是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">mul</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甚至py也可以指定函数返回值类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a: <span class="built_in">int</span>, b: <span class="built_in">int</span> </span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> a*b</span><br></pre></td></tr></table></figure><p>但是大家熟悉的c，函数是这样，返回值类型在最前面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反而是c语言的类型前置才像个异类。当初从c入坑go的时候，总感觉后置比较别扭，后来发现是我被c毒害的太深了：<span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvYmxvZy9kZWNsYXJhdGlvbi1zeW50YXg=">Go’s declaration syntax<i class="fa fa-external-link-alt"></i></span>  </p><p>这是c，返回值类型前置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*(*fp)(<span class="type">int</span> (*)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span>))(<span class="type">int</span>, <span class="type">int</span>)</span><br></pre></td></tr></table></figure><p>这是go，返回值类型甩在后面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f <span class="title function_">func</span><span class="params">(func(<span class="type">int</span>,<span class="type">int</span>) <span class="type">int</span>, <span class="type">int</span>)</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> <span class="type">int</span></span><br></pre></td></tr></table></figure><p>写一个闭包看起来也很自然：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> a+b &#125; (<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>写多了go可能会感觉到，go里面很少出现c语言一样一大坨*号和括号挤在一起，区分不出来这到底是个啥。函数返回值后置就比较舒服，一般写函数的时候都是返回值在后面的，lambda表达式也是。</p><p>$$<br>f(x, y) &#x3D; x \times y<br>$$</p><p>对于空的返回值，扔在后面直接不写看起来也更加自然。一个void总是怪怪的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">echo</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上有相当多的文章教大家怎么识别c语言的复杂的类型定义。什么函数指着呐，什么指针函数呐。甚至有一些网站，比如<span class="exturl" data-url="aHR0cHM6Ly9jZGVsLm9yZy8=">cdel<i class="fa fa-external-link-alt"></i></span>专门给你拆解这是个啥。别的语言为啥就没有呢？</p><p>后来接触了好多返回值后置的语言，我才意识到：看不c语言这一大坨东西，不是我的问题，是c的问题。。。你看下面这一串是个啥，你不说这是c我都要幻视了以为是lisp呢。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 括号乱起来了</span></span><br><span class="line"><span class="type">int</span> (*(*foo)())()</span><br><span class="line"><span class="comment">// 下面这个更有内味</span></span><br><span class="line">(*(<span class="type">void</span>(*)())<span class="number">0</span>)();</span><br></pre></td></tr></table></figure><p>c++11也有类型后置的写法，前面使用auto占位。比较符合我先写输入再写输出的喜欢，现在rust和go写多了经常c++一起手就在先思考一下函数返回值类型那里愣住了五秒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, b)</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配合decltype可以实现类型推导。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">((*(T1 *) <span class="number">0</span>) + (*(T2 *) <span class="number">0</span>))</span> <span class="title">mul</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用auto占位写成后置</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">mul</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(a * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> v = <span class="built_in">mul</span>(<span class="number">1.0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> u = <span class="built_in">mul</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvYmxvZy9kZWNsYXJhdGlvbi1zeW50YXg=">Go’s declaration syntax<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jLWZhcS5jb20vZGVjbC9zcGlyYWwuYW5kZXJzb24uaHRtbA==">The &#96;&#96;Clockwise&#x2F;Spiral Rule’’<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不喜欢倒装吗你们&lt;/p&gt;</summary>
    
    
    
    
    <category term="type" scheme="https://zhangjk98.xyz/tags/type/"/>
    
    <category term="c" scheme="https://zhangjk98.xyz/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>记一次git错误：“error object file .git/objects/.... is empty”</title>
    <link href="https://zhangjk98.xyz/git-error-object-file-is-empty/"/>
    <id>https://zhangjk98.xyz/git-error-object-file-is-empty/</id>
    <published>2024-01-08T00:53:04.000Z</published>
    <updated>2024-01-08T00:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>git又坏了。系统又卡死了，tty都调不出来，强按关机键重启后出现的。应该是git操作中途强退导致的数据损毁。见<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3MDYyMTUvaG93LWNhbi1pLWZpeC10aGUtZ2l0LWVycm9yLW9iamVjdC1maWxlLWlzLWVtcHR5">How can I fix the Git error “object file … is empty”?<i class="fa fa-external-link-alt"></i></span> </p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$git</span> status</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">fatal: bad object HEAD</span><br></pre></td></tr></table></figure><p>修复倒也简单，之前传了一份到github上了。把本地的repo删了重新clone一遍就好了。</p><p>但是这些断点损毁的问题还挺好玩的，尝试一下能不能手动修复。先执行fsck检查一下，出现了一堆error。错误主要有</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">~/codes/cg/ray_tracing ❯ git fsck --full                                 ✘ INT</span><br><span class="line">error: inflate: data stream error (unknown compression method)</span><br><span class="line">error: unable to unpack header of .git/objects/30/c28c65105992b8bf597f0388378c4724e163a5</span><br><span class="line">error: 30c28c65105992b8bf597f0388378c4724e163a5: object corrupt or missing: .git/objects/30/c28c65105992b8bf597f0388378c4724e163a5</span><br><span class="line">error: object file .git/objects/35/bfb29f7bf7d9940faa7b6859a1c3df91cca116 is empty</span><br><span class="line">error: unable to mmap .git/objects/35/bfb29f7bf7d9940faa7b6859a1c3df91cca116: No such file or directory</span><br><span class="line">error: 35bfb29f7bf7d9940faa7b6859a1c3df91cca116: object corrupt or missing: .git/objects/35/bfb29f7bf7d9940faa7b6859a1c3df91cca116</span><br><span class="line">error: object file .git/objects/36/c81d09506146f59c67b572ad816bbecb60db1c is empty</span><br><span class="line">error: unable to mmap .git/objects/36/c81d09506146f59c67b572ad816bbecb60db1c: No such file or directory</span><br><span class="line">error: 36c81d09506146f59c67b572ad816bbecb60db1c: object corrupt or missing: .git/objects/36/c81d09506146f59c67b572ad816bbecb60db1c</span><br><span class="line">error: object file .git/objects/56/1f5c8ca81e1ecb6f98c614b3d5f31309c1b037 is empty</span><br><span class="line">error: unable to mmap .git/objects/56/1f5c8ca81e1ecb6f98c614b3d5f31309c1b037: No such file or directory</span><br><span class="line">error: 561f5c8ca81e1ecb6f98c614b3d5f31309c1b037: object corrupt or missing: .git/objects/56/1f5c8ca81e1ecb6f98c614b3d5f31309c1b037</span><br><span class="line">error: object file .git/objects/86/74f05d2355cb5ca9b32cdc2c2939f2fcc921d4 is empty</span><br><span class="line">error: unable to mmap .git/objects/86/74f05d2355cb5ca9b32cdc2c2939f2fcc921d4: No such file or directory</span><br><span class="line">error: 8674f05d2355cb5ca9b32cdc2c2939f2fcc921d4: object corrupt or missing: .git/objects/86/74f05d2355cb5ca9b32cdc2c2939f2fcc921d4</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: unable to mmap .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0: No such file or directory</span><br><span class="line">error: 9045d3aeb3539443f6b0a904935e9eb559fa5ef0: object corrupt or missing: .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: inflate: data stream error (unknown compression method)</span><br><span class="line">error: unable to unpack header of .git/objects/c1/d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br><span class="line">error: c1d4bc9d219d8b729d9b7e8a865f8972beac3014: object corrupt or missing: .git/objects/c1/d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br><span class="line">error: object file .git/objects/cb/4fbbc9dcff805f550461cf27a860c1f884b77c is empty</span><br><span class="line">error: unable to mmap .git/objects/cb/4fbbc9dcff805f550461cf27a860c1f884b77c: No such file or directory</span><br><span class="line">error: cb4fbbc9dcff805f550461cf27a860c1f884b77c: object corrupt or missing: .git/objects/cb/4fbbc9dcff805f550461cf27a860c1f884b77c</span><br><span class="line">error: object file .git/objects/d2/f1a78796402cb9858f66c7fe0d3dd90855fac1 is empty</span><br><span class="line">error: unable to mmap .git/objects/d2/f1a78796402cb9858f66c7fe0d3dd90855fac1: No such file or directory</span><br><span class="line">error: d2f1a78796402cb9858f66c7fe0d3dd90855fac1: object corrupt or missing: .git/objects/d2/f1a78796402cb9858f66c7fe0d3dd90855fac1</span><br><span class="line">error: object file .git/objects/da/3cd6e317e0deb80fd7beda238d7baae23d2e60 is empty</span><br><span class="line">error: unable to mmap .git/objects/da/3cd6e317e0deb80fd7beda238d7baae23d2e60: No such file or directory</span><br><span class="line">error: da3cd6e317e0deb80fd7beda238d7baae23d2e60: object corrupt or missing: .git/objects/da/3cd6e317e0deb80fd7beda238d7baae23d2e60</span><br><span class="line">error: object file .git/objects/e3/d3c4a99ac521fd488886206c5677f1b7f526b7 is empty</span><br><span class="line">error: unable to mmap .git/objects/e3/d3c4a99ac521fd488886206c5677f1b7f526b7: No such file or directory</span><br><span class="line">error: e3d3c4a99ac521fd488886206c5677f1b7f526b7: object corrupt or missing: .git/objects/e3/d3c4a99ac521fd488886206c5677f1b7f526b7</span><br><span class="line">error: object file .git/objects/f3/af97d3545900a65d722ee8ba661bad4e632884 is empty</span><br><span class="line">error: unable to mmap .git/objects/f3/af97d3545900a65d722ee8ba661bad4e632884: No such file or directory</span><br><span class="line">error: f3af97d3545900a65d722ee8ba661bad4e632884: object corrupt or missing: .git/objects/f3/af97d3545900a65d722ee8ba661bad4e632884</span><br><span class="line">error: object file .git/objects/fb/2dc1179dc5274f930b0c0a030c38cbb1c014fd is empty</span><br><span class="line">error: unable to mmap .git/objects/fb/2dc1179dc5274f930b0c0a030c38cbb1c014fd: No such file or directory</span><br><span class="line">error: fb2dc1179dc5274f930b0c0a030c38cbb1c014fd: object corrupt or missing: .git/objects/fb/2dc1179dc5274f930b0c0a030c38cbb1c014fd</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: refs/heads/master: invalid sha1 pointer 9045d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: refs/remotes/origin/master: invalid sha1 pointer 9045d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: object file .git/objects/90/45d3aeb3539443f6b0a904935e9eb559fa5ef0 is empty</span><br><span class="line">error: HEAD: invalid sha1 pointer 9045d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: refs/heads/master: invalid reflog entry 9045d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: HEAD: invalid reflog entry 9045d3aeb3539443f6b0a904935e9eb559fa5ef0</span><br><span class="line">error: object file .git/objects/36/c81d09506146f59c67b572ad816bbecb60db1c is empty</span><br><span class="line">error: object file .git/objects/36/c81d09506146f59c67b572ad816bbecb60db1c is empty</span><br><span class="line">error: 36c81d09506146f59c67b572ad816bbecb60db1c: invalid sha1 pointer <span class="keyword">in</span> cache-tree of .git/index</span><br><span class="line">missing blob 30c28c65105992b8bf597f0388378c4724e163a5</span><br><span class="line">missing blob 35bfb29f7bf7d9940faa7b6859a1c3df91cca116</span><br><span class="line">dangling tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904</span><br><span class="line">missing blob 561f5c8ca81e1ecb6f98c614b3d5f31309c1b037</span><br><span class="line">missing blob 8674f05d2355cb5ca9b32cdc2c2939f2fcc921d4</span><br><span class="line">missing blob c1d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br><span class="line">missing blob cb4fbbc9dcff805f550461cf27a860c1f884b77c</span><br><span class="line">missing blob d2f1a78796402cb9858f66c7fe0d3dd90855fac1</span><br><span class="line">missing blob da3cd6e317e0deb80fd7beda238d7baae23d2e60</span><br><span class="line">missing blob e3d3c4a99ac521fd488886206c5677f1b7f526b7</span><br><span class="line">missing blob fb2dc1179dc5274f930b0c0a030c38cbb1c014fd</span><br></pre></td></tr></table></figure><p>object corrupt or missing 和 empty object的问题可以直接删除损坏的object，然后接着修下面的报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~/codes/cg master ✚ ? ❯ git fsck --full                                          </span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">broken <span class="built_in">link</span> from    tree f3af97d3545900a65d722ee8ba661bad4e632884</span><br><span class="line">              to    blob c1d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br><span class="line">dangling tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904</span><br><span class="line">missing blob c1d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br></pre></td></tr></table></figure><p>broken link的问题可以通过删除git的index后重新生成解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> .git/index</span><br><span class="line">git reset</span><br></pre></td></tr></table></figure><p>此时git能正常使用了，但还是存在dangling tree 和 missing blob，dangling tree不是错误，见<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTk1NTcxMy9naXQtZGFuZ2xpbmctYmxvYnM=">git: dangling blobs<i class="fa fa-external-link-alt"></i></span>  </p><p>missing blob 的问题可以找到有问题的blob对应的文件，然后重新生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/codes/cg master ● ⍟1 ❯ git ls-tree -r HEAD | grep c1d4bc9d219d8b729d9b7e8a865f8972beac3014</span><br><span class="line">100644 blob c1d4bc9d219d8b729d9b7e8a865f8972beac3014    ray_tracing/CMakeLists.txt</span><br><span class="line">git hash-object -w ray_tracing/CMakeLists.txt</span><br></pre></td></tr></table></figure><p>或者用<code>git reflog</code>直接删了也可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog expire --expire=now --all</span><br></pre></td></tr></table></figure><p>修复完成，收工。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/codes/cg master ❯ git fsck --full                              </span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">Checking objects: 100% (128/128), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;git又坏了。系统又卡死了，tty都调不出来，强按关机键重启后出现的。应该是git操作中途强退导致的数据损毁。见&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE3MDYyMTUvaG93LWNhbi1pLWZpeC10aGUtZ2l0LWVycm9yLW9iamVjdC1maWxlLWlzLWVtcHR5&quot;&gt;How can I fix the Git error “object file … is empty”?&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt;</summary>
    
    
    
    
    <category term="git" scheme="https://zhangjk98.xyz/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Git存储结构与实现</title>
    <link href="https://zhangjk98.xyz/git-structure/"/>
    <id>https://zhangjk98.xyz/git-structure/</id>
    <published>2023-11-13T08:00:07.000Z</published>
    <updated>2023-11-13T08:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>突然发现git还挺有意思的，实现很像kv存储文件系统。</p><span id="more"></span><p>有一天博客的repo在vscode侧栏source control显示不出更改文件和详情了，只有一个几个更改的文件个数，但是其他的repo又是好的。用sublime merge和<code>git diff</code>,<code>git status</code>等其他工具和命令也都是好的。（别问我为什么不用sublime merge，我现在被迫）于是研究了半天<code>.git</code>文件夹和git原理试图搞清哪出问题了。（最后发现是submodule的问题）之前在hackergame2023游玩的时候有道题是从 git repo 里找flag，然后又去拆<code>.git</code>文件夹。看着看着发现git有点意思。</p><p>先来看一下git的目录结构，<code>.git</code>目录下面文件大概长这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> .git</span><br><span class="line">&gt;tree -L 1</span><br><span class="line">.</span><br><span class="line">├── branches</span><br><span class="line">├── COMMIT_EDITMSG</span><br><span class="line">├── config</span><br><span class="line">├── description</span><br><span class="line">├── FETCH_HEAD</span><br><span class="line">├── HEAD</span><br><span class="line">├── hooks</span><br><span class="line">├── index</span><br><span class="line">├── info</span><br><span class="line">├── logs</span><br><span class="line">├── objects</span><br><span class="line">├── ORIG_HEAD</span><br><span class="line">├── packed-refs</span><br><span class="line">└── refs</span><br></pre></td></tr></table></figure><p>用<code>ncdu</code>看一下文件的大小，发现Objects是很大的</p><p><code>objects</code>下面有info和pack，以及存放的所有对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">cd</span> objects &amp;&amp; <span class="built_in">ls</span></span><br><span class="line">03  15  27  35  49  5e  64  6c  7b  84  99  ac  bf  c6  d3  e0  ee  fd</span><br><span class="line">0b  17  2a  37  4e  60  65  6e  7c  85  9c  ba  c0  c7  d4  e4  f0  fe</span><br><span class="line">0d  20  2d  40  53  62  69  72  7f  87  a4  bc  c1  c9  <span class="built_in">dd</span>  ea  f5  info</span><br><span class="line">0f  21  34  43  55  63  6b  74  81  92  a9  bd  c2  d2  <span class="built_in">df</span>  ed  f6  pack</span><br></pre></td></tr></table></figure><p>git用sha1值存储，其他的两个数字或字母开头的文件名是sha1前两位，目录中文件名是sha1值，文件采用zlib压缩格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~/codes/blog/.g/objects master ?1 ❯ tree                               7s</span><br><span class="line">.</span><br><span class="line">├── 03</span><br><span class="line">│   └── 4c85b33ffa84adfb9f44d3c38fe13915e18a7c</span><br><span class="line">├── 0b</span><br><span class="line">│   └── 54054172c2050751407e0e9ae9a6c67436822c</span><br><span class="line">├── 0d</span><br><span class="line">│   ├── 0bc9b8cf7b882a3e5dfcd0790f09bc3482e8fe</span><br><span class="line">│   ├── 48c09ea03af3c3f6667be46ed57514e257acfc</span><br><span class="line">│   └── a1ba91c7ead0c0bb4e020a89b8a81ccaec137d</span><br></pre></td></tr></table></figure><p>今年的hackergame的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VTVEMtSGFja2VyZ2FtZS9oYWNrZXJnYW1lMjAyMy13cml0ZXVwcy9ibG9iL21hc3Rlci9vZmZpY2lhbC9HaXQlMjBHaXQhL1JFQURNRS5tZA==">git题目<i class="fa fa-external-link-alt"></i></span>就是从这里面找flag，撤销commit后在objects下面还有残留数据，于是从objects下的zlib文件后解压后查找flag即可。（文件名的hash可以从git reflog中获取）</p><p>解压可以用gzip或者openssl</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zlibd() (<span class="built_in">printf</span> <span class="string">&quot;\x1f\x8b\x08\x00\x00\x00\x00\x00&quot;</span> | <span class="built_in">cat</span> - <span class="string">&quot;<span class="variable">$@</span>&quot;</span> | gzip -dc)</span><br><span class="line">zlibd 97126e45aebd4c938edc8e11c28cef347cd317 | hexdump -C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用pigz</span></span><br><span class="line">unpigz &lt; 97126e45aebd4c938edc8e11c28cef347cd317 | hexdump -C</span><br></pre></td></tr></table></figure><p>或者蟒蛇</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line">s = <span class="string">&#x27;...&#x27;</span></span><br><span class="line">z = zlib.uncompress(s)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;yourfile&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(z)</span><br></pre></td></tr></table></figure><p>refs目录比较简单，是对obejects的reference，其中origin的HEAD为远程分支。packed-refs文件和refs作用一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/codes/blog/.git master ?1 ❯ tree refs        </span><br><span class="line">refs</span><br><span class="line">├── heads</span><br><span class="line">│   └── master</span><br><span class="line">├── remotes</span><br><span class="line">│   └── origin</span><br><span class="line">│       ├── HEAD</span><br><span class="line">│       └── master</span><br><span class="line">└── tags</span><br></pre></td></tr></table></figure><p>config文件为git的配置，index是索引, logs是提交日志，hooks下面是一堆bash脚本</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>git的对象包括blob，tree，commit，tag，blob是文件，tree是目录，在上面的目录结构中都已经看过了。还有一些二进制文件，推荐使用<code>git-lfs</code></p><p>git的存储方式是通过类似inode的指针，一般是一个树状，但是commit和branch会变成一个比较复杂的图。</p><p><img src="/git-structure/image.png" alt="pointer">  </p><p><img src="/git-structure/image-1.png" alt="git">  </p><ul><li>add操作</li></ul><p><code>git add</code>会把文件添加到缓冲区（staged）</p><ul><li>commit操作</li></ul><p><code>git commit</code>会添加缓冲区的版本<br>如果<code>git commit -a</code>会直接跳过缓冲区（跳过git add），直接添加untracked的版本</p><ul><li>rm操作</li></ul><p>rm操作把文件从tracked file list中移除（但是Object中还有历史版本，可以找到）。还没有staged的文件可以直接<code>git rm</code>，但是如果已经staged或者已经commit添加到snapshot中，就需要<code>git rm -f</code>。</p><p>如果直接rm，会把文件也删除，大多数情况下是不小心把一堆编译产物或者二进制文件加到缓冲区去了，这时候要用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached yourfile</span><br></pre></td></tr></table></figure><ul><li>mv操作</li></ul><p>git中没有类似文件系统的重命名，mv操作相当于删除后再次添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">mv</span> oldname newname</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line"><span class="built_in">mv</span> oldname newname</span><br><span class="line">git <span class="built_in">rm</span> oldname</span><br><span class="line">git add newname</span><br></pre></td></tr></table></figure><h3 id="git是增量存储吗"><a href="#git是增量存储吗" class="headerlink" title="git是增量存储吗"></a>git是增量存储吗</h3><p>中文网上大多数资料（比如不靠谱的某乎某SDN某思否）想当然的说git是增量存储的。但是，Pro Git和 Github Blog上说了，<strong>Commits are snapshots, not diffs</strong>。当然是选择相信Github Blog啦，如果不信自己建一个repo commit一下试试看看上一节的<code>.git</code>目录里的Object有什么变化就知道了。上一接我们已经看过Objects下面的blob了，并不是增量的。</p><p>git采用的保存方式是快照（snapshot），比较像zfs和btrfs的快照（当然那个是块级别的，这个只是对每个文件做快照），tree和blob内容都是zlib压缩后</p><blockquote><p>Commits, trees, and blobs are immutable</p></blockquote><p>git的增量，是当每次更改的时候</p><h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><ul><li>push, pull, clone</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h3><p>初版git的实现比较精简，代码量也比较少，可以观摩一下。先看一下第一次提交的版本。”initial revision of “git”, the information manager from hell”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/git/git.git</span><br><span class="line">git checkout e83c5163316f89bfbde7d9ab23ca2e25604af290</span><br></pre></td></tr></table></figure><p>README依然狂野<code>GIT - the stupid content tracker</code></p><p>初版代码量很少，没有今天常用的<code>git add</code>和<code>git commit</code>等功能，实现很精简，完成了自举。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">~/codes/git @e83c5163 +11 !4 ?3 ❯ cloc ./</span><br><span class="line">      12 text files.</span><br><span class="line">      11 unique files.                              </span><br><span class="line">       4 files ignored.</span><br><span class="line"></span><br><span class="line">github.com/AlDanial/cloc v 1.98  T=0.01 s (789.0 files/s, 78109.3 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">C                                8            115             59            775</span><br><span class="line">C/C++ Header                     1             17             23             57</span><br><span class="line">make                             1             15              0             27</span><br><span class="line">JSON                             1              0              0              1</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">SUM:                            11            147             82            860</span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><blockquote><p>This is a stupid (but extremely fast) directory content manager.  It<br>doesn’t do a whole lot, but what it <em>does</em> do is track directory<br>contents efficiently. </p></blockquote><p>直接<code>make</code>会报错，需要修改makefile，LIBS改为<code>LIBS= -lcrypto -lz</code>，然后在<code>cache.h</code>中<code>#include &lt;string.h&gt;</code></p><p>或者用别人改好的能编译的babygit：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://bitbucket.org/jacobstopak/baby-git.git</span><br></pre></td></tr></table></figure><p>先看一下README的介绍：There are two object abstractions: the “object database”, and the “current directory cache”.</p><p>初版的BLOB和TREE Object和现在的差不多，以及一个CHANGESET。</p><blockquote><p>CHANGESET: The “changeset” object is an object that introduces the notion of history into the picture.  In contrast to the other objects, it doesn’t just describe the physical state of a tree, it describes how we got there, and why. </p></blockquote><p>changeset用来记录提交信息</p><blockquote><p>Note on changesets: unlike real SCM’s, changesets do not contain rename<br>information or file mode chane information.  All of that is implicit in<br>the trees involved (the result tree, and the result trees of the<br>parents), and describing that makes no sense in this idiotic file<br>manager.</p></blockquote><p>可以看到，git一开始最早设计的时候就没有其他源码管理系统的重命名功能，这些操作被视为tree的删除和添加替代了。</p><p>init-db.c比较简单，用来初始化，类似现在的<code>git init</code>，创建repo并初始化，会在当前目录创建一个<code>.dircache</code>目录，类似<code>.git</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The default case is to have a DB per managed directory. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sha1_dir = DEFAULT_DB_ENVIRONMENT;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;defaulting to private storage area\n&quot;</span>);</span><br><span class="line">len = <span class="built_in">strlen</span>(sha1_dir);</span><br><span class="line"><span class="keyword">if</span> (mkdir(sha1_dir, <span class="number">0700</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (errno != EEXIST) &#123;</span><br><span class="line">    perror(sha1_dir);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">path = <span class="built_in">malloc</span>(len + <span class="number">40</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(path, sha1_dir, len);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">sprintf</span>(path+len, <span class="string">&quot;/%02x&quot;</span>, i);</span><br><span class="line">  <span class="keyword">if</span> (mkdir(path, <span class="number">0700</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno != EEXIST) &#123;</span><br><span class="line">      perror(path);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cache结构体用来存储时间、SHA、大小等信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cache_time</span> <span class="title">ctime</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cache_time</span> <span class="title">mtime</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_dev;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_ino;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_mode;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_uid;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_gid;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> st_size;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> sha1[<span class="number">20</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> namelen;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> name[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>update-cache.c</code>实现了文件缓冲区的功能，类似<code>git stage</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add_cache_entry</span><span class="params">(<span class="keyword">struct</span> cache_entry *ce)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pos;</span><br><span class="line">    <span class="comment">// 获取pos</span></span><br><span class="line">  pos = cache_name_pos(ce-&gt;name, ce-&gt;namelen);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* existing match? Just replace it */</span></span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    active_cache[-pos<span class="number">-1</span>] = ce;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure the array is big enough .. */</span></span><br><span class="line">  <span class="keyword">if</span> (active_nr == active_alloc) &#123;</span><br><span class="line">    active_alloc = alloc_nr(active_alloc);</span><br><span class="line">    active_cache = <span class="built_in">realloc</span>(active_cache, active_alloc * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cache_entry *));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add it in.. */</span></span><br><span class="line">  active_nr++;</span><br><span class="line">  <span class="keyword">if</span> (active_nr &gt; pos)</span><br><span class="line">    memmove(active_cache + pos + <span class="number">1</span>, active_cache + pos, (active_nr - pos - <span class="number">1</span>) * <span class="keyword">sizeof</span>(ce));</span><br><span class="line">  active_cache[pos] = ce;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到缓冲区（类似stage changes）</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">add_file_to_cache</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> size, namelen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cache_entry</span> *<span class="title">ce</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">  fd = open(path, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT)</span><br><span class="line">      <span class="keyword">return</span> remove_file_from_cache(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  namelen = <span class="built_in">strlen</span>(path);</span><br><span class="line">  size = cache_entry_size(namelen);</span><br><span class="line">  ce = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="built_in">memset</span>(ce, <span class="number">0</span>, size);</span><br><span class="line">  <span class="built_in">memcpy</span>(ce-&gt;name, path, namelen);</span><br><span class="line">  ce-&gt;ctime.sec = st.st_ctime;</span><br><span class="line">  ce-&gt;ctime.nsec = st.st_ctim.tv_nsec;</span><br><span class="line">  ce-&gt;mtime.sec = st.st_mtime;</span><br><span class="line">  ce-&gt;mtime.nsec = st.st_mtim.tv_nsec;</span><br><span class="line">  ce-&gt;st_dev = st.st_dev;</span><br><span class="line">  ce-&gt;st_ino = st.st_ino;</span><br><span class="line">  ce-&gt;st_mode = st.st_mode;</span><br><span class="line">  ce-&gt;st_uid = st.st_uid;</span><br><span class="line">  ce-&gt;st_gid = st.st_gid;</span><br><span class="line">  ce-&gt;st_size = st.st_size;</span><br><span class="line">  ce-&gt;namelen = namelen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index_fd(path, namelen, ce, fd, &amp;st) &lt; <span class="number">0</span>)   <span class="comment">// 索引</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> add_cache_entry(ce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rm功能：（类似于 git rm –cached，移出缓冲区）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">remove_file_from_cache</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> pos = cache_name_pos(path, <span class="built_in">strlen</span>(path));</span><br><span class="line">  <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    pos = -pos<span class="number">-1</span>;</span><br><span class="line">    active_nr--;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; active_nr)</span><br><span class="line">      memmove(active_cache + pos, active_cache + pos + <span class="number">1</span>, (active_nr - pos - <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cache_entry *));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入cache：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_cache</span><span class="params">(<span class="type">int</span> newfd, <span class="keyword">struct</span> cache_entry **cache, <span class="type">int</span> entries)</span></span><br><span class="line">&#123;</span><br><span class="line">  SHA_CTX c;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cache_header</span> <span class="title">hdr</span>;</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  hdr.signature = CACHE_SIGNATURE;</span><br><span class="line">  hdr.version = <span class="number">1</span>;</span><br><span class="line">  hdr.entries = entries;</span><br><span class="line"></span><br><span class="line">  SHA1_Init(&amp;c);</span><br><span class="line">  SHA1_Update(&amp;c, &amp;hdr, offsetof(<span class="keyword">struct</span> cache_header, sha1));</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; entries; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cache_entry</span> *<span class="title">ce</span> =</span> cache[i];</span><br><span class="line">    <span class="type">int</span> size = ce_size(ce);</span><br><span class="line">    SHA1_Update(&amp;c, ce, size);</span><br><span class="line">  &#125;</span><br><span class="line">  SHA1_Final(hdr.sha1, &amp;c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write(newfd, &amp;hdr, <span class="keyword">sizeof</span>(hdr)) != <span class="keyword">sizeof</span>(hdr))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; entries; i++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cache_entry</span> *<span class="title">ce</span> =</span> cache[i];</span><br><span class="line">    <span class="type">int</span> size = ce_size(ce);</span><br><span class="line">    <span class="keyword">if</span> (write(newfd, ce, size) != size)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><code>read-tree.c</code>比较简单，读取tree的sha1和path等信息并打出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入SHA1值，读取并打印</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">unpack</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *sha1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buffer;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">  <span class="type">char</span> type[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">  buffer = read_sha1_file(sha1, type, &amp;size);</span><br><span class="line">  <span class="keyword">if</span> (!buffer)</span><br><span class="line">    usage(<span class="string">&quot;unable to read sha1 file&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">strcmp</span>(type, <span class="string">&quot;tree&quot;</span>))</span><br><span class="line">    usage(<span class="string">&quot;expected a &#x27;tree&#x27; node&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (size) &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(buffer)+<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *sha1 = buffer + len;</span><br><span class="line">    <span class="type">char</span> *path = <span class="built_in">strchr</span>(buffer, <span class="string">&#x27; &#x27;</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mode;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; len + <span class="number">20</span> || <span class="built_in">sscanf</span>(buffer, <span class="string">&quot;%o&quot;</span>, &amp;mode) != <span class="number">1</span>)</span><br><span class="line">      usage(<span class="string">&quot;corrupt &#x27;tree&#x27; file&quot;</span>);</span><br><span class="line">    buffer = sha1 + <span class="number">20</span>;</span><br><span class="line">    size -= len + <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%o %s (%s)\n&quot;</span>, mode, path, sha1_to_hex(sha1));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>show-diff.c</code>用来比较文件差异, <code>match_stat</code>判断是否一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断两个文件的cache_entry中的名称、uid、大小等信息是否一致，用以判断是否更改</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">match_stat</span><span class="params">(<span class="keyword">struct</span> cache_entry *ce, <span class="keyword">struct</span> stat *st)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> changed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;mtime.sec != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_mtim.tv_sec</span><br><span class="line">        || ce-&gt;mtime.nsec != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_mtim.tv_nsec)</span><br><span class="line">        changed |= MTIME_CHANGED;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;ctime.sec != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_ctim.tv_sec</span><br><span class="line">        || ce-&gt;ctime.nsec != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_ctim.tv_nsec)</span><br><span class="line">        changed |= CTIME_CHANGED;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;st_uid != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_uid || ce-&gt;st_gid != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_gid)</span><br><span class="line">        changed |= OWNER_CHANGED;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;st_mode != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_mode)</span><br><span class="line">        changed |= MODE_CHANGED;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;st_dev != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_dev || ce-&gt;st_ino != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_ino)</span><br><span class="line">        changed |= INODE_CHANGED;</span><br><span class="line">    <span class="keyword">if</span> (ce-&gt;st_size != (<span class="type">unsigned</span> <span class="type">int</span>) st-&gt;st_size)</span><br><span class="line">        changed |= DATA_CHANGED;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>show_differences</code>用于显示差异</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">show_differences</span><span class="params">(<span class="keyword">struct</span> cache_entry *ce,</span></span><br><span class="line"><span class="params">                             <span class="keyword">struct</span> stat *cur,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> *old_contents,</span></span><br><span class="line"><span class="params">                             <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> old_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> cmd[<span class="number">1000</span>];</span><br><span class="line">    FILE *f;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(cmd, <span class="keyword">sizeof</span>(cmd), <span class="string">&quot;diff -u - %s&quot;</span>, ce-&gt;name);</span><br><span class="line">    f = popen(cmd, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    fwrite(old_contents, old_size, <span class="number">1</span>, f);</span><br><span class="line">    pclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>commit-tree.c</code>用于commit提交：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPARENT (16)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, len;</span><br><span class="line">    <span class="type">int</span> parents = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tree_sha1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> parent_sha1[MAXPARENT][<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> *gecos, *realgecos;</span><br><span class="line">    <span class="type">char</span> *email, realemail[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">char</span> *date, *realdate;</span><br><span class="line">    <span class="type">char</span> comment[<span class="number">1000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> *<span class="title">pw</span>;</span></span><br><span class="line">    <span class="type">time_t</span> now;</span><br><span class="line">    <span class="type">char</span> *buffer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || get_sha1_hex(argv[<span class="number">1</span>], tree_sha1) &lt; <span class="number">0</span>)</span><br><span class="line">        usage(<span class="string">&quot;commit-tree &lt;sha1&gt; [-p &lt;sha1&gt;]* &lt; changelog&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; argc; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *a, *b;</span><br><span class="line">        a = argv[i];</span><br><span class="line">        b = argv[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!b || <span class="built_in">strcmp</span>(a, <span class="string">&quot;-p&quot;</span>) || get_sha1_hex(b, parent_sha1[parents]))</span><br><span class="line">            usage(<span class="string">&quot;commit-tree &lt;sha1&gt; [-p &lt;sha1&gt;]* &lt; changelog&quot;</span>);</span><br><span class="line">        parents++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!parents)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Committing initial tree %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    pw = getpwuid(getuid());</span><br><span class="line">    <span class="keyword">if</span> (!pw)</span><br><span class="line">        usage(<span class="string">&quot;You don&#x27;t exist. Go away!&quot;</span>);</span><br><span class="line">    realgecos = pw-&gt;pw_gecos;</span><br><span class="line">    len = <span class="built_in">strlen</span>(pw-&gt;pw_name);</span><br><span class="line">    <span class="built_in">memcpy</span>(realemail, pw-&gt;pw_name, len);</span><br><span class="line">    realemail[len] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">    gethostname(realemail + len + <span class="number">1</span>, <span class="keyword">sizeof</span>(realemail) - len - <span class="number">1</span>);</span><br><span class="line">    time(&amp;now);</span><br><span class="line">    realdate = ctime(&amp;now);</span><br><span class="line"></span><br><span class="line">    gecos = getenv(<span class="string">&quot;COMMITTER_NAME&quot;</span>) ?: realgecos;</span><br><span class="line">    email = getenv(<span class="string">&quot;COMMITTER_EMAIL&quot;</span>) ?: realemail;</span><br><span class="line">    date = getenv(<span class="string">&quot;COMMITTER_DATE&quot;</span>) ?: realdate;</span><br><span class="line"></span><br><span class="line">    remove_special(gecos);</span><br><span class="line">    remove_special(realgecos);</span><br><span class="line">    remove_special(email);</span><br><span class="line">    remove_special(realemail);</span><br><span class="line">    remove_special(date);</span><br><span class="line">    remove_special(realdate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加buffer，准备写入</span></span><br><span class="line">    init_buffer(&amp;buffer, &amp;size);</span><br><span class="line">    add_buffer(&amp;buffer, &amp;size, <span class="string">&quot;tree %s\n&quot;</span>, sha1_to_hex(tree_sha1));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * NOTE! This ordering means that the same exact tree merged with a</span></span><br><span class="line"><span class="comment">   * different order of parents will be a _different_ changeset even</span></span><br><span class="line"><span class="comment">   * if everything else stays the same.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; parents; i++)</span><br><span class="line">        add_buffer(&amp;buffer, &amp;size, <span class="string">&quot;parent %s\n&quot;</span>, sha1_to_hex(parent_sha1[i]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Person/date information */</span></span><br><span class="line">    add_buffer(&amp;buffer, &amp;size, <span class="string">&quot;author %s &lt;%s&gt; %s\n&quot;</span>, gecos, email, date);</span><br><span class="line">    add_buffer(&amp;buffer, &amp;size, <span class="string">&quot;committer %s &lt;%s&gt; %s\n\n&quot;</span>, realgecos, realemail, realdate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* And add the comment */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(comment, <span class="keyword">sizeof</span>(comment), <span class="built_in">stdin</span>) != <span class="literal">NULL</span>)</span><br><span class="line">        add_buffer(&amp;buffer, &amp;size, <span class="string">&quot;%s&quot;</span>, comment);</span><br><span class="line"></span><br><span class="line">    finish_buffer(<span class="string">&quot;commit &quot;</span>, &amp;buffer, &amp;size);       <span class="comment">// 写入buffer</span></span><br><span class="line"></span><br><span class="line">    write_sha1_file(buffer, size);  <span class="comment">// 写入sha1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove_special的实现也比较简单，一个简单的遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_special</span><span class="params">(<span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> *dst = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        c = *p;</span><br><span class="line">        p++;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *dst++ = c;</span><br><span class="line">        <span class="keyword">if</span> (!c)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译通过之后可以用一下试试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> +x *.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">./init-db</span><br><span class="line"><span class="comment"># 随便添加点内容</span></span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">date</span> +%c) &gt;&gt; test.txt</span><br><span class="line"><span class="comment"># 写入到缓冲区</span></span><br><span class="line">./update-cache test.txt</span><br><span class="line"><span class="comment"># 然后在 .dircache/objects 下面会看到相关内容</span></span><br><span class="line">tree -L .dircache/objects</span><br><span class="line"></span><br><span class="line"><span class="comment"># objects下面的内容可以用catfile查看</span></span><br><span class="line">./cat-file </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将缓冲区object写入</span></span><br><span class="line">./write-tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看写入内容</span></span><br><span class="line">./read-tree </span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交更改</span></span><br><span class="line"><span class="comment"># 填写commit信息</span></span><br><span class="line">./commit-tree </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看提交内容</span></span><br><span class="line">./cat-file </span><br><span class="line"></span><br><span class="line"><span class="comment"># echo </span></span><br></pre></td></tr></table></figure><p>我们看初版的源码可以发现，git确实是一个保存snapshot而不是保存diff的工具。后面版本我们可以看到git对存储冗余的优化。</p><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dpdC9naXQ=">git<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29r">Pro Git<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuYmxvZy8yMDIwLTEyLTE3LWNvbW1pdHMtYXJlLXNuYXBzaG90cy1ub3QtZGlmZnMv">Commits are snapshots, not diffs<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuYmxvZy8yMDIyLTA4LTI5LWdpdHMtZGF0YWJhc2UtaW50ZXJuYWxzLWktcGFja2VkLW9iamVjdC1zdG9yZS8=">Git’s database internals I: packed object store<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9iaXRidWNrZXQub3JnL2Jsb2cvd2hhdC1jYW4td2UtbGVhcm4tZnJvbS10aGUtY29kZS1pbi1naXRzLWluaXRpYWwtY29tbWl0">What Can We Learn from the Code in Git’s Initial Commit?<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;突然发现git还挺有意思的，实现很像kv存储文件系统。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://zhangjk98.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="git" scheme="https://zhangjk98.xyz/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>关于柯里化</title>
    <link href="https://zhangjk98.xyz/currying/"/>
    <id>https://zhangjk98.xyz/currying/</id>
    <published>2023-11-09T06:00:18.000Z</published>
    <updated>2023-11-09T06:00:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>柯里化（Currying）把接受多个参数的函数变成单个参数的函数</p><span id="more"></span><p>比如我们有一个sum函数，接受三个参数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(x, y, z <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改成接受单个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">curryingSum</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(z <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> x + y + z</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是调用起来就从f(x, y, z)变为f(x)(y)(z)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">curryingSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这样看起来性质很良好，只接受一个参数，返回一个输出。直觉告诉我们，接收单个变量的函数，比接收多个变量的函数有一些更加良好的性质。</p><p>但是go的curringSum函数要写返回值类型，看起来比较难受，用js来一版</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curryingAdd = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">z</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> x + y + z</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheme版本的看起来也跟js差不多</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">currySum</span> f)</span><br><span class="line">    (<span class="name"><span class="built_in">lambda</span></span>(x)</span><br><span class="line">        (<span class="name">labmda</span>(<span class="name">y</span>)</span><br><span class="line">            (<span class="name"><span class="built_in">lambda</span></span>(z)</span><br><span class="line">                (<span class="name">f</span> x y z)))))</span><br></pre></td></tr></table></figure><p>对n个变量的Curry函数很容易实现</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span>  (<span class="name">curry</span> n f)  </span><br><span class="line"> (<span class="name">if</span> (<span class="name">=</span> n <span class="number">1</span>) f</span><br><span class="line">  (<span class="name">curry</span> </span><br><span class="line">    (<span class="name">-</span> n <span class="number">1</span>) </span><br><span class="line">    (<span class="name">lambda</span> s (<span class="name">lambda</span>  (<span class="name">a</span>) (<span class="name">apply</span> f (<span class="name">append</span> s (<span class="name">list</span> a))))))))</span><br></pre></td></tr></table></figure><p>js版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> innerArgs = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">        <span class="keyword">var</span> finalArgs = args.<span class="title function_">concat</span>(innerArgs);</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="literal">null</span>, finalArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，我们可以实现反柯里化，说明多变量函数和单变量单返回函数可以相互转换</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> ((<span class="name">uncurry</span> f) . t)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> t)</span><br><span class="line">      f</span><br><span class="line">      (<span class="name"><span class="built_in">apply</span></span> (<span class="name">uncurry</span> (<span class="name">f</span> (<span class="name"><span class="built_in">car</span></span> t)))</span><br><span class="line">             (<span class="name"><span class="built_in">cdr</span></span> t))))</span><br></pre></td></tr></table></figure><p>那柯里化有什么用呢，可以用来实现多参数函数。（lambda演算是匿名的，并且只接收一个输入）在$\lambda$演算中，柯里化做了这样一个事情:</p><p>$$<br>\lambda x.(\lambda y.xy) &#x3D; \lambda x.(\lambda y. xy)<br>$$</p><p>在手搓自制scheme中，我们已经实现了有一个接收一个输入、返回一个输出的函数，那么可以通过柯里化实现一个接收多参数的函数。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU2JTlGJUFGJUU5JTg3JThDJUU1JThDJTk2">柯里化<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGFtYmRhX2NhbGN1bHVz">Lambda Calcus<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;柯里化（Currying）把接受多个参数的函数变成单个参数的函数&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://zhangjk98.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="currying" scheme="https://zhangjk98.xyz/tags/currying/"/>
    
  </entry>
  
  <entry>
    <title>Qt打包动态库并调用</title>
    <link href="https://zhangjk98.xyz/qt-dll/"/>
    <id>https://zhangjk98.xyz/qt-dll/</id>
    <published>2023-11-06T03:28:43.000Z</published>
    <updated>2023-11-06T03:28:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般QT多以动态链接库为主，因为静态链接库会有一些版权的问题。静态库步骤和动态库基本相同，选择的时候改一点编译参数就可以了。</p><span id="more"></span><h2 id="QTCreator新建库项目"><a href="#QTCreator新建库项目" class="headerlink" title="QTCreator新建库项目"></a>QTCreator新建库项目</h2><p>本文QT环境为5.14.2，QTCreator为11.0.2。</p><p>已经存在的QWdiget项目快速改为动态链接库项目并调用可直接跳到下一节</p><p>QTCreator新建项目：<br>file -&gt; new project -&gt; library -&gt;c++ library，然后选shared library</p><p>然后类名随便取（这里以testDynamicLib为例），然后选择依赖core，gui和widget按需选，如果有额外的依赖，比如sql和xml等，在<code>.pro</code>文件里面添加即可。项目除了没有main.cpp，长得和QApplication几乎一样，除了没有main.cpp，多了一个<code>_global.h</code>文件。</p><p>然后写一个twosum测试dll调用是否成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/mnt/c/U/0/c/testDynamicLib master !2 ❯tree</span><br><span class="line">.</span><br><span class="line">├── testdynamiclib.cpp</span><br><span class="line">├── testDynamicLib_global.h</span><br><span class="line">├── testdynamiclib.h</span><br><span class="line">├── testDynamicLib.pro</span><br><span class="line">└── testDynamicLib.pro.user</span><br><span class="line"></span><br><span class="line">1 directory, 5 files</span><br></pre></td></tr></table></figure><p>testdynamiclib.h头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TESTDYNAMICLIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TESTDYNAMICLIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testDynamicLib_global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TESTDYNAMICLIB_EXPORT</span> TestDynamicLib</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestDynamicLib</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">twosum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// TESTDYNAMICLIB_H</span></span></span><br></pre></td></tr></table></figure><p>testDynamicLib.cpp文件添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestDynamicLib::twosum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后build，会在编译目录生成一个.dll和.lib文件。</p><p>然后创建一个新项目，file-&gt;new project-&gt;Application(Qt)-&gt;Qt Widget Application。把刚才的dll和lib复制到当前</p><p>点击添加库-&gt;外部库-&gt;选刚才的.lib库和平台。</p><p>然后<code>.pro</code>文件中会多这么一行（刚才的添加库操作等价于.pro配置中添加了一行LIBS配置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win32:CONFIG(release, debug|release): LIBS += -L$$OUT_PWD/./release/ -ltestDynamicLib</span><br></pre></td></tr></table></figure><p>然后就可以调用了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TestDynamicLib testLib;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; testLib.<span class="built_in">twosum</span>(<span class="number">16</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>如果有widget等图形界面，调用也是类似的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QHBoxLayout *layout = <span class="keyword">new</span> <span class="built_in">QHBoxLayout</span>();</span><br><span class="line">testDynamicLib *testLib = <span class="keyword">new</span> <span class="built_in">testDynamicLib</span>(ui-&gt;widget);</span><br><span class="line">testLib-&gt;<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure><h2 id="已有的Applicaiton项目改C-Library项目"><a href="#已有的Applicaiton项目改C-Library项目" class="headerlink" title="已有的Applicaiton项目改C++ Library项目"></a>已有的Applicaiton项目改C++ Library项目</h2><p>明白了QTCreator创建的动态库和Applicaiton项目的区别，我们可知直接修改原有的项目，能使其变为动态库。</p><p>比如我们要写一个dll，c++ Library项目不方便运行和调试，可以在开发的时候直接建一个普通的可执行的Qt项目，然后在完成后改为动态库。(假设项目叫YOURPROEJ)</p><p>首先删掉<code>main.cpp</code>，然后新建一个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> YOURPROEJ_GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YOURPROEJ_GLOBAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtCore/qglobal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(YOURPROEJ_LIBRARY)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> YOURPROEJ_EXPORT Q_DECL_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> YOURPROEJ_EXPORT Q_DECL_IMPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// YOURPROEJ_GLOBAL_H</span></span></span><br></pre></td></tr></table></figure><p>其中<code>Q_DECL_IMPORT</code>和<code>Q_DECL_EXPORT</code>两个宏作用类似于.def文件。</p><p>然后在<code>yourproj.h</code>中include一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;yourproj_global.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>然后修改<code>.pro</code>文件，添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATE = lib</span><br><span class="line">DEFINES += YOURPROJ_LIBRARY</span><br></pre></td></tr></table></figure><p>然后在动态库中修改类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class YourProj : public QMainWindow</span></span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YOURPROJ_EXPORT</span> YourProj : <span class="keyword">public</span> QMainWindow</span><br></pre></td></tr></table></figure><p>然后编译，调用即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一般QT多以动态链接库为主，因为静态链接库会有一些版权的问题。静态库步骤和动态库基本相同，选择的时候改一点编译参数就可以了。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://zhangjk98.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Qt" scheme="https://zhangjk98.xyz/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>在Archlinux下编译Linux内核（以添加系统调用为例）</title>
    <link href="https://zhangjk98.xyz/add-a-syscall-to-linux-kernel/"/>
    <id>https://zhangjk98.xyz/add-a-syscall-to-linux-kernel/</id>
    <published>2023-11-02T11:59:43.000Z</published>
    <updated>2023-11-02T11:59:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天手痒玩一下Archlinux的编译内核，顺便观摩一下Arch内核打包是什么样的（不知道用什么举例子就添加个syscall算了）</p><span id="more"></span><p>体验还不错，Archlinux编译内核啥的还都挺简单的（相比于LFS），而且打包也方便。以后不开qemu了，直接裸机编译内核玩喽。  </p><h2 id="下载和准备编译环境"><a href="#下载和准备编译环境" class="headerlink" title="下载和准备编译环境"></a>下载和准备编译环境</h2><p>Archlinux编译内核有两种方式，一种是传统的编译方式（玩过LFS或者gentoo的应该很熟悉），另一种是ABS（Arch Build System，可以打一个AUR包供他人使用）。其他发行版的读者请跳过ABS，只看手动编译即可。</p><p>第一种和通常的手工编译内核没什么区别，这里先演示添加系统调用并手动打包。（如果不是为了打包其实直接手动编译更方便点）下载内核源码并解压，内核版本和解压路径换成你自己想要的（如果不想打包生成patch文件，不需要<code>git init</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.16.15.tar.xz</span><br><span class="line"><span class="built_in">mkdir</span> ./linux-zhixi</span><br><span class="line">tar xf linux-5.16.15.tar.xz --directory=./linux-zhixi --strip-components 1</span><br><span class="line"><span class="built_in">cd</span> linux-zhixi</span><br><span class="line"><span class="comment"># if you want to create a patch for packaging</span></span><br><span class="line"><span class="comment"># git init</span></span><br></pre></td></tr></table></figure><h2 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h2><p>接下来我们添加一个系统调用，统计开机到现在用了多少秒。<br>修改<code>arch/x86/entry/syscalls/syscall_64.tbl</code>系统调用表，仿照上面的格式加上一行，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">548 common  uptime          sys_getuptime</span><br></pre></td></tr></table></figure><p>然后增加系统调用，随便找个位置，比如<code>kernel/time/getuptime.c</code>， 但是为了不把kernel目录搞乱，我自己建一个<code>zhixi</code>的目录放<code>getuptime.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_getuptime - get how many seconds have elapsed since boot</span></span><br><span class="line"><span class="comment"> * @secs: return the value of secs corresponding to jiffies</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line">SYSCALL_DEFINE1(getuptime, <span class="type">unsigned</span> <span class="type">int</span> __user *, secs)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> kjiffies = (get_jiffies_64() - INITIAL_JIFFIES) / <span class="number">1000</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> ksecs = jiffies_to_secs(kjiffies);</span><br><span class="line">        copy_to_user(secs, &amp;ksecs, <span class="keyword">sizeof</span>(ksecs));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了在编译内核的时候编译这个文件，在<code>zhixi</code>目录下增加<code>Makefile</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-y := getuptime.o</span><br></pre></td></tr></table></figure><p>然后给源码根目录的Makefile加上<code>zhixi/</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ zhixi/</span><br></pre></td></tr></table></figure><p>然后编辑<code>include/linux/syscalls.h</code>头文件加上自己的系统调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* zhixi/getuptime.c */</span></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_getms_sinceboot</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> __user *secs)</span>;</span><br></pre></td></tr></table></figure><p>一个简单的系统调用就加好了。</p><h2 id="手动编译内核"><a href="#手动编译内核" class="headerlink" title="手动编译内核"></a>手动编译内核</h2><p>编译内核的时候可以直接copy目前linux的config:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat /proc/config.gz &gt; .config</span><br></pre></td></tr></table></figure><p>或者自己手动选择一些配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><h3 id="减少编译时间"><a href="#减少编译时间" class="headerlink" title="减少编译时间"></a>减少编译时间</h3><p>可以用modprobed-db生成配置（<code>make localmodconfig</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S modprobed-db</span><br></pre></td></tr></table></figure><p>然后编辑<code>~/.config/modprobed-db.conf</code></p><p>这个工具可以在编译内核的时候忽略不需要的module，加快编译速度。我这里编译的速度缩短了大概三分之一左右。</p><h3 id="给kernel打patch"><a href="#给kernel打patch" class="headerlink" title="给kernel打patch"></a>给kernel打patch</h3><p>在PKGBUILD中打patch请参考：<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvUGF0Y2hpbmdfcGFja2FnZXNfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4NykjJUU1JUJBJTk0JUU3JTk0JUE4JUU4JUExJUE1JUU0JUI4JTgx">Patching_packages_(简体中文)#应用补丁<i class="fa fa-external-link-alt"></i></span>  </p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvUGF0Y2hpbmdfcGFja2FnZXM=">ArchWiki Patching pacakages<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvS2VybmVsL1RyYWRpdGlvbmFsX2NvbXBpbGF0aW9u">Kernel&#x2F;Traditional compilation<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQXJjaF9CdWlsZF9TeXN0ZW1fKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">Arch Build System (简体中文)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9iaXNjdWl0b3MuZ2l0aHViLmlvL2Jsb2cvU1lTQ0FMTF9BRERfTkVXX1g4Nl82NC8jaGVhZGVy">X86_64 架构增加一个系统调用<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天手痒玩一下Archlinux的编译内核，顺便观摩一下Arch内核打包是什么样的（不知道用什么举例子就添加个syscall算了）&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="syscall" scheme="https://zhangjk98.xyz/tags/syscall/"/>
    
    <category term="linux" scheme="https://zhangjk98.xyz/tags/linux/"/>
    
    <category term="archlinux" scheme="https://zhangjk98.xyz/tags/archlinux/"/>
    
  </entry>
  
  <entry>
    <title>更新至wsl2.0.0，开启mirrored网络模式</title>
    <link href="https://zhangjk98.xyz/wsl2/"/>
    <id>https://zhangjk98.xyz/wsl2/</id>
    <published>2023-10-23T01:21:08.000Z</published>
    <updated>2023-10-23T01:21:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>上个月wsl2发布了2.0.0，新特性很多，比如networkingMode新增了mirrored，可以像wsl1那样和宿主机共享网络（mirrored模式），也可以直接吃到windows的系统代理设置。</p><span id="more"></span><p>迫于生计，要用win10干活，只好在wsl里面跑几个linux玩一玩了。目前这个功能只有Windows Insider Preview Canary有，所以需要冒进到Canary channel才行。<strong>注意，Canary是比dev和beta channel更新的预览通道，请谨慎更新。</strong></p><p>上个月wsl2发布了2.0.0，现在还是pre-release，所以需要手动更新。（建议开全局代理，不然下载更新很慢）</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--update</span> <span class="literal">--pre-release</span></span><br></pre></td></tr></table></figure><p>目前wsl2.0.0的新特性需要在<code>%userprofile%\.wslconfig</code>配置里面手动设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">autoMemoryReclaim=gradual</span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=true</span><br><span class="line">firewall=true</span><br><span class="line">autoProxy=true</span><br><span class="line">sparseVhd=true</span><br></pre></td></tr></table></figure><p>然后就可以用mirrored模式了，就像wsl1那样，宿主机和wsl网络互通，可以直接<code>127.0.0.1</code>去访问wsl中的端口（ipv6也可以），不需要手动端口转发了。</p><p>而且可以吃到Windows的代理设置，也可以用Windows的防火墙规则去过滤包。</p><p>新版wsl还有很多新特性，比如：</p><p>DNS Tunneling: DNS隧道。之前wsl2的DNS经常出问题，得在<code>/etc/wsl.conf</code>里面设置<code>generateResolvConf = false</code>，然后手动在<code>/etc/reslov.conf</code>里面指定DNS Server。如果你不改，那wsl的DNS会默认去找Windows本机的DNS，然后如果你随便配了点什么防火墙规则啊、有点什么VPN啊，或者又是整了个万恶的Docker，恭喜你，wsl尝试去找Windows的DNS的包发过去又失败了，你上不了网了。</p><blockquote><p>This is because the networking packet for DNS sent by the WSL VM to the Windows host was being blocked by the existing networking configuration.</p></blockquote><p>这玩意还是偶发性的，因为wsl每次启动会随机, 哪次wsl启动的时候随机分配的子网，然后跟抽奖一样，哪次分配的子网就被防火墙给拦了，下次又好了。</p><p>这也是从wsl1就开始的祖传老bug了，我们看一下相关问题的赞数就知道这破玩意有多恼火：<br><span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vY29sdGVua3JhdXRlci82MDhjZmUwMjMxOWNlNjBmYWNkNzYzNzMyNDliOGNhNg==">https://gist.github.com/coltenkrauter/608cfe02319ce60facd76373249b8ca6<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjIzMTQ3ODkvbm8taW50ZXJuZXQtY29ubmVjdGlvbi1vbi13c2wtdWJ1bnR1LXdpbmRvd3Mtc3Vic3lzdGVtLWZvci1saW51eC82NDA1NzgzNQ==">https://stackoverflow.com/questions/62314789/no-internet-connection-on-wsl-ubuntu-windows-subsystem-for-linux/64057835<i class="fa fa-external-link-alt"></i></span><br>我是不明白为什么巨硬这么多问题还是执着的想让wsl的默认DNS用Windos宿主机一样的，直接像虚拟机一样用自己的不好吗。。。这个bug摆在这里这么久，最后巨硬决定整个DNS Tunneling</p><p>autoMemoryReclaim：自动回收内存，一定程度上缓解了我的16G内存的寒酸笔记本。但是这个也和docker有点小冲突，又是万恶的cgroupv1（docker啥时候才能支持cgroupv2啊，我等的花都谢了）。</p><p>这个选项有三个参数：gradual，dropcache和disable，gradual在空闲五分钟后一点一点缓慢释放内存（聪明的你应该猜到了，又是用cgroup实现的），dropcache会直接释放所有空闲内存。</p><p>sparseVhd: 自动释放虚拟硬盘，没啥好说的。</p><p>wsl2 2.0.0新版还是没有解决和windows互传文件性能拉跨的问题。建议继续使用9p virtfs（就是qemu用的那个）。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZibG9ncy5taWNyb3NvZnQuY29tL2NvbW1hbmRsaW5lL3dpbmRvd3Mtc3Vic3lzdGVtLWZvci1saW51eC1zZXB0ZW1iZXItMjAyMy11cGRhdGUv">Windows Subsystem for Linux September 2023 update<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sZWFybi5taWNyb3NvZnQuY29tL2VuLXVzL3dpbmRvd3Mvd3NsL3dzbC1jb25maWc=">Advanced settings configuration in WSL<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上个月wsl2发布了2.0.0，新特性很多，比如networkingMode新增了mirrored，可以像wsl1那样和宿主机共享网络（mirrored模式），也可以直接吃到windows的系统代理设置。&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://zhangjk98.xyz/tags/linux/"/>
    
    <category term="wsl" scheme="https://zhangjk98.xyz/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>迁移到Neovim的新插件管理器lazy.nvim</title>
    <link href="https://zhangjk98.xyz/neovim-lazy/"/>
    <id>https://zhangjk98.xyz/neovim-lazy/</id>
    <published>2023-09-01T02:16:48.000Z</published>
    <updated>2023-09-01T02:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久没写博客了，工作安定下来终于可以继续摸鱼了。</p><span id="more"></span><p>Neovim这些插件的半衰期太短了，几个月不折腾就跟不上了。刚用Neovim的时候就听说过很火的Packer.nvim插件管理器，当时Neovim可以用vim的vim-plug当插件管理器，就一直懒得往packer迁移，一直拖到现在，结果我还没迁移packer就已经凉了，emmmm</p><h2 id="lazy-nvim安装"><a href="#lazy-nvim安装" class="headerlink" title="lazy.nvim安装"></a>lazy.nvim安装</h2><p>AURe有一个包，我没用，照着github上的官方文档</p><p>在<code>~/.config/nvim/init.lua</code>或者<code>~/.config/nvim/init.lua</code>中添加</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定插件位置，不存在则clone到本地</span></span><br><span class="line"><span class="keyword">local</span> lazypath = vim.fn.stdpath(<span class="string">&quot;data&quot;</span>) .. <span class="string">&quot;/lazy/lazy.nvim&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> vim.loop.fs_stat(lazypath) <span class="keyword">then</span></span><br><span class="line">  vim.fn.system(&#123;</span><br><span class="line">    <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="string">&quot;clone&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--filter=blob:none&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://github.com/folke/lazy.nvim.git&quot;</span>,</span><br><span class="line">    <span class="string">&quot;--branch=stable&quot;</span>, <span class="comment">-- latest stable release</span></span><br><span class="line">    lazypath,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vim.opt.rtp:prepend(lazypath)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 照例require一下，如果同时使用vim-plug插件，记得把这个放在vim-plug后面</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).setup(plugins, opts)</span><br></pre></td></tr></table></figure><p>然后打开nvim，在normal mode下<code>:checkhealth lazy</code>，能看到3个ok就行了</p><p>推荐将插件配置扔到单独的一个lua文件，将上面的require改为</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;lazy&quot;</span>).setup(<span class="string">&quot;plugins&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后添加插件，在<code>~/.config/nvim/lua/plugins.lua</code>中或者<code>~/.config/nvim/lua/plugins/*lua</code>中，比如im-select插件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="string">&quot;keaising/im-select.nvim&quot;</span>,</span><br><span class="line">    <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&quot;im_select&quot;</span>).setup(&#123;&#125;)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动nvim，按照提示按i安装就行了。</p><p>之前从vim迁到neovim的时候，用的coc.nvim。今年coc的作者已经不怎么更新了，曾经在知乎和推上很活跃的作者也不怎么网上冲浪了（记得曾经是位emacs铁粉，ghhn网上热情极高）。</p><p>用了Neovim默认的lsp, 然后加了个美化插件，功能依然不如coc.nvim。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;neovim/nvim-lspconfig&quot;</span>,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="string">&#x27;nvimdev/lspsaga.nvim&#x27;</span>,</span><br><span class="line">    <span class="built_in">config</span> = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">        <span class="built_in">require</span>(<span class="string">&#x27;lspsaga&#x27;</span>).setup(&#123;&#125;)</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    dependencies = &#123;</span><br><span class="line">        <span class="string">&#x27;nvim-treesitter/nvim-treesitter&#x27;</span>, <span class="comment">-- optional</span></span><br><span class="line">        <span class="string">&#x27;nvim-tree/nvim-web-devicons&#x27;</span>     <span class="comment">-- optional</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZvbGtlL2xhenkubnZpbQ==">https://github.com/folke/lazy.nvim<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很久没写博客了，工作安定下来终于可以继续摸鱼了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="neovim" scheme="https://zhangjk98.xyz/tags/neovim/"/>
    
    <category term="lazy" scheme="https://zhangjk98.xyz/tags/lazy/"/>
    
  </entry>
  
  <entry>
    <title>immutable思路面对依赖冲突：Nix包管理器</title>
    <link href="https://zhangjk98.xyz/dependency-conflicts/"/>
    <id>https://zhangjk98.xyz/dependency-conflicts/</id>
    <published>2022-05-31T13:56:02.000Z</published>
    <updated>2022-05-31T13:56:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直没有什么处理依赖问题的好思路，后知后觉发现Nix包管理器。要是当年我还沉迷lisp的时候真的注意到这个，说不定现在人已经跑到NixOS去了</p><span id="more"></span><p>大多数发行版的版本是几年或者几个月一个大版本，然后维护对应版本的依赖和软件（一般依赖不怎么大更新，打补丁）， 比如Ubuntu、红帽这些商业发行版，没什么大问题基本不怎么动。不过维护这么多版本需要耗费不少的精力，而且由于rpm和deb打包比较麻烦，包不太多。</p><p>几年前我用deb包管理器的时候遇到依赖问题几乎是家常便饭，然后动不动就用第三方的方式装，比如make编译、比如野路子<code>curl XXX install.sh &amp;&amp; ./install</code>， 于是环境变得乱糟糟的。后来Ubuntu开始推snap。于是我跑路到了pacman，后来就一直用Arch了，还自己打了点AUR的包。</p><p>pacman包管理器没有deb系那么多功能，不过我觉得好就好在简单，这样打包门槛低，促进了AUR的繁荣。不管AUR的PKGBUILD再怎么质量差再怎么野，至少也比找不到deb或者rpm的包然后纷纷make或者<code>install.sh</code>好多了</p><p>另一种思路是尽量不要动态链接库，代价是打包出来的体积会比较巨大。依赖？没有依赖不就不冲突了吗？统统静态链接，不过问题是打出来的包比较大。另一个好处是可以顺便做一个虚拟的目录，把更多的东西都给每个软件单独做一份，做出类似沙盒隔离。比如flatpak，这样打出来的包比较容易跨发行版，也不太容易遇到依赖找不到或者依赖版本冲突的问题。</p><p>Arch已经足够让我满意了，包多，自己打包也简单。不过每次多版本共存的时候还是有点别扭，难道就真只能所有人尽量统一版本往前滚了吗？多版本怎么共存呢？我不想要pyenv、archlinux-java、gvm、nvm、conda这些东西，这些东西应该由一个全局的包管理器去处理。</p><p>理论上如果绝大部分上游应用和库的向后兼容做的足够好，那确实不太需要太关心多版本并存的问题，每个大版本打一个包就好了。比如go，我从1.14升到1.18，原来的代码和库基本能跑的依然能跑。但是python这样的，好家伙，python2到python3升级大量beraking changes就算了。python3.5、python3.6、pyhton3.9、python3.10这样的小版本号动不动就不兼容，然后一堆依赖出问题了。python那一堆包的用法和函数还天天改，动不动版本更新之后原来import的包不能跑了，你要改函数名。尤其是一些深度学习的包和django的一些东西、好端端的为什么要改来改去？还有grpc也是，不遵循语义化版本号，我好几次滚arch都是某个应用依赖grpc然后出问题了，版本又不兼容。</p><p>除了兼容问题还有另一个问题不大的小问题，就是不同包的文件冲突，比如bear和interception tools， 都在arch的community包里面， 都有一个<code>/usr/bin/intercept</code>。当然一般软件命名不一样没这个问题，或者把这两个包标为<code>conflict</code>。那有没有办法不改名也能用呢，那能不能给每个包一个自己的专属目录。这个问题和上面那个多版本并存的问题是很像的，同时安装两个版本也会在<code>/usr/bin/XXX</code>等各种重名目录下面相同文件冲突。</p><p>最近才看了一下Nix包管理器，之前一直觉得这个玩意就是茫茫多包管理器中的一个，和别的也没多少区别。一看才发现这不就是我要找的吗？</p><blockquote><p>Nix is a purely functional package manager. This means that it treats packages like values in purely functional programming languages such as Haskell — they are built by functions that don’t have side-effects, and they never change after they have been built. Nix stores packages in the Nix store, usually the directory &#x2F;nix&#x2F;store</p></blockquote><p>Nix包管理器将包放在<code>/nix/store</code>下面，然后根据sha256 的 hash去找版本。这样就实现了多版本共存，然后这个在打包的时候每个包是显式声明依赖的，不会出现打包的时候漏写了哪个依赖然后跑到别的电脑上寄了的情况。就算系统上有需要的依赖也不自己去找，需要显式声明。这样就可以确定完备的依赖关系，然后对一些嵌套的依赖进行推导。</p><p>然后有了这个声明式（Declarative）的配置，我们可以还原以前的版本（有点像git）</p><p>Nix保留每一个包版本，像python3.9和3.10如果有依赖或者显式声明都会安装，然后依赖这些的包分别根据hash和打包声明去找相应的版本。这里是只要有一点不同就是一个新的版本，就算3.9.1和3.9.0也不一样。这样就不怕一些包不管语义化版本随便乱改API或者ABI了。</p><p><del>那这么多包，体积岂不是很大？是的</del></p><p>以Nix包管理器为发行版的NixOS，是需要你去写一个全局的配置文件<code>configuration.nix</code>，就像dotfiles一样。</p><p>不过NixOS应该也确实没什么太多人用，一直不怎么火。毕竟为了一个Nix包管理器再多学一门Nix语言，然后为了这盘醋包了这盘饺子，总感觉有点代价太大了。当然也可以不学，有一个Guix是直接用lisp的。不过这个更加清蒸，一些非自由软件你要自力更生。</p><p>NixOS另一个巨大的问题是不兼容FHS，就是<code>/usr/bin</code>之类的那一套目录。然后很多在别的发行版跑的好好的应用由于目录问题就跑不起来了，需要打一大堆patch。而且Nix的包现在太少了，各种问题需要自己解决。虽然安装门槛并不比Arch高，但是打包门槛和工作量我觉得比Arch高不少。于是我在虚拟机里面玩了一圈又滚回了Arch，又不是不能用.jpg （其实再不删掉继续玩下去我硬盘不够了）</p><p>最近听说deepin要脱离deb做自己的包管理器了，祝他们好运吧。deepin这么做会不会加剧发行版包管理器碎片化已经无所谓了，比起只顾着套壳圈钱的产品，折腾出点什么总不算太坏。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://edolstra.github.io/pubs/phd-thesis.pdf">The Purely Functional Software<br>Deployment Model</a><br><span class="exturl" data-url="aHR0cHM6Ly90dW5hLm1vZS9ldmVudC8yMDIxL25peC8=">金枪鱼之夜：Nix - 从构建系统到配置管理<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cubXBzY2hvbHRlbi5kZS9kb2NrZXIvMjAxNi8wMS8yNy95b3UtYXJlLW1vc3QtbGlrZWx5LW1pc3VzaW5nLWRvY2tlci5odG1s">You Are Most Likely Misusing Docker<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05peE9TL25peA==">Nix, the purely functional package manager<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9uaXhvcy5vcmcvbWFudWFsL25peC9zdGFibGUv">Nix Manual<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一直没有什么处理依赖问题的好思路，后知后觉发现Nix包管理器。要是当年我还沉迷lisp的时候真的注意到这个，说不定现在人已经跑到NixOS去了&lt;/p&gt;</summary>
    
    
    
    <category term="杂七杂八" scheme="https://zhangjk98.xyz/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"/>
    
    
    <category term="dependency hell" scheme="https://zhangjk98.xyz/tags/dependency-hell/"/>
    
    <category term="functional" scheme="https://zhangjk98.xyz/tags/functional/"/>
    
    <category term="Nix" scheme="https://zhangjk98.xyz/tags/Nix/"/>
    
  </entry>
  
  <entry>
    <title>Quorum机制和边界问题</title>
    <link href="https://zhangjk98.xyz/quorum/"/>
    <id>https://zhangjk98.xyz/quorum/</id>
    <published>2022-05-24T06:00:00.000Z</published>
    <updated>2022-05-24T06:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式的多副本复制中，一个简单的做法是单主节点+多副本，另一种是多主节点，此时需要处理主节点冲突问题。在无主节点的写入一致性上，经常会用到Quorum机制（类似鸽笼原理），在Raft里面也有类似的机制（joint consensus），用来在多个节点变更的时候达成共识选出master</p><span id="more"></span><h2 id="Quorum"><a href="#Quorum" class="headerlink" title="Quorum"></a>Quorum</h2><p>n个节点要获取最新的值，一种方案是只有一个主节点，其他的都是副本。读取的时候只读主节点。这样对主节点压力很大，而且容错性低，主节点一旦故障就无法读取了。</p><p>所以有了一些多主节点和无主节点的方案。</p><p>先看比较简单的无主节点的情况，假设有n个节点，客户端向节点发送写请求w，读请求r。类似鸽巢原理，当$w+r&gt;n$的时候，读取到的节点包含最新值。</p><p>这样一个好处是容错，如果有少量节点故障依然可以正常工作。另一个好处是不必等写入全部完成后再进行读取，只要等到满足$w+r&gt;n$就可以读到新值。</p><p>那么如何找到最新的节点？可以用时间戳或者递增id等方式，从所有读取中找到一个最新的。</p><p>实际上关键问题是我们<strong>只要找到一个最新的就可以了</strong>，于是我们其实可以不用严格的$w+r&gt;n$，比如elasticsearch的consistency的quorum选项，区分了primary和replicas，<code>quroum = int( (primary + number_of_replicas) / 2 ) + 1</code>。这样区分了主从之后基本上只要从主节点读就可以了。考虑最简单最常用的主从备份，一个主节点一个从节点，只要从主节点读到就可以了（或者主从节点都读到）</p><p>再比如etcd的joint consensus，要选出leader，同时变更多个节点的时候要达成共识（不然有可能同时选出两个leader）<br>变更之前是C_old, 变更之后是C_new, 中间状态是C_old,new, 也需要用鸽巢原理选出majority认可的leader。（注意中间达成共识是需要时间的，不能从C_old直接跳到C_new, 在边界条件从C_old,new才能避免）。通过一个中间状态保证了要么是C_old,new的leader，要么是C_new的leader，这样就不会选出两个。</p><p>在类似elasticsearch的系统中w和r的参数可以配置，读多写少的场景下就将w设置的大一点。一种很简单的复制方法是WARO（Write All Read One），其实这就是w&#x3D;n, r&#x3D;1情况下的一种特例。这个时候容错很低，只要有1个节点出问题，就会出现写入失败的情况，此时读就没法读到新值。</p><h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><p>读写都是随机均匀的，有节点不可用的情况:</p><p>n&#x3D;3, w&#x3D;2, r&#x3D;2时可以容忍一个副本节点故障<br>n&#x3D;5, w&#x3D;3, r&#x3D;3时可以容忍2个<br>一般设置w和r都是$\frac{n}{2}$ ，可以容忍$\frac{n}{2}$个问题副本（读写都在$\frac{n}{2}$个剩余节点上）</p><p>当对读到新值的要求不那么高时，可以设置$w+r&lt;n$, 此时有概率不满足一致性，有可能读到旧数据。不过这样可以提供更高的可用性，只有当可用节点低于$min(w,r)$时，才会无法读写（不可用）。这个一般被称为sloppy quorum</p><h2 id="Quorum的问题"><a href="#Quorum的问题" class="headerlink" title="Quorum的问题"></a>Quorum的问题</h2><p>TLDR, Quorum无法保证强一致性。</p><p>没有返回最新的值的情况：</p><p>1.并发写入，解决并发写冲突的一种办法是丢弃早的（覆盖掉，会产生新的问题）<br>2.同时读写，但一部分节点还没写完（如果对时效要求不是很高那这个没关系）<br>3.之前新值大于w,但是某个节点故障了，恢复的时候恢复了一个旧值，此时新值为w-1，此时读不到新值</p><p>那有什么办法来保证强一致性呢，当然是Paxos和Raft啦（逃</p><p>那么如何判断并发写呢，下一篇再说吧（逃</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在分布式的多副本复制中，一个简单的做法是单主节点+多副本，另一种是多主节点，此时需要处理主节点冲突问题。在无主节点的写入一致性上，经常会用到Quorum机制（类似鸽笼原理），在Raft里面也有类似的机制（joint consensus），用来在多个节点变更的时候达成共识选出master&lt;/p&gt;</summary>
    
    
    
    <category term="Concurrency&amp;Go" scheme="https://zhangjk98.xyz/categories/Concurrency-Go/"/>
    
    
    <category term="quorum" scheme="https://zhangjk98.xyz/tags/quorum/"/>
    
  </entry>
  
  <entry>
    <title>写一个跳表</title>
    <link href="https://zhangjk98.xyz/skiplist/"/>
    <id>https://zhangjk98.xyz/skiplist/</id>
    <published>2022-05-20T11:14:02.000Z</published>
    <updated>2022-05-20T11:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>写起来确实比树家族简单太多了，树家族的并发我不太会整。为什么要费劲左旋右旋去平衡呢，跳表靠概率分布多么简单优雅啊</p><span id="more"></span><h2 id="关于跳表"><a href="#关于跳表" class="headerlink" title="关于跳表"></a>关于跳表</h2><p>跳表上个世纪的论文里面就有了，不过有业界大量使用貌似比较晚， 貌似是leveldb开始的，后来redis等很多数据库都上了跳表。</p><p>跳表在单链表上面加了一层一层的稀疏节点，于是查找的复杂度就降到了$O(\log_2n)$, 类似二分查找，从稀疏节点向下逐级找就行了。如果每一层的节点数量都是下一层的$\frac{1}{2}$</p><p><img src="/skiplist/1653038576.png"></p><p>跳表我很喜欢的一个地方是这个玩意不需要像树家族那样去靠左旋右旋来平衡，于是实现就特别简单。</p><p>跳表这个结构对缓存不是很友好（链表在内存里面不连续）但是实现很简单，而且加锁比较容易做到加锁力度小。</p><p>MuQSS调度器用的就是跳表， 取代了原来BFS调度器里面runqueue的链表，然后查找runqueue的插入复杂度变成了$O(logN)$，然后由于skiplist是有序的，每次只要取出头节点就可以了（优先级最高的），对于MuQSS查找task的复杂度是$O(1)$</p><p>MuQSS加锁的时候就直接对每个CPU的skiplist加了一把大锁（task不是很多，加小锁没必要）</p><p>这里多说一下BFS调度器的遍历$O(N)$复杂度，这个其实并不慢的，在绝大多数没有跑很多东西的桌面用户，可能链表里面就只有十几个task，遍历起来并不一定比$O(logN)$或者$O(1)$的调度器慢</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>leetcode上就有一道设计跳表的题，直接做呗 <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGVzaWduLXNraXBsaXN0Lw==">design skiplist<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  skl := Constructor()</span><br><span class="line">  skl.Add(<span class="number">1</span>)</span><br><span class="line">  skl.Add(<span class="number">2</span>)</span><br><span class="line">  skl.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(skl.Search(<span class="number">0</span>)) <span class="comment">// false</span></span><br><span class="line">  skl.Add(<span class="number">4</span>)</span><br><span class="line">  fmt.Println(skl.Search(<span class="number">1</span>)) <span class="comment">// true</span></span><br><span class="line">  skl.Add(<span class="number">5</span>)</span><br><span class="line">  skl.Erase(<span class="number">0</span>)</span><br><span class="line">  skl.Erase(<span class="number">1</span>)</span><br><span class="line">  fmt.Println(skl.Search(<span class="number">1</span>)) <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// fmt.Println(skl.Search(6)) // false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MAX_LEVEL <span class="type">int</span> = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Skiplist <span class="keyword">struct</span> &#123;</span><br><span class="line">  currentLevel <span class="type">int</span></span><br><span class="line">  root         *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">  Val  <span class="type">int</span></span><br><span class="line">  Prev []*Node</span><br><span class="line">  Next []*Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  rand.Seed(time.Now().UnixNano())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomLevel</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  level := <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> rand.Intn(<span class="number">2</span>) == <span class="number">1</span> &#123;</span><br><span class="line">    level++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> level &gt; MAX_LEVEL &#123;</span><br><span class="line">    level = MAX_LEVEL</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> Skiplist &#123;</span><br><span class="line">  <span class="keyword">var</span> skiplist Skiplist</span><br><span class="line">  <span class="keyword">var</span> node Node</span><br><span class="line">  skiplist.root = &amp;node</span><br><span class="line">  skiplist.currentLevel = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> skiplist</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sk *Skiplist)</span></span> Search(target <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">  _, ok := search(sk.root, target)</span><br><span class="line">  <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(root *Node, target <span class="type">int</span>)</span></span> (node *Node, ok <span class="type">bool</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="built_in">len</span>(root.Next) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    <span class="keyword">var</span> head = root.Next[i]</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Val &gt; target &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Val == target &#123;</span><br><span class="line">      node, ok = head, <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Val &lt; target &#123; <span class="comment">// 小于则向下</span></span><br><span class="line">      root = head</span><br><span class="line">      i = <span class="built_in">len</span>(root.Next)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sk *Skiplist)</span></span> Add(num <span class="type">int</span>) &#123;</span><br><span class="line">  level := randomLevel() <span class="comment">// 随机选择level</span></span><br><span class="line">  node := Node&#123;</span><br><span class="line">    Val:  num,</span><br><span class="line">    Prev: <span class="built_in">make</span>([]*Node, level),</span><br><span class="line">    Next: <span class="built_in">make</span>([]*Node, level),</span><br><span class="line">  &#125;</span><br><span class="line">  add(sk.root, &amp;node)</span><br><span class="line">  <span class="keyword">if</span> level &gt; sk.currentLevel &#123;</span><br><span class="line">    <span class="keyword">for</span> i := sk.currentLevel; i &lt; level; i++ &#123;</span><br><span class="line">      sk.root.Next = <span class="built_in">append</span>(sk.root.Next, &amp;node)</span><br><span class="line">      node.Prev[i] = sk.root</span><br><span class="line">    &#125;</span><br><span class="line">    sk.currentLevel = level</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(root *Node, node *Node)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="built_in">len</span>(root.Next) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    <span class="keyword">var</span> head = root.Next[i]</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(node.Next) &#123;</span><br><span class="line">        root.Next[i] = node</span><br><span class="line">        node.Prev[i] = root</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Val &gt;= node.Val &#123;</span><br><span class="line">      <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(node.Next) &#123;</span><br><span class="line">        root.Next[i] = node</span><br><span class="line">        node.Next[i] = head</span><br><span class="line">        node.Prev[i] = root</span><br><span class="line">        node.Next[i].Prev[i] = node</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> head.Val &lt; node.Val &#123;</span><br><span class="line">      root = head</span><br><span class="line">      i = <span class="built_in">len</span>(root.Next)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除元素，然后直接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sk *Skiplist)</span></span> Erase(num <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">  node, ok := search(sk.root, num)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(node.Next); i++ &#123;</span><br><span class="line">    node.Prev[i].Next[i] = node.Next[i]</span><br><span class="line">    <span class="keyword">if</span> node.Next[i] != <span class="literal">nil</span> &#123;</span><br><span class="line">      node.Next[i].Prev[i] = node.Prev[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://15721.courses.cs.cmu.edu/spring2018/papers/08-oltpindexes1/pugh-skiplists-cacm1990.pdf">Skip Lists: A Probabilistic Alternative to<br>Balanced Trees</a>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写起来确实比树家族简单太多了，树家族的并发我不太会整。为什么要费劲左旋右旋去平衡呢，跳表靠概率分布多么简单优雅啊&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://zhangjk98.xyz/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="skiplist" scheme="https://zhangjk98.xyz/tags/skiplist/"/>
    
  </entry>
  
  <entry>
    <title>CS144 Lab0 笔记：环境配置和热身</title>
    <link href="https://zhangjk98.xyz/cs144-note/"/>
    <id>https://zhangjk98.xyz/cs144-note/</id>
    <published>2022-05-07T08:38:17.000Z</published>
    <updated>2022-05-07T08:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>写习惯了go之后c&#x2F;cpp水平直线下滑，每三行都有一行忘了加分号。麻了，全靠clang-tidy和报错clang报错救我狗命</p><span id="more"></span><h2 id="关于cs144"><a href="#关于cs144" class="headerlink" title="关于cs144"></a>关于cs144</h2><p>cs144的Lab是实现一个TCP协议栈，可惜是用C++写的，而且那个代码风格我也不怎么喜欢。我C++水平很菜，基本写东西都是C with Class 风格的。而且我不怎么喜欢 Modern C++， 所以不会按照Lab的要求（比如用迭代器代替循环、不使用malloc&#x2F;free之类的东西、使用智能指针等）</p><h3 id="做了几个Lab之后的更新"><a href="#做了几个Lab之后的更新" class="headerlink" title="做了几个Lab之后的更新"></a>做了几个Lab之后的更新</h3><p>做了三个Lab了回来说一下，这个课程的讲解和Lab的参考材料非常不详细，不像6.S081那样有不少Hints，各种讲解和助教的大作业FAQ什么的也把容易踩坑的地方都提到了。于是CS144的Lab做起来就很麻，颇有一种<code>fly bitch!</code>的感觉。</p><p><img src="/cs144-note/1652191785.png"></p><p>我做这个东西人麻了的程度甚至比6.824那一堆race条件debug找不出来还要麻。6.824实现Raft好好看论文和资料，大概知道Raft的状态转移和实现思路，剩下的是漫长的debug和race条件抓虫。这个不一样，这个好多思路和细节Lab根本不告诉你，然后实现的时候脑子是懵的，经常不知道干嘛，完全没有思路。然后翻了半天《TCP&#x2F;IP详解：卷2》，然后各种乱找资料</p><p>而且golang我用的比c++，尤其是modern c++熟太多了。然后这个Lab的各种命名也不像xv6那种unix和POSIX风格的精简</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Archlinux下装这些包很简单，直接把<span class="exturl" data-url="aHR0cHM6Ly9zdGFuZm9yZC5lZHUvY2xhc3MvY3MxNDQvdm1faG93dG8vdm0taG93dG8tYnlvLmh0bWw=">BYO Linux installation<i class="fa fa-external-link-alt"></i></span> 列出来的包用pacman装一遍就好了</p><p>需要注意的是NetworkManger要配置一下忽略实验用的虚拟设备。</p><h2 id="Lab-0"><a href="#Lab-0" class="headerlink" title="Lab 0"></a>Lab 0</h2><p>前面几个Lab是用一下telnet和nc玩，跳过（nc用的不多，我还是习惯nmap）</p><h3 id="webget"><a href="#webget" class="headerlink" title="webget"></a>webget</h3><p>准备环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/cs144/sponge </span><br><span class="line"><span class="built_in">cd</span> sponge</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="comment"># 我比较喜欢用clang，报错比较舒服</span></span><br><span class="line">CC=clang CXX=clang++ cmake ..</span><br><span class="line">make -j12</span><br></pre></td></tr></table></figure><p>这个很简单，直接照着<code>TCPSocket</code>的文档改就可以了， 见 <span class="exturl" data-url="aHR0cHM6Ly9jczE0NC5naXRodWIuaW8vZG9jL2xhYjAvY2xhc3NfdF9jX3Bfc29ja2V0Lmh0bWw=">https://cs144.github.io/doc/lab0/class_t_c_p_socket.html<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_URL</span><span class="params">(<span class="type">const</span> string &amp;host, <span class="type">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    TCPSocket sock1&#123;&#125;;</span><br><span class="line">    sock1.<span class="built_in">connect</span>(<span class="built_in">Address</span>(host, <span class="string">&quot;http&quot;</span>));</span><br><span class="line">    sock1.<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/1.1\r\nHost: &quot;</span> + host + <span class="string">&quot;\r\n\r\n&quot;</span>);</span><br><span class="line">    sock1.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">    <span class="keyword">while</span> (!sock1.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; sock1.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    sock1.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编译并测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make webget</span><br><span class="line">make check_webget</span><br></pre></td></tr></table></figure><h3 id="An-in-memory-reliable-byte-stream"><a href="#An-in-memory-reliable-byte-stream" class="headerlink" title="An in-memory reliable byte stream"></a>An in-memory reliable byte stream</h3><p>实现一个内存中有序的字节流。这个算是开胃菜，TCP是在不可靠的网络下实现有序的字节流。这里不要求并发和加锁，所以只要一个非常简单的队列+buffer缓冲就可以了。</p><blockquote><p>Your byte stream is for use in a single thread—you don’t have to worry about concurrent writers&#x2F;readers, locking, or race conditions.</p></blockquote><p>看到这句话之前我还以为这个Lab要折腾menory barrier那些东西，这样就好办了。</p><p>第一反应是整一个像kqueue那样的循环队列，可是这个Lab的C++风格他不让我用指针，习惯了c风格好难受。算了算了上stl吧。字节流那就直接用队列吧。然后这个类里面再加上是容量（capacity），写入字节，读取字节、是否结束，就差不多了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ByteStream</span> &#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::deque&lt;<span class="type">char</span>&gt; _buffer;</span><br><span class="line">    <span class="type">size_t</span> _capacity;</span><br><span class="line">    <span class="type">bool</span> _input_end;</span><br><span class="line">    <span class="type">size_t</span> _byte_written;</span><br><span class="line">    <span class="type">size_t</span> _byte_read;</span><br></pre></td></tr></table></figure><p>然后我们分别实现这几个类的方法，write好办，注意一下长度就行了。这里要求编码规范是Modern C++, 但是我Modern C++ 不熟，也没怎么用迭代器，蠢蠢的扔了好多for循环之类的东西</p><p>write就是一个简单的队尾出队，然后<code>_byte_written</code>计数增加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="type">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_input_end == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> _data_length = data.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (_data_length + _buffer.<span class="built_in">size</span>() &gt; _capacity) &#123;</span><br><span class="line">        _data_length = _capacity - _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    _byte_written += _data_length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _data_length; i++) &#123;</span><br><span class="line">        _buffer.<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _data_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peek好办，直接拼成字符串就行了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peek的时候输出是一个string</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> _length = len;</span><br><span class="line">    <span class="keyword">if</span> (_length &gt; _buffer.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        _length = _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">(_buffer.begin(), _buffer.begin() + _length)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop_output</code>也简单，注意一下长度然后从队列头部pop就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buffer里面弹出长度为len的字节，需要考虑len &gt; _buffer.size()的情况</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> _data_length = len;</span><br><span class="line">    <span class="keyword">if</span> (_data_length &gt; _buffer.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        _data_length = _buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _data_length; i++) &#123;</span><br><span class="line">        _buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">        _byte_read++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后read就是先<code>peek_output</code>再<code>pop_output</code>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写端的read，注意需要pop_ouput, 读出来之后需要pop的</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string output = <span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="built_in">pop_output</span>(len);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这一堆方法就直接返回相应的值就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; _input_end = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _input_end; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _buffer.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _buffer.<span class="built_in">empty</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _input_end; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _byte_written; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _byte_read; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _buffer.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure><p>emmmmm, 然后<code>make check_lab0</code>有两个test没过，看一下报错<code>Failure message:        The ByteStream should have had eof equal to 0 but instead it was 1</code></p><p>哦，忘了设置EOF了。不对我设了，那是哪出问题了。。。找了五分钟发现EOF要加上队列empty的条件，我是傻逼</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _input_end &amp;&amp; <span class="built_in">buffer_empty</span>(); &#125;</span><br></pre></td></tr></table></figure><p>这样测试就过了</p><h2 id="链接和参考材料"><a href="#链接和参考材料" class="headerlink" title="链接和参考材料"></a>链接和参考材料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jczE0NC5naXRodWIuaW8v">https://cs144.github.io/<i class="fa fa-external-link-alt"></i></span> 课程主页<br>还有视频录像不过我不喜欢看视频，没看，直接上的Lab<br>《TCP&#x2F;IP详解 卷2》 这个有不少实现的细节, Lab讲的不详细我基本上都是跑到这里面翻的<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z6eXo5OTkvQW5hbHlzaXNfVENQX2luX0xpbnV4">Linux 4.4.0内核源码分析——TCP实现<i class="fa fa-external-link-alt"></i></span> 太感动了这个资料，注释极为详细（不过linux协议栈的实现很复杂，适合没思路的时候偶尔翻翻找找灵感，这个Lab的实现一般都很Naive，差别很大不适合照抄）  </p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NhbWluaWlyL2xldmVsLWlw">level-ip<i class="fa fa-external-link-alt"></i></span> 一个用户态玩具TCP&#x2F;IP协议栈，c写的<br>我最开始先看的这个，对TCP&#x2F;IP协议栈有个大概的概念，感觉这个看过一遍有了点头绪，CS144的Lab指导看完对整个TCP&#x2F;IP协议栈是啥样的没啥头绪<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stMS1ldGhlcm5ldC1hcnAv">Let’s code a TCP&#x2F;IP stack, 1: Ethernet &amp; ARP<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stMi1pcHY0LWljbXB2NC8=">Let’s code a TCP&#x2F;IP stack, 2: IPv4 &amp; ICMPv4<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stMy10Y3AtaGFuZHNoYWtlLw==">Let’s code a TCP&#x2F;IP stack, 3: TCP Basics &amp; Handshake<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stNC10Y3AtZGF0YS1mbG93LXNvY2tldC1hcGkv">Let’s code a TCP&#x2F;IP stack, 4: TCP Data Flow &amp; Socket API<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stNS10Y3AtcmV0cmFuc21pc3Npb24v">Let’s code a TCP&#x2F;IP stack, 5: TCP Retransmission<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cHM6Ly9yZmMuZnlpLw==">rfc.fyi<i class="fa fa-external-link-alt"></i></span> RFC标准速查表  </p><p>然后是对写这门课的Lab可能帮助不是特别大的书和资料(资料本身其实都还不错)</p><p>《TCP&#x2F;IP详解 卷1》 这个主要讲概念，看完一遍之后还是不知道怎么实现，如果是为了做Lab找资料推荐直接翻卷2<br>《计算机网络: 自顶向下方法》这个书好是好，但是讲的太简略了，看完想实现没啥头绪，还得去TCP&#x2F;IP协议卷2翻细节，这本书的协议栈实现讲的是<code>4.4BSD-Lite</code>，<br>《深入理解LINUX网络技术内幕》大量的章节都在讲网络驱动，和这门课的Lab的TCP协议栈的内容关系不是特别大<br>《Effective Modern C++ 中文版》 这本书我研一买的，彩色印刷，包装很烂。我当时就想看看modern c++，然后看到一半彻底对C++喜欢不起来了。当时我唯一的想法就是不要把有限的生命浪费在一个充斥着语言律师的语言上。那个时候还在看《The Little Schemer》，看那些优雅连贯的递归的奇妙感觉，和同时在看的c++的繁杂形成了鲜明的对比。也是在那会，被C++坑的多了突然喜欢上go了。  </p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby9lbmcvMjAxNy8wMi8wNi9tb25pdG9yaW5nLXR1bmluZy1saW51eC1uZXR3b3JraW5nLXN0YWNrLXNlbmRpbmctZGF0YQ==">Monitoring and Tuning the Linux Networking Stack: Sending Data<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby9lbmcvMjAxNi8wNi8yMi9tb25pdG9yaW5nLXR1bmluZy1saW51eC1uZXR3b3JraW5nLXN0YWNrLXJlY2VpdmluZy1kYXRhLw==">Monitoring and Tuning the Linux Networking Stack: Receiving Data<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2FydGh1cmNoaWFvLmFydC9ibG9nL3R1bmluZy1zdGFjay10eC16aC8=">[译] Linux 网络栈监控和调优：发送数据（2017）<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2FydGh1cmNoaWFvLmFydC9ibG9nL3R1bmluZy1zdGFjay1yeC16aC8=">[译] Linux 网络栈监控和调优：接收数据（2016）<i class="fa fa-external-link-alt"></i></span>  这两篇文章适合做完Lab再看，很容易迷失在细节里面  </p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzExODAudHh0">A TCP&#x2F;IP Tutorial<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2FydGh1cmNoaWFvLmFydC9ibG9nL3JmYzExODAtYS10Y3AtaXAtdHV0b3JpYWwtemgv">[译] RFC 1180：朴素 TCP&#x2F;IP 教程（1991）<i class="fa fa-external-link-alt"></i></span><br>我一开始还以为是实现一个TCP协议栈的，点开才发现很老的一个简短介绍，大概相当于TCP&#x2F;IP卷1的太长不看版。其实讲的还可以，没有一点废话，不过对Lab没啥帮助。</p><p><span class="exturl" data-url="aHR0cDovL3d3dy41MmltLm5ldC90aHJlYWQtMTAwMy0xLTEuaHRtbA==">不为人知的网络编程(一)：浅析TCP协议中的疑难杂症(上篇)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL3d3dy41MmltLm5ldC90aHJlYWQtMTAwNC0xLTEuaHRtbA==">不为人知的网络编程(二)：浅析TCP协议中的疑难杂症(下篇)<i class="fa fa-external-link-alt"></i></span> 做Lab4的时候搜资料看到的，解决了我对TCP的一点疑惑  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写习惯了go之后c&amp;#x2F;cpp水平直线下滑，每三行都有一行忘了加分号。麻了，全靠clang-tidy和报错clang报错救我狗命&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="network" scheme="https://zhangjk98.xyz/tags/network/"/>
    
    <category term="cs144" scheme="https://zhangjk98.xyz/tags/cs144/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Networking 笔记，完结撒花</title>
    <link href="https://zhangjk98.xyz/6-S081-lab-network-driver/"/>
    <id>https://zhangjk98.xyz/6-S081-lab-network-driver/</id>
    <published>2022-05-05T09:15:11.000Z</published>
    <updated>2022-05-05T09:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个Lab就是补全一个DMA收发的驱动, 不要被Lab标的Hard难度吓到，我感觉这是6.S081这几个Lab最简单的几个Lab之一。写个驱动都不用上板子调试，没啥意思，怎么感觉比当年你电PPT吹水课程微嵌的实验大作业给FPGA的板子写个驱动还水。。。<br>最后一个Lab放水，愉快的完结撒花。也难怪在2021 fall的lab net不是最后一个。等等，这个Lab还有附加内容，实现一个TCP&#x2F;UDP协议栈。。。</p><span id="more"></span><h2 id="Lab内容"><a href="#Lab内容" class="headerlink" title="Lab内容"></a>Lab内容</h2><p>这个难度明明是easy，不要被标的那个hard吓到了。做起来这个Lab挺没意思的，e1000这种远古网卡，现在应该没多少人用了。这个网卡是qemu虚拟出来的网卡，就跟代理的时候用的那个tun&#x2F;tap差不多</p><blockquote><p>Your job is to complete e1000_transmit() and e1000_recv(), both in kernel&#x2F;e1000.c, so that the driver can transmit and receive packets</p></blockquote><p>这个好办，我们直接扒拉e1000的手册就可以了。或者我们直接看<code>kernel/e1000_dev.h</code>, <code>E1000_RDH</code>是E1000 RX Descriptor Head， <code>E1000_RDT</code>是RX descriptor tail，同理<code>E1000_TDT</code>是TX descriptor tail（由TX的功能我们可以知道这是the next packet的坐标）， <code>E1000_RXD_STAT_DD</code>是 Descriptor Done， 然后<code>E1000_TXD_CMD_EOP</code>是 End of Packet。</p><p>RX ring接受网卡数据的读取buffer， TX ring是发送packet的发送buffer。<code>rx_ring</code>是一个环形链表<code>rx_desc</code>，里面放的是packet的地址（packet是通过DMA放在内存里面）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [E1000 3.2.3]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rx_desc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  uint64 addr;       <span class="comment">/* Address of the descriptor&#x27;s data buffer */</span></span><br><span class="line">  uint16 length;     <span class="comment">/* Length of data DMAed into data buffer */</span></span><br><span class="line">  uint16 csum;       <span class="comment">/* Packet checksum */</span></span><br><span class="line">  uint8 status;      <span class="comment">/* Descriptor status */</span></span><br><span class="line">  uint8 errors;      <span class="comment">/* Descriptor Errors */</span></span><br><span class="line">  uint16 special;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后我们照着提示就可以补全<code>kernel/e1000.c</code>了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span> &#123;</span><br><span class="line">    <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">    <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">    <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    acquire(&amp;e1000_lock); <span class="comment">// 发送时加spin_lock</span></span><br><span class="line">    uint32 idx = regs[E1000_TDT];</span><br><span class="line">    <span class="keyword">if</span> (!(E1000_TXD_STAT_DD &amp; tx_ring[idx].status)) &#123; <span class="comment">// buffer不足</span></span><br><span class="line">        release(&amp;e1000_lock);                         <span class="comment">// 释放锁</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tx_mbufs[idx]) &#123;</span><br><span class="line">        mbuffree(tx_mbufs[idx]);</span><br><span class="line">        tx_mbufs[idx] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tx_ring[idx].addr = (uint64)m-&gt;head;</span><br><span class="line">    tx_ring[idx].length = m-&gt;len;</span><br><span class="line"></span><br><span class="line">    tx_ring[idx].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line">    tx_mbufs[idx] = m;</span><br><span class="line"></span><br><span class="line">    regs[E1000_TDT] = (idx + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">e1000_recv</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">    <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// First ask the E1000 for the ring index at which the next waiting</span></span><br><span class="line">        <span class="comment">// received packet (if any) is located, by fetching the E1000_RDT</span></span><br><span class="line">        <span class="comment">// control register and adding one modulo RX_RING_SIZE.</span></span><br><span class="line">        uint32 idx = regs[E1000_RDT];</span><br><span class="line">        idx = (idx + <span class="number">1</span>) % RX_RING_SIZE; <span class="comment">// 这是个环形链表，需要mod ring size</span></span><br><span class="line">        <span class="keyword">if</span> (!(E1000_RXD_STAT_DD &amp; rx_ring[idx].status)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rx_mbufs[idx]-&gt;len = rx_ring[idx].length;</span><br><span class="line">        net_rx(rx_mbufs[idx]);</span><br><span class="line">        rx_mbufs[idx] = mbufalloc(<span class="number">0</span>); <span class="comment">//这里直接mbufalloc就可以了，不需要kalloc</span></span><br><span class="line">        rx_ring[idx].addr = (uint64)rx_mbufs[idx]-&gt;head;</span><br><span class="line">        rx_ring[idx].status = <span class="number">0</span>;</span><br><span class="line">        regs[E1000_RDT] = idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ make grade</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">== Test running nettests == </span><br><span class="line">$ make qemu-gdb</span><br><span class="line">(2.8s) </span><br><span class="line">== Test   nettest: ping == </span><br><span class="line">  nettest: ping: OK </span><br><span class="line">== Test   nettest: single process == </span><br><span class="line">  nettest: single process: OK </span><br><span class="line">== Test   nettest: multi-process == </span><br><span class="line">  nettest: multi-process: OK </span><br><span class="line">== Test   nettest: DNS == </span><br><span class="line">  nettest: DNS: OK </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 100/100</span><br></pre></td></tr></table></figure><p>一开始以为很难，又是讨厌的驱动，然后一看难度还是hard，勾起了我当年痛苦的。上一次写驱动的大作业还是本科的时候，当时换了两块xilinx的阴间开发板全都是坏的，害得我还以为是我自己写的有问题，找了一周没找到bug。本来是抱着人又麻了的心态来做这个Lab的（这个Lab在2020年是最后一个Lab，在2021年放到了前面），拖了几个月，别的Lab都做完了，然后陆续把笔记也补上了，最后捡起了一直咕咕咕的6.824，做到Raft的Lab4死活跑不过测试这才回来做这个Lab，结果发现意外的简单。</p><p>好久之前写的Lab，由于懒癌发作一直没有写笔记，现在把Lab的笔记补上。这个Lab比较玩具，没啥好讲的。驱动和网络单独拿出来都是一个大坑，水平有限不多讲了。</p><p>这个Lab的Optional Challenges比较麻烦，其中最后两个challenge是：</p><blockquote><p>Implement a UDP server for xv6. (moderate)<br>Implement a minimal TCP stack and download a web page. (hard)</p></blockquote><p>然后搜了一下发现有一个xv6-net的实现：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhbmRheDM4MS94djYtbmV0L2Jsb2IvbmV0L3RjcC5j">https://github.com/pandax381/xv6-net/blob/net/tcp.c<i class="fa fa-external-link-alt"></i></span></p><p>由于懒癌发作我当然又是没做，我的菜鸡计网水平和对TCP的熟悉程度应该一时半会做不出来。听说有cs144这门课就是实现一个TCP协议栈，等研三有空了回头把这个做了把这个大坑填上。</p><p>6.S081这个课从去年7月开始，断断续续做了将近一年把Lab做了，xv6的源码看了不到一半。xv6作为一个教学的系统，挺精简挺小巧，能比较顺利的看下去。像linux源码那种看不太动，拿着赵炯那本《linux内核完全注释》看早期内核也比较麻烦。xv6-book写的真的好，推荐做Lab和读xv6源码的时候好好把xv6-book看一下：</p><p><em>xv6: a simple, Unix-like teaching operating system</em><br>作者Russ Cox, Frans Kaashoek, Robert Morris 应该都听过，Russ Cox是争议比较大的go现任掌门，喜欢在go的issue区开喷，Morris是6.824这门课的主讲，就是那个蠕虫病毒的作者。</p><p>一开始我没在意，觉得这本书就是跟手册一样，偶尔翻一翻。后来发现这本册子写的是真的好，几乎没有一点废话，比课程讲义好多了。早应该看这个的。</p><p>然后就是重新翻了k&amp;r这本书，写的真好，也没有多少废话。里面的例子非常精简。</p><p>更新：不等研三了，直接上CS144了。之前没事喜欢摆弄nmap、wireshark这些东西瞎玩，却没好好看过TCP的细节，再这样不思进取下去就要沦为脚本小子了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个Lab就是补全一个DMA收发的驱动, 不要被Lab标的Hard难度吓到，我感觉这是6.S081这几个Lab最简单的几个Lab之一。写个驱动都不用上板子调试，没啥意思，怎么感觉比当年你电PPT吹水课程微嵌的实验大作业给FPGA的板子写个驱动还水。。。&lt;br&gt;最后一个Lab放水，愉快的完结撒花。也难怪在2021 fall的lab net不是最后一个。等等，这个Lab还有附加内容，实现一个TCP&amp;#x2F;UDP协议栈。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="network" scheme="https://zhangjk98.xyz/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>又被Docker坑了（这次是内存</title>
    <link href="https://zhangjk98.xyz/aware-docker-memory/"/>
    <id>https://zhangjk98.xyz/aware-docker-memory/</id>
    <published>2022-04-24T14:07:46.000Z</published>
    <updated>2022-04-24T14:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>好端端一个Docker container，怎么就内存占用过高被kill了呢</p><span id="more"></span><p>好吧这好像也不全算Docker的锅，罪魁祸首竟是dentry</p><h2 id="dentry还我内存"><a href="#dentry还我内存" class="headerlink" title="dentry还我内存"></a>dentry还我内存</h2><p>发现是dentry的锅</p><h2 id="Docker的一些替代品"><a href="#Docker的一些替代品" class="headerlink" title="Docker的一些替代品"></a>Docker的一些替代品</h2><p>说起来当时把那几台老的Ubuntu16.04和远古版本的</p><p>Docker看起来简单但是坑真的不算少，要用好Docker（很多人是图方便才来用Docker的）</p><p>如果只是日常使用为了装一些软件或依赖方便呢，装一个Archlinux显然更方便（这比搞懂Docker那一堆网络、layer、）</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJkYW5sYWJzLmNvbS9ibG9nLzIwMjAvMDIvZG9ja2VyLWltYWdlcy1wYXJ0MS1yZWR1Y2luZy1pbWFnZS1zaXplLmh0bWw=">https://www.ardanlabs.com/blog/2020/02/docker-images-part1-reducing-image-size.html<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MzEzMzA4NQ==">https://zhuanlan.zhihu.com/p/43133085<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmFyc3RlcmN6LmNvbS9jZW50b3MtJUU3JUIzJUJCJUU3JUJCJTlGLXNsYWItZGVudHJ5LSVFOCVCRiU4NyVFOSVBQiU5OCVFNSVCQyU5NSVFOCVCNSVCNyVFNyVCMyVCQiVFNyVCQiU5RiVFNSU4RCVBMSVFOSVBMSVCRiVFNSU4OCU4NiVFNiU5RSU5MCVFNSVBNCU4NCVFNyU5MCU4Ni8=">https://blog.arstercz.com/centos-系统-slab-dentry-过高引起系统卡顿分析处理/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9oYWNrZXJub29uLmNvbS9hbm90aGVyLXJlYXNvbi13aHkteW91ci1kb2NrZXItY29udGFpbmVycy1tYXktYmUtc2xvdy1kMzcyMDdkZWMyN2Y=">https://hackernoon.com/another-reason-why-your-docker-containers-may-be-slow-d37207dec27f<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2FvZ2FvNjcvYXJ0aWNsZXMvMTU1NjgzNzguaHRtbA==">https://www.cnblogs.com/gaogao67/articles/15568378.html<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好端端一个Docker container，怎么就内存占用过高被kill了呢&lt;/p&gt;</summary>
    
    
    
    
    <category term="Docker" scheme="https://zhangjk98.xyz/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Multithreading 笔记</title>
    <link href="https://zhangjk98.xyz/6-S081-lab-multithreading/"/>
    <id>https://zhangjk98.xyz/6-S081-lab-multithreading/</id>
    <published>2022-04-20T11:27:58.000Z</published>
    <updated>2022-04-20T11:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个用户态线程uthread，就照着xv6的内核态线程抄呗。怎么什么FUSE啊、UIO啊，什么东西都想往用户态搬啊，连RCU都有人想往用户态搬。</p><span id="more"></span><h2 id="xv6中的process"><a href="#xv6中的process" class="headerlink" title="xv6中的process"></a>xv6中的process</h2><h3 id="process的状态"><a href="#process的状态" class="headerlink" title="process的状态"></a>process的状态</h3><p>xv6的线程状态包括 UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE</p><p><img src="/6-S081-lab-multithreading/1650459636.png"></p><h3 id="process调度"><a href="#process调度" class="headerlink" title="process调度"></a>process调度</h3><p>用户态进程的切换是需要内核态的 kstack scheduler的</p><p><img src="/6-S081-lab-multithreading/1650459961.png"></p><p>我们下面来看调度过程，相比linux里面的调度器这个简单多了。就是一个最简单的时间片轮转。</p><p>首先我们看proc这个结构体（就相当于linux里面的task这个结构体）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">trapframe</span>;</span> <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span>  <span class="comment">// Open files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span>           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在process切换的时候，保存proc的trapframe和context用来恢复，然后还有proc的状态（STATE）、pid等。</p><p>在切换的时候主要的工作是context和trapframe的保存和恢复。context被翻译成上下文，然后当年书里说半天我也没搞懂这到底是个啥玩意。后来看了xv6的源码才知道这是个啥。到底是谁最先把context翻译成上下文的啊？？？？ 我们直接看源码， <code>kernel/proc.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for kernel context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra; <span class="meta"># return address, 返回地址</span></span><br><span class="line">  uint64 sp; <span class="meta"># stack pointer，栈指针寄存器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>context是一个结构体，里面是寄存器的值（用来保存和恢复process的状态）</p><p>trapframe也是一个结构体，放的东西更多了点。比如process的内核页表、比如kernel_sp寄存器，比如epc寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  <span class="comment">/*  40 */</span> uint64 ra;</span><br><span class="line">  <span class="comment">/*  48 */</span> uint64 sp;</span><br><span class="line">  <span class="comment">/*  56 */</span> uint64 gp;</span><br><span class="line">  <span class="comment">/*  64 */</span> uint64 tp;</span><br><span class="line">  <span class="comment">/*  72 */</span> uint64 t0;</span><br><span class="line">  <span class="comment">/*  80 */</span> uint64 t1;</span><br><span class="line">  <span class="comment">/*  88 */</span> uint64 t2;</span><br><span class="line">  <span class="comment">/*  96 */</span> uint64 s0;</span><br><span class="line">  <span class="comment">/* 104 */</span> uint64 s1;</span><br><span class="line">  <span class="comment">/* 112 */</span> uint64 a0;</span><br><span class="line">  <span class="comment">/* 120 */</span> uint64 a1;</span><br><span class="line">  <span class="comment">/* 128 */</span> uint64 a2;</span><br><span class="line">  <span class="comment">/* 136 */</span> uint64 a3;</span><br><span class="line">  <span class="comment">/* 144 */</span> uint64 a4;</span><br><span class="line">  <span class="comment">/* 152 */</span> uint64 a5;</span><br><span class="line">  <span class="comment">/* 160 */</span> uint64 a6;</span><br><span class="line">  <span class="comment">/* 168 */</span> uint64 a7;</span><br><span class="line">  <span class="comment">/* 176 */</span> uint64 s2;</span><br><span class="line">  <span class="comment">/* 184 */</span> uint64 s3;</span><br><span class="line">  <span class="comment">/* 192 */</span> uint64 s4;</span><br><span class="line">  <span class="comment">/* 200 */</span> uint64 s5;</span><br><span class="line">  <span class="comment">/* 208 */</span> uint64 s6;</span><br><span class="line">  <span class="comment">/* 216 */</span> uint64 s7;</span><br><span class="line">  <span class="comment">/* 224 */</span> uint64 s8;</span><br><span class="line">  <span class="comment">/* 232 */</span> uint64 s9;</span><br><span class="line">  <span class="comment">/* 240 */</span> uint64 s10;</span><br><span class="line">  <span class="comment">/* 248 */</span> uint64 s11;</span><br><span class="line">  <span class="comment">/* 256 */</span> uint64 t3;</span><br><span class="line">  <span class="comment">/* 264 */</span> uint64 t4;</span><br><span class="line">  <span class="comment">/* 272 */</span> uint64 t5;</span><br><span class="line">  <span class="comment">/* 280 */</span> uint64 t6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>说一下trapframe和context的区别，context保存的是线程切换（比如调度器切换线程）时候的数据（寄存器），trapframe保存的是trap的时候（切换内核态时候）的数据</p><h4 id="运行状态切换"><a href="#运行状态切换" class="headerlink" title="运行状态切换"></a>运行状态切换</h4><p>进入RUNNING是由<code>scheduler</code>处理的，这里就直接是一个简单的for循环，加锁找到可用的直接将状态变成RUNNING释放锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">scheduler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> =</span> mycpu();</span><br><span class="line">  </span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);    <span class="comment">// 保存context（上下文）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里swtch是保存并切换context。<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context);</code>表示保存c的context, 加载p的context。我们直接看一下<code>swtch.S</code>的代码就明白了：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">.globl</span> swtch</span><br><span class="line"><span class="symbol">swtch:</span></span><br><span class="line">        sd ra, <span class="number">0</span>(a0)</span><br><span class="line">        sd <span class="built_in">sp</span>, <span class="number">8</span>(a0)</span><br><span class="line">        sd <span class="built_in">s0</span>, <span class="number">16</span>(a0)</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        ld ra, <span class="number">0</span>(<span class="built_in">a1</span>)</span><br><span class="line">        ld <span class="built_in">sp</span>, <span class="number">8</span>(<span class="built_in">a1</span>)</span><br><span class="line">        ld <span class="built_in">s0</span>, <span class="number">16</span>(<span class="built_in">a1</span>)</span><br><span class="line">        .......</span><br><span class="line"></span><br><span class="line">        ret</span><br></pre></td></tr></table></figure><p>退出的过程是调用了<code>yield</code>，从RUNNING进入RUNNABLE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Give up the CPU for one scheduling round.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  acquire(&amp;p-&gt;lock);    <span class="comment">// 这里也要加一个自旋锁，如果不加，在yield过程中来一个中断之类的会出问题</span></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line">  sched();  <span class="comment">// 这里调用sched切换进程（恢复上下文等操作）</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>yield 调用了 sched</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sched</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;p-&gt;lock))    <span class="comment">// 必须持有锁</span></span><br><span class="line">    panic(<span class="string">&quot;sched p-&gt;lock&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff != <span class="number">1</span>)    <span class="comment">//中断是关的</span></span><br><span class="line">    panic(<span class="string">&quot;sched locks&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)   <span class="comment">//之前已经设为RUNNABLE，肯定不能是RUNNING</span></span><br><span class="line">    panic(<span class="string">&quot;sched running&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get())    <span class="comment">// 中断不能是enabled</span></span><br><span class="line">    panic(<span class="string">&quot;sched interruptible&quot;</span>);</span><br><span class="line"></span><br><span class="line">  intena = mycpu()-&gt;intena; <span class="comment">//将itena置为当前CPU的itena</span></span><br><span class="line">  swtch(&amp;p-&gt;context, &amp;mycpu()-&gt;context);    <span class="comment">//恢复context（上下文）</span></span><br><span class="line">  mycpu()-&gt;intena = intena;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说一下这个itena，定义在<code>kernel/proc.h</code>中，就是中断（interrupt）是否在push_off之前enable了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Per-CPU state.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从RUNNING退出到别的状态可能是收到了中断，也可能是进入SLEEPING（比如耗时较长的文件IO），也可能是被kill了或者父进程被kill了进入了ZOMBIE状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">kill</span><span class="params">(<span class="type">int</span> pid)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;pid == pid)&#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING)&#123;</span><br><span class="line">        <span class="comment">// Wake process from sleep().</span></span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h4><p>wakeup比较简单，就正常的加锁然后置为RUNNABLE就好了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p != myproc())&#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sleep这里要注意！这个spinlock是为了保证在执行sleep的时候没有别的进程调用wakeup。开始执行sleep之后lk就可以释放掉了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Atomically release lock and sleep on chan.</span></span><br><span class="line"><span class="comment">// Reacquires lock when awakened.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">  release(lk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  acquire(lk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><p>这个Lab有点意思，实现可以直接照抄内核态线程，做一个naive的用户态线程</p><h3 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (moderate)</h3><p>用户态线程的状态只有三种，FREE, RUNNING, RUNNABLE。状态机比较简单。<code>thread_init</code>初始化的时候状态设为RUNNING</p><p>创建a,b,c三个用户态thread,然后每个线程打印一次后就执行<code>thread_yield</code>切换线程，并将当前线程的状态设置为RUNNABLE</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_yield</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    current_thread-&gt;state = RUNNABLE;</span><br><span class="line">    thread_schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在线程结束的时候将状态置为FREE, <code>current_thread-&gt;state = FREE;</code>，调用</p><p><code>thread_create</code>传进来的参数是一个函数指针（比如thread_a）, 我们把函数指针存入ra寄存器，用来做恢复。<code>thread_create</code>实现可以参考<code>kernel/proc.c</code>里面的<code>allcproc()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;state == FREE)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;state = RUNNABLE;</span><br><span class="line">    t-&gt;thread_context.ra = (uint64)func;</span><br><span class="line">    t-&gt;thread_context.sp = t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把<code>kernel/proc.h</code>中的context抄过来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Saved registers for user context switches.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">    <span class="type">int</span> state;              <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_context</span> <span class="title">thread_context</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后<code>user/uthread_switch.S</code>中的<code>thread_switch</code>照抄<code>kernel/swtch.S</code>实现状态切换，不过<code>thread_switch</code>这里的上下文只保存Callee-saved的寄存器就可以了，所以我们删掉<code>sd ra, 0(a0)</code>和<code>ld ra, 0(a1)</code></p><p><strong>sp寄存器是callee寄存器，只有ra寄存器是caller寄存器</strong>，这个不能删，删了之后用户线程没法切换了！一开始记错了把sp寄存器也记成caller寄存器了，没输出调了好久</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># void thread_switch(struct context *old, struct context *new);</span></span><br><span class="line"><span class="symbol">thread_switch:</span></span><br><span class="line">    sd <span class="built_in">sp</span>, <span class="number">8</span>(a0)</span><br><span class="line">    sd <span class="built_in">s0</span>, <span class="number">16</span>(a0)</span><br><span class="line">    sd <span class="built_in">s1</span>, <span class="number">24</span>(a0)</span><br><span class="line">    sd <span class="built_in">s2</span>, <span class="number">32</span>(a0)</span><br><span class="line">    sd <span class="built_in">s3</span>, <span class="number">40</span>(a0)</span><br><span class="line">    sd <span class="built_in">s4</span>, <span class="number">48</span>(a0)</span><br><span class="line">    sd <span class="built_in">s5</span>, <span class="number">56</span>(a0)</span><br><span class="line">    sd <span class="built_in">s6</span>, <span class="number">64</span>(a0)</span><br><span class="line">    sd <span class="built_in">s7</span>, <span class="number">72</span>(a0)</span><br><span class="line">    sd <span class="built_in">s8</span>, <span class="number">80</span>(a0)</span><br><span class="line">    sd <span class="built_in">s9</span>, <span class="number">88</span>(a0)</span><br><span class="line">    sd <span class="built_in">s10</span>, <span class="number">96</span>(a0)</span><br><span class="line">    sd <span class="built_in">s11</span>, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">    ld <span class="built_in">sp</span>, <span class="number">8</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s0</span>, <span class="number">16</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s1</span>, <span class="number">24</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s2</span>, <span class="number">32</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s3</span>, <span class="number">40</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s4</span>, <span class="number">48</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s5</span>, <span class="number">56</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s6</span>, <span class="number">64</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s7</span>, <span class="number">72</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s8</span>, <span class="number">80</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s9</span>, <span class="number">88</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s10</span>, <span class="number">96</span>(<span class="built_in">a1</span>)</span><br><span class="line">    ld <span class="built_in">s11</span>, <span class="number">104</span>(<span class="built_in">a1</span>)</span><br><span class="line"></span><br><span class="line">  ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure><p>然后在<code>thread_switch</code>里面直接调用<code>thread_switch((uint64)t, (uint64)current_thread);</code></p><p>然后。。。报错了。调了一下午没找到哪出问题了，gdb打出来的调试信息看不出来。这个报错跟当初页表那个很像，debug的时候被误导了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ uthread</span><br><span class="line">usertrap(): unexpected scause 0x000000000000000f pid=3</span><br><span class="line">            sepc=0x0000000000000002 stval=0xfffffffffffffff8</span><br></pre></td></tr></table></figure><p>调了半天发现是我thread_switch的函数参数传错了，传进去的应该是context，寄存器a0是第一个参数，寄存器a1是参数，放的是寄存器的struct，然后按照地址偏移分别对应s0，s1等Callee寄存器的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_switch((uint64)&amp;t-&gt;thread_context, (uint64)&amp;current_thread-&gt;thread_context);</span><br></pre></td></tr></table></figure><p>终于正常了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ uthread</span><br><span class="line"><span class="number">310514718</span>thread_a started</span><br><span class="line">thread_b started</span><br><span class="line">thread_c started</span><br><span class="line">thread_c <span class="number">0</span></span><br><span class="line">thread_a <span class="number">0</span></span><br><span class="line">thread_b <span class="number">0</span></span><br><span class="line">thread_c <span class="number">1</span></span><br><span class="line">thread_a <span class="number">1</span></span><br><span class="line">thread_b <span class="number">1</span></span><br><span class="line">thread_c <span class="number">2</span></span><br><span class="line">thread_a <span class="number">2</span></span><br><span class="line">......</span><br><span class="line">thread_c <span class="number">99</span></span><br><span class="line">thread_a <span class="number">99</span></span><br><span class="line">thread_b <span class="number">99</span></span><br><span class="line">thread_c: <span class="built_in">exit</span> after <span class="number">100</span></span><br><span class="line">thread_a: <span class="built_in">exit</span> after <span class="number">100</span></span><br><span class="line">thread_b: <span class="built_in">exit</span> after <span class="number">100</span></span><br><span class="line">thread_schedule: no runnable threads</span><br></pre></td></tr></table></figure><h3 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h3><p>这个就是学一下怎么用pthread（这个是在unix&#x2F;linux里面，不是在qemu里），练习一下加mutex锁。<code>ph.c</code>里面有一个并发不安全的哈希表，就是一个简单的取模，然后放到相应的bucket里面，bucket中有重复的key就依次加到链表的后面。实现就和leetcode 706 设计哈希映射的官方题解差不多。这里bucket数量是5，所以很容易发生冲突，缓解hash冲突的一般做法是bucket去一个更大的质数，或者设计其他更好的hash函数减少hash冲突，或者我们不要链表，用开放定址或者rehash去解决hash冲突</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$make</span> ph</span><br><span class="line">$./ph 1</span><br><span class="line">100000 puts, 5.690 seconds, 17573 puts/second</span><br><span class="line">0: 0 keys missing</span><br><span class="line">100000 gets, 5.491 seconds, 18211 gets/second</span><br></pre></td></tr></table></figure><p>我们把线程开多一点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$./ph 10</span><br><span class="line">100000 puts, 0.333 seconds, 300217 puts/second</span><br><span class="line">2: 63594 keys missing</span><br><span class="line">7: 63594 keys missing</span><br><span class="line">1: 63594 keys missing</span><br><span class="line">9: 63594 keys missing</span><br><span class="line">5: 63594 keys missing</span><br><span class="line">8: 63594 keys missing</span><br><span class="line">6: 63594 keys missing</span><br><span class="line">4: 63594 keys missing</span><br><span class="line">0: 63594 keys missing</span><br><span class="line">3: 63594 keys missing</span><br><span class="line">1000000 gets, 5.871 seconds, 170320 gets/second</span><br></pre></td></tr></table></figure><p>然后我们把线程开到100，现在打字都卡了, 成千上万个 key missng。这里的hashmap在并发写的时候会冲突，就像go的map一样并发写的时候会直接报<code>fatal error: concurrent map writes</code>。读是没有关系的，但是<code>ph.c</code>第26行那个insert在写的时候是向entry（存key和value的链表后面加），并发写会把同时正在插入的覆盖掉。</p><p>Go map in actions 中有一个非常简单的给map加锁的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line"></span><br><span class="line">counter.RLock()</span><br><span class="line">n := counter.m[<span class="string">&quot;some_key&quot;</span>]</span><br><span class="line">counter.RUnlock()</span><br><span class="line">fmt.Println(<span class="string">&quot;some_key:&quot;</span>, n)</span><br><span class="line"></span><br><span class="line">counter.Lock()</span><br><span class="line">counter.m[<span class="string">&quot;some_key&quot;</span>]++</span><br><span class="line">counter.Unlock()</span><br></pre></td></tr></table></figure><p>我们仿照go的map写入加<code>sync.Mutex</code>，给insert加互斥锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock; <span class="comment">// declare a lock</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">put_thread</span><span class="params">(<span class="type">void</span> *xa)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = (<span class="type">int</span>)(<span class="type">long</span>)xa; <span class="comment">// thread number</span></span><br><span class="line">    <span class="type">int</span> b = NKEYS / nthread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        put(keys[b * n + i], n);</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就没有missing了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$make</span> ph</span><br><span class="line">$./ph 2</span><br><span class="line">100000 puts, 5.522 seconds, 18111 puts/second</span><br><span class="line">1: 0 keys missing</span><br><span class="line">0: 0 keys missing</span><br><span class="line">200000 gets, 5.628 seconds, 35535 gets/second</span><br></pre></td></tr></table></figure><p>但是这样有一个问题，速度没什么优势，把nthread开到10，puts用时6.094 seconds，还不如单线程。<code>make grade</code>的时候只能跑过<code>ph_safe</code>，没法通过<code>ph_fast</code>的。</p><p>想要速度我们需要更细粒度的锁，我们仿照go的concurrent-map那样分片加锁的方案在insert插入的时候给对应的bucket加锁。（go的sync.Map的那个加锁比较适合读多写少的方案，这里大量写入优势不大）这里我们只要对每个bucket单独加锁就可以了，问题转换为对entry链表加锁，我们用NBUCKET把小锁分别对NBUCKET个entry链表加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock[NBUCKET]; <span class="comment">// declare a lock</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is the key already present?</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e) &#123;</span><br><span class="line">        <span class="comment">// update the existing key.</span></span><br><span class="line">        e-&gt;value = value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// the new is new.</span></span><br><span class="line">        pthread_mutex_lock(&amp;lock[i]);</span><br><span class="line">        insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">        pthread_mutex_lock(&amp;lock[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    pthread_mutex_init(&amp;lock[NBUCKET], <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$./ph 10</span><br><span class="line">100000 puts, 0.684 seconds, 146180 puts/second</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这样就足以跑过<code>ph_fast</code>的测试了（其实如果想偷鸡直接将NBUCKET改成一个大点的质数减少一下hash冲突就能用大锁跑过测试）</p><p>还有更细粒度的加锁方案，就是对链表（entry）的节点加锁，不过通常设计比较好的hashmap的拉链，链表不会很长。这里就不这么加了。</p><p>还有一种链表并发的方案就是rcu，不过这个是在内核态实现的，想要在userspace模仿一个有点难。</p><h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>这个也是在Unix&#x2F;linux真机下面，练习一下条件变量。这个barrier是用<code>pthread_cond</code>实现的，<code>a point in an application at which all participating threads must wait until all other participating threads reach that point too. </code></p><p>让执行完的线程wait(睡眠)，然后面足条件的时候调用signal唤醒，这里全部唤醒用broadcast就好了。</p><p>注意使用条件变量的时候需要加锁，参考Three Easy Piecies第30章。某些情况下signal可以不加锁，但是wait必须要加锁。<code>hold the lock when calling signal</code>，不然会发生race，书里给了一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">thr_exit</span><span class="params">()</span> &#123;</span><br><span class="line">  done = <span class="number">1</span>;</span><br><span class="line">  Pthread_cond_signal(&amp;c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">thr_join</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (done == <span class="number">0</span>) &#123;</span><br><span class="line">    Pthread_cond_wait(&amp;c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候如果一个thread执行<code>thr_join</code>，满足done为0，开始wait睡眠，但是在判断完if到执行wait睡眠的期间，<code>thr_exit()</code>开始执行唤醒全部全部线程，那么这个thread执行wait就会一直sleep醒不过来了（书里面是用的parent和child的例子）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">barrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">    pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">    bstate.nthread++;</span><br><span class="line">    <span class="keyword">if</span> (bstate.nthread &lt; nthread) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">    &#125; </span><br><span class="line">    pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个锁也要加上，不然唤醒的时候如果有线程睡眠会睡死</span></span><br><span class="line">    pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">    <span class="keyword">if</span> (bstate.nthread == nthread) &#123;</span><br><span class="line">        bstate.nthread = <span class="number">0</span>;</span><br><span class="line">        bstate.round++;</span><br><span class="line">        pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样<code>./barrier 100</code>就pass了。如果我们不加mutex锁，那么<code>./barrier 100</code>是会一直卡在那里结束不了的。如果我们执行strace看一下<code>strace ./barrier 100</code>，会发现卡在这个地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">futex(<span class="number">0x7f0a8b7a1910</span>, FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, <span class="number">219673</span>, <span class="literal">NULL</span>, FUTEX_BITSET_MATCH_ANY) = ? ERESTARTSYS (To be restarted <span class="keyword">if</span> SA_RESTART is <span class="built_in">set</span>)</span><br><span class="line">--- SIGWINCH &#123;si_signo=SIGWINCH, si_code=SI_KERNEL&#125; ---</span><br><span class="line">futex(<span class="number">0x7f0a8b7a1910</span>, FUTEX_WAIT_BITSET|FUTEX_CLOCK_REALTIME, <span class="number">219673</span>, <span class="literal">NULL</span>, FUTEX_BITSET_MATCH_ANY</span><br></pre></td></tr></table></figure><p>用<code>valgrind --tool=helgrind ./barrier 2</code>检查了一下，应该这样也是可以的，都加到一把锁里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">barrier</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">    pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">    bstate.nthread++;</span><br><span class="line">    <span class="keyword">if</span> (bstate.nthread &lt; nthread) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (bstate.nthread == nthread) &#123;</span><br><span class="line">        bstate.nthread = <span class="number">0</span>;</span><br><span class="line">        bstate.round++;</span><br><span class="line">        pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这次看题目本来以为很简单的，用户态thread就照着内核线程抄一个呗，剩下两个就是用一下pthread和锁呗。然后写起来debug就花了很久的时间，对寄存器不太熟，频繁翻车。然后折腾了两天才整出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ make grade</span><br><span class="line">uthread: OK (2.5s) </span><br><span class="line">== Test answers-thread.txt == answers-thread.txt: OK </span><br><span class="line">== Test ph_safe == make[1]: Entering directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">gcc -o ph -g -O2 -DSOL_THREAD -DLAB_THREAD notxv6/ph.c -pthread</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">ph_safe: OK (8.0s) </span><br><span class="line">== Test ph_fast == make[1]: Entering directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">make[1]: <span class="string">&#x27;ph&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">ph_fast: OK (19.7s) </span><br><span class="line">== Test barrier == make[1]: Entering directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">gcc -o barrier -g -O2 -DSOL_THREAD -DLAB_THREAD notxv6/barrier.c -pthread</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/zhixi/codes/xv6-labs-2021&#x27;</span></span><br><span class="line">barrier: OK (2.7s) </span><br><span class="line">== Test time == </span><br><span class="line">time: OK </span><br><span class="line">Score: 60/60</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi5TMDgxLzIwMjAvbGFicy90aHJlYWQuaHRtbA==">https://pdos.csail.mit.edu/6.S081/2020/labs/thread.html<i class="fa fa-external-link-alt"></i></span>   </p><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQxMC9ob3ctZG8teW91LXBhc3MtYS1mdW5jdGlvbi1hcy1hLXBhcmFtZXRlci1pbi1j">How do you pass a function as a parameter in C?<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvYmxvZy9tYXBz">Go Map in Actions<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL21hc3Rlci9zcmMvc3luYy9tYXAuZ28=">https://github.com/golang/go/blob/master/src/sync/map.go<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L3N5bmM/dXRtX3NvdXJjZT1nb2RvYyNNYXA=">https://pkg.go.dev/sync?utm_source=godoc#Map<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jb2xvYnUuY29tLzIwMTcvMDcvMTEvZGl2ZS1pbnRvLXN5bmMtTWFwLw==">Go 1.9 sync.Map揭秘<i class="fa fa-external-link-alt"></i></span> 鸟窝大大写的sync.Mutex介绍  </p><p><span class="exturl" data-url="aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAv">Operating Systems Three Easy Pices<i class="fa fa-external-link-alt"></i></span>，中文就是那个蓝皮的操作系统导论<br>第29章，讲并发链表、并发队列和并发散列表<br>第20章，讲条件变量  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实现一个用户态线程uthread，就照着xv6的内核态线程抄呗。怎么什么FUSE啊、UIO啊，什么东西都想往用户态搬啊，连RCU都有人想往用户态搬。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="thread" scheme="https://zhangjk98.xyz/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Copy on Write笔记</title>
    <link href="https://zhangjk98.xyz/6-S081-lab-cow/"/>
    <id>https://zhangjk98.xyz/6-S081-lab-cow/</id>
    <published>2022-04-17T11:17:29.000Z</published>
    <updated>2022-04-17T11:17:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>COW实现起来好多小坑啊（更新了一点页表相关的笔记，当时做页表那个Lab的时候xv6页表相关的源码研究的不仔细, 把页表和进程那一堆东西好好看一遍这个Lab就好做了）</p><span id="more"></span><h2 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy on Write"></a>Copy on Write</h2><p>大概思路就是，父子进程fork出来的时候共享物理内存（这个时候是只读的）。当子进程修改的时候copy出来一份（通过page fault触发的）。</p><p>设置内存是只读还是可写就在PTE里面修改相关的标志位：</p><p>PTE_V: is the PTE present? （是否valid，如果不是尝试访问将会缺页异常）<br>PTE_R: allowed to read (to the page)? （COW刚fork出来的时候是只读的）<br>PTE_W: allowed to write? （COW时child有修改，复制后状态变为可写）<br>PTE_X: interpret the content of the page as instructions and execute （内容（4k大小的页里面村的东西）能否被当成指令执行）<br>PTE_U: allowed user mode instructions to access the page （这个是用来区分用户页表和内核页表的，下面Lab用到的是用户进程页表）</p><p><img src="/6-S081-lab-cow/1652757417.png"></p><p>然后先说一下RISC-V中的page fault，当CPU无法完成虚拟地址（virtual address）到物理地址（physical address）的转换，就会page fault。一般有三种：  </p><p>load page fault：load指令不能地址转换<br>store page fault：store指令不能完成地址转换<br>instruction page fault：when the address for an instruction<br>doesn’t translate</p><p>前面两个比较熟悉，那个<code>instruction page fault</code>是什么呢， 翻了一下RISC-V的手册的SCAUSE，好像就是其他指令触发的page fault</p><p><img src="/6-S081-lab-cow/1652757093.png"></p><p>我们要获取page fault的原因就去读SCAUSE寄存器的值，xv6中直接用xv6封装好的<code>r_scause()</code>函数</p><p>要判断是哪个virtual address造成的page fault就去看STVAL寄存器， xv6中可以用封装好的<code>r_stval()</code>函数（STVAl寄存器保存的是page fault时出错的地址， Supervisor bad address or instruction.）</p><p>然后就是引用计数的问题，在xv6面一个physical page一般只对应一个进程（或者COW的父子进程），进程销毁物理页就直接删了就好了。所以不需要引用计数也能跑过这个Lab的test。但是在linux等其他系统中，会存在多个进程共享一个物理页的情况，一般是用引用计数来解决这个问题。</p><h2 id="xv6进程的虚拟内存和页表操作"><a href="#xv6进程的虚拟内存和页表操作" class="headerlink" title="xv6进程的虚拟内存和页表操作"></a>xv6进程的虚拟内存和页表操作</h2><p>相关函数在<code>kernel/vm.c</code>，一些定义在<code>riscv.h</code>。</p><p>页大小是4k，然后pageshift（offset）是12（32位系统）。下面引用一下linux里面PAGE_SHIFT的作用：</p><blockquote><p>PAGE_SHIFT的作用是通过对地址右移PAGE_SHIFT得到一个地址所在页的页号<br>内核地址，无论是虚拟的还物理的，其都由两部分组成。往往是高N位是页号，低M位是页内的偏移量。<br>当我们将地址中的低M位偏移量抛弃不用，高N位的页号，移到右端，得到这个结果称页帧号。<br>移动位以在页帧数和地址之间转换是一个常用操作。宏PAGE_SHIFT， 告诉我们要右移多少位得到页帧号。</p></blockquote><p>这个先简单的当成offset就可以了</p><p><img src="/6-S081-lab-cow/1652791105.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以PGSIZE为单位向上取整， 比如514会被取整为4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz) (((sz) + PGSIZE - 1) &amp; ~(PGSIZE - 1))</span></span><br><span class="line"><span class="comment">// 以PGSIZE为单位向下取整， 比如114会被取整为0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE - 1))</span></span><br></pre></td></tr></table></figure><p>pagetable_t类型是一个uint64</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 *<span class="type">pagetable_t</span>; <span class="comment">// 512 PTEs</span></span><br></pre></td></tr></table></figure><p>PTE(page table, entry, 页表项)也是一个uint64</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> uint64 <span class="type">pte_t</span>;</span><br></pre></td></tr></table></figure><p>然后我们看mappages，用来创建Virtual Address的PTE, 将长度为size，从pa开始的物理内存映射到虚拟内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create PTEs for virtual addresses starting at va that refer to</span></span><br><span class="line"><span class="comment">// physical addresses starting at pa. va and size might not</span></span><br><span class="line"><span class="comment">// be page-aligned. Returns 0 on success, -1 if walk() couldn&#x27;t</span></span><br><span class="line"><span class="comment">// allocate a needed page-table page.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mappages</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa,</span></span><br><span class="line"><span class="params">             <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    uint64 a, last;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;mappages: size&quot;</span>);</span><br><span class="line"></span><br><span class="line">    a = PGROUNDDOWN(va);</span><br><span class="line">    last = PGROUNDDOWN(va + size - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walk(pagetable, a, <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (*pte &amp; PTE_V)</span><br><span class="line">            panic(<span class="string">&quot;mappages: remap&quot;</span>);</span><br><span class="line">        *pte = PA2PTE(pa) | perm | PTE_V;</span><br><span class="line">        <span class="keyword">if</span> (a == last)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a += PGSIZE;</span><br><span class="line">        pa += PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程在fork的时候调用了uvmcopy，用来从parent拷贝一份一样的内存到child</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">    <span class="keyword">if</span> (uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        freeproc(np);</span><br><span class="line">        release(&amp;np-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现是直接copy的，类似memcpy那样直接拷贝了一段内存（实际上xv6里面的memcpy就是memmove实现的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the</span></span><br><span class="line"><span class="comment">// physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa, i;</span><br><span class="line">    uint flags;</span><br><span class="line">    <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="keyword">if</span> ((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        memmove(mem, (<span class="type">char</span> *)pa, PGSIZE);</span><br><span class="line">        <span class="keyword">if</span> (mappages(new, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">            kfree(mem);</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>uvmcreate也是类似的，分别调用了<code>kalloc</code>， 然后设置一下PTE标志位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create an empty user page table.</span></span><br><span class="line"><span class="comment">// returns 0 if out of memory.</span></span><br><span class="line"><span class="type">pagetable_t</span> <span class="title function_">uvmcreate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pagetable_t</span> pagetable;</span><br><span class="line">    pagetable = (<span class="type">pagetable_t</span>)kalloc();</span><br><span class="line">    <span class="keyword">if</span> (pagetable == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">    <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相对应的是<code>uvmfree</code>，这个需要递归的释放子进程的内存，<code>freewalk</code>递归的释放了所有子进程的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages.</span></span><br><span class="line"><span class="comment">// All leaf mappings must already have been removed.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freewalk</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span> &#123;</span><br><span class="line">    <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">        <span class="keyword">if</span> ((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// this PTE points to a lower-level page table.</span></span><br><span class="line">            uint64 child = PTE2PA(pte);</span><br><span class="line">            freewalk((<span class="type">pagetable_t</span>)child);</span><br><span class="line">            pagetable[i] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">            panic(<span class="string">&quot;freewalk: leaf&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    kfree((<span class="type">void</span> *)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>kernel/proc.c</code>中, <code>proc_freepagetable</code>先调用uvmunmap释放当前进程的内存，然后调用了<code>uvmfree</code>释放子进程的pagetable</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Free a process&#x27;s page table, and free the</span></span><br><span class="line"><span class="comment">// physical memory it refers to.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span> &#123;</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>uvmalloc</code>和<code>uvmdealloc</code>用来调整virtual memory的大小，封装调用了kalloc、memset和uvmunmap这些，这里不多说了。</p><p>说完用户态页表我们看一下内核页表, 在开机的时候由kvminit直接创建，这些是不参与page fault的，也没有COW或者换页那些，也不会参与TLB或者参与分页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add a mapping to the kernel page table.</span></span><br><span class="line"><span class="comment">// only used when booting.</span></span><br><span class="line"><span class="comment">// does not flush TLB or enable paging.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">kvmmap</span><span class="params">(<span class="type">pagetable_t</span> kpgtbl, uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mappages(kpgtbl, va, sz, pa, perm) != <span class="number">0</span>)</span><br><span class="line">        panic(<span class="string">&quot;kvmmap&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><blockquote><p>Your task is to implement copy-on-write fork in the xv6 kernel. You are done if your modified kernel executes both the cowtest and usertests programs successfully.</p></blockquote><p>我们要通过修改PTE来调整内存的访问权限， PTE相关的标志为已经给出了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br></pre></td></tr></table></figure><p><img src="/6-S081-lab-cow/1652761766.png"></p><p>在PTE的标志位中， 第8-9位是保留的（Reversed for supervisor software）， 我们可以把第八位指定成COW的标志位（上图RSW那里）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8) <span class="comment">// cow</span></span></span><br></pre></td></tr></table></figure><blockquote><p>Modify uvmcopy() to map the parent’s physical pages into the child, instead of allocating new pages. Clear PTE_W in the PTEs of both child and parent.</p></blockquote><p>首先我们修改<code>uvmcopy()</code>, 在copy的时候将父子进程的PTE标志位都设为只读</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a parent process&#x27;s page table, copy</span></span><br><span class="line"><span class="comment">// its memory into a child&#x27;s page table.</span></span><br><span class="line"><span class="comment">// Copies both the page table and the</span></span><br><span class="line"><span class="comment">// physical memory.</span></span><br><span class="line"><span class="comment">// returns 0 on success, -1 on failure.</span></span><br><span class="line"><span class="comment">// frees any allocated pages on failure.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span> &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte;</span><br><span class="line">    uint64 pa, i;</span><br><span class="line">    uint flags;</span><br><span class="line">    <span class="type">char</span> *mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; i += PGSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> ((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">            panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">        pa = PTE2PA(*pte);</span><br><span class="line">        *pte &amp;= ~PTE_W;</span><br><span class="line">        *pte |= PTE_COW;</span><br><span class="line">        flags = PTE_FLAGS(*pte);</span><br><span class="line">        <span class="comment">// 这里不需要立即memove分配内存了，注释掉</span></span><br><span class="line">        <span class="comment">// if ((mem = kalloc()) == 0)</span></span><br><span class="line">        <span class="comment">//     goto err;</span></span><br><span class="line">        <span class="comment">// memmove(mem, (char *)pa, PGSIZE);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mappages(new, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// kfree(mem);</span></span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Modify usertrap() to recognize page faults. When a page-fault occurs on a COW page, allocate a new page with kalloc(), copy the old page to the new page, and install the new page in the PTE with PTE_W set.</p></blockquote><p>然后发生page fault的时候（要用<code>r_scasue</code>判断是否发生原因），然后用kalloc分配内存，同时将PTE标志位从只读变为可写。</p><blockquote><p>Ensure that each physical page is freed when the last PTE reference to it goes away – but not before. A good way to do this is to keep, for each physical page, a “reference count” of the number of user page tables that refer to that page. Set a page’s reference count to one when kalloc() allocates it. Increment a page’s reference count when fork causes a child to share the page, and decrement a page’s count each time any process drops the page from its page table. kfree() should only place a page back on the free list if its reference count is zero. It’s OK to to keep these counts in a fixed-size array of integers. You’ll have to work out a scheme for how to index the array and how to choose its size. For example, you could index the array with the page’s physical address divided by 4096, and give the array a number of elements equal to highest physical address of any page placed on the free list by kinit() in kalloc.c.</p></blockquote><p>按照这个提示，我们在kalloc的时候将引用计数设为1, 在fork的时候增加引用计数，然后在进程不需要这个页的时候将引用计数减1，等到引用计数为0的时候就可以kfree了</p><blockquote><p>Modify copyout() to use the same scheme as page faults when it encounters a COW page.</p></blockquote><h2 id="闲聊一下Linux的COW漏洞"><a href="#闲聊一下Linux的COW漏洞" class="headerlink" title="闲聊一下Linux的COW漏洞"></a>闲聊一下Linux的COW漏洞</h2><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;COW实现起来好多小坑啊（更新了一点页表相关的笔记，当时做页表那个Lab的时候xv6页表相关的源码研究的不仔细, 把页表和进程那一堆东西好好看一遍这个Lab就好做了）&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="cow" scheme="https://zhangjk98.xyz/tags/cow/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Filesystem 笔记</title>
    <link href="https://zhangjk98.xyz/6-S081-lab-filesystem/"/>
    <id>https://zhangjk98.xyz/6-S081-lab-filesystem/</id>
    <published>2022-04-13T03:22:50.000Z</published>
    <updated>2022-04-13T03:22:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>鸽了有点日子的6.S081的filesystem笔记，主要是看到ZFS和Btrfs之类的现代文件系统，再看看自己做的Lab，感觉跟幼儿园哄小孩玩的一样</p><p><img src="https://imgs.xkcd.com/comics/dark_arts.png"></p><p>不过，如果你只是一个路过的普通用户，懂的越少越幸福。在我接触Btrfs之前，我根本没担心过我电脑的文件系统。<br>THERE POWER LEADS ONLY TO RUIN.  </p><span id="more"></span><h2 id="文件系统笔记"><a href="#文件系统笔记" class="headerlink" title="文件系统笔记"></a>文件系统笔记</h2><p>经典的文件系统网上各种资料和介绍太多了，也无外乎inode、多级索引、引用计数、权限这些。现代文件系统比较复杂，像Btrfs的那些日志、秒级快照、COW我又不太懂不敢讲，像Ceph这些分布式的文件系统我也不太懂。我感觉像Btrfs这样的文件系统已经很像数据库了，你看b-tree索引啊日志啊COW事物啊。</p><p>这一篇写的比较凌乱，而且大部分内容都和Lab没关系，随便说说吧</p><h3 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h3><p>Btrfs我不太敢讲，相比ext4比较复杂、资料也更少。把台式主力的文件系统换成Btrfs后我都有些提心吊胆的，一直害怕哪一天Boom-tree-fs炸了。还好，快一年了，依然存活。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> btrfs device stats /dev/nvme0n1p1</span><br><span class="line">[/dev/nvme0n1p1].write_io_errs    0</span><br><span class="line">[/dev/nvme0n1p1].read_io_errs     0</span><br><span class="line">[/dev/nvme0n1p1].flush_io_errs    0</span><br><span class="line">[/dev/nvme0n1p1].corruption_errs  0</span><br><span class="line">[/dev/nvme0n1p1].generation_errs  0</span><br></pre></td></tr></table></figure><p>普通用户用Btrfs的一些好处是透明压缩、快照、COW。不过，Btrfs的问题是真要是出了什么问题会修的人不多，用ext4什么的坏了实在不行可以花钱找数据恢复，btrfs就自求多福吧（或者你在群里大喊fc老师救我，fc老师没空就自求多福吧）。而且市面上的磁盘修复工具几乎也都不怎么支持btrfs。</p><p>Btrfs可以直接添加、删除设备、调整大小（增加和缩小都行，XFS暂时还不支持缩）。我用Btrfs将两个500G的固态硬盘拼成了一个1T的逻辑分区（这个东西有点像LVM的逻辑卷）<br>Btrfs可以直接热插拔增删设备，比如我要加一快硬盘，直接添加然后balance一下就可以了。我要移除一块硬盘，直接remove就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo btrfs device add /dev/nvme0n1p1 / -f   <span class="comment"># 添加设备</span></span><br><span class="line">sudo btrfs balance start /  <span class="comment"># 开始平衡</span></span><br><span class="line">sudo btrfs device remove /dev/nvme0n1p1</span><br></pre></td></tr></table></figure><p>之前用ext4等文件系统很多都习惯<code>/</code>，<code>/home</code>, <code>/var</code>，Btrfs一般不分那么多区，而是用子卷。一般对<code>var</code>这样的目录单独建一个子卷，然后禁用COW。</p><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>b-tree有三种结构：keys, items, and a block header</p><p>block header 包括uuid和checksum之类的东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btrfs_header</span> &#123;</span></span><br><span class="line">    u8 csum[<span class="number">32</span>];</span><br><span class="line">    u8 fsid[<span class="number">16</span>];</span><br><span class="line">    __le64 bytenr;</span><br><span class="line">    __le64 flags;</span><br><span class="line"></span><br><span class="line">    u8 chunk_tree_uid[<span class="number">16</span>];</span><br><span class="line">    __le64 generation;</span><br><span class="line">    __le64 owner;</span><br><span class="line">    __le32 nritems;</span><br><span class="line">    u8 level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>key中包括了存储的数据类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btrfs_disk_key</span> &#123;</span></span><br><span class="line">    __le64 objectid;</span><br><span class="line">    u8 type;</span><br><span class="line">    __le64 offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>item的大小是可变的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">btrfs_item</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">btrfs_disk_key</span> <span class="title">key</span>;</span></span><br><span class="line">    __le32 offset;</span><br><span class="line">    __le32 size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件系统的struct放在 item data 里面，比如objectid、inode和offset这些。每个文件都有一个objectid，然后根据objectid组成了一个B-tree的索引。inode放在<code>btrfs_inode_item</code>结构体里面。</p><p>Btrfs的索引是b树（free space tree），每个子卷（subvolume）有一颗b-tree索引，大概长这个样子<br><img src="/6-S081-lab-filesystem/1649948946.png"></p><p>Btrfs中有很多的树索引，包括FS Tree(包括Extent tree, Root tree)，Chunk tree(区块索引)，Checksum tree， Device Tree。</p><p><img src="/6-S081-lab-filesystem/1649988331.png"></p><p>其中文件树（FS Tree）长这样</p><p><img src="/6-S081-lab-filesystem/1649949073.png"></p><p>Btrfs的snapshot是类似COW的操作，增量备份节点</p><p><img src="/6-S081-lab-filesystem/1649992014.png"></p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>大多数比较新的文件系统都对SSD存储的优化。这里简单说一下Btrfs的文件存储。Btrfs的一个对小文件的优化是直接塞进Metadata里面，这样就不用占一个块（block）了。大文件存在将block合并的Extent中，这样就不用每个block一个Metadata占空间了。<br>Btrfs还有一个很出名的特性是透明压缩，此外还有COW的reflink（这个不能），de-duplicaiton，这个之前写过不多说了</p><h4 id="关于Btrfs的性能问题"><a href="#关于Btrfs的性能问题" class="headerlink" title="关于Btrfs的性能问题"></a>关于Btrfs的性能问题</h4><p>Btrfs性能不好的说法主要来源于跑分跑不过ext4等等。不过跑分这种事情对于普通的桌面用户意义不大，以下引用fc老师的话</p><blockquote><p>phoronix 測文件系統性能的最大問題在於容易讓讀者以為文件系統是左右存儲性能的關鍵，實際上文件系統只是夾在內存子系統和塊IO子系統中間的決策層，通常瓶頸不會在文件系統，除非文件系統過度簡化設計，對存儲性能影響更大的是別的層面的東西，按他們的方式測試文件系統只能測出一堆難以預計到的副作用的結果，沒法對文件系統優化提供可供參考的提示<br>要測純讀寫做對比肯定不考慮 reflink 和透明壓縮，但是實際幹活的時候這些新特性很節省時間（</p></blockquote><p>当然Btrfs在重io的情况下桌面特别卡，那很有可能是quota的问题，把quota关掉吧，quota有已知的性能问题，尤其是在ssd上。（关了这个磁盘配额你就看不到快照大小、指定不了每个子卷的大小）</p><h2 id="简单说一下Lab"><a href="#简单说一下Lab" class="headerlink" title="简单说一下Lab"></a>简单说一下Lab</h2><p>这个Lab很简单，一个是让给xv6的文件系统做一个二级索引用来支持大文件，一个是让你给xv6实现一下软链接。xv6作为一个教学的系统，文件系统索引很简单，并没有像Btrfs等文件系统那样采用b-tree等树形结构。软链接的实现也很简单，就类似一个指针+引用计数嘛，不像一些现代文件系统的reflink那样类似COW的操作实现de-duplication很麻烦。</p><p>其实没啥好说的，但是这一篇一开始是6.S081的Lab笔记，一点Lab的内容都没有有点挂羊头卖狗肉的嫌疑。还是写点吧。</p><h2 id="xv6中的文件系统"><a href="#xv6中的文件系统" class="headerlink" title="xv6中的文件系统"></a>xv6中的文件系统</h2><p>这里简化起见不讲磁盘结构了。不考虑底层差异，磁盘直接被文件系统视为一连串块（block），xv6中block大小是1024k。block0一般是引导块，然后block1是superblock，然后是log, inodes，bitmap，这些统称为Metadata block。再后面都是 data block</p><p><img src="/6-S081-lab-filesystem/1650031214.png"></p><p>这里xv6的精简实现比较简单，不像linux那样很复杂，我们直接看源码好了。超级块superblock用来记录总共有多少个block、inode block、log block，以及它们的开始位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// super block describes the disk layout:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">superblock</span> &#123;</span></span><br><span class="line">  uint magic;        <span class="comment">// Must be FSMAGIC</span></span><br><span class="line">  uint size;         <span class="comment">// Size of file system image (blocks)</span></span><br><span class="line">  uint nblocks;      <span class="comment">// Number of data blocks</span></span><br><span class="line">  uint ninodes;      <span class="comment">// Number of inodes.</span></span><br><span class="line">  uint nlog;         <span class="comment">// Number of log blocks</span></span><br><span class="line">  uint logstart;     <span class="comment">// Block number of first log block</span></span><br><span class="line">  uint inodestart;   <span class="comment">// Block number of first inode block</span></span><br><span class="line">  uint bmapstart;    <span class="comment">// Block number of first free map block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>inode的定义也非常简单，inode在磁盘中大概就记录文件类型、大小、链接数量这些信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On-disk inode structure</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="type">short</span> type;           <span class="comment">// File type</span></span><br><span class="line">  <span class="type">short</span> major;          <span class="comment">// Major device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> minor;          <span class="comment">// Minor device number (T_DEVICE only)</span></span><br><span class="line">  <span class="type">short</span> nlink;          <span class="comment">// Number of links to inode in file system</span></span><br><span class="line">  uint size;            <span class="comment">// Size of file (bytes)</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];   <span class="comment">// Data block addresses</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in-memory copy of an inode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number</span></span><br><span class="line">  <span class="type">int</span> ref;            <span class="comment">// Reference count</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here</span></span><br><span class="line">  <span class="type">int</span> valid;          <span class="comment">// inode has been read from disk?</span></span><br><span class="line"></span><br><span class="line">  <span class="type">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="type">short</span> major;</span><br><span class="line">  <span class="type">short</span> minor;</span><br><span class="line">  <span class="type">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内存中inode有 refernce conut，这个就是引用计数，删除文件的时候只有当引用计数减为0的时候才会真正删除</p><p><img src="/6-S081-lab-filesystem/1650032123.png"></p><h2 id="sleeplock"><a href="#sleeplock" class="headerlink" title="sleeplock"></a>sleeplock</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Long-term locks for processes</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> &#123;</span></span><br><span class="line">  uint locked;       <span class="comment">// Is the lock held? 0是没有， 1是hold</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lk</span>;</span> <span class="comment">// spinlock protecting this sleep lock</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// For debugging:</span></span><br><span class="line">  <span class="type">char</span> *name;        <span class="comment">// Name of lock.</span></span><br><span class="line">  <span class="type">int</span> pid;           <span class="comment">// Process holding lock</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>xv6的文件系统用的是睡眠锁而不是spinlock，因为读写这种io操作耗时很长。相关定义在<code>kernel/sleeplock.c</code>，其中<code>wakeup</code>和<code>sleep</code>定义在<code>kernel/proc.c</code>， 这里就简单认为sleep操作干了<code>p-&gt;state = SLEEPING;</code>这一件事，而<code>wakeup</code>干了<code>p-&gt;state = RUNNABLE;</code>，作用是让process睡眠和唤醒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wake up all processes sleeping on chan.</span></span><br><span class="line"><span class="comment">// Must be called without any p-&gt;lock.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p != myproc())&#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">        p-&gt;state = RUNNABLE;  <span class="comment">// 这里我们只关注这一行就行了</span></span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initsleeplock</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;lk-&gt;lk, <span class="string">&quot;sleep lock&quot;</span>);</span><br><span class="line">  lk-&gt;name = name;</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>; <span class="comment">//locked = 0 没上锁，= 1 表示被锁住了</span></span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">acquiresleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk); <span class="comment">// 获取spinlock</span></span><br><span class="line">  <span class="keyword">while</span> (lk-&gt;locked) &#123;  <span class="comment">// 如果其他pid持有锁</span></span><br><span class="line">    sleep(lk, &amp;lk-&gt;lk); <span class="comment">//睡眠</span></span><br><span class="line">  &#125;</span><br><span class="line">  lk-&gt;locked = <span class="number">1</span>;       <span class="comment">// 上锁</span></span><br><span class="line">  lk-&gt;pid = myproc()-&gt;pid;  <span class="comment">//拿锁进程的pid</span></span><br><span class="line">  release(&amp;lk-&gt;lk); <span class="comment">//释放spinlock</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">releasesleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  lk-&gt;locked = <span class="number">0</span>; <span class="comment">// 释放锁</span></span><br><span class="line">  lk-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  wakeup(lk); <span class="comment">// 唤醒</span></span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否持有sleeplock锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">holdingsleep</span><span class="params">(<span class="keyword">struct</span> sleeplock *lk)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  acquire(&amp;lk-&gt;lk);</span><br><span class="line">  r = lk-&gt;locked &amp;&amp; (lk-&gt;pid == myproc()-&gt;pid); <span class="comment">// r表示当前proc的pid是否持有锁</span></span><br><span class="line">  release(&amp;lk-&gt;lk);</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sleeplock是用spinlock实现的，在中断（IO）操作的时候可以持有锁。实现比较精简，我加了点注释，不多说了。</p><p>ps：睡眠锁类似linux里面的信号量semaphore（后来改用mutex了）</p><h3 id="xv6的日志"><a href="#xv6的日志" class="headerlink" title="xv6的日志"></a>xv6的日志</h3><p>xv6的日志实现比较简单，在磁盘上有一段固定的block。<br>日志这里不多说了，log-structured的文件系统和COW这些有点跑题了。掉电恢复什么的建议买个UPS电源。</p><h3 id="block-cache"><a href="#block-cache" class="headerlink" title="block cache"></a>block cache</h3><p>这里就是经典的LRU和睡眠锁</p><h2 id="Lab内容"><a href="#Lab内容" class="headerlink" title="Lab内容"></a>Lab内容</h2><h3 id="Large-Files"><a href="#Large-Files" class="headerlink" title="Large Files"></a>Large Files</h3><blockquote><p>In this assignment you’ll increase the maximum size of an xv6 file. Currently xv6 files are limited to 268 blocks, or 268*BSIZE bytes (BSIZE is 1024 in xv6). This limit comes from the fact that an xv6 inode contains 12 “direct” block numbers and one “singly-indirect” block number, which refers to a block that holds up to 256 more block numbers, for a total of 12+256&#x3D;268 blocks.</p></blockquote><p>ext3支持4TB的大文件，ext4支持16TB的大文件，ZFS、Btrfs等现代文件系统支持16EB（如果你执行<code>ulimit -a</code>会显示file size (blocks)，其实这个数字是64位操作系统的上限（16EB&#x3D;2^64））</p><p>这里让xv6的文件系统支持大文件的做法很naive，做一个二级索引，让inode有更多block就行了。</p><h3 id="Symbolic-Links"><a href="#Symbolic-Links" class="headerlink" title="Symbolic Links"></a>Symbolic Links</h3><p>这个也很简单，实现一个符号链接就行了。之前看了醉卧沙场写的XFS的符号链接的实现，这里做的很顺利。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wZWtvcGVrbzExLnNha3VyYS5uZS5qcC91bml4X3Y2L3h2Ni1ib29rL2VuL0ZpbGVfc3lzdGVtLmh0bWw=">Chapter 6 File system<i class="fa fa-external-link-alt"></i></span>  </p><p>下面放的链接是一些文件系统相关的文章，跟这个Lab关系并不是特别大，适合无聊的时候读着玩</p><p><span class="exturl" data-url="aHR0cHM6Ly9mYXJzZWVyZmMubWUvemhzL3RhZy9mc2JpLWppLmh0bWw=">fc老师的fs笔记<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE3MDcuMDg1MTQucGRm">Analyzing IO Amplification in Linux File Systems<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzYzODU0Ni8=">XFS: There and back … and there again?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9mYXJzZWVyZmMubWUvemhzL2J0cmZzLXZzLXpmcy1kaWZmZXJlbmNlLWluLWltcGxlbWVudGluZy1zbmFwc2hvdHMuaHRtbA==">Btrfs vs ZFS 实现 snapshot 的差异<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NzY4NjgxNw==">醉卧沙场 README - 计算机专业性文章及回答总索引<i class="fa fa-external-link-alt"></i></span> 这个知乎答主写了好多XFS的文章  </p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGF0aG5hbWUuY29tL2Zocy8yLjIvaW5kZXguaHRtbA==">Filesystem Hierarchy Standard<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy5yZWFkdGhlZG9jcy5pby8=">BTRFS documentation<i class="fa fa-external-link-alt"></i></span> 偏向使用文档，没怎么介绍原理<br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL1RyZWVz">Btrfs Trees<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL0J0cmZzX2Rlc2lnbg==">Btrfs Design<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMjAwMjI2MTMzNzQ3L2h0dHBzOi8vd3d3LmlibS5jb20vZGV2ZWxvcGVyd29ya3MvY24vbGludXgvbC1jbi1idHJmcy9pbmRleC5odG1s">新一代 Linux 文件系统 btrfs 简介<i class="fa fa-external-link-alt"></i></span>  比较老的一篇文章<br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL0ZBUQ==">Btrfs FAQ<i class="fa fa-external-link-alt"></i></span> 希望你用不到这些东西，有一天要翻这那你Btrfs多半是出问题了  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鸽了有点日子的6.S081的filesystem笔记，主要是看到ZFS和Btrfs之类的现代文件系统，再看看自己做的Lab，感觉跟幼儿园哄小孩玩的一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgs.xkcd.com/comics/dark_arts.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;不过，如果你只是一个路过的普通用户，懂的越少越幸福。在我接触Btrfs之前，我根本没担心过我电脑的文件系统。&lt;br&gt;THERE POWER LEADS ONLY TO RUIN.  &lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="fs" scheme="https://zhangjk98.xyz/tags/fs/"/>
    
    <category term="btrfs" scheme="https://zhangjk98.xyz/tags/btrfs/"/>
    
  </entry>
  
  <entry>
    <title>用systemd-boot做bootloader</title>
    <link href="https://zhangjk98.xyz/systemd-boot/"/>
    <id>https://zhangjk98.xyz/systemd-boot/</id>
    <published>2022-04-10T05:41:03.000Z</published>
    <updated>2022-04-10T05:41:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>又研究了一下linux的启动流程，然后换成systemd-boot了。原先好看的grub主题就不要了，但是systemd-boot它启动快啊，grub好臃肿</p><span id="more"></span><h2 id="从Grub迁移到systemd-boot"><a href="#从Grub迁移到systemd-boot" class="headerlink" title="从Grub迁移到systemd-boot"></a>从Grub迁移到systemd-boot</h2><p>grub有好看的主题，也能方便的在开机的时候选内核版本、进btrfs的sanpshot回滚。但是我想尝试一下systemd-boot，grub看起来实在是太复杂了，我用不到那些功能。systemd-boot已经在systemd全家桶里面了，所以不需要额外安装。</p><p>systemd-boot一般要放在第一个EFI分区，而且直到今天systemd-boot和btrfs配合的还不是很好。我建了一个512M的EFI分区, 格式化为FAT32</p><p>注意需要EFI分区(EFI system partition, ef00)，不能是Linux filesystem(8300), 分区的Type如果是这样，grub是可以的，但是systemd-boot不认。用cgdisk重新分区的时候Type选ef00</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sudo</span> bootctl --path=/boot install</span><br><span class="line">File system <span class="string">&quot;/dev/block/259:1&quot;</span> has wrong <span class="built_in">type</span> <span class="keyword">for</span> an EFI System Partition (ESP).</span><br></pre></td></tr></table></figure><p>然后安装hook让每次更新内核的时候自动配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -S systemd-boot-pacman-hook</span><br></pre></td></tr></table></figure><p>systemd-boot是单文件启动的，配置文件放在<code>/boot/loader/entries</code>下面，可以根据不同的启动选项创建不同的配置文件，比如按照Arch Wiki的推荐创建一个<code>arch.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title Arch</span><br><span class="line">linux /vmlinuz-linux</span><br><span class="line">initrd /amd-ucode.img</span><br><span class="line">initrd /initramfs-linux.img</span><br><span class="line">options root=LABEL=ROOT rootflags=subvol=@ rw</span><br></pre></td></tr></table></figure><p>title是名称，就是systemd-boot界面显示的那个。<br>linux选项是指定可执行的压缩内核，一般就<code>vmlinuz-linux</code>，如果是桌面用户装了其他内核应该能在<code>boot</code>目录下找到，比如<code>vmlinuz-linux-zen</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/boot❯ <span class="built_in">ls</span></span><br><span class="line">amd-ucode.img                     initramfs-linux-lts.img              initramfs-linux-zen.img  vmlinuz-linux-lts</span><br><span class="line">EFI                               initramfs-linux-xanmod-fallback.img  initramfs-linux.img      vmlinuz-linux-xanmod</span><br><span class="line">initramfs-linux-fallback.img      initramfs-linux-xanmod.img           loader                   vmlinuz-linux-zen</span><br><span class="line">initramfs-linux-lts-fallback.img  initramfs-linux-zen-fallback.img     vmlinuz-linux </span><br></pre></td></tr></table></figure><p>然后用initrd选项指定一下想要的initramfs镜像，装了amd或者intel的微码也要指定一下</p><p>最后options里面指定一下根分区和内核参数（如果用btrfs还有rootflags指定一下是哪个subvol）</p><p>ps: 在写rootflags的时候我们可以直接照抄grub生成的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo grub-mkconfig 2&gt;/dev/null | grep vmlinuz</span><br></pre></td></tr></table></figure><p>然后我们配置一下loader.conf, 指定默认启动使用<code>arch.conf</code>的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default arch.conf</span><br><span class="line">timeout 4</span><br><span class="line">console-mode max</span><br><span class="line">editor vim</span><br></pre></td></tr></table></figure><p>现在boot目录的结构大概是这个样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">❯ tree /boot</span><br><span class="line">/boot</span><br><span class="line">├── amd-ucode.img</span><br><span class="line">├── EFI</span><br><span class="line">│   ├── BOOT</span><br><span class="line">│   │   └── BOOTX64.EFI</span><br><span class="line">│   ├── Linux</span><br><span class="line">│   └── systemd</span><br><span class="line">│       └── systemd-bootx64.efi</span><br><span class="line">├── initramfs-linux-fallback.img</span><br><span class="line">├── initramfs-linux.img</span><br><span class="line">├── loader</span><br><span class="line">│   ├── entries</span><br><span class="line">│   │   └── arch.conf</span><br><span class="line">│   ├── loader.conf</span><br><span class="line">│   └── random-seed</span><br><span class="line">├── vmlinuz-linux</span><br></pre></td></tr></table></figure><p>然后我们可以把grub卸了</p><h3 id="使用Unified-Kernel-image"><a href="#使用Unified-Kernel-image" class="headerlink" title="使用Unified Kernel image"></a>使用Unified Kernel image</h3><p>就是把vmlinuz、ucode、initramfs的img都揉到一起做了一的大的可执行的内核镜像</p><h3 id="systemd-boot如何设置内核参数（参数是怎么传递的）"><a href="#systemd-boot如何设置内核参数（参数是怎么传递的）" class="headerlink" title="systemd-boot如何设置内核参数（参数是怎么传递的）"></a>systemd-boot如何设置内核参数（参数是怎么传递的）</h3><p>在options选项里面附加就可以了，然后systemd-boot会把参数传给initramfs，然后就是<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC92NC4xNC9hZG1pbi1ndWlkZS9rZXJuZWwtcGFyYW1ldGVycy5odG1s">kernel’s command-line parameters<i class="fa fa-external-link-alt"></i></span>那一套(能用<code>cat /proc/cmdline</code>看到的)，就是嵌入式uboot启动传参的那个tag链表。然后init的时候将参数传给systemd（既然你都用systemd-boot了那你的init系统肯定是systemd吧）</p><p>我以前看名字以为systemd直接就接管了，传给systemd之后就是熟悉的sysctl那一套<code>systemd-sysctl</code>。后来发现systemd-boot就是一个<code>bootctl</code>那种efi引导文件生成的一个工具（可以理解为一个bootloader差不多的东西），bootloader的界面那个时候就跟其他的bootloader差不多， 那个时候还没systemd什么事呢。</p><p>内核参数的传递大概是这样的：grub等bootloader的配置中配置了一些内核参数，然后grub在引导过程中将参数传给initramfs ，initramfs 先掛載一遍根，然後 initramfs 裡面的 init switch-root 到根裡面的 systemd ，然後 systemd 讀 fstab 生成 mount 文件，對根做 remount 。有些參數能在 remount 的時候改，比如 rw</p><h3 id="怎么指定启动时的kernel"><a href="#怎么指定启动时的kernel" class="headerlink" title="怎么指定启动时的kernel"></a>怎么指定启动时的kernel</h3><p>在systemd-boot的开机选择画面按e</p><h3 id="systemd-boot开机怎么进rootfs"><a href="#systemd-boot开机怎么进rootfs" class="headerlink" title="systemd-boot开机怎么进rootfs"></a>systemd-boot开机怎么进rootfs</h3><p>一开始用了比较扭曲的办法，后来发现这个只要在将UUID指定成boot分区的UUID就可以了</p><h3 id="systemd-boot开机怎么进bytfs-snapshot"><a href="#systemd-boot开机怎么进bytfs-snapshot" class="headerlink" title="systemd-boot开机怎么进bytfs snapshot"></a>systemd-boot开机怎么进bytfs snapshot</h3><p>这个貌似还真没啥好办法，要用这个还是装回grub吧。如果想开机进snapshot,需要手动将那个rootflag指定成snapshot所在的subvol。reddit上有一种方案是同时保留systemd-boot和grub, 然后在BIOS里面把systemd-boot的启动项放在前面，但是我不想要grub了。</p><blockquote><p>To use a subvolume as the root mountpoint specify the subvolume via a kernel parameter using rootflags&#x3D;subvol&#x3D;&#x2F;path&#x2F;to&#x2F;subvolume. Edit the root mountpoint in &#x2F;etc&#x2F;fstab and specify the mount option subvol&#x3D;. Alternatively the subvolume can be specified with its id, rootflags&#x3D;subvolid&#x3D;objectid as kernel parameter and subvolid&#x3D;objectid as mount option in &#x2F;etc&#x2F;fstab. It is preferable to mount using subvol&#x3D;&#x2F;path&#x2F;to&#x2F;subvolume, rather than the subvolid, as the subvolid may change when restoring #Snapshots, requiring a change of mount configuration, or else the system will not boot.</p></blockquote><p>如果要用systemd-boot进snapshot，需要改systemd-boot的配置文件指定rootflags。既然要手动改，不如直接用livecd进chroot操作更方便一点。需要手动改systemd-boot的参数不如grub那样装上<code>grub-btrfs</code>之后用上下键选择用哪个内核或者进入snapshot进行修复。</p><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>可以在systemctl命令中直接选择entry</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl reboot --boot-loader-entry=auto-windows</span><br></pre></td></tr></table></figure><h2 id="其他的一些操作"><a href="#其他的一些操作" class="headerlink" title="其他的一些操作"></a>其他的一些操作</h2><h3 id="如何加快启动速度"><a href="#如何加快启动速度" class="headerlink" title="如何加快启动速度"></a>如何加快启动速度</h3><p>换成systemd-boot已经很快了，不过如果你想再快，可以用<code>systemd-analyze</code>, 看一下是什么拖慢了你的启动速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$systemd</span>-analyze</span><br><span class="line">Startup finished <span class="keyword">in</span> 11.282s (firmware) + 4.842s (loader) + 3.317s (kernel) + 7.955s (userspace) = 27.398s</span><br><span class="line">graphical.target reached after 7.955s <span class="keyword">in</span> userspace</span><br></pre></td></tr></table></figure><p>如果想更详细的调查一下， <code>systemd-analyze blame</code>或者<code>systemd-analyze plot &gt; boot_process.svg</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$systemd</span>-analyze blame</span><br><span class="line">4.841s NetworkManager-wait-online.service</span><br><span class="line">2.429s systemd-udev-settle.service</span><br><span class="line">2.144s systemd-modules-load.service</span><br><span class="line"> 579ms systemd-binfmt.service</span><br><span class="line"> 496ms systemd-timesyncd.service</span><br><span class="line"> 320ms dev-nvme0n1p1.device</span><br><span class="line"> 223ms docker.service</span><br><span class="line"> 157ms systemd-journal-flush.service</span><br><span class="line"> 129ms systemd-remount-fs.service</span><br><span class="line">  93ms udisks2.service</span><br><span class="line">  84ms boot.mount</span><br><span class="line">  83ms user@1000.service</span><br><span class="line">  64ms libvirtd.service</span><br><span class="line">  63ms lvm2-monitor.service</span><br><span class="line">  38ms systemd-udev-trigger.service</span><br><span class="line">  37ms systemd-journald.service</span><br><span class="line">  36ms upower.service</span><br><span class="line">  33ms systemd-tmpfiles-setup.service</span><br><span class="line">  32ms systemd-udevd.service</span><br><span class="line">  30ms systemd-tmpfiles-clean.service</span><br><span class="line">  30ms systemd-logind.service</span><br></pre></td></tr></table></figure><p>可以看到是NetworkManger拖慢了我们的速度，然后发现是<code>systemd-networkd-wait-online.service</code>, 如果我们不需要这个直接禁用就好了</p><p>一般systemd-boot和systemd开机那一堆service和DM和DE（Desktop Environment）的加载相比不会拖慢你的速度的。不过我们其实可以连bootlaoder都不要的，如果是UEFI， 那直接EFI Stub就可以了</p><p>BIOS加载bootloader的启动文件（比如systemd-boot的systemd-bootx64.efi），bootloader再去引导内核启动</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ tree EFI</span><br><span class="line">EFI</span><br><span class="line">├── BOOT</span><br><span class="line">│   └── BOOTX64.EFI</span><br><span class="line">├── Linux</span><br><span class="line">└── systemd</span><br><span class="line">    └── systemd-bootx64.efi</span><br></pre></td></tr></table></figure><p>其实我们可以直接用efibootmgr生成linux的efi启动文件，然后跳过booloader这个中间商。同样指定ucode和initramfs的img， 以及root所在的分区，然后会生成一个efi文件，直接引导进linux</p><h3 id="直接跑在内存上"><a href="#直接跑在内存上" class="headerlink" title="直接跑在内存上"></a>直接跑在内存上</h3><p>Archlinux可以直接用ramroot, 这个只要装个AUR包然后配置一下就可以了</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="关于UEFI和BIOS"><a href="#关于UEFI和BIOS" class="headerlink" title="关于UEFI和BIOS"></a>关于UEFI和BIOS</h3><p>UEFI确切的说法是UEFI BIOS，其实也算作BIOS的一种，通常所说的BIOS指Legacy BIOS。这里按照通常习惯简称UEFI BIOS为UEFI, Legacy BIOS为BIOS。</p><h3 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h3><p>linux在很早的时候是不需要bootloader的，后来有了bootloader这种东西，不过你还是可以不要bootloader的，比如上面说到的EFI Stub。<br>systemd-boot也算是个bootloader，不过相比其他的booloader已经精简了很多了。</p><h3 id="关于initramfs和rootfs"><a href="#关于initramfs和rootfs" class="headerlink" title="关于initramfs和rootfs"></a>关于initramfs和rootfs</h3><p>看这里： <span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi9maWxlc3lzdGVtcy9yYW1mcy1yb290ZnMtaW5pdHJhbWZzLnR4dA==">https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmdlbnRvby5vcmcvd2lraS9Jbml0cmFtZnMvR3VpZGUvemgtY24=">https://wiki.gentoo.org/wiki/Initramfs/Guide/zh-cn<i class="fa fa-external-link-alt"></i></span>  </p><h3 id="傻多戴的阴间BIOS固件"><a href="#傻多戴的阴间BIOS固件" class="headerlink" title="傻多戴的阴间BIOS固件"></a>傻多戴的阴间BIOS固件</h3><p>你戴的阴间BIOS固件，强制升级不能回退就算了，每次TM升级bug不修还锁CPU频率，次次更新BIOS反向升级，想淘汰老用户就直说呗。当年我想不要grub了整个EFI Stub玩，结果发现你戴的阴间BIOS怎么还是不行。。。</p><blockquote><p>EFISTUB does not work on some Dell systems<br>Several generation Dell firmwares are wrongly passing the arguments to the bootloader, thus making EFISTUB parse a null command line which normally means unbootable system (see the complete linux-efi thread).</p></blockquote><blockquote><p>A workaround has been found since Linux 5.10 to correct this behavior (see this commit ). For Linux &lt; 5.10, you can use an efi-packer like arch-efiboot, or a different bootloader.</p></blockquote><p>从13年到现在用过3台dell的笔记本了，一个比一个糟心，我再买dell的笔记本我是XX</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQXJjaF9ib290X3Byb2Nlc3NfKCVFNyVBRSU4MCVFNCVCRCU5MyVFNCVCOCVBRCVFNiU5NiU4Nyk=">Arch boot process(简体中文)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9iYnMucGVkaXkuY29tL3RocmVhZC0yNjAzOTkuaHRt">浅析安全启动（Secure Boot）<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cDovLzUwbGluZXNvZmNvLmRlL3Bvc3QvMjAxOC0wMi0yOC13cml0aW5nLWFuLXg4Ni1oZWxsby13b3JsZC1ib290bG9hZGVyLXdpdGgtYXNzZW1ibHk=">Writing an x86 “Hello world” bootloader with assembly<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuanVubWFqaW5sb25nLmNvbS9saW51eC9zeXN0ZW1kL3N5c3RlbWRfYm9vdHVwLw==">systemd时代的开机启动流程(UEFI+systemd)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2Jsb2cuY2hpbmF1bml4Lm5ldC91aWQtOTU0MzE3My1pZC0xOTg5MDA0Lmh0bWw=">Linux内核参数传递Tag(init_tags)<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cHM6Ly9zeXN0ZW1kLmlvL0JPT1RfTE9BREVSX1NQRUNJRklDQVRJT04v">systemd The Boot Loader Specification<i class="fa fa-external-link-alt"></i></span>  官方文档  </p><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvSW5pdF8oJUU3JUFFJTgwJUU0JUJEJTkzJUU0JUI4JUFEJUU2JTk2JTg3KQ==">init (简体中文)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQXJjaF9ib290X3Byb2Nlc3M=">https://wiki.archlinux.org/title/Arch_boot_process<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvU3lzdGVtZC1ib290">https://wiki.archlinux.org/title/Systemd-boot<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvRUZJX3N5c3RlbV9wYXJ0aXRpb24=">https://wiki.archlinux.org/title/EFI_system_partition<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvVW5pZmllZF9rZXJuZWxfaW1hZ2U=">https://wiki.archlinux.org/title/Unified_kernel_image<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvbWljcm9jb2Rl">https://wiki.archlinux.org/title/microcode<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvRUZJU1RVQg==">https://wiki.archlinux.org/title/EFISTUB<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cHM6Ly9yYW1zZGVuai5jb20vMjAxNi8wNC8xNS9tdWx0aS1ib290LWxpbnV4LXdpdGgtb25lLWJvb3QtcGFydGl0aW9uLmh0bWw=">Multi Boot Linux With One Boot Partition<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9MaW51eF9kaXN0cmlidXRpb25zX3RoYXRfcnVuX2Zyb21fUkFN">https://en.wikipedia.org/wiki/List_of_Linux_distributions_that_run_from_RAM<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FyY21hZ3MvcmFtcm9vdA==">https://github.com/arcmags/ramroot<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC92NC4xNC9hZG1pbi1ndWlkZS9rZXJuZWwtcGFyYW1ldGVycy5odG1s">https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi9lZmktc3R1Yi50eHQ=">https://www.kernel.org/doc/Documentation/efi-stub.txt<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;又研究了一下linux的启动流程，然后换成systemd-boot了。原先好看的grub主题就不要了，但是systemd-boot它启动快啊，grub好臃肿&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="linux" scheme="https://zhangjk98.xyz/tags/linux/"/>
    
    <category term="systemd-boot" scheme="https://zhangjk98.xyz/tags/systemd-boot/"/>
    
    <category term="bootloader" scheme="https://zhangjk98.xyz/tags/bootloader/"/>
    
  </entry>
  
  <entry>
    <title>Vim中的宏：自动化魔法</title>
    <link href="https://zhangjk98.xyz/vim-macros/"/>
    <id>https://zhangjk98.xyz/vim-macros/</id>
    <published>2022-04-01T12:21:15.000Z</published>
    <updated>2022-04-01T12:21:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>清明节闲着没事写点Vim的东西。我对Vim有诸多怨念，不过Vim有几个地方我很喜欢，最重要的一个就是操作可以组合和自动化。</p><span id="more"></span><h2 id="宏的魔法世界"><a href="#宏的魔法世界" class="headerlink" title="宏的魔法世界"></a>宏的魔法世界</h2><p>宏可以完成很多自动化的操作，不过相比自动化，更迷人的是像写代码一样编辑文本。有一点元编程的画风，不过相比于模板元那种黑魔法，vim里的宏是人见人爱的白魔法。而且vim编辑文本的操作命令很简单，你要打印1000个 Hello, World!，不使用循环等高级功能，只需要将print这一行复制999次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>用vim这很简单，只需要<code>yy1000p</code>这种组合命令就可以了。用别的编程语言生成这么1000行print都比把print直接放在循环里麻烦。</p><p>如果是很简单的重复操作，也不需要专门录制宏。比如：</p><p><code>.</code>重复上一个edit命令<br><code>;</code> 重复上一个查找命令<br><code>&amp;</code> 替换下一个文本<br><code>@:</code> 命令重复上一个Editor Command，这个我不常用，我喜欢上箭头选上一个然后回车</p><p>但是如果想连续执行一段<code>;.</code>, 就需要用宏了（<code>11;.</code>的结果是先执行11次;再执行11次.）</p><p>如果要输出从1到1000，用vim的循环也可以完成</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">for</span> i in <span class="built_in">range</span>(<span class="number">6</span>)</span><br><span class="line">:   <span class="keyword">call</span> <span class="built_in">setline</span>(i, i.<span class="string">&#x27; &#x27;</span>.<span class="built_in">getline</span>(i))</span><br><span class="line">:<span class="keyword">endfor</span></span><br></pre></td></tr></table></figure><p>如果用宏来操作是这样的，<code>Ctrl+a</code>和<code>Ctrl+x</code>分别是对数字自增和自减，我们可以将操作分解成复制粘贴自增，然后重复998次就可以了</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一行输入<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">qa</span> 开始宏录制</span><br><span class="line">yyp 复制并粘贴第一行</span><br><span class="line">C-<span class="keyword">a</span> 自增<span class="number">1</span></span><br><span class="line">q   结束宏录制</span><br><span class="line"><span class="number">998</span>@ 重复<span class="number">998</span>次，输出<span class="number">1</span>-<span class="number">1000</span></span><br></pre></td></tr></table></figure><h2 id="稍微正经点的用途的例子"><a href="#稍微正经点的用途的例子" class="headerlink" title="稍微正经点的用途的例子"></a>稍微正经点的用途的例子</h2><p>注释几行文本：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">qa</span>  开始宏录制</span><br><span class="line">I#  <span class="keyword">insert</span>模式行首加#</span><br><span class="line">Esc 退出<span class="keyword">insert</span></span><br><span class="line"><span class="keyword">j</span>   下一行</span><br><span class="line">q   完成宏录制</span><br><span class="line"><span class="number">7</span>@a 注释<span class="number">7</span>行</span><br></pre></td></tr></table></figure><p>同理，我们想要把开头序号<code>1.</code>都变成<code>1)</code>的样子</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">qa</span>  q开始录制，保存到<span class="keyword">a</span>寄存器中</span><br><span class="line"><span class="number">0</span><span class="keyword">f</span>. 跳转到开头并查找第一个.</span><br><span class="line"><span class="keyword">j</span>  跳转到下一行</span><br></pre></td></tr></table></figure><p>大多数时候这种情况正则更方便，但是有的时候一堆混乱的文本容易误伤，宏的操作加入了位置信息等操作比较容易控制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. X1..XX</span><br><span class="line">2. SN.1FN</span><br><span class="line">3. PIN.GF</span><br><span class="line">4. 12 3.</span><br></pre></td></tr></table></figure><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>这里举例子用宏加注释什么的，其实有很多操作并不需要宏来完成，比如注释有插件。</p><h2 id="关于Vim的使用姿势"><a href="#关于Vim的使用姿势" class="headerlink" title="关于Vim的使用姿势"></a>关于Vim的使用姿势</h2><p>曾经几年前我对Vim实在说不上喜欢，当时我还在Windows上（Windows上的vim体验你也知道），经常要连到linux上改改东西的时候我日常使用nano（后来发现了micro）。如果只是将Vim当成一套键盘操作，那效率可能并不比IDE的快捷键+鼠标操作更好。（而且vim的hjkl的键位等操作，对很多人是极大的劝退）<br>Vim的键位用好了可以形成肌肉记忆将操作交给小脑解放大脑，而宏这些操作是要开动大脑的。<br>我觉得吸引玩家入坑vim就应该从录制宏等操作讲起，这些才是图形界面的点击操作不具备的优势。  </p><p>宏适合干的就是重复的动作，比较适合处理一些枯燥的工作。比如经典的某些大道至简的语言sublime多光标实现泛型这样的事情，我们可以写一个宏去完成它。（其实我个人还是喜欢多光标）</p><p><img src="/uploads/generic.gif" alt="Go Type Parameters in Sublime"></p><p><span class="exturl" data-url="aHR0cHM6Ly9tYWNwbGF5LmdpdGh1Yi5pby9wb3N0cy92aW0tYnUteHUteWFvLWR1by1ndWFuZy1iaWFvLWJpYW4tamktZ29uZy1uZW5nLw==">【译】Vim 不需要多光标编辑功能<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BzY2h0b2VmZmVsL3lvdS1kb24tdC1uZWVkLW1vcmUtdGhhbi1vbmUtY3Vyc29yLWluLXZpbS0yYzQ0MTE3ZDUxZGI=">You don’t need more than one cursor in vim<i class="fa fa-external-link-alt"></i></span>   </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;清明节闲着没事写点Vim的东西。我对Vim有诸多怨念，不过Vim有几个地方我很喜欢，最重要的一个就是操作可以组合和自动化。&lt;/p&gt;</summary>
    
    
    
    <category term="不务正业系列" scheme="https://zhangjk98.xyz/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vim" scheme="https://zhangjk98.xyz/tags/Vim/"/>
    
  </entry>
  
</feed>
