<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>止息的博客</title>
  
  <subtitle>唯见月寒日暖，来煎人寿</subtitle>
  <link href="https://zhangjk98.xyz/atom.xml" rel="self"/>
  
  <link href="https://zhangjk98.xyz/"/>
  <updated>2022-04-01T12:21:15.000Z</updated>
  <id>https://zhangjk98.xyz/</id>
  
  <author>
    <name>Zhang.j.k</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vim中的宏：自动化魔法</title>
    <link href="https://zhangjk98.xyz/vim-macros/"/>
    <id>https://zhangjk98.xyz/vim-macros/</id>
    <published>2022-04-01T12:21:15.000Z</published>
    <updated>2022-04-01T12:21:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>清明节闲着没事写点Vim的东西。我对Vim有诸多怨念，不过Vim有几个地方我很喜欢，最重要的一个就是操作可以组合和自动化。</p><span id="more"></span><h2 id="宏的魔法世界"><a href="#宏的魔法世界" class="headerlink" title="宏的魔法世界"></a>宏的魔法世界</h2><p>宏可以完成很多自动化的操作，不过相比自动化，更迷人的是像写代码一样编辑文本。有一点元编程的画风，不过相比于模板元那种黑魔法，vim里的宏是人见人爱的白魔法。而且vim编辑文本的操作命令很简单，你要打印1000个 Hello, World!，不使用循环等高级功能，只需要将print这一行复制999次</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello, World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用vim这很简单，只需要<code>yy1000p</code>这种组合命令就可以了。用别的编程语言生成这么1000行print都比这麻烦。</p><p>如果要输出从1到1000，那就要用宏了：<br>qa  开始录制，放到a寄存器<br>复制</p><h2 id="稍微正经点的用途"><a href="#稍微正经点的用途" class="headerlink" title="稍微正经点的用途"></a>稍微正经点的用途</h2><p>注释几行文本：</p><p>qa  开始宏录制<br>I#  insert模式行首加#<br>Esc 退出insert<br>j   下一行<br>q   完成宏录制<br>7@a 注释7行</p><h2 id="无需宏的简单命令"><a href="#无需宏的简单命令" class="headerlink" title="无需宏的简单命令"></a>无需宏的简单命令</h2><h2 id="关于Vim的使用姿势"><a href="#关于Vim的使用姿势" class="headerlink" title="关于Vim的使用姿势"></a>关于Vim的使用姿势</h2><p>曾经几年前我对Vim实在说不上喜欢，当时我还在Windows上（Windows上的vim体验你也知道），经常要连到linux上改改东西的时候我日常使用nano（后来发现了micro）。如果只是将Vim当成一套键盘操作，那效率可能并不比IDE的快捷键+鼠标操作更好。（而且vim的hjkl的键位等操作，对很多人是极大的劝退）<br>我觉得吸引玩家入坑vim就应该从录制宏等操作讲起，这些才是图形界面的点击操作不具备的优势。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;清明节闲着没事写点Vim的东西。我对Vim有诸多怨念，不过Vim有几个地方我很喜欢，最重要的一个就是操作可以组合和自动化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="vim" scheme="https://zhangjk98.xyz/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Vim的寄存器与复制粘贴</title>
    <link href="https://zhangjk98.xyz/vim-registers-copy-and-paste/"/>
    <id>https://zhangjk98.xyz/vim-registers-copy-and-paste/</id>
    <published>2022-04-01T12:19:37.000Z</published>
    <updated>2022-04-01T12:19:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>清明节假期写点Vim相关的东西，说一下寄存器。在此之前我眼中的复制粘贴从未如此复杂，就像我从未</p><span id="more"></span><p>另一个比我想象中复杂和有用的是Vim的undotree，有点git那种branch的味道（装上gnudo插件就更像了）。</p><h2 id="Linux下的复制粘贴"><a href="#Linux下的复制粘贴" class="headerlink" title="Linux下的复制粘贴"></a>Linux下的复制粘贴</h2><p>首先说一下linux下面的复制粘贴，一般linux桌面的复制粘贴是<code>x11</code>负责的，复制粘贴的时候和<code>X Server</code>通信（一般管复制粘贴叫selections），有两个常见的selections：</p><p>PRIMARY：鼠标左键选中复制，鼠标中键粘贴<br>CLIPBOARD： <code>Ctrl + Shift + C</code>和<code>Ctrl + Shift + V</code></p><p>这两个保存的内容是不同的，而且当你复制粘贴的时候两个应用必须同时开着，x11本身不全局保存复制的内容，应用关了就没了。所以如果你想要只有一个全局的剪切板，你得装一个<code>clipboard manager</code>（大多数桌面都贴心的自带了，可惜某些suck的wm并没有这个东西，曾经搞得我好几次弄丢了复制的东西不知道怎么回事）</p><p>推荐鼠标操作的时候尝试适应鼠标中键的操作，这样只要一只手控制鼠标就行了，比一只手鼠标一只手<code>Ctrl+C Ctrl+V</code>节省了一只手。在x11下的terminal中复制东西我一般用<code>xclip</code>。</p><h2 id="如果你只是简简单单复制粘贴"><a href="#如果你只是简简单单复制粘贴" class="headerlink" title="如果你只是简简单单复制粘贴"></a>如果你只是简简单单复制粘贴</h2><p>如果你不得不用vim，那还是鼠标选中和的复制粘贴更适合你，进入insert模式粘贴即可。简单的命令可以在normal模式下使用y和p即可（yank和paste， c命令被change占了）。y和p两个命令和其他的命令组合，可以覆盖绝大多数的用途。  </p><h2 id="精细组合操作"><a href="#精细组合操作" class="headerlink" title="精细组合操作"></a>精细组合操作</h2><p>比如<code>yw</code>复制一个单词，<code>yy</code>复制一行，<code>y$</code>复制当前光标到结尾, <code>y^</code>复制当前光标到开头， 同理，<code>yG</code>复制当前行到结尾。<br>这些命令还可以和数字继续组合，比如<code>y3w</code>复制3个单词， <code>2yy</code>复制三个单词。<br>还可以用来复制配对的括号的内容， 比如<code>yi&#123;</code>复制大括号<code>&#123;</code>中的内容，<code>ya&#123;</code>连括号一起复制。    </p><h2 id="寄存器的进阶用法"><a href="#寄存器的进阶用法" class="headerlink" title="寄存器的进阶用法"></a>寄存器的进阶用法</h2><h3 id="多种多样的寄存器"><a href="#多种多样的寄存器" class="headerlink" title="多种多样的寄存器"></a>多种多样的寄存器</h3><p>使用<code>:reg</code>查看寄存器，Vim的寄存器可以让复制粘贴玩出更多的花样， 下面介绍这些寄存器。<br>Vim的0-9寄存器是普通的寄存器，y命令默认会放到0，然后每次y会把最新的放到0，0放到1，依次保存结果。 如果你想粘贴哪个寄存器的值，在insert模式下<code>Ctrl+R 寄存器</code>， 比如粘贴寄存器3：<code>Ctrl+R 3</code>。</p><p>比较有用的是4个只读寄存器和搜索寄存器：</p><p><code>.</code>  最近插入的文本<br><code>:</code>  最近执行的命令<br><code>%</code>  存放当前文件名（相对）<br><code>#</code>  交替文件（这个好像没啥用, 就是你在当前terminal打开的上一个文件的文件名）<br><code>/</code> 搜索寄存器，可以设置默认的搜索内容。比如<code>:let @/ = &quot;package main&quot;</code>, 下次搜索的时候只要输入<code>/</code>， 会自动查找<code>package main</code>这段文本</p><h2 id="后悔药"><a href="#后悔药" class="headerlink" title="后悔药"></a>后悔药</h2><p>小删除寄存器</p><h3 id="Vim剪切板和x11的剪切板交互"><a href="#Vim剪切板和x11的剪切板交互" class="headerlink" title="Vim剪切板和x11的剪切板交互"></a>Vim剪切板和x11的剪切板交互</h3><p>在设置中<code>set clipboard^=unnamed,unnamedplus</code>，开启系统的剪切板，就会多出来两个寄存器<code>*</code>和<code>+</code>。一般<code>*</code>是PRIMARY，<code>+</code>是CLIPBOARD。（开系统剪切板功能你可能需要gvim或者neovim，vim这个包可能不支持）  </p><p>当然这么干会把匿名寄存器“”的值和系统的CLIPBOARD复制粘贴绑定，不过比起少打几个<code>+</code>， 可以接受。<br>（并没有绑定PRIMARY，<code>*p</code>会粘贴CLIPBOARD的内容，PRIMARY直接鼠标中键粘贴就可以了。所以复制同步的过程并不会在每次鼠标选中文本的时候发生，只有在手动<code>Ctrl+Shitf+C</code>的时候才有，可以接受）</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQ2xpcGJvYXJk">https://wiki.archlinux.org/title/Clipboard<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cudW5pbmZvcm1hdGl2LmRlL2Jsb2cvcG9zdGluZ3MvMjAxNy0wNC0wMi8wL1BPU1RJTkctZW4uaHRtbA==">X11: How does “the” clipboard work?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJpYW5zdG9ydGkuY29tL3ZpbS1yZWdpc3RlcnMv">Vim registers: The basics and beyond<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;清明节假期写点Vim相关的东西，说一下寄存器。在此之前我眼中的复制粘贴从未如此复杂，就像我从未&lt;/p&gt;</summary>
    
    
    
    
    <category term="vim" scheme="https://zhangjk98.xyz/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>VSCode C/C++ 开发环境和调试配置：Clangd+Codelldb</title>
    <link href="https://zhangjk98.xyz/vscode-c-and-cpp-develop-and-debug-setting/"/>
    <id>https://zhangjk98.xyz/vscode-c-and-cpp-develop-and-debug-setting/</id>
    <published>2022-03-20T12:02:25.000Z</published>
    <updated>2022-03-20T12:02:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>卸了cpptools和C++ Intelligence吧，来试试clangd或者ccls</p><span id="more"></span><h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><p>别用微软官方的那个C&#x2F;C++扩展（cpptools）和 C++ intelligence 扩展，用 clangd 和 CodeLLDB。<br><strong>全文完。我们下次再见</strong></p><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>寻找保姆级教程、习惯鼠标操作、想将VSCode打造成一个C&#x2F;C++ IDE的读者建议立刻退出并寻找其他教程。以下操作以Archlinux为例，如果你是Windos用户请去用尊贵的宇宙第一IDE Visual Studio 或者通过WSL和VSCode Remote获得一个linux的开发环境。以下假定读者有一定的基础和使用搜索引擎查资料的能力。<strong>这不是一个保姆级教程、详细教程</strong>。  </p><p>配置环境本应该是一件很简单的事情，然而M$的官方文档在推自己的cpptools塞私货，大量配置教程不是太啰嗦就是教你用cpptools，已经造成了信息污染。于是有了这篇clangd和Codelldb安利文。</p><p>事实上这是很简单的，你只需要干这些事：</p><h3 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h3><p>通常一条命令就可以了，已安装用户请略过</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装code-oss版本，和插件市场</span>yay -S code code-marketplace<span class="token comment"># 如果你想装闭源的VSCode</span>yay -S visual-studio-code-bin <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h3><p>想用gcc就用gcc，无特殊需求系统自带的gcc已经足矣（有特殊版本和交叉编译请自行安装对应版本）。想用clang就装clang。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay -S llvm lld lldb clang<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>点击安装就可以</p><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWxsdm0tdnMtY29kZS1leHRlbnNpb25zLnZzY29kZS1jbGFuZ2Q=">clangd插件<i class="fa fa-external-link-alt"></i></span>  用于高亮、自动补全、跳转<br><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXZhZGltY24udnNjb2RlLWxsZGI=">CodeLLDB插件<i class="fa fa-external-link-alt"></i></span>  如果你需要图形界面debug</p><p>ps: 如果你用闭源的VSCode，那就直接在M$的插件市场装。Code-OSS版本可以修改<code>product.json</code>使用插件市场。如果你使用或者VSCodium版本，请从OpenVSX安装<span class="exturl" data-url="aHR0cHM6Ly9vcGVuLXZzeC5vcmcvZXh0ZW5zaW9uL2xsdm0tdnMtY29kZS1leHRlbnNpb25zL3ZzY29kZS1jbGFuZ2Q=">clangd插件<i class="fa fa-external-link-alt"></i></span>（或者手动下载）</p><h3 id="安装clangd-LSP"><a href="#安装clangd-LSP" class="headerlink" title="安装clangd LSP"></a>安装clangd LSP</h3><p>然后按<code>F1</code>，选<code>clangd:Downlaod Language Server</code>, 下载clangd LSP （如果你想用系统包管理器装clangd也可以, Archlinux在<code>llvm</code>这个包里，Debian等发行版有单独的<code>clangd</code>包）</p><h2 id="Debug和运行"><a href="#Debug和运行" class="headerlink" title="Debug和运行"></a>Debug和运行</h2><p>编译运行这个就没必要装插件了吧，单个文件我使用gcc&#x2F;g++命令或者clang&#x2F;clang++命令，编译并运行。一个项目那就写个Makefile或者cmake之类的东西呗。</p><h3 id="使用gdb和lldb命令Debug"><a href="#使用gdb和lldb命令Debug" class="headerlink" title="使用gdb和lldb命令Debug"></a>使用gdb和lldb命令Debug</h3><p>如果你需要Debug，在终端使用gdb和lldb即可， over～</p><h3 id="使用VSCode提供的图形界面Debugger"><a href="#使用VSCode提供的图形界面Debugger" class="headerlink" title="使用VSCode提供的图形界面Debugger"></a>使用VSCode提供的图形界面Debugger</h3><p>哦，你要图形界面啊，安装Codelldb插件。<code>Ctrl+Shift+D</code>点左边栏的debug按钮，然后应该会自动生成一个<code>launch.json</code>，然后自行配置你的debug命令、参数和环境变量，参考：<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9lZGl0b3IvZGVidWdnaW5n">VSCode Debugging<i class="fa fa-external-link-alt"></i></span></p><p><code>tasks.json</code>如下，我以c语言为例，设置输出到<code>build</code>文件夹下同名<code>.out</code>文件，有需要请自行修改。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"2.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"tasks"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"Compile"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"process"</span><span class="token punctuation">,</span>            <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"clang"</span><span class="token punctuation">,</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"$&#123;file&#125;"</span><span class="token punctuation">,</span>                <span class="token string">"-g"</span><span class="token punctuation">,</span>                <span class="token string">"-o"</span><span class="token punctuation">,</span>                <span class="token string">"$&#123;fileDirname&#125;/build/$&#123;fileBasenameNoExtension&#125;.out"</span><span class="token punctuation">,</span> <span class="token comment">// 输出到build文件夹下</span>                <span class="token string">"-Wall"</span><span class="token punctuation">,</span>                <span class="token string">"-std=c11"</span><span class="token punctuation">,</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"group"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"build"</span><span class="token punctuation">,</span>                <span class="token property">"isDefault"</span><span class="token operator">:</span> <span class="token boolean">true</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token property">"options"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;fileDirname&#125;"</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>launch.json</code>如下，注意<code>preLaunchTask</code>要先执行<code>task.json</code>的label为<code>Compile</code>的任务</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"LLDB Debug"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"lldb"</span><span class="token punctuation">,</span>            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"$&#123;fileDirname&#125;/build/$&#123;fileBasenameNoExtension&#125;.out"</span><span class="token punctuation">,</span>            <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;fileDirname&#125;"</span><span class="token punctuation">,</span>            <span class="token property">"preLaunchTask"</span><span class="token operator">:</span> <span class="token string">"Compile"</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，这样就可以了。</p><h2 id="其他的配置"><a href="#其他的配置" class="headerlink" title="其他的配置"></a>其他的配置</h2><h3 id="调试时使用命令操作"><a href="#调试时使用命令操作" class="headerlink" title="调试时使用命令操作"></a>调试时使用命令操作</h3><p>按F5进行调试，此时按<code>Ctrl+Shift+Y</code>调出Debug Console REPL就可以用gdb&#x2F;lldb的命令进行调试了。这样就又回到了熟悉的gdb&#x2F;lldb的命令，就可以不需要鼠标点点点进行调试了，一些Codelldb不支持显示在图形界面的调试功能也可以用了。</p><h3 id="每次调试都多产生一个Debug-Console"><a href="#每次调试都多产生一个Debug-Console" class="headerlink" title="每次调试都多产生一个Debug Console"></a>每次调试都多产生一个Debug Console</h3><p>给<code>launch.json</code>加上</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">//args的这个设置是为了防止每次Debug都会多弹出一个Debug Console</span><span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span>       <span class="token string">"&amp;&amp;"</span><span class="token punctuation">,</span>    <span class="token string">"exit"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="随便说说"><a href="#随便说说" class="headerlink" title="随便说说"></a>随便说说</h2><h3 id="关于C-x2F-C-的LSP其他选择"><a href="#关于C-x2F-C-的LSP其他选择" class="headerlink" title="关于C&#x2F;C++的LSP其他选择"></a>关于C&#x2F;C++的LSP其他选择</h3><p>目前用的比较多的C&#x2F;C++的LSP是ccls和clangd，各有优劣。我的体验是ccls没有clangd的补全和错误提示那么舒服，就一直在用clangd，有兴趣可以试试ccls。<br><del>反正这两个都比cpptools好用就是了</del></p><h3 id="关于VSCode和插件"><a href="#关于VSCode和插件" class="headerlink" title="关于VSCode和插件"></a>关于VSCode和插件</h3><p>本来是不想写这个的。但是看到你们官方文档闭口不提clangd，网上各路教程也都在教大家用cpptools和C++ intelligence这两个插件，我蚌埠住了。昨天一个小学弟配vscode的c&#x2F;c++环境，折腾了一整天，然后跟我吐槽vscode又慢又卡，我心里暗叫不好，这不会是又用了cpptools和C++ intelligence这两个插件吧。我问小学弟为什么不用clangd，他表示官方文档也没说啊，他明明按照官方文档来的。好吧，这也不怪小学弟，连官方文档都在叫你用M$那两个又吃内存又难用的插件。Google能搜到的也都在让你装这个。甚至你从EXTENSOINS的搜索栏里面搜c或者c++，前两个插件就是这两个，至于clangd，已经排在无数个名字里有c&#x2F;c++插件的后面找不着了。</p><p><strong>我的操作逐渐转为快捷键和terminal，图形界面主要用来展示而不是用来点点点完成操作</strong>。我主要是将VSCode作为一个neovim&#x2F;gdb&#x2F;lldb的展示前端来用，<a href="https://zhangjk98.xyz/vscode-neovim-setting/">Neovim插件配置见上一篇博客</a>。目前用习惯了VSCode还真没动力换别的，几次试图切到纯Neovim最后又滚回了VSCode+Neovim插件。  </p><p>VSCode正在变得臃肿，而且打字延迟比Sublime和Neovim高。VSCode丝滑的感觉远不如Sublime Text，也不如高配电脑上的Jetbrains家的全家桶。我比较喜欢VSCode一个是LSP，一个是没有太多捆绑功能+丰富的插件生态和开箱即用。但是最近这两年总感觉它不再想好好做一个编辑器了，总想抢IDE的活，可能是风头压过atom和sublime之后也失去了方向。单纯作为一个文本编辑器，VSCode的打磨和细节体验和Vim、Sublime都有还有不小的差距，但是现在眼看着要向一个IDE的方向狂奔了。</p><p>VSCode的插件良莠不齐，而VSCode本体也逐渐和我想要的编辑器差距越来越大。但是毕竟用习惯了。现在很多网上的教程都是把VSCode配置成IDE，装了一大堆插件，最后又慢又卡。大多数复杂的功能学习所用的时间很有可能赶不上学会以后帮你节省的时间，尤其是点点点的图形界面，每次更新按钮换位置又要从头找起。就算学也学一点一些不怎么变的快捷键和Vim操作，那些在肌肉记忆可以一直用下去。</p><p>我觉得如果VSCode你要用的开心，<strong>不要当IDE用，就当一个编辑器用</strong>。要有一种又不是不能用的<strong>摆烂</strong>心态，不要刻意去配置。简单配置到<strong>能用就行</strong>。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9vcGVuLXZzeC5vcmcv">https://open-vsx.org/<i class="fa fa-external-link-alt"></i></span> M$的VSCode插件市场的开源替代<br><span class="exturl" data-url="aHR0cHM6Ly9jbGFuZ2QubGx2bS5vcmcv">https://clangd.llvm.org<i class="fa fa-external-link-alt"></i></span> clangd项目</p><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9lZGl0b3IvZGVidWdnaW5n">https://code.visualstudio.com/docs/editor/debugging<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9pbnRyb3ZpZGVvcy9kZWJ1Z2dpbmc=">https://code.visualstudio.com/docs/introvideos/debugging<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;卸了cpptools和C++ Intelligence吧，来试试clangd或者ccls&lt;/p&gt;</summary>
    
    
    
    
    <category term="VSCode" scheme="https://zhangjk98.xyz/tags/VSCode/"/>
    
    <category term="clangd" scheme="https://zhangjk98.xyz/tags/clangd/"/>
    
  </entry>
  
  <entry>
    <title>使用 Go Multi-Module Workspace：本地可以愉快的replace了</title>
    <link href="https://zhangjk98.xyz/go-multi-module-workspace/"/>
    <id>https://zhangjk98.xyz/go-multi-module-workspace/</id>
    <published>2022-03-18T02:45:03.000Z</published>
    <updated>2022-03-18T02:45:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天go2:1.18终于发布了，万众期待的泛型终于来了。不过我一直期待的是 go mod 的改动，新增了workspace和go vendor那几个命令不再默认更新<code>go.mod</code>和<code>go.sum</code>，不用再苦哈哈的replace和固定版本了。<br><del>然而这并不能改变go包管理器依旧鸡肋的现状</del></p><span id="more"></span><h2 id="终于等到workspace"><a href="#终于等到workspace" class="headerlink" title="终于等到workspace"></a>终于等到workspace</h2><p>之前用 go module 我们有各种奇奇怪怪的理由要用replace：</p><ol><li>我在本地新建了一个项目，然后我<code>go mod init github/archaeoraptor/XXX</code>， 但是我暂时不想push上去</li><li>写的比较乱我暂时不想commit</li><li>用到了别人的依赖但是我魔改了点内容</li><li>哎哎哎，go mod tidy 怎么自动把我modules版本升上去了，我不想升啊</li><li>我想把github上面的私有项目迁移到gitea，想把url换成这个</li></ol><p>我自己写就在<code>go.mod</code>里面replace就好了，手写几行 replace 又不是太麻烦的事情。<br>然而我和我室友一起写点项目的时候麻烦就来了，replace 的本地路径不一样，我是<code>/home/xxx/xxx</code>，他是<code>C:\XXX\XXX</code>，这样在 commit 的时候就有问题。但是把<code>go.mod</code>放到<code>.gitignore</code>里面忽略掉又不好。</p><p>如果有一个像vscode那样的workspace，workspace中的本地json设置可以覆盖全局的json设置就好了。</p><h2 id="go-work-使用"><a href="#go-work-使用" class="headerlink" title="go work 使用"></a>go work 使用</h2><p>举例说明一下, 新建一个叫hello的repo, hello.go和main.go内容:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//hello.go</span><span class="token keyword">package</span> hello<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// main.go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/archaeoraptor/hello"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    hello<span class="token punctuation">.</span><span class="token function">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你想不commit和push, 也不想修改go.mod文件加入replace，在本地能跑，那么需要将这两个文件放到同一个 go module 里面：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ go mod init github.com/archaeoraptor/hello_repo$ tree<span class="token builtin class-name">.</span>├── go.mod├── hello│   ├── go.mod│   └── hello.go└── main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>repo根目录的<code>go.mod</code>:</p><pre class="line-numbers language-none"><code class="language-none">module github.com&#x2F;archaeoraptor&#x2F;hello_repogo 1.18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个时候不commit并push到远程，直接执行<code>go run main.go</code>是可以正常运行出<code>Hello, World!</code>的。</p><p>不过有的时候我们想要设置嵌套模块(nested modules)或者一个repo里面多个module（<strong>比如万恶的grpc，一个项目里面可能要依赖不同版本的grpc</strong>, 这时候就需要一个项目中多个<code>go.mod</code>来兼容不同的版本）</p><p>如果你想给hello单独设为嵌套模块<br>目录结构变成这样:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">module github.com/archaeoraptor/hellogo <span class="token number">1.18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时：hello目录的<code>go.mod</code>长这样：</p><pre class="line-numbers language-none"><code class="language-none">module github.com&#x2F;archaeoraptor&#x2F;hello&#x2F;hellogo 1.18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时我们还没有上传，就会报错<code>go: finding module for package github.com/archaeoraptor/hello/hello  ... fatal: repository &#39;https://github.com/archaeoraptor/hello/&#39; not found</code>或者<code>can&#39;t request version &quot;latest&quot; of the main module (github.com/archaeoraptor/hello)</code></p><p>这个时候我们以前会改<code>go.mod</code>用replace替换成本地的：</p><pre class="line-numbers language-config" data-language="config"><code class="language-config">module github.com&#x2F;archaeoraptor&#x2F;hellogo 1.18require github.com&#x2F;archaeoraptor&#x2F;hello&#x2F;hello v0.0.0-20220318143722-96fbd621879dreplace github.com&#x2F;archaeoraptor&#x2F;hello&#x2F;hello &#x3D;&gt; ..&#x2F;hello&#x2F;hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了workspace，可以将replace写在<code>go.work</code>中，然后将<code>go.work</code>添加到<code>.gitignore</code>。这样不同人对replace的更改就不会影响repo中的<code>go.mod</code>了</p><p>新建workspace(在module的外层目录)</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">cd <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">go</span> work init <span class="token punctuation">.</span><span class="token operator">/</span>hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>会产生一个<code>go.work</code>文件夹，加入replace</p><pre class="line-numbers language-none"><code class="language-none">go 1.18use .&#x2F;helloreplace github.com&#x2F;archaeoraptor&#x2F;hello&#x2F;hello &#x3D;&gt; .&#x2F;hello&#x2F;hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="终于不再默认更新依赖"><a href="#终于不再默认更新依赖" class="headerlink" title="终于不再默认更新依赖"></a>终于不再默认更新依赖</h2><p>1.18终于更改了之前<code>go mod vendor</code>等命令默认更新<code>go.mod</code>和<code>go.sum</code>的迷惑行为。</p><p>什么？这难道不好吗？理论上来说这很好，如果这些包都按照语义化版来。但是有的包它不讲武德，小版本升级有breaking changes，最爱干这种事的还不是那些野鸡包，<strong>就是是谷歌自家的grpc</strong></p><p>按照语义化版本号一般的习惯，只有大版本更新（v1更新到v2, v2更新到v3）才有 breaking changes， 小版本的更新是向下兼容的（v1.1更新到v1.2），grpc基本每次小版本更新总有 breaking changes。我好几次arch滚出问题都是因为grpc。</p><p>每次想执行<code>go mod vendor</code>等命令的时候，之前为了不让它自动更新<code>go.mod</code>的依赖版本，只能用各种扭曲的办法，比如加<code>-mod=readonly</code>参数。</p><h2 id="闲话包管理器"><a href="#闲话包管理器" class="headerlink" title="闲话包管理器"></a>闲话包管理器</h2><p>相比广为诟病的错误处理啊，没有泛型啊，我一直觉得go的包管理器是个更麻烦的问题。包管理器的问题很容易成为历史包袱的。包管理器一开始留下的问题，再想改就很麻烦，有兴趣可以看看npm之类的历史包袱。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvZG9jL3R1dG9yaWFsL3dvcmtzcGFjZXM=">Tutorial: Getting started with multi-module workspaces<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvNDU3MTM=">https://github.com/golang/go/issues/45713<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZXB1ZGRzL2dvLW1vZHVsZS1rbm9icy9ibG9iL21hc3Rlci9SRUFETUUubWQ=">go-module-knobs<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbmNvcmUuZGV2L2d1aWRlL2dvLm1vZA==">Go modules cheat sheet<i class="fa fa-external-link-alt"></i></span>  </p><h3 id="包管理器相关"><a href="#包管理器相关" class="headerlink" title="包管理器相关"></a>包管理器相关</h3><p><span class="exturl" data-url="aHR0cHM6Ly93eHNtLnNwYWNlLzIwMjEvbnBtLWhpc3Rvcnkv">Node.js 包管理器发展史<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9nby5nb29nbGVzb3VyY2UuY29tL3Byb3Bvc2FsLysvbWFzdGVyL2Rlc2lnbi80NTcxMy13b3Jrc3BhY2UubWQ=">Proposal: Multi-Module Workspaces in cmd&#x2F;go<i class="fa fa-external-link-alt"></i></span>   </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天go2:1.18终于发布了，万众期待的泛型终于来了。不过我一直期待的是 go mod 的改动，新增了workspace和go vendor那几个命令不再默认更新&lt;code&gt;go.mod&lt;/code&gt;和&lt;code&gt;go.sum&lt;/code&gt;，不用再苦哈哈的replace和固定版本了。&lt;br&gt;&lt;del&gt;然而这并不能改变go包管理器依旧鸡肋的现状&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Concurrency&amp;Go" scheme="https://zhangjk98.xyz/categories/Concurrency-Go/"/>
    
    
    <category term="go" scheme="https://zhangjk98.xyz/tags/go/"/>
    
    <category term="workspace" scheme="https://zhangjk98.xyz/tags/workspace/"/>
    
  </entry>
  
  <entry>
    <title>6.824 Lab1 MapReduce 经典老番</title>
    <link href="https://zhangjk98.xyz/map-reduce/"/>
    <id>https://zhangjk98.xyz/map-reduce/</id>
    <published>2022-03-01T12:57:10.000Z</published>
    <updated>2022-03-01T12:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Long Live Map Reduce</p><span id="more"></span><p>MapReduce的影响挺大的</p><h2 id="Map和Reduce操作"><a href="#Map和Reduce操作" class="headerlink" title="Map和Reduce操作"></a>Map和Reduce操作</h2><p>MapReduce 最早是函数式编程里的概念，我一开始也是在python里面最听到这两个词的。map用来映射，reduce用来聚合。</p><p>python里面是这样的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> <span class="token builtin">reduce</span><span class="token keyword">def</span> <span class="token function">f1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token operator">*</span>x<span class="token keyword">def</span> <span class="token function">f2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token operator">*</span>ynums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>suqare <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token builtin">reduce</span>作用于一个序列，效果相当于阶乘factorial <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">reduce</span><span class="token punctuation">(</span>f2<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求阶乘的操作用循环也可以做到，但是我们注意到这些操作有很好的性质，可以分离开计算再求总和，这样就可以拆解为一些小的并行计算。（循环也可以被SIMD指令并行，这里先不多说了）</p><p>遍历使用迭代器完成的</p><h2 id="分布式的MapReduce"><a href="#分布式的MapReduce" class="headerlink" title="分布式的MapReduce"></a>分布式的MapReduce</h2><p><img src="/map-reduce/1647509929.png"></p><p>Map和Reduce两种操作和上面python的例子用法一样</p><p><img src="/map-reduce/1647509989.png"></p><p>论文以 wc （单词统计）为例。master会分出M个Map任务和N个Reduce任务，然后分配给worker。</p><p>Map任务执行用户自定义的map函数，输出一个&lt;key, value&gt;。</p><p>Reduce执行用户自定义的reduce函数，用来聚合相同的&lt;key, value&gt;。</p><p>要注意Map和Reduce是有先后顺序的，需要完成Map操作</p><h2 id="Lab1-实现一个玩具MapReduce"><a href="#Lab1-实现一个玩具MapReduce" class="headerlink" title="Lab1 实现一个玩具MapReduce"></a>Lab1 实现一个玩具MapReduce</h2><p>注：看起来这个Lab和去年的一样，把去年做的直接拿过来了，当时实现的时候不少地方挺粗糙的。</p><p>6.824的Lab1是做一个MapReduce，例子就是当年Google经典论文里面的那个 word count。wc和阶乘、求和一样有很好的性质，能够并行。</p><p>这个Lab很简单，<code>src/main/mrapps/wc.go</code>给好了一个单机版的例子，实现这样的效果：<code>cat mr-out-* | sort | more</code></p><p>仿照单机版本用rpc通信做一个并行版本就可以了。（这里没有真正的集群，用多个goroutine模拟并行）</p><p>我们需要补全3个文件：coordinator.go, worker.go, rpc.go。这里的coordinator就是论文里的master，因为<del>黑命贵</del>某些原因惨遭和谐，你打开以前的Lab就可以看到它本来就是master.go</p><p>rpc.go 里面已经给了一个例子，我们仿照着写就可以了（其实本来我是想直接用grpc来着）。注意PRC的struct要大写。</p><p>worker很容易，向master发送RPC请求然后接任务并返回就可以了。将Map任务分配到对应的worker中可以直接使用给好的<code>ihash</code>函数</p><p>master要产生并分配map任务和reduce任务，然后接收的时候判断一下是否可以合并。这里一个比较麻烦的地方是处理worker超时、停机等情况。不过这里提示我们用一个简单的方法：For this lab, have the master wait for ten seconds; after that the master should assume the worker has died (of course, it might not have). 不区分超时和宕机，直接等待10s，10s后如果没收到就直接不要这个worker的任务了。</p><h3 id="race问题"><a href="#race问题" class="headerlink" title="race问题"></a>race问题</h3><p>我去年做的时候是给channel加Mutex锁来保证没有race。go的风格是尽量用channel避免加锁，我试着全用channel但是更乱了，可能是我的操作不对，最后还是用了锁。</p><h3 id="reduce需要在每个map全部完成后再开始"><a href="#reduce需要在每个map全部完成后再开始" class="headerlink" title="reduce需要在每个map全部完成后再开始"></a>reduce需要在每个map全部完成后再开始</h3><p>Map任务和Reduce任务是不能并行的，Reduce需要等待所有Map任务完成之后才能开始。</p><p>之前做的时候是傻呼呼的让reduce任务的节点发rpc给master，然后等到map完成数为M了才开始。这次翻了翻Lab的Hints，原来可以用<code>sync.Cond</code> (条件变量)，大概像下面这样</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// w.cond = sync.NewCond(w)</span><span class="token comment">// master</span><span class="token keyword">func</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>Worker<span class="token punctuation">)</span> BeginReduceWork <span class="token punctuation">&#123;</span>    w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">&#123;</span>        all_map_task_finish <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span>    w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span><span class="token function">Broadcast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">//广播，开始每一个Reduce任务</span><span class="token punctuation">&#125;</span><span class="token comment">//worker</span><span class="token keyword">func</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>Worker<span class="token punctuation">)</span> doReduce <span class="token punctuation">&#123;</span>    w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token operator">!</span>all_map_task_finish <span class="token punctuation">&#123;</span>        w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// start Reduce Task</span>    w<span class="token punctuation">.</span><span class="token function">startReduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sync.Cond</code>这个讨论串挺有意思的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvMjExNjU=">proposal: Go 2: sync: remove the Cond type<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="写入的原子性"><a href="#写入的原子性" class="headerlink" title="写入的原子性"></a>写入的原子性</h3><p>Lab的提示告诉你，写入新建一个副本，然后应用更改的时候重命名</p><blockquote><p>To ensure that nobody observes partially written files in the presence of crashes, the MapReduce paper mentions the trick of using a temporary file and atomically renaming it once it is completely written. You can use ioutil.TempFile to create a temporary file and os.Rename to atomically rename it.</p></blockquote><h3 id="master挂了怎么办"><a href="#master挂了怎么办" class="headerlink" title="master挂了怎么办"></a>master挂了怎么办</h3><p>我做Lab的时候没有考虑这个问题，假设它不会挂。</p><p>如果真的挂了那就再来一遍吧（可以保存中间文件，这样已经产生的中间文件就不用从Map操作再产生一遍了）</p><h3 id="输入在变怎么办"><a href="#输入在变怎么办" class="headerlink" title="输入在变怎么办"></a>输入在变怎么办</h3><p>如果输入（比如需要wc的单词）一直在改变，这样也是不适合用MapReduce处理的。这种可以去用storm和flink。实时计算这些我也不不懂，不管了。</p><h3 id="网络问题和恶意篡改"><a href="#网络问题和恶意篡改" class="headerlink" title="网络问题和恶意篡改"></a>网络问题和恶意篡改</h3><p>一般我们部署在内网集群，不考虑网络带宽问题。TB级别的文件分为总文件大小除以64M的Map<br>同理假定所有节点不存在恶意篡改，也不考虑Paxos等算法考虑的拜占庭问题。</p><!-- ## Push一下老板老板给本科生讲课讲王珊《数据库系统概论》，基本就还是老一套。除了上机和作业，一半的时间在讲约束和范式，一半的课时在讲触发器、游标、存储过程，还是有两把刷子的。好吧，老板的课我当年都没从头到尾好好听，只听了和看了书里面范式、约束、隔离级别和锁那些。老板讲的那一套用面向对象那一套建好多个表和约束、多表联结查询、逻辑都写在存储过程里面，做一个传统的金融、HIS系统那种对约束要求严格业务繁多的不过上周组会还是出乎我的意料。老板他老人家最近又有了奇思妙想，虽然他组会上说下周找一个毕业的师兄过来给我们讲一下联邦学习的时候，一口一个大数据，啊，开始吹什么大公司都在用啊这个很有前景啊。我一脸懵，联邦学习是什么？老板：巴拉巴拉....我：这不就跟MapReduce那一套东西差不多老板：MapReduce是什么？我：巴拉巴拉老板：不是的，不是这个东西老板大概是多年没有亲自写过代码了，技术水平和概念还停留在sql server 2000、Oracle那一堆逻辑写在存储过程里面和上个世纪在金蝶公司用C++写图形界面。（**年轻帅气的老板在写代码的时候我甚至还没有出生**，Google经典三篇发布都已经是零几年的事了，当时老板做的东西也还是Oracle单机那一套，没听过可能也正常）咳咳，不黑老板了老板你要是看到我这篇博客，少玩点手机啊，看看DDIA吧 --><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p> GFS的经典论文</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Long Live Map Reduce&lt;/p&gt;</summary>
    
    
    
    <category term="Concurrency&amp;Go" scheme="https://zhangjk98.xyz/categories/Concurrency-Go/"/>
    
    
    <category term="6.824" scheme="https://zhangjk98.xyz/tags/6-824/"/>
    
    <category term="MapReduce" scheme="https://zhangjk98.xyz/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Page table 笔记：虚拟内存、页表和MMU</title>
    <link href="https://zhangjk98.xyz/6.S081-lab-page-table/"/>
    <id>https://zhangjk98.xyz/6.S081-lab-page-table/</id>
    <published>2022-01-12T09:56:03.000Z</published>
    <updated>2022-01-12T09:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个Lab前几个月写的，最近比较闲整理一下之前做的Lab。内存管理这块比较复杂，当时做Lab的时候对内存这块理解也浅，实现有些挺蠢的地方，重新整理了一下。接下来的笔记会多一点和Lab作业关系不是特别大的东西，闲着没事看OS相关的东西觉得有意思就一起记到笔记里了。</p><span id="more"></span><h2 id="从单片机的内存和MMU说起"><a href="#从单片机的内存和MMU说起" class="headerlink" title="从单片机的内存和MMU说起"></a>从单片机的内存和MMU说起</h2><p>早期的操作系统是就像现在的一些单片机一样没有虚拟内存、页表这些东西的。以前我一开始用ARM的STM32的单片机的时候，用的是cortex-m系列，没有MMU（Memory Management Unit，内存管理单元）的，直接访问物理地址。当时我上嵌入式的课上也不讲这些东西，上课、做实验讲到内存的时候都直接访问物理地址的（Keil里面直接看物理地址的值确实比较简单）。</p><p>这个时候内存的管理方式挺简单的，<strong>可能为数不多的坑就是大小端</strong>，有一次被坑了挺久</p><p>下面这张图很熟悉了，堆、栈，数据段、代码段</p><p>访问栈就直接用sp去寻址就可以了，简单直接。</p><p>没有MMU也有好处，这样便宜、功耗低、而且比较简单。有的对实时性要求比较高的东西，也没有MMU（比如Cortex-R系列）</p><p>注：嵌入式的soc芯片，如果能跑操作系统的大概率有MMU，但是两者之前没有必然关系。比如uCLinux，就是为了在没有MMU上的设备跑。有MMU，当然也可以不用操作系统，直接跑裸机（MMU其实可以关掉，但是我们一般不关，手动指定映射，因为MMU的cache对性能提升很大）。（uClinux要小心内存碎片，而且由于MMU没了，内存保护、内存置换、COW基本都没了，大部分时候还是用mmap和内存直接打交道）</p><p>单片机可以不要MMU，但是一个运行着很多任务的操作系统需要对内存进行抽象和封装，提供给应用。于是后来诞生了虚拟内存&#x2F;虚拟存储器（Virtual Memory），虚拟内存可以比物理内存大，可以让每个程序都认为自己拥有一段连续独立的内存，还可以权限控制（内存保护），虚拟内存在硬件上是MMU实现的。操作系统的虚拟内存几乎都依赖MMU。（当然，操作系统有自己的页表，这个一会再说）<br>像Cortex-A系列的soc芯片，是有mmu的，上面能跑一些完整的操作系统，有页表等一系列完整的内存管理机制。下图来自xv6 book，每个进程都有自己独立的虚拟内存，这样主要的好处一个是安全隔离，一个是让进程操作一段连续的内存，即使映射到物理内存上是不连续的（你可以<strong>试试在Cortex-A系列soc的板子上跑个uClinux这种没有虚拟内存的，很容易搞出内存碎片然后OOM了</strong>）。</p><p><img src="/6.S081-lab-page-table/1642081823.png"></p><p>下面这是ARM的图，RISC-V和x86我不熟，就没找RISC的图。下面这些图来自：<span class="exturl" data-url="aHR0cHM6Ly9jczE0MGUuc2VyZ2lvLmJ6L2RvY3MvQVJNdjgtQS1Qcm9ncmFtbWVyLUd1aWRlLnBkZg==">ARMv8-A-Programmer-Guide<i class="fa fa-external-link-alt"></i></span></p><p><img src="/6.S081-lab-page-table/1642057127.png"></p><p>MMU以页为最小单位将内存从物理地址映射到虚拟地址，页表大小一般是4k。除了地址映射MMU还实现了内存保护。每个页有读、写、执行三种权限。</p><p>MMU里有TLB（Translation Lookaside Buffer），专门用来缓存页表，CPU要访问内存的时候会先去TLB里面找，没有命中再去遍历找物理地址（Translation Table Walk）。</p><p>图中的Caches就是我们熟悉的L1、L2、L3缓存，l1一般有ICache和DCache，分别用来缓存指令和数据。</p><p><img src="/6.S081-lab-page-table/1642057382.png"></p><p>一部分ARM的芯片是将L1的ICache做成逻辑地址的（不经过MMU），有的芯片是逻辑地址（Cache缓存的是经过MMU转换后的虚拟地址），这个和芯片的实现有关，不是这里的重点。我们就简单的认为，Cache一般速度远比主存快，用于缓存最常用的内存数据（页）。</p><p><img src="/6.S081-lab-page-table/1642057536.png"></p><p>当L1、L2、L3都没有命中（Write Miss）的时候，会走总线去内存里面找。至于L1、L2、L3缓存的置换、一致性这些问题，我们也简单的认为芯片已经帮我们做好了，这里我们不去管它。</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>以页为单位完成了物理内存到虚拟内存的映射，要访问这些页我们需要查表，于是就有了页表（Page Table）。但是如果把每个页都映射成一张页表，这一个页表是很大的，于是就有了多级页表。多级页表中每一级都有index和offset用于定位页和页中的偏移量。</p><p><img src="/6.S081-lab-page-table/1642065542.png"></p><p>上图中的PPN是物理page号（PPN，Physical Page Number）。</p><h3 id="进程页表和内核页表"><a href="#进程页表和内核页表" class="headerlink" title="进程页表和内核页表"></a>进程页表和内核页表</h3><p>xv6里面有，内核页表和用户页表（进程页表），每个进程都有自己独立的页表。内核页表只有一个。一般进程页表都有一份内核页表的直接copy，但是一些开了内核页表隔离（KPTI, Kernel Page Table Isolation）的，情况会比较复杂。</p><p><img src="/6.S081-lab-page-table/1642124957.png"></p><p>我们这里先不考虑这些复杂情况，做Lab的时候只需要知道进程地址空间是<code>exec</code>创建的，进程页表是<code>proc_pagetable</code>创建的</p><h2 id="页表放在哪"><a href="#页表放在哪" class="headerlink" title="页表放在哪"></a>页表放在哪</h2><p>放在内存里面（是虚拟内存）。准确的说，是在内存的内核空间（kernel address space）里。在RISC-V中，SATP寄存器保存当前进程的页表地址，通过切换SATP的值来切换进程页表，MMU通过这个地址去找页表（先去TLB找，那里放的是页表的缓存）。<br>x86的寄存器是CR3，作用类似。</p><h2 id="这么多年过去了页大小怎么还是4K"><a href="#这么多年过去了页大小怎么还是4K" class="headerlink" title="这么多年过去了页大小怎么还是4K"></a>这么多年过去了页大小怎么还是4K</h2><p>如果你执行<code>getconf PAGE_SIZE</code>看一下，大概率还是<code>4096</code>。<br>页表的级数一直在增加，ARM的嵌入式soc（比如Cortex-A系列）一般是二级页表，Linux一开始也是二级，后来有了3级和4级页表。然而这么多年过去了，页表大小基本还是4k。</p><p>透明大页</p><h2 id="Lab作业笔记"><a href="#Lab作业笔记" class="headerlink" title="Lab作业笔记"></a>Lab作业笔记</h2><p>这个Lab是第四章内存管理的配套Lab，做之前推荐还是看一下第四章的讲义。涉及到的几个函数在<code>vm.c</code>中</p><h3 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h3><blockquote><p>Some operating systems (e.g., Linux) speed up certain system calls by sharing data in a read-only region between userspace and the kernel. This eliminates the need for kernel crossings when performing these system calls.</p></blockquote><p>仿照Linux通过共享内存来加快syscall。一开始看lwm这篇：<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzE4NDExLw==">How to speed up system calls<i class="fa fa-external-link-alt"></i></span> 02年的文章和<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzE4NDE0Lw==">Patch<i class="fa fa-external-link-alt"></i></span>没看懂是要干嘛，后来搜了一下vsyscall才明白这个Lab想让我们做什么。  </p><blockquote><p>vsyscall 或 virtual system call 是第一种也是最古老的一种用于加快系统调用的机制。 vsyscall 的工作原则其实十分简单。Linux 内核在用户空间映射一个包含一些变量及一些系统调用的实现的内存页。<br>不过后来vsyscall几乎都换成vDSO和vvar了（安全原因），现在不少发行版默认禁用这个的。  </p></blockquote><p>知道干什么就好办了，我们照着课程提示先看<code>user/ulib.c</code>中的<code>ugetpid()</code>，这里已经将共享地址<code>USYSCALL</code>转成usyscall结构体，然后返回pid</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token function">ugetpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span>u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span><span class="token punctuation">)</span>USYSCALL<span class="token punctuation">;</span>  <span class="token keyword">return</span> u<span class="token operator">-></span>pid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只要在<code>kernel/proc.h</code>中补全USYSCALL的映射（mapping），这个仿照trapframe就好了，在<code>proc.h</code>中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span>usyscall    <span class="token comment">// data page for getpid syscall</span><span class="token keyword">struct</span> <span class="token class-name">trapframe</span> <span class="token operator">*</span>trapframe<span class="token punctuation">;</span> <span class="token comment">// data page for trampoline.S</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后在<code>proc.c</code>设置映射和读权限（PTE_U、PTE_R，详见xv6文档）。我们继续照着trapframe的写法加上：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// map the getpid (for systemcall return)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span>            <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usyscall<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在<code>allocproc()</code>中分配，在<code>freeproc()</code>中释放内存（这个直接照抄trapframe的分配和释放就可以了）。注意还要在<code>proc.c</code>中的<code>proc_freepagetable</code>释放一下<code>uvmunmap(pagetable, USYSCALL, 1, 0);</code></p><h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><p>这个也简单，实现一个打印页表方便下面调试。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9uaWV5b25nLmdpdGh1Yi5pby93aWtpX2NwdS9DUFUlRTQlQkQlOTMlRTclQjMlQkIlRTYlOUUlQjYlRTYlOUUlODQtTU1VLmh0bWw=">CPU体系架构-MMU<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTG95ZW5XYW5nL3AvMTE0MDY2OTMuaHRtbA==">（一）ARMv8 MMU及Linux页表映射<i class="fa fa-external-link-alt"></i></span>  </p><p>阅读更多</p><p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzE4NDExLw==">How to speed up system calls<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly92dmwubWUvMjAxOS8wNi9saW51eC1zeXNjYWxsLWFuZC12c3lzY2FsbC12ZHNvLWluLXg4Ni8=">x86 架构下 Linux 的系统调用与 vsyscall, vDSO<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QveDg2L3B0aS5odG1s">17. Page Table Isolation (PTI)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L2tlcm5lbC1tb2RlL2RlZmVuc2UvaXNvbGF0aW9uL3VzZXIta2VybmVsL2twdGk=">KPTI - Kernel Page Table Isolation CTF-Wiki<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个Lab前几个月写的，最近比较闲整理一下之前做的Lab。内存管理这块比较复杂，当时做Lab的时候对内存这块理解也浅，实现有些挺蠢的地方，重新整理了一下。接下来的笔记会多一点和Lab作业关系不是特别大的东西，闲着没事看OS相关的东西觉得有意思就一起记到笔记里了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="page table" scheme="https://zhangjk98.xyz/tags/page-table/"/>
    
  </entry>
  
  <entry>
    <title>用Markdown制做PPT</title>
    <link href="https://zhangjk98.xyz/make-ppt-with-markdown/"/>
    <id>https://zhangjk98.xyz/make-ppt-with-markdown/</id>
    <published>2022-01-09T12:42:16.000Z</published>
    <updated>2022-01-09T12:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>纯文本好，富文本坏。这是一个劝你放弃PowerPoint和Wps演示的安利文，回归简陋，回归开源。</p><span id="more"></span><p>这是迫于毕业不得不向PPT低头才干出来的事情，在PPT上浪费时光真没意思。能不做PPT还是不做PPT最好。（没推荐Beamer是因为LaTeX这种专业排版工具还是太复杂了，还是会浪费不少时间在排版上。）</p><h2 id="喧宾夺主的PPT"><a href="#喧宾夺主的PPT" class="headerlink" title="喧宾夺主的PPT"></a>喧宾夺主的PPT</h2><p><del>但是根据约翰霍普金斯大学的研究，喜欢做PPT的大概率是个传销分子</del></p><p>Office三件套里面，我对word只是喜欢不起来（真要做到内容样式分离还是可以的，而且把富文本的所见即所得做到了地表最强），对Excel有点厌恶（谁让你多管闲事把身份者号给我改成科学计数法了？），PPT我真的心力憔悴了。Beamer一类的Slides演示还比较重视内容，你软家的</p><p>如果不是生活所迫谁愿意做PPT呢，直接拿Markdown写文档呗。（我们现在确实除了毕业答辩这种迫不得已的事情，都用Markdown给老板讲东西了。PPT？当年老板嫌弃小胡师兄PPT做的烂，反正PPT不好好做看起来甚至不如Markdown在typora里面或者hexo里面好看）。好在毕业答辩类的学术PPT不用做的太好看，简陋一点反而显得比较朴实无华，Markdown生成的PPT也够看了。而且我前期给老板交差的调研材料什么的基本都是用Markdown写的，改一改就成PPT了。其实如果不是开题、毕设答辩要求PPT，我真的想用Markdown列一个大纲讲。</p><p>至于为什么不用LaTeX的Beamer，那是我对LaTeX不熟，而我对CSS和HTML比较熟，Markdown做不到的可以伤感CSS魔改。<br>功能简陋也好，这样免得我在PPT上面调格式浪费很多时间。<strong>而且可以用键盘操作</strong>。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>作为一个毕业答辩之类的PPT，Marp的功能已经足够做一个丐版的学术简陋风格PPT了，Beamer的功能Marp几乎都有。这个东西有VSCode插件，直接装就好了。网页版也可以直接用。</p><p>当然这个东西没有什么惊艳的动画效果和对布局细致的控制和调整，Markdown本来就不适合干这个事情呢。如果是做传销风格的PPT那还请<del>直接用Office</del>试试隔壁的reveal.js，像写前端一样写你的演示，各种漂亮的动画效果全都有。</p><p>直接新建一个Markdown，在开头启用marp就好了。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token front-matter-block"><span class="token punctuation">---</span><span class="token front-matter yaml language-yaml"><span class="token key atrule">marp</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></span><span class="token punctuation">---</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>语法都是markdown的语法，每一张PPT之间隔断就用<code>---</code>就可以了（最好在<code>---</code>前面空一行）</p><p>为了更符合传统的PPT界面的布局，VSCode打开Preview，然后将preview调到左边侧栏。好，它现在看起来和wps演示和PowerPoint完全一致。</p><p><img src="/make-ppt-with-markdown/1641736904.png"></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的支持当然没有PowerPoint那么好。Markdown本来就不支持调整图片的大小、图片缩放、指定图片位置这种操作。对于博客文章或者文档可以统一用css去设置居中、边框这些，但是PPT的图片几乎每页的布局和位置都不太一样。Marp对Markdown提供了一些扩展，能基本满足我对图片的位置调整需求。如果不满足要求可以用html标签去调图片。</p><p>下面的操作是一些粗略调整宽度高度的语法、以及上下左右、居中、背景图片。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token url"><span class="token operator">!</span>[<span class="token content">bg right vertical weight:600</span>](<span class="token url">zhixi.png</span>)</span><span class="token comment">&lt;!-- 将图片置于右上，宽度600px --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>Marp自带的模板合适可以自己定制，只需要一点CSS就可以了</p><p>定制可以参考：<span class="exturl" data-url="aHR0cHM6Ly9tYXJwaXQubWFycC5hcHAvdGhlbWUtY3Nz">https://marpit.marp.app/theme-css<i class="fa fa-external-link-alt"></i></span></p><p>太长不看版：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcnAtdGVhbS9tYXJwL2Rpc2N1c3Npb25zLzExNQ==">How to create a theme?<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;纯文本好，富文本坏。这是一个劝你放弃PowerPoint和Wps演示的安利文，回归简陋，回归开源。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ppt" scheme="https://zhangjk98.xyz/tags/ppt/"/>
    
    <category term="markdown" scheme="https://zhangjk98.xyz/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>RCU，读多写少的锁实现</title>
    <link href="https://zhangjk98.xyz/rcu-and-userspace-rcu/"/>
    <id>https://zhangjk98.xyz/rcu-and-userspace-rcu/</id>
    <published>2022-01-07T02:34:18.000Z</published>
    <updated>2022-01-07T02:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前做的垃圾骗钱项目有很多都是读多写少，而且不怎么需要实时。一直比较好奇应该用什么锁，读写锁总是不满意，最近看6.S081看到rcu，咦，是我想要找的东西。</p><span id="more"></span><h2 id="水平超低预警"><a href="#水平超低预警" class="headerlink" title="水平超低预警"></a>水平超低预警</h2><p>一年前就开始看DDIA和做6.824 Raft 那些东西，不过当时水平太菜了。一直不太敢写并发和分布式相关的东西。并发有很多反直觉的地方，我写出来总是踩坑。好在golang的channel什么的写起来都很舒服。<br>一年过去了，自认水平总没有当初那么菜了，鼓起勇气开始写一点关于并发和Go的东西，所以新开了一个分类。（结果发现一年前看的好多东西都忘了。。。记住的好多也是错的。。。）<br><strong>这个系列肯定有很多丢人现眼的地方，路过的朋友看到我说的不对的地方请在评论告诉我</strong></p><h2 id="用途和概念"><a href="#用途和概念" class="headerlink" title="用途和概念"></a>用途和概念</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><img src="/2022-01-08-22-40-18.png"></p><p>我们可以用读写锁来保证读取和写入的一致性。在大量读取、少量写入的场景，读写锁的效率会比较低，用RCU可以提高读的性能。使用RCU，读的时候可以不加锁，也不用去管什么内存屏障和原子性了，直接读就完事了。<br>而且如果写入很少，几乎没有同时写入的情况，RCU的写入速度是很快的，写并不一定比读写锁慢（Grace Period其实很短）</p><p><img src="/2022-01-08-22-34-22.png"></p><p>典型场景包括：路由表、DNS查询、内核</p><blockquote><p>The basic form of such “Pure RCU” designs is as follows:</p><ol><li>Make a change, for example, to the way that the OS reacts to an NMI.</li><li>Wait for all pre-existing read-side critical sections to completely finish (for example,by using the synchronize_sched() primitive). The key observation here is that subsequent RCU read-side critical sections are guaranteed to see whatever change was made.</li><li>Clean up, for example, return status indicating that the change was successfully made</li></ol></blockquote><p>在内核里面主要是处理中断、代替读写锁、订阅发布、代替引用计数等。在内核中应用的介绍可以看文章：<span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAxOC9yZWFkaW5ncy9yY3UtZGVjYWRlLWxhdGVyLnBkZg==">RCU Usage In the Linux Kernel: One Decade Later<i class="fa fa-external-link-alt"></i></span><br>下面是一个NMI的例子（不可打断中断应该也不会被抢占，正适合RCU）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">rcu_list_t</span> nmi_list<span class="token punctuation">;</span><span class="token class-name">spinlock_t</span> nmi_list_lock<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handle_nmi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rcu_list_for_each</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list<span class="token punctuation">,</span> <span class="token class-name">handler_t</span> cb<span class="token punctuation">)</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rcu_read_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">register_nmi_handler</span><span class="token punctuation">(</span><span class="token class-name">handler_t</span> cb<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rcu_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list<span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">unregister_nmi_handler</span><span class="token punctuation">(</span><span class="token class-name">handler_t</span> cb<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rcu_list_remove</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">synchronize_rcu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RCU在用户态用的比较少，远不如mutex和spinlock普遍。<br>当然，用户态一般不怎么用这个东西，像数据库那种（用redis上内存用cache硬抗.jpg）</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>reader很简单，就是<code>rcu_read_lock</code>和<code>rcu_read_unlock</code>。<code>rcu_read_lock</code>和<code>rcu_read_unlock</code>中间的这一段通常叫读侧临界区 (read-side critical sections)</p><p>writer的要复杂一点</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>rcu的实现有很多，比如实时性比较好的srcu（sleepable rcu）、嵌入式用的比较多的tinyrcu、用于CPU核数非常多的tree-rcu；这里只说一下简单经典的rcu实现，其他具体的实现可以去看Paul的文章。<br>这里大部分都是从lwn那里抄来的，建议英文好的直接看原文：<br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzI2MzEzMC8=">What is RCU? Part 2: Usage<i class="fa fa-external-link-alt"></i></span></p><p>如果想看详细实现可以去看linux rcu主要作者Paul的文章和书：<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmVkZ2Uua2VybmVsLm9yZy9wdWIvbGludXgva2VybmVsL3Blb3BsZS9wYXVsbWNrL3BlcmZib29rL3BlcmZib29rLmh0bWw=">Is Parallel Programming Hard, And, If So, What Can You Do About It?<i class="fa fa-external-link-alt"></i></span></p><p><strong>Linux对于指针的load和store都是原子的</strong>，所以在链表读取的时候，指针要么指向新插入完成的，要么指向旧的还没被删的链表，不会出现正在修改链表的时候刚删除指针还没来得及插入产生<code>segmentation fault</code>。</p><p>以链表为例，写入（Write）的时候先复制（copy）一个副本，然后在读取（read）较少的合适时间执行插入操作。当然，我们可以等到完全没有写入的间隙。但是读取（reader）很多一直没用空闲，写入会非常慢；一直都有reader的极端情况会导致一直无法写入。rcu用宽限期（grace period）巧妙的解决了这个问题。</p><h3 id="怎么知道copy之前的读取全部完成可以reclaim了"><a href="#怎么知道copy之前的读取全部完成可以reclaim了" class="headerlink" title="怎么知道copy之前的读取全部完成可以reclaim了"></a>怎么知道copy之前的读取全部完成可以reclaim了</h3><p>我看rcu之前的第一反应是引用计数，当引用计数降到0就说明copy的副本可以reclaim了。但是引用计数效率太低了，而且多核的时候引用计数更麻烦了。</p><p>经典的rcu模型是不允许抢占的。当读取完成进入临界区，我们认为这个CPU进入一次<strong>静止状态（quiescent state）</strong>，以下简称QS。linux里面用cpumask来记录这个状态，我们就简单的当成是用一个bitmap来保存每个cpu的状态好了。显然，从bitmap得知copy之后每个CPU都经历过一次QS后，那在copy之前的读操作都已经完成了，这个时候就可以reclaim了。</p><h3 id="多个writer怎么处理"><a href="#多个writer怎么处理" class="headerlink" title="多个writer怎么处理"></a>多个writer怎么处理</h3><p>如果有多个writer，那通常会给不同的writer加spin_lock来处理</p><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁是对于读来说的，写入的时候锁比较多。在修改bitmap的时候是需要加锁的（一般是spin_lock）。太多的写入同时对bitmap加锁效率很低，于是就有了tree-rcu。tree-rcu是将不同的CPU状态分组加锁，然后树状结构向上汇总状态。</p><p><img src="/2022-01-08-22-35-28.png"></p><p>如果你的逻辑CPU数量（就是你在htop里看到的，比如6核12线程的5600x是12）小于16，那它会退化成单个rcu_node。<br>tree-rcu详见[A Tour Through TREE-RCU’s DataStructures]</p><p>多个writer的情况下也要加锁，一般是spin_lock锁。</p><h2 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h2><p>rcu的实现依赖了很多内核态的东西，移植到用户态比较困难。比较出名的一个用户态rcu是<code>liburcu</code></p><p>模仿rcu的思想可以实现一点读多写少的优化，比如<code>sonic</code>的map<br><span class="exturl" data-url="aHR0cHM6Ly9oYW5zaGFuZ2xpbi5zcGFjZS90ZWNoL3JjdS8=">如何实现一个超快读的map<i class="fa fa-external-link-alt"></i></span></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvUkNVL3doYXRpc1JDVS5odG1s">What is RCU? – “Read, Copy, Update”<i class="fa fa-external-link-alt"></i></span> Linux Kernel文档的介绍<br><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAxOC9yZWFkaW5ncy9yY3UtZGVjYWRlLWxhdGVyLnBkZg==">RCU Usage In the Linux Kernel: One Decade Later<i class="fa fa-external-link-alt"></i></span> MIT 6.828课 RCU的阅读材料，我就是在这个课上看到rcu的，看起来还挺有意思<br><span class="exturl" data-url="aHR0cDovL3d3dy5yZHJvcC5jb20vdXNlcnMvcGF1bG1jay9SQ1Uv">Introduction to RCU<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmVkZ2Uua2VybmVsLm9yZy9wdWIvbGludXgva2VybmVsL3Blb3BsZS9wYXVsbWNrL3BlcmZib29rL3BlcmZib29rLmh0bWw=">Is Parallel Programming Hard, And, If So, What Can You Do About It?<i class="fa fa-external-link-alt"></i></span> 我对于rcu的不少疑惑是看了这个才懂，推荐（本书主要作者Paul也是linux rcu的主要实现者）<br><span class="exturl" data-url="aHR0cDovL2lmZXZlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxMy8wNS8lRTYlQjclQjElRTUlODUlQTUlRTclOTAlODYlRTglQTclQTMlRTUlQjklQjYlRTglQTElOEMlRTclQkMlOTYlRTclQTglOEJWMS4wLnBkZg==">深入理解并行编程<i class="fa fa-external-link-alt"></i></span> 上面那本书的中文翻译<br>谢宝友 深入理解RCU系列文章<br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzQ5MDIyODI=">Linux锁机制：可抢占RCU原理<i class="fa fa-external-link-alt"></i></span><br>[CPU masks - linux-insiders] linux-insiders的CPU masks介绍（这本书也挺不错的，我好几次查资料翻到，讲的比较易懂）<br><span class="exturl" data-url="aHR0cHM6Ly94aW5xaXUuZ2l0Ym9va3MuaW8vbGludXgtaW5zaWRlcy1jbi9jb250ZW50L0NvbmNlcHRzL2xpbnV4LWNwdS0yLmh0bWw=">CPU masks 介绍<i class="fa fa-external-link-alt"></i></span> 中文翻译  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前做的垃圾骗钱项目有很多都是读多写少，而且不怎么需要实时。一直比较好奇应该用什么锁，读写锁总是不满意，最近看6.S081看到rcu，咦，是我想要找的东西。&lt;/p&gt;</summary>
    
    
    
    <category term="Concurrency&amp;Go" scheme="https://zhangjk98.xyz/categories/Concurrency-Go/"/>
    
    
    <category term="rcu" scheme="https://zhangjk98.xyz/tags/rcu/"/>
    
  </entry>
  
  <entry>
    <title>新年开箱一个 Canokey Pigeon</title>
    <link href="https://zhangjk98.xyz/canokey-pigeon-unboxing/"/>
    <id>https://zhangjk98.xyz/canokey-pigeon-unboxing/</id>
    <published>2022-01-02T06:05:36.000Z</published>
    <updated>2022-01-02T06:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>迟来的开箱，本来以为快递1号当天能到的，结果晚了一点。不管怎么说，元旦快落！</p><span id="more"></span><h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p>Canokey就是tuna那一帮人弄的重置版yubikey啦，stm32版本完全开源，发售的版本固件开源加密算法没开。至于后门和售后这些问题，由子安人格担保。这一批的500个比以前更贵了，169大洋，小贵。（据说以前是亏本买的）和之前透明探索版不同，这次虽然有壳，但是似乎更脆弱了，总担心一不小心掉水里。然而还是买了，看到群友人均有一个key我也想整一个。虽然小贵，但是飞天的key又怕有后门不太敢要。其他的产品算上跨国邮费还是比这个贵了。（虽然我有个stm32的，找嘉立创打样整了一个，不过做工一般（毕竟白嫖的嘉立创打样，有就不错了），不太适合挂钥匙扣上一直带着）</p><p>子安29号从深圳发的，去快递的时候货架上还放着不少连号的相同包装，应该都是群友的。外包装有点脏，里面完好，附带一个绳子和USB-A转type-c的转接头。插上以后chromium浏览器会自动弹出管理界面（Firefox不支持Webusb所以用不了）<br><img src="/canokey-pigeon-unboxing/canokey2.webp"><br>好，然后生成个ed25519的密钥换掉我原来用于ssh登陆的rsa（这个对我来说好处是密钥不像rsa那么长，可以用笔抄在纸上一份，不要paperkey一类的工具把它变短了）。按照惯例找个liveusb，装好gpg，断网，生成公钥密钥子密钥。然后将子密钥导入CanoKey，主密钥抄下来。</p><p>感觉还是原来的透明探索版看起来耐用一点，这个的壳子不怎么防水容易进灰。上几张图给大家看一下灯光亮度。亮度和罗技G102鼠标最亮的蓝光大致相当，远高于我的键盘（dell kb522）指示灯和机箱电源的蓝光。（建议在管理页面调成默认关闭LED）</p><p><img src="/canokey-pigeon-unboxing/canokey3.webp"><br><img src="/canokey-pigeon-unboxing/canokey4.webp"></p><p>一个惊喜是这个功率比较低，在我的键盘USB插槽上可以正常使用。我的键盘USB插槽功率连U盘都带不动，也带不动g102等大部分鼠标，闲置了许久终于有了用途。</p><h2 id="用途和体验"><a href="#用途和体验" class="headerlink" title="用途和体验"></a>用途和体验</h2><p>1.两步验证</p><p>这个没有FIDO认证，因为没交保护费。所以YubiKey能干的一些事他干不了，比如可以跳过验证的<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZGZsYXJlY2hhbGxlbmdlLmNvbS8=">cloudflarechallenge<i class="fa fa-external-link-alt"></i></span>。<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzc2MzE4NjE=">互联网上消防栓的消亡-Cloudflare 无图 CAPTCHA 的应运而生<i class="fa fa-external-link-alt"></i></span> 想不要CAPTCHA那得交保护费。 </p><p>国内大多数网站不支持，不过Google帐号之类的还是可以的。Webauthn有FIDO2会用FIDO2,没有会去用U2F。</p><p>2.NFC</p><p>打开了一直关闭的iphone NFC功能试了一下，然而没有成功。据说这一批的确不太行，可能还不如之前的透明探索版。见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhbm9rZXlzL2Nhbm9rZXktcGlnZW9uL2Rpc2N1c3Npb25zLzQ=">对 NFC 的一些说明和建议<i class="fa fa-external-link-alt"></i></span>。</p><p>更新：读取成功了！弹出提示 网站NFC标签 “在Safari浏览器中打开”canokeys.org””（当然，没有webUSB，console用不了），NFC Tools成功读到标签类型和序列号。试了一下Google的两步验证，登陆成功。<br>iphone读NFC的位置非常靠上，大概在刘海屏的背面那里，其他位置读不到。 </p><p>更新：如果NFC不好使请试试：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhbm9rZXlzL2Nhbm9rZXktcGlnZW9uL2Rpc2N1c3Npb25zLzY=">NFC修复指南<i class="fa fa-external-link-alt"></i></span></p><p>3.sudo免密码</p><p>可以装<code>pam_u2f</code>实现，配置方式见<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvVW5pdmVyc2FsXzJuZF9GYWN0b3I=">Universal_2nd_Factor ArchWiki<i class="fa fa-external-link-alt"></i></span>。不过还是建议不要sudo免密，在恍惚走神的状态下使用sudo容易酿成大祸。有的时候确认处在清醒状态直接<code>sudo su -</code>临时操作一下就好了。</p><p>4.放密钥</p><p>终于说到了我买这个key的主要目的了，拿来放密钥。体验还不错，有些时候跑到别人的电脑上或者在公共电脑上用ssh登陆的时候终于不用担心密钥泄漏了。 </p><p>5.加密LUKS之类的</p><p>去年systemd-homed刚出的那个时候我写过一篇博客，还说等我有了YubiKey试试LUKS加密home分区。不过到今年我已经很不喜欢systemd了（底裤，注意底裤！）。更重要的是我终于想明白了我home分区里面那点破玩意价值不足10元，用一个几百元的key去保护一个连key的零头都不到的破数据没必要。是时候停止我的被迫害妄想症了。</p><p>对于防止普通人直接把你硬盘扣了插到别的电脑上读数据，Arch可以直接装<code>mkinitcpio-tpm2-encrypt</code>和<code>luks-tpm2</code>这两个包配置TPM2+LUKS加密。systemd 248以上版本用systemd-cryptenroll也行。不过dell、hp几家的国行没有TPM的，有TPM的联想之类的也是有后门的TPM，所以你如果想拿来对付非普通人士还是算了吧。</p><h2 id="推不推荐买"><a href="#推不推荐买" class="headerlink" title="推不推荐买"></a>推不推荐买</h2><p>这要看你拿它来干什么，如果你很在乎体验又不缺钱也对开源没有特殊的感情，那去买YubiKey吧。如果不是很想掏钱或者对安全没那么在乎，那没必要买类似的产品。如果你想找一个足够方便的两步验证设备，那建议去用给FIDO2交了保护费的FIDO2之类的。  </p><p>我只是用它放个密钥啥的，倒也够用了。其实三年前我第一次开始用密钥是因为不想每次输入密码，后来逐渐变成了被迫害妄想症，一发不可收拾（倒也不全是杞人忧天，至少我大四的时候经历过一次被盗，由于出租屋家徒四壁幸免于难，合租的两位损失过万）<br>设置密码或者加密文件到底是防谁呢？</p><blockquote><p>There are two types of encryption: one that will prevent your sister from reading your diary and one that will prevent your government.   —-Bruce Schneier</p></blockquote><p>一顿操作下来，突然有一天发现密码忘了、钥匙无了、LUKS损坏了。<strong>防的竟是我自己</strong><br>第一种我身边的人用密码挡一下就已经够了，第二种暂时没有这个需求。现在除了你姐姐和gov，更多的是一些大小公司的流氓软件，扫描你的目录上传你的相册。现在已经懒得和它们斗智斗用了，流氓软件扔进虚拟机，密钥扔进CanoKey。   </p><p>说说局限<br>1.NFC不太灵<br>2.蓝色的灯光比较刺眼（设置里可以关）<br>3.由于芯片性能原因不能直接在CanoKey里面生成rsa4096（不过可以导入）<br>4.加密算法不开源（不过有子安人格担保）<br>5.这次一个Yubikey的价格没法买5个CanoKey了症<br>6.送的type-c转接头短一截看着逼死强迫</p><p><img src="/canokey-pigeon-unboxing/canokey5.webp"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplbml0aGFsLm1lLzIwMjEvMDIvMTUvQW50LURlc2lnbi1HaXRIdWItMkZBLXVuYXZhaWxhYmxlLWluLUNoaW5hLw==">从Ant Design GitHub失窃案谈开去：国内有可用的2FA吗<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMVBQNmFrU3RMX3hIVFk2OHpETW1LYkpyQnFRaE4zRkU5TXdMRG9NR3hiYXMvZWRpdCNnaWQ9MA==">Comparison of security keys<i class="fa fa-external-link-alt"></i></span> 群友整理的关于隔壁各家类似产品的功能对比<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNhbm9rZXlzLm9yZy8=">CanoKeys官方文档<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyZHVoL1l1YmlLZXktR3VpZGU=">YubiKey Guide<i class="fa fa-external-link-alt"></i></span> CanoKey的资料比较少，一些用法可以参考yubikey<br><span class="exturl" data-url="aHR0cHM6Ly9pYW10d3ouZ2l0Ym9va3MuaW8veXViaWtleS1oYW5kYm9vay1jaGluZXNlLw==">YubiKey 使用手册<i class="fa fa-external-link-alt"></i></span> 中文资料<br><span class="exturl" data-url="aHR0cHM6Ly9ud24ubW9lL3Bvc3RzL3l1YmlrZXktZXhhbXBsZXM=">应用 Yubikey 的N种方法<i class="fa fa-external-link-alt"></i></span>   </p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FnaGVyemFuL3l1YmlrZXktZnVsbC1kaXNrLWVuY3J5cHRpb24=">yubikey full disk encryption<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ud24ubW9lL3Bvc3RzL2J0cmZzLW9uLWx1a3Mv">让系统更安全 - 系统分区加密 (Btrfs on LUKS) 操作实录<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTI1ODYyMTU4">Unlocking LUKS2 Volumes with TPM2, FIDO2, PKCS#11 Security HW on Systemd 248<i class="fa fa-external-link-alt"></i></span>  如果只是想电脑被偷之后，不让普通小偷&#x2F;电脑城修电脑的&#x2F;脚本小子看你的数据，用tpm2加密home分区增加的破解成本差不多能够保护你不太之前的数据了。  </p><p><span class="exturl" data-url="aHR0cHM6Ly9mbHloaWdoZXIudG9wL2RldmVsb3AvMjE2MC5odG1s">谈谈 WebAuthn<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93ZWJhdXRobi5tZS8=">webauth.me<i class="fa fa-external-link-alt"></i></span> 用于测试webauthn的网站    </p><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvUGFwZXJrZXk=">Paperkey Archwiki<i class="fa fa-external-link-alt"></i></span> paperkey用来减少密钥长度方便抄下来<br><span class="exturl" data-url="aHR0cHM6Ly91bHljLmdpdGh1Yi5pby8yMDIxLzAxLzEzLzIwMjElRTUlQjklQjQtJUU3JTk0JUE4JUU2JTlCJUI0JUU3JThFJUIwJUU0JUJCJUEzJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUJEJUJGJUU3JTk0JUE4UEdQLSVFNCVCOCU4QS8=">2021年，用更现代的方法使用PGP（上）<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly91bHljLmdpdGh1Yi5pby8yMDIxLzAxLzE4LzIwMjElRTUlQjklQjQtJUU3JTk0JUE4JUU2JTlCJUI0JUU3JThFJUIwJUU0JUJCJUEzJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUJEJUJGJUU3JTk0JUE4UEdQLSVFNCVCOCVBRC8=">2021年，用更现代的方法使用PGP（中）<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly91bHljLmdpdGh1Yi5pby8yMDIxLzAxLzI2LzIwMjElRTUlQjklQjQtJUU3JTk0JUE4JUU2JTlCJUI0JUU3JThFJUIwJUU0JUJCJUEzJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUJEJUJGJUU3JTk0JUE4UEdQLSVFNCVCOCU4Qi8=">2021年，用更现代的方法使用PGP（下）<i class="fa fa-external-link-alt"></i></span>  </p><p>目前Pigeon暂时卖完了，你可以自己去嘉立创整一个stm32版本的</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhbm9rZXlzL2Nhbm9rZXktc3RtMzI=">Canokey-stm32<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sY2VkYS5jbi96NHl4L25mYy1wb3dlci10ZXN0">Canokey-NFC-A<i class="fa fa-external-link-alt"></i></span>   </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;迟来的开箱，本来以为快递1号当天能到的，结果晚了一点。不管怎么说，元旦快落！&lt;/p&gt;</summary>
    
    
    
    <category term="不务正业系列" scheme="https://zhangjk98.xyz/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="canokey" scheme="https://zhangjk98.xyz/tags/canokey/"/>
    
  </entry>
  
  <entry>
    <title>文件系统的Reflink（Reflink、hardlink、symlink的区别）</title>
    <link href="https://zhangjk98.xyz/reflink-hardlink-symlink/"/>
    <id>https://zhangjk98.xyz/reflink-hardlink-symlink/</id>
    <published>2021-12-19T05:24:54.000Z</published>
    <updated>2021-12-19T05:24:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>reflink暂且翻译成引用链接吧，新版coreutils的cp和mv的默认行为就是reflink（如果文件系统支持）</p><span id="more"></span><h2 id="Reflink"><a href="#Reflink" class="headerlink" title="Reflink"></a>Reflink</h2><p>如果你的coreutils&gt;9.0，而且装的是Btrfs或XFS等支持Reflink的文件系统，那么<code>cp</code>和<code>mv</code>的默认行为是使用reflink(mv应该是在不同子卷之间，when moving files across BTRFS subvols)，<code>cp --reflink=auto</code></p><p>最早是从Btrfs听说的reflink,以为这就是一个COW，后来发现它并不一定需要COW，而是和de-duplication（重复数据删除）有关。</p><h2 id="整理碎片对reflink的影响"><a href="#整理碎片对reflink的影响" class="headerlink" title="整理碎片对reflink的影响"></a>整理碎片对reflink的影响</h2><p>以Btrfs为例，defragment会打断reflink，于是你做完defrag以后会发现占用空间可能大了好多。不过像Btrfs之类的文件系统几乎都跑在SSD上，整理碎片不仅不会像机械那样提升性能，而且会增加写入。所以直接不整理碎片就好了。</p><h2 id="硬链接和软链接和Reflink的区别"><a href="#硬链接和软链接和Reflink的区别" class="headerlink" title="硬链接和软链接和Reflink的区别"></a>硬链接和软链接和Reflink的区别</h2><p>这两个东西的区别基本上网上都说烂了。这里再简单说一下。</p><p>硬链接（hardlink）的inode号和原来的一样</p><p>但是hardlink和symlink有一些问题，创建的时候很开心，修改和删除就比较麻烦。</p><h2 id="Reflink这个东西有啥用"><a href="#Reflink这个东西有啥用" class="headerlink" title="Reflink这个东西有啥用"></a>Reflink这个东西有啥用</h2><p>1.加快复制和移动速度<br>2.节省空间</p><p>比如wine的reflink补丁。比如你steam开proton下了很多游戏，你会发现<code>.local/share/Steam</code>下面每个游戏的目录都有一堆相同的ddl。reflink的补丁可以有效减小Wine应用的体积，很多重复的ddl文件都会以reflink的方式复制。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PVJlZmxpbmstRm9yLVdpbmUtUGF0Y2hlcw==">Proposed Reflink Support Would Provide Big Space Savings For Wine<i class="fa fa-external-link-alt"></i></span>， <span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PVdpbmUtUmVmbGluay1SZXZpc2Vk">Wine Reflink Support Continues To Be Worked On For Significant Space Savings<i class="fa fa-external-link-alt"></i></span>  </p><p>坏消息这玩意暂时不支持ext4，好消息Steam Deck将采用Btrfs。对于不支持的文件系统，可以通过OVerlayfs实现，不过好像没多少人这么干（Overlayfs这个名字你也在Docker那里听说过对罢？坑也不少）</p><p>那wine为什么不用符号链接呢？看起来这种情况下用symlink不是也挺合适的？</p><blockquote><p>Because most of the file WINE is running didn’t have symlink support in mind.They assumes that the open give them the file, not a symlink.After opening the file, they would just update it without replacing that symlink with an actual file.</p></blockquote><p>另一个麻烦的问题是相当多的游戏反作弊软件，他们在检查的时候不认符号链接。于是就认为你这ddl有问题，然后就封号了。用reflink就比较好解决了，在Wine应用和你看来是感觉不到链接存在的，reflink看起来就像是正常的文件一样；而symlink看起来就是一个link，如果Wine应用和外挂检测不去处理他会出问题。举一个不恰当的例子，reflink就像透明代理一样，用户和软件感觉不到它的存在。</p><p>要不我们叫它透明链接算了（逃</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5vcmFjbGUuY29tL2xpbnV4L3Bvc3QveGZzLWRhdGEtYmxvY2stc2hhcmluZy1yZWZsaW5r">https://blogs.oracle.com/linux/post/xfs-data-block-sharing-reflink<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL0RlZHVwbGljYXRpb24=">Deduplication Btrfs Wiki<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3J1Y2lhbC5jb20vYXJ0aWNsZXMvYWJvdXQtc3NkL3Nob3VsZC15b3UtZGVmcmFnLWFuLXNzZA==">Should You Defrag an SSD? <i class="fa fa-external-link-alt"></i></span> </p><p><span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9pb2N0bF9maWNsb25lLjIuaHRtbA==">https://man7.org/linux/man-pages/man2/ioctl_ficlone.2.html<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzMzMTgwOC8=">https://lwn.net/Articles/331808/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;reflink暂且翻译成引用链接吧，新版coreutils的cp和mv的默认行为就是reflink（如果文件系统支持）&lt;/p&gt;</summary>
    
    
    
    
    <category term="fs" scheme="https://zhangjk98.xyz/tags/fs/"/>
    
    <category term="reflink" scheme="https://zhangjk98.xyz/tags/reflink/"/>
    
  </entry>
  
  <entry>
    <title>现代文件系统笔记，顺便说说Btrfs</title>
    <link href="https://zhangjk98.xyz/filesystem-note-btrfs-introduction/"/>
    <id>https://zhangjk98.xyz/filesystem-note-btrfs-introduction/</id>
    <published>2021-12-17T14:34:07.318Z</published>
    <updated>2021-12-17T14:34:07.318Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgs.xkcd.com/comics/dark_arts.png"><br>之前做6.s081的lab的时候照猫画虎写了一个类似ext2的超简陋的文件系统，自己用了有将近一年的Btrfs，一直想写点什么。然而之前看OS的书和做Lab都是</p><span id="more"></span><h2 id="从简单的文件系统说起"><a href="#从简单的文件系统说起" class="headerlink" title="从简单的文件系统说起"></a>从简单的文件系统说起</h2><p>我们先不管日志、快照、原子性、加密这些功能。也暂时先不看类似9p那种分布式文件系统。<br>磁盘被划分成很多块（block），我们拿出来一些块放用户数据（data region），为了记录文件的</p><h2 id="现代文件系统"><a href="#现代文件系统" class="headerlink" title="现代文件系统"></a>现代文件系统</h2><blockquote><p>如果reiserfs没有因为作者杀妻进去<br>如果SUN没有被Oracle收购，ZFS没那些版权问题</p></blockquote><h3 id="Reference-Link"><a href="#Reference-Link" class="headerlink" title="Reference Link"></a>Reference Link</h3><h2 id="说说Btrfs"><a href="#说说Btrfs" class="headerlink" title="说说Btrfs"></a>说说Btrfs</h2><p>Btrfs推出也很久了，最初是打算取代ext3&#x2F;ext4地位做默认的新一代文件系统的。当然，Btrfs已经十几年了，进入Linux内核主线都8年了，大家也看到了。。。</p><p>最近的Linux内核每次更新几乎都有Btrfs的内容，而且在phoronix之类的地方讨论总是很热烈</p><p><a href="https://www.phoronix.com/forums/forum/software/general-linux-open-source/1276327-btrfs-adds-degenerate-raid-support-performance-improvements-with-linux-5-15"></a><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PUZlZG9yYTMzLURlc2t0b3AtQnRyZnMtUHJvcG9zYWw=">There’s A Proposal To Switch Fedora 33 On The Desktop To Using Btrfs<i class="fa fa-external-link-alt"></i></span>  </p><p>这话怎么听着这么耳熟，隔壁Wayland是不是好多年前也说过要*&amp;&amp;%&amp;<em>￥%</em>&amp;……，真是不巧我还在用x11呢。。。</p><p>现在在用Btrfs的大概也就Facebook，群晖，默认用Btrfs的发行版几乎就openSUSE，然后去年好像Fedora也把Btrfs作为默认了（可能）。</p><h3 id="关于Btrfs性能不好"><a href="#关于Btrfs性能不好" class="headerlink" title="关于Btrfs性能不好"></a>关于Btrfs性能不好</h3><p>Btrfs性能不好的说法主要来源于跑分跑不过ext4等等。跑分这种事情很多时候也就图一乐，以下引用fc老师的话</p><blockquote><p>phoronix 測文件系統性能的最大問題在於容易讓讀者以為文件系統是左右存儲性能的關鍵，實際上文件系統只是夾在內存子系統和塊IO子系統中間的決策層，通常瓶頸不會在文件系統，除非文件系統過度簡化設計，對存儲性能影響更大的是別的層面的東西，按他們的方式測試文件系統只能測出一堆難以預計到的副作用的結果，沒法對文件系統優化提供可供參考的提示</p></blockquote><blockquote><p>要測純讀寫做對比肯定不考慮 reflink 和透明壓縮，但是實際幹活的時候這些新特性很節省時間（</p></blockquote><p>当然Btrfs在重io的情况下桌面特别卡，那很有可能是quota的问题，把quota关掉吧，quota有已知的性能问题，尤其是在ssd上。（关了这个磁盘配额你就看不到快照大小、指定不了每个子卷的大小）</p><h3 id="Copy-on-Write写时复制"><a href="#Copy-on-Write写时复制" class="headerlink" title="Copy-on-Write写时复制"></a>Copy-on-Write写时复制</h3><p>写时复制（COW）原理看起来好像很简单，但是实现起来一堆坑。我做6.S081的Lab的时候折腾COW快把我整麻了，从Lab4以后每次做完Lab之后不想写博客总结了，做完之后思绪混乱，没什么心情写笔记。</p><h4 id="给数据库所在的目录关闭COW"><a href="#给数据库所在的目录关闭COW" class="headerlink" title="给数据库所在的目录关闭COW"></a>给数据库所在的目录关闭COW</h4><p>SSD会有写入放大的问题，这个现象在Btrfs上尤其严重。<br>不想和Btrfs和数据库斗智斗勇可以选择别的文件系统。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>如果用不到现代文件系统的那些功能，对于大多数用户直接去用ext4可能是一个更好的选择。然后忘了文件系统这回事吧，就像开头xkcd的漫画说的那样：<code>BUT I NOW </code></p><h3 id="都要2022年了，Btrfs稳定了吗"><a href="#都要2022年了，Btrfs稳定了吗" class="headerlink" title="都要2022年了，Btrfs稳定了吗"></a>都要2022年了，Btrfs稳定了吗</h3><p>无可奉告。<br>平时用倒是能用，不过真出了问题</p><h3 id="Btrfs挂了要怎么修"><a href="#Btrfs挂了要怎么修" class="headerlink" title="Btrfs挂了要怎么修"></a>Btrfs挂了要怎么修</h3><p><del>去群里找fc老师</del></p><p>做好备份，真挂了把备份找回来。大多数修复软件几乎都不怎么支持Btrfs，你去电脑城找做修复的师傅人家也不会，自求多福吧。</p><h3 id="RAID、子卷、分区问题"><a href="#RAID、子卷、分区问题" class="headerlink" title="RAID、子卷、分区问题"></a>RAID、子卷、分区问题</h3><p>之前用ext4等文件系统很多都习惯<code>/</code>，<code>/home</code>, <code>/var</code><br>Btrfs一般不分那么多区，而是用子卷。</p><p>一般对<code>var</code>这样的目录单独建一个子卷，然后禁用COW</p><p>Btrfs可以直接添加、删除设备、调整大小（增加和缩小都行，XFS暂时还不支持缩）</p><h3 id="snapshot"><a href="#snapshot" class="headerlink" title="snapshot"></a>snapshot</h3><h4 id="要怎么查看snapshot的大小"><a href="#要怎么查看snapshot的大小" class="headerlink" title="要怎么查看snapshot的大小"></a>要怎么查看snapshot的大小</h4><p>查看snapshot大小需要打开quota，但是打开quota可能会有性能问题。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE3MDcuMDg1MTQucGRm">Analyzing IO Amplification in Linux File Systems<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzYzODU0Ni8=">XFS: There and back … and there again?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9mYXJzZWVyZmMubWUvemhzL2J0cmZzLXZzLXpmcy1kaWZmZXJlbmNlLWluLWltcGxlbWVudGluZy1zbmFwc2hvdHMuaHRtbA==">Btrfs vs ZFS 实现 snapshot 的差异<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9oYWJyLmNvbS9ydS9wb3N0LzQ3NjQxNC8=">Выявляем процессы с дисковой активностью в Linux<i class="fa fa-external-link-alt"></i></span>  一篇俄文的Write Amplification讨论  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://imgs.xkcd.com/comics/dark_arts.png&quot;&gt;&lt;br&gt;之前做6.s081的lab的时候照猫画虎写了一个类似ext2的超简陋的文件系统，自己用了有将近一年的Btrfs，一直想写点什么。然而之前看OS的书和做Lab都是&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="btrfs" scheme="https://zhangjk98.xyz/tags/btrfs/"/>
    
    <category term="fs" scheme="https://zhangjk98.xyz/tags/fs/"/>
    
  </entry>
  
  <entry>
    <title>Linux from Scratch 编译笔记</title>
    <link href="https://zhangjk98.xyz/build-linux-from-scratch/"/>
    <id>https://zhangjk98.xyz/build-linux-from-scratch/</id>
    <published>2021-11-29T11:55:37.000Z</published>
    <updated>2021-11-29T11:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>久闻大名，然而真的编译了几圈下来，和想象中的不太一样。照着手册一步一步来并不难，但是特别繁琐。其实我更建议去看一看Alpine等更精简的Linux的构建过程。哦，对了，我等编译的时候通关了蔚蓝a面</p><span id="more"></span><p>LFS的主要目的是教你打造一个你自己的发行版，所以它特别繁琐。如果你想自己做一个优麒麟去骗钱那不妨看看。如果想了解一下Linux的依赖和编译过程，想看看一个特别精简版的Linux长什么样子，<strong>请试试Alpine而不是LFS</strong></p><p><strong>感觉Alpine更适合作为一个 玩具来学习，而LFS更适合作为正经用途。</strong> 大家不知为何都反着来。</p><p>推荐阅读：<span class="exturl" data-url="aHR0cHM6Ly90dHlzMy5kZXYvcG9zdC9kby1ub3QtdXNlLWFscGluZS1pbi1wcm9kdWN0aW9uLWVudmlyb25tZW50Lw==">不要在生产环境中使用alpine基础镜像 – 容器基础镜像的选择<i class="fa fa-external-link-alt"></i></span></p><p>之前觉得就是一个安装超麻烦版的Arch&#x2F;Gentoo，就没试过。最近终于试了一下，学到的东西倒不是很多，没有当时第一次完整安装Arch时的收获大。</p><p>这个东西告诉你linux里面glibc之类的依赖关系是什么样的。这个东西就像单片机最小系统一样，告诉你。你可以从头开始看一看系统是怎么从源码构建的，glibc那一堆依赖又是怎么鸡生蛋、蛋生鸡的。推荐想了解系统构建依赖的Linux用户看一看这个东西。</p><p>闲着没事的人最适合玩一玩这个了，不过不太推荐日常使用。虽然还是是有一些人真的把这个当日用主力的，比如fcitx输入法初代目鱼王（Yuking）就是在LFS上面写了早期的fcitx输入法。<br>LFS is free if your time is free.     </p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先去找一个好一点的机器用来编译。你要有一个宿主机，一般用Ubuntu 20的比较多一点，我用的Arch, 暂时没遇到什么大问题。</p><p>然后下载LFS的手册和源码，我用的是最新的r11.0-92这个版本：<span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhmcm9tc2NyYXRjaC5vcmcvbGZzL2Rvd25sb2Fkcy9kZXZlbG9wbWVudC8=">https://www.linuxfromscratch.org/lfs/downloads/development/<i class="fa fa-external-link-alt"></i></span></p><p>手册说的wget-list没有说在哪，wget-list 可以用香港的镜像： <span class="exturl" data-url="aHR0cHM6Ly9sZnMtaGsua29kZG9zLm5ldC9sZnMvdmlldy9yMTEuMC05Mi93Z2V0LWxpc3Q=">https://lfs-hk.koddos.net/lfs/view/r11.0-92/wget-list<i class="fa fa-external-link-alt"></i></span></p><p>如果想稳一点可以用stable版本，喜欢systemd可以用systemd版本（最近对systemd全家桶有点怨念，就不上systemd了）。</p><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>这里面绝大部分编译都是make那一套流程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="个人的改动"><a href="#个人的改动" class="headerlink" title="个人的改动"></a>个人的改动</h2><p>其实不太建议第一次就用dev版本还加上一大堆自己的改动。我自己乱改，前面几次都没有开机成功，反复编译了四五次才成功开机。</p><h3 id="我和手册有些出入的地方"><a href="#我和手册有些出入的地方" class="headerlink" title="我和手册有些出入的地方"></a>我和手册有些出入的地方</h3><p>手册里面要求使用bash，我在宿主机一直都用的zsh，好在没出什么大问题（主要是想接着用我习惯的那几个插件和语法，反正这个东西兼容sh，问题不大）（<strong>不要学我，坑特别多</strong>）</p><p>chroot之后用的是bash，然而看到那个没有自动补全和色彩高亮的bash, 我不能接受，于是配了半天的</p><p>分区我只分了一个100G的<code>/</code>分区，swap和boot都是和Arch共用的。（我懒）</p><h3 id="一些手册上有但我没编译和安装的东西"><a href="#一些手册上有但我没编译和安装的东西" class="headerlink" title="一些手册上有但我没编译和安装的东西"></a>一些手册上有但我没编译和安装的东西</h3><p>现在看文档基本都在浏览器上面搜了，很少看本地目录的文档，那些doc之类的东西我基本上都没装。没用默认的vim，参考BLFS的手册装了一个我习惯的neovim</p><p>Meson这个包编译报错了，这个是systemd和BLFS需要的，我就没管</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>lfs <span class="token function">chroot</span><span class="token punctuation">)</span> root:/sources/meson-0.60.2<span class="token comment"># python3 setup.py build</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:  File <span class="token string">"/sources/meson-0.60.2/setup.py"</span>, line <span class="token number">23</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    from setuptools <span class="token function">import</span> setup  File <span class="token string">"/usr/lib/python3.10/site-packages/setuptools/__init__.py"</span>, line <span class="token number">18</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    from setuptools.dist <span class="token function">import</span> Distribution  File <span class="token string">"/usr/lib/python3.10/site-packages/setuptools/dist.py"</span>, line <span class="token number">38</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    from setuptools <span class="token function">import</span> windows_support  File <span class="token string">"/usr/lib/python3.10/site-packages/setuptools/windows_support.py"</span>, line <span class="token number">2</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    <span class="token function">import</span> ctypes  File <span class="token string">"/usr/lib/python3.10/ctypes/__init__.py"</span>, line <span class="token number">8</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    from _ctypes <span class="token function">import</span> Union, Structure, ArrayModuleNotFoundError: No module named '_ctypes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="加快速度"><a href="#加快速度" class="headerlink" title="加快速度"></a>加快速度</h2><h3 id="多核编译"><a href="#多核编译" class="headerlink" title="多核编译"></a>多核编译</h3><p>通常可以直接拉满，比如我的宿主机最多能<code>-j20</code> 那就<code>export MAKEFLAGS=&#39;-j20&#39; </code>。<br>需要注意的是有的时候必须用<code>-j1</code>参数，比如编译<code>binutils</code></p><h3 id="多核压缩解压"><a href="#多核压缩解压" class="headerlink" title="多核压缩解压"></a>多核压缩解压</h3><p>xz压缩格式，使用最新版的tar看起来默认就是多核的。加上参数之后<code>XZ_OPT=&#39;-T0&#39; tar -xf linux-5.15.2.tar.xz</code>和直接<code>tar -xf linux-5.15.2.tar.xz</code>没有区别。<br>有几个gz后缀的使用<code>pizg</code>应该会快一点，但是这几个文件太小了，几乎没区别。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>第七章结尾会教你<code>tar -cJpf $HOME/lfs-temp-tools-r11.0.92.tar.xz .</code>进行备份，这个备份速度很慢，比上面那些解压慢不少。</p><p>我推荐使用Btrfs snapshot，在每次重要的make都建立一个snapshot，这样不用从头开始，而且备份和恢复的速度也很快。</p><h2 id="其他的一些小问题"><a href="#其他的一些小问题" class="headerlink" title="其他的一些小问题"></a>其他的一些小问题</h2><h3 id="i和l"><a href="#i和l" class="headerlink" title="i和l"></a>i和l</h3><p><code>Iana-etc</code>这里是大写的<code>i</code>，不是小写的<code>L</code>，另一个叫<code>Inetutils</code>的也是。</p><h3 id="chroot的时候PTY-allocation-request-failed"><a href="#chroot的时候PTY-allocation-request-failed" class="headerlink" title="chroot的时候PTY allocation request failed"></a>chroot的时候PTY allocation request failed</h3><p>我是ssh连的另一台电脑编译的（本地和远程都是Arch），结果有一天突然<code>PTY allocation request failed</code></p><p>我以为是chroot或者ssh的问题，穷尽毕生所学调试了半个小时，<strong>结果发现是那台服务器的校园网账户欠费了</strong>。</p><h3 id="一些编译报错"><a href="#一些编译报错" class="headerlink" title="一些编译报错"></a>一些编译报错</h3><p>编译findutils报错，但是装上去能用。</p><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token file-path string">/sources/findutils-4.8.0/find/pred.c</span><span class="token operator">:</span><span class="token number">751</span><span class="token operator">:</span> undefined reference to `rpl_fnmatch'<span class="token file-path string">/usr/bin/ld</span><span class="token operator">:</span> libfindtools<span class="token punctuation">.</span>a<span class="token operator">(</span>pred<span class="token punctuation">.</span>o<span class="token operator">)</span><span class="token operator">:</span><span class="token file-path string">/sources/findutils-4.8.0/find/pred.c</span><span class="token operator">:</span><span class="token number">1180</span><span class="token operator">:</span> more undefined references to `rpl_fnmatch' follow<span class="token property">collect2:</span> <span class="token property">error:</span> ld returned <span class="token number">1</span> exit status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译gzip时报错：</p><pre class="line-numbers language-log" data-language="log"><code class="language-log">In file included from <span class="token file-path string">./lib/getopt.h</span><span class="token operator">:</span><span class="token number">84</span><span class="token punctuation">,</span>                 from gzip<span class="token punctuation">.</span>c<span class="token operator">:</span><span class="token number">77</span><span class="token operator">:</span><span class="token file-path string">./lib/getopt-cdefs.h</span><span class="token operator">:</span><span class="token number">31</span><span class="token operator">:</span><span class="token number">5</span><span class="token operator">:</span> error<span class="token operator">:</span> <span class="token operator">#</span>if with no expression   <span class="token number">31</span> <span class="token operator">|</span> <span class="token operator">#</span>if      <span class="token operator">|</span>     <span class="token operator">^</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行<code>make clean</code>后错误消失。</p><p><code>make check</code>失败一项：<code>FAIL: help-version</code>，这个影响不大，忽略。</p><p>在编译Patch的时候发生了同样的报错，重新编译后成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">In <span class="token function">file</span> included from <span class="token punctuation">..</span>/lib/getopt.h:84,                 from patch.c:27:<span class="token punctuation">..</span>/lib/getopt-cdefs.h:32:5: error: <span class="token comment">#if with no expression</span>   <span class="token number">32</span> <span class="token operator">|</span> <span class="token comment">#if</span>      <span class="token operator">|</span>     ^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怀疑是多线程编译的问题，采用<code>make -j1</code>和<code>make -j20</code>分别编译了10次，发现这个问题确实是在<code>-j20</code>多线程编译时才会发生。</p><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>接下来就是重头戏编译内核了。编译内核这个gentoo用户应该很熟悉了。可以自己选择编译参数，没有什么特殊喜好就默认吧。</p><p><img src="/build-linux-from-scratch/image-20211204142505342.png" alt="image-20211204142505342"></p><p>编译速度比想象中的快，我从下午2:49编译到3:17，大概半个小时左右。</p><p>魔改编译参数请量力而行。我前面几次都自己改了很多参数，编译虽然没报错，但是启动的时候CapsLock和ScrollLock同时闪烁，只能重新编译。</p><h3 id="编译时make-clean和make-mrproper的区别"><a href="#编译时make-clean和make-mrproper的区别" class="headerlink" title="编译时make clean和make mrproper的区别"></a>编译时make clean和make mrproper的区别</h3><p><code>make mrproper</code>相比<code>make clean</code>多删除了config文件。</p><h3 id="启动引导设置"><a href="#启动引导设置" class="headerlink" title="启动引导设置"></a>启动引导设置</h3><p><strong>设置Grub的时候记得备份你宿主机的grub！</strong></p><p>本来我是想用Arch的<code>os-prober</code>自动识别<code>grub-mkconfig -o /boot/grub/grub.cfg</code>，但是不行。这样会识别成<code>Arch Linux， with Linux 5.15.2.-lfs-r11.0.92</code></p><p>在Archlinux宿主机中编辑Grub，加上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menuentry <span class="token string">"GNU/Linux, Linux 5.15.2-lfs-r11.0-92"</span> <span class="token punctuation">&#123;</span>linux /boot/vmlinuz-5.15.2-lfs-r11.0-92 <span class="token assign-left variable">root</span><span class="token operator">=</span>/dev/sda2 ro<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Fly-Bitch！"><a href="#Fly-Bitch！" class="headerlink" title="Fly Bitch！"></a>Fly Bitch！</h2><p>到这里我已经累了，BLFS已经不打算再弄了，没啥意思。Nvidia驱动，折腾了好几次，想用dkms装驱动结果都失败了。最后我把Nvidia独显拆了，整个世界都美好了。<br>试图整个KDE桌面上去，结果一堆依赖没成功，结果发现最容易的反而是dwm。。。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>终于记住了tar命令解压时候哪个参数是压缩哪个是解压。<br>不过sed还是不太会用，已经被sd惯坏了。<br>发现了starship这个不错的prompt，bash上很舒服，体验接近powerlevel10k。<br>LFS的企鹅LOGO真的好丑啊，见过的最丑的企鹅。<br>bash里<code>+h</code>关闭hash查找。这个参数的意思是不使用当前hash表里面存放的路径，精确的使用现在给出的路径。使用<code>set +h</code>关闭hash，使用<code>set -h</code>启用hash。（我总觉得<code>+h</code>才是开启hash, 真是令人迷惑）  </p><p>断断续续折腾了四五天，等编译期的间隙里蔚蓝从3a跳到了到7a登顶。</p><h2 id="编译时无聊发现的其他东西"><a href="#编译时无聊发现的其他东西" class="headerlink" title="编译时无聊发现的其他东西"></a>编译时无聊发现的其他东西</h2><p>这几天在等编译的时候闲着没事发现了其他一些有意思的东西。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rjam9uZXMvbWs=">https://github.com/dcjones/mk<i class="fa fa-external-link-alt"></i></span> plan9的mk</p><h3 id="bash和zsh的环境变量是怎么传递和继承的"><a href="#bash和zsh的环境变量是怎么传递和继承的" class="headerlink" title="bash和zsh的环境变量是怎么传递和继承的"></a>bash和zsh的环境变量是怎么传递和继承的</h3><p>login shell 和 nonlongin shell的读取环境变量方式不太一样</p><h3 id="zsh里面的‘-’命令是干什么的"><a href="#zsh里面的‘-’命令是干什么的" class="headerlink" title="zsh里面的‘-’命令是干什么的"></a>zsh里面的‘-’命令是干什么的</h3><p><span class="exturl" data-url="aHR0cHM6Ly96c2guc291cmNlZm9yZ2UuaW8vRG9jL1JlbGVhc2UvU2hlbGwtR3JhbW1hci5odG1sI1ByZWNvbW1hbmQtTW9kaWZpZXJz">zsh的文档<i class="fa fa-external-link-alt"></i></span>是这样说的：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">- The command is executed with a ‘-’ prepended to its argv[0] string.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看起来似乎它会在<code>argv[0]</code>前面加上一个<code>-</code>，可是这有什么用？</p><p>argv[0]你可以当作<span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9leGVjdmUuMi5odG1s">execve<i class="fa fa-external-link-alt"></i></span>的第一个变量，通常是<code>\bin\bash</code>这样的可执行路径。</p><p>再看一下exec这个命令，参数<code>-l</code>的效果和zsh里面的<code>-</code>是一致的</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">exec [ -cl ] [ -a argv0 ]    The following command together with any arguments is run in place of the current process, rather than as a sub-process. The shell does not fork and is replaced. The shell does not invoke TRAPEXIT, nor does it source zlogout files. The options are provided for compatibility with other shells.    The -c option clears the environment.    The -l option is equivalent to the - precommand modifier, to treat the replacement command as a login shell; the command is executed with a - prepended to its argv[0] string. This flag has no effect if used together with the -a option.    The -a option is used to specify explicitly the argv[0] string (the name of the command as seen by the process itself) to be used by the replacement command and is directly equivalent to setting a value for the ARGV0 environment variable. <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>哦，就是把当前shell视为login shell，试了一下看起来的确是这样</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">❯ <span class="token builtin class-name">echo</span> <span class="token variable">$0</span>/bin/zsh❯ - <span class="token builtin class-name">echo</span> <span class="token variable">$0</span>/bin/zsh❯ - <span class="token function">zsh</span>❯ <span class="token builtin class-name">echo</span> <span class="token variable">$0</span>-zsh❯ <span class="token builtin class-name">exit</span>❯ <span class="token function">zsh</span>❯ <span class="token builtin class-name">echo</span> <span class="token variable">$0</span><span class="token function">zsh</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTI4ODIwNjAy">Linux from Scratch with Training Wheels<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hbHBpbmVsaW51eC5vcmcv">Alpine<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy84NjAxMi93aGF0LWlzLXRoZS1wdXJwb3NlLW9mLXRoZS1oYXNoLWNvbW1hbmQ=">What is the purpose of the hash command?<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;久闻大名，然而真的编译了几圈下来，和想象中的不太一样。照着手册一步一步来并不难，但是特别繁琐。其实我更建议去看一看Alpine等更精简的Linux的构建过程。哦，对了，我等编译的时候通关了蔚蓝a面&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="Linux" scheme="https://zhangjk98.xyz/tags/Linux/"/>
    
    <category term="LFS" scheme="https://zhangjk98.xyz/tags/LFS/"/>
    
  </entry>
  
  <entry>
    <title>从KDE迁移到i3，顺便说说Linux桌面(DE)和窗口管理器（WM）</title>
    <link href="https://zhangjk98.xyz/migrating-from-kde-to-i3/"/>
    <id>https://zhangjk98.xyz/migrating-from-kde-to-i3/</id>
    <published>2021-11-13T14:25:47.000Z</published>
    <updated>2021-11-13T14:25:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这样又将一部分鼠标干的活还给了键盘。</p><span id="more"></span><p>前一阵不是KDE 25周年吗，然后KDE推出了25周年纪念版，从这开始的几个版本，小问题不断。迫害GNOME是KDE群友的传统艺能，然而，最近似乎KDE用户受到的迫害比GNOME还多。KDE怎么会变成了这个样子？ 于是决定从KDE先迁移到i3之类的wm去。（当然，最主要的原因是我逐渐不需要一个完整DE的那么功能了）</p><h2 id="从KDE说起"><a href="#从KDE说起" class="headerlink" title="从KDE说起"></a>从KDE说起</h2><p>KDE一度是我最看好的Linux桌面，功能该有的都有，当时也比较稳定，那时我觉得最近3年应该不用换到其他的桌面去了。<br>KDE为什么是神，首先，要从Konqueror和KHTML的荣光说起…<br>KDE4时代虽然好看，但是因为不稳定而饱受诟病。自从KDE5以来，KDE也稳定了,<br>直到，KDE 25周年特供版……每次更新总有一些新问题，又开始不稳定了…..</p><h3 id="防火防盗防抄袭的配置文件"><a href="#防火防盗防抄袭的配置文件" class="headerlink" title="防火防盗防抄袭的配置文件"></a>防火防盗防抄袭的配置文件</h3><p>想抄一下我的KDE的桌面设置？不好意思KDE的设置我自己也不知道它给我保存到哪里去了。</p><p>KDE的配置文件在<code>config</code>里面扔的到处都是，实乃居家旅行防偷配置利器。</p><p><code>.config</code>目录下面有一个有一个小写的<code>kde</code>目录，还有一个大写的<code>KDE</code>目录,还有一个<code>kde.org</code>目录，下面有<code>systemsettings.conf</code>和<code>plasmashell.conf</code>这样的配置文件。如果你是祖传home目录，那八成还有个<code>kde4</code>。如果你是比较新的用户，你会开心的发现<code>~/.config</code>下面没有<code>kde4</code>，是的，他跑到<code>~/.kde4</code>这来了,<code>~/.kde4/share/config</code>下面有一些kde4的配置。<br>然后，<code>~/.config</code>下面，还有<code>plasmarc</code>，<code>kded5rc</code>，<code>plasmashellrc</code>，<code>kdeglobals</code>，天知道它们有什么区别。<br>然后是一堆散落在<code>.config</code>下面的KDE全家桶应用, 比如<code>kalarmrc</code>。这次看起来挺合理吧，你看别的应用好多不也都把配置文件扔在<code>~/.config</code>下面。</p><p>别急，比如KDE出品的和notepad3、vscode类似的文本编辑器kate，在<code>~/.config</code>下面有<code>katerc</code>, <code>kateschemarc</code>, <code>katevirc</code>等等，跟VSCode一个json文件比起来拆的还是太散了。在比如elisa这个音乐播放器，有一个<code>elisarc</code>，还有一个<code>kde.org/elisa.conf</code>。</p><p>更麻烦的是这些KDE的设置和其他应用都混在一起了。有一天你的配置崩溃了，KDE起不来，你想全部恢复默认设置，又不能直接全删了来恢复默认设置。（比较好的办法是挑出不是KDE的设置或者）。比如<code>trashrc</code>是KDE的配置文件，它看起来跟KDE毫无关系。</p><p>当然有一些第三方工具可以保存KDE的设置，比如<code>konsave</code>，我还给他打过一个AUR包。不过用了两天我立刻发现这并不能解决问题，我想抄别人的配置去改一改还是要打开KDE系统设置的图形界面。某一部分微小的改动，我还是要从茫茫的配置文件里面找到它们，KDE官方有没有说明，结果就是改起配置文件比手动在设置里面调整慢。</p><p>当然KDE有一个kcmshell5的命令工具可以在命令行配置，不过我想正常人没有用这个的。你以为他是命令行工具，实际上你执行他，他给你弹出一个和系统设置一样的图形界面。</p><p>估计KDE也没想让你使用<code>dotfiles</code>或者直接编辑配置文件，都给我用鼠标在设置里面点击选择的你设置！</p><h3 id="小而美的Baloo"><a href="#小而美的Baloo" class="headerlink" title="小而美的Baloo"></a>小而美的Baloo</h3><blockquote><p>baloo 是张小龙开发的吗</p></blockquote><p>哎，这index索引文件怎么50多个G？哎，我桌面怎么突然卡死了？哎，我CPU怎么突然100%了？哎，我内存怎么占用飙升？</p><p>Baloo这个用过KDE的应该都有体会，体验大概就是Windows装了个流氓全家桶的感觉。 </p><p>一个索引服务, 磁盘写入远超读取是怎样一种体验？</p><p>我建议每个每个KDE用户装上KDE立刻关闭Baloo，我也建议有良心的KDE发行版在KDE的默认设置里面禁用Baloo</p><pre class="line-numbers language-none"><code class="language-none">balooctl suspendbalooctl disablebalooctl purge #delete the index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你还想要一个搜索工具，推荐rg、fd、fzf。<br>如果你想要一个Baloo那样带索引的，试试plocate</p><h3 id="混成器"><a href="#混成器" class="headerlink" title="混成器"></a>混成器</h3><p>混成器（Compositer）造成了KDE4时代KDE不如GNOME稳定的传说，当时OpenGL导致画质撕裂。据说当时大部分不稳定的锅都是混成器的，KDE其他的部分还是挺稳定的。<br>就在10月份，KDE将Compositer的选项</p><p>Vulkan也不知道要等到什么时候，据说要KDE6了，到时候再试试KDE吧。</p><h2 id="使用平铺wm"><a href="#使用平铺wm" class="headerlink" title="使用平铺wm"></a>使用平铺wm</h2><p>最近一年来我对Desktop Enviroment的需求逐渐降低，很多操作都从鼠标点击过渡到了命令操作。我在KDE桌面上操作窗口也从鼠标点击变成了Win+上下左右平铺、Alt+Tab切换窗口、Win+Tab切换桌面。之前非常喜欢的yakuake也被我用tdrop+alacritty替代了。那些标题栏、桌面小组件、任务栏逐渐开始变得鸡肋，而且我也不想要那么多的桌面过渡特效。为了更好地移动窗口我试过krohnkite（一个模仿dwm操作的脚本）</p><p>在发现自己的需求基本上wm都能满足之后，好像没有什么用DE的必要了。</p><p>平铺的好处是比较充分的铺满整个桌面，而且可以省掉标题栏，对于比较小的笔记本屏幕可以省空间。（笔记本上用wm还比较省电，轻松撑过一整天）</p><p>关于wm的介绍可以看这个视频：<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1BcGk2ZEZNbHhBQQ==">https://www.youtube.com/watch?v=Api6dFMlxAA<i class="fa fa-external-link-alt"></i></span></p><p>dwm是类似栈的操作，而i3wm的窗口是一棵树。不过轻度使用应该区别不大，我几乎只用将屏幕两等分或者四等分、或者竖着三等分。</p><h3 id="真的一定要那么依赖鼠标和GUI吗"><a href="#真的一定要那么依赖鼠标和GUI吗" class="headerlink" title="真的一定要那么依赖鼠标和GUI吗"></a>真的一定要那么依赖鼠标和GUI吗</h3><p>早些时候人们用键盘的快捷键和命令和计算机打交道，鼠标和GUI界面反而是比较后来的事情了。据说微软当年为了让用户习惯鼠标操作，推出了扫雷、空当接龙和蜘蛛纸牌让大家玩</p><p>我从第一次用Windows XP开始就是拿鼠标在图形界面上点点点，在小时候的相当长一段时间内键盘打字都不熟练，后来微机课教的也是Office、Flash、photoshop等拿着鼠标在一堆设置按钮里面选来选取的那种，甚至外的游戏也都是pvz、愤怒的小鸟等鼠标操作居多</p><h3 id="i3的一些问题"><a href="#i3的一些问题" class="headerlink" title="i3的一些问题"></a>i3的一些问题</h3><p>不管是i3还是sway，或者dwm之类的，都对浮动窗口支持很差。其实挺难受的，比如沙拉查词之类的翻译软件或者浏览器小窗播放、又比如输入法那个小菜单栏（虽然现在fcitx5没有浮在外面的菜单栏），不太适合平铺。</p><p>i3的浮动窗口必须置于平铺的下面，挺难受的。</p><p>另外这些平铺桌面</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 我装的cn源里面那个功能最多的开发版本，如果没什么特殊需求可以直接装i3wm或者i3-gaps（支持窗口缝隙）</span><span class="token comment"># yay -S i3-gaps</span>yay -S i3-gaps-next-git yay -S picom <span class="token comment"># 用来设置外观、锁屏什么的</span>yay -S lxappearance <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一些fcitx5的configtool、qt界面的设置软件，我用KDE的时候都装过了，这里略过。</p><h3 id="polybar作为状态栏"><a href="#polybar作为状态栏" class="headerlink" title="polybar作为状态栏"></a>polybar作为状态栏</h3><p>polybar比i3bar功能多一点而且好看，但是占用也高</p><p>polybar自己一点一点配置会很麻烦，比较懒的我直接用的这个：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkaTEwOTB4L3BvbHliYXItdGhlbWVz">polybar-themes<i class="fa fa-external-link-alt"></i></span>，一个awesome wm的polybar设置脚本，有相当多的主题可供选择。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone --depth<span class="token operator">=</span><span class="token number">1</span> https://github.com/adi1090x/polybar-themes.git<span class="token builtin class-name">cd</span> polybar-themes<span class="token function">chmod</span> +x setup.sh./setup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后选一个你喜欢的主题改一改就好了。</p><h3 id="picom配置"><a href="#picom配置" class="headerlink" title="picom配置"></a>picom配置</h3><p>其实我对阴影特效、模糊透明毛玻璃、圆角都没有什么需求。装picom主要是解决一下画面撕裂的问题（毕竟Nvidia f**k you, 混成器不要是不行的）</p><p>picom可选<code>xrender</code>和<code>glx</code>，以及&#96;&#96;<br>如果要用自带的毛玻璃效果请使用cn源里的<code>picom-git</code>并开启experimental-backends。然后在i3的<code>config</code>设置里面也加上<code>picom --experimental-backends</code></p><h3 id="i3lock-color锁屏"><a href="#i3lock-color锁屏" class="headerlink" title="i3lock-color锁屏"></a>i3lock-color锁屏</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay -S i3lock-color<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="gtk主题配置"><a href="#gtk主题配置" class="headerlink" title="gtk主题配置"></a>gtk主题配置</h3><p>我用的是capitaine-cursors arc-gtk-theme。这个用lxappearance设置。</p><h3 id="HiDPI配置"><a href="#HiDPI配置" class="headerlink" title="HiDPI配置"></a>HiDPI配置</h3><p>大部分应用在<code>~/.Xresources</code>里面配置一下就可以了。但是polybar、rofi这几个都不吃</p><p>polybar</p><p>config里面</p><pre class="line-numbers language-none"><code class="language-none">dpi &#x3D; $&#123;xrdb:Xft.dpi:-1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>rofi需要自己一点一点都调了，字体差不多16px，然后圆角和图标那都调大一点。绝大部分rofi主题都是1080p的，要自己调大小。</p><h2 id="KISS"><a href="#KISS" class="headerlink" title="KISS"></a>KISS</h2><blockquote><p>Keep it simple, stupid</p></blockquote><p>现在越来越喜欢简单的东西了</p><blockquote><p>keep it sufficiently sophisticated</p></blockquote><h2 id="其他的选择"><a href="#其他的选择" class="headerlink" title="其他的选择"></a>其他的选择</h2><p>1.Wayland</p><p>I use Nvidia…., so Nvidia f**k</p><p>最近某些媒体宣称KDE+Wayland+Nvidia已经差不多了，然而前几天我试了一下KDE的wayland还是有不少小问题的。暂时没有什么迁移到wayland的动力。而且不少应用在xwayland下面的HiDPI体验不是很好。最重要的是alacritty这个东西，在wayland会卡。而我现在对</p><p>2.Sway</p><p>原因Wayland，我用Nvidia显卡。<br>Sway现在输入法问题基本可以了，剩下的是xwayland在HiDPI有一点不清晰和一部分x的应用我比较习惯所以暂时不打算迁移到wayland</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N3YXl3bS9zd2F5L3B1bGwvNDc0MA==">https://github.com/swaywm/sway/pull/4740<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZjaXR4L2ZjaXR4NS9pc3N1ZXMvMzk=">https://github.com/fcitx/fcitx5/issues/39<i class="fa fa-external-link-alt"></i></span></p><p>3.Wayfire</p><p>Wayland的原因同上。<br>Wayfire主要还是堆叠窗口的操作，特效和流畅程度看宣传和演示视频可能是Wayland里面最棒的一个了，响应丝滑、特效也很棒。<br>不过Wayfire的那些炫酷的桌面效果我不太想用，我自己大概有blur和活动窗口变亮一点就可以了。<br>Wayfire关掉点特效用来做平铺和堆叠的混合桌面应该不错。因为像i3等对堆叠窗口的操作没有那么丰富，比如堆叠窗口只能放在平铺窗口的上面。</p><p>Wayfire目前是0.7版本，最近我看到依云在试水，HiDPI和输入法的问题patch得差不多了，我再等等吧。等1.0正式版，我迁移到Wayland和Wayfire。</p><ol start="4"><li>KDE的平铺选择？</li></ol><p>如果你对平铺操作的要求不太高，那么KDE自带的快捷键差不多就够了，如果要更多功能，推荐<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Jpc211dGgtRm9yZ2UvYmlzbXV0aA==">bismuth<i class="fa fa-external-link-alt"></i></span></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly90Lm1lL0FyY2hDTktERVZTR05PTUU=">迫害GNOME的频道<i class="fa fa-external-link-alt"></i></span> （仅供娱乐）<br><span class="exturl" data-url="aHR0cHM6Ly9pbnZlbnQua2RlLm9yZy9wbGFzbWEva3dpbi8tL21lcmdlX3JlcXVlc3RzLzEwODg=">https://invent.kde.org/plasma/kwin/-/merge_requests/1088<i class="fa fa-external-link-alt"></i></span> KDE在这个Merge移除了XRender混成器<br><span class="exturl" data-url="aHR0cHM6Ly9tYWlsLmtkZS5vcmcvcGlwZXJtYWlsL2t3aW4vMjAyMS1KdW5lLzAwNTIzMi5odG1s">https://mail.kde.org/pipermail/kwin/2021-June/005232.html<i class="fa fa-external-link-alt"></i></span> 讨论移除XRender的邮件列表<br><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2tkZS9jb21tZW50cy9xYW1sZmQvd2FzX3hyZW5kZXJfY29tcG9zaXRvcl9yZW1vdmVkX2luX3BsYXNtYV81MjMv">https://www.reddit.com/r/kde/comments/qamlfd/was_xrender_compositor_removed_in_plasma_523/<i class="fa fa-external-link-alt"></i></span> reddit上的移除XRender受害者（这位是i卡，不是N卡）</p><p>Vulkan<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuZGF2aWRlZG11bmRzb24uY28udWsvYmxvZy9ydW5uaW5nLXBsYXNtYXNoZWxsLXdpdGgtdnVsa2FuLw==">http://blog.davidedmundson.co.uk/blog/running-plasmashell-with-vulkan/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tERS9rd2luL2NvbW1pdC84MTFiZWI5NGUwYTdkZDU2NjY5MDZiMDdhNTFhODRlZmU1ZjFiYjUz">https://github.com/KDE/kwin/commit/811beb94e0a7dd5666906b07a51a84efe5f1bb53<i class="fa fa-external-link-alt"></i></span></p><p>Nvidia的问题（不是很懂为什么移除xrender）<br><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2tkZS9jb21tZW50cy9xc2t2cjEvc2NyZWVuX2ZsaWNrZXJfcHJvYmxlbV93aXRoXzE0NGh6X29uX2tkZV9uZW9uX2FueS8=">https://www.reddit.com/r/kde/comments/qskvr1/screen_flicker_problem_with_144hz_on_kde_neon_any/<i class="fa fa-external-link-alt"></i></span></p><p>i3wm配置参考：</p><p><span class="exturl" data-url="aHR0cHM6Ly96anV5ay5naXRsYWIuaW8vcG9zdHMvaTN3bS1jb25maWcv">I3wm 配置思路<i class="fa fa-external-link-alt"></i></span></p><p>Polybar配置：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkaTEwOTB4L3BvbHliYXItdGhlbWVz">https://github.com/adi1090x/polybar-themes<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这样又将一部分鼠标干的活还给了键盘。&lt;/p&gt;</summary>
    
    
    
    
    <category term="KDE" scheme="https://zhangjk98.xyz/tags/KDE/"/>
    
    <category term="i3wm" scheme="https://zhangjk98.xyz/tags/i3wm/"/>
    
    <category term="kiss" scheme="https://zhangjk98.xyz/tags/kiss/"/>
    
  </entry>
  
  <entry>
    <title>又被Docker坑了（其实是被Yaml坑了</title>
    <link href="https://zhangjk98.xyz/aware-docker-yaml/"/>
    <id>https://zhangjk98.xyz/aware-docker-yaml/</id>
    <published>2021-11-08T11:50:24.000Z</published>
    <updated>2021-11-08T11:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>大聪明yaml将60以下的数字识别成60进制，所以需要用引号括起来。自作聪明程度直追Excel将身份证号识别成科学计数法然后直接末尾四位变零。<br>珍爱生命，远离yaml  </p><p>更新：发现了一个网站：<span class="exturl" data-url="aHR0cHM6Ly9ub3lhbWwuY29tLw==">https://noyaml.com/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大聪明yaml将60以下的数字识别成60进制，所以需要用引号括起来。自作聪明程度直追Excel将身份证号识别成科学计数法然后直接末尾四位变零。&lt;br&gt;珍爱生命，远离yaml  &lt;/p&gt;
&lt;p&gt;更新：发现了一个网站：&lt;span class=&quot;exturl&quot; data-url=</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://zhangjk98.xyz/tags/Docker/"/>
    
    <category term="yaml" scheme="https://zhangjk98.xyz/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>Hackergame 2021 (中科大信安赛) Write Up</title>
    <link href="https://zhangjk98.xyz/hackergame-2021-write-up/"/>
    <id>https://zhangjk98.xyz/hackergame-2021-write-up/</id>
    <published>2021-10-30T04:00:01.000Z</published>
    <updated>2021-10-30T04:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>吃瓜群众第一次参赛，从LUG过来的，打酱油路过，没学过信安和密码学，然而很遗憾，跟Linux有关的那几个题全都没做出来。。。。<br>很意外自己能挤进200名的，事前完全没有准备，也没接触过CTF之类的东西，甚至比赛开始3天，进行到一半了我才突然发现这比赛它已经开始了，如果早知道 p😭q<br>对，今年这个Hackergame就是UTF-8比赛，对萌新可友好了（确信  </p><span id="more"></span><p>周二还在想今年中科大信安赛是不是要开始了，结果一看已经进行一半了，来划个水吧。由于太菜加上懒，math零蛋，只能流下数理基础不扎实的泪水p😭q 。 </p><p>作为一个纯萌新和老废物，第一次参加Hackergame，以前看到他们中科大LUG办的，就想着下次举办去参加一下玩。以前看到好多Web题和有意思的小题目，虽然我js也特别菜，好歹还能挣扎一下。结果几年一打开就是一堆binary糊脸，二进制和逆向pwm之类的完全不懂，罢了，就做点General吧。</p><p>结果？？？？进前200了？</p><p><img src="/hackergame-2021-write-up/image-20211030121230343.png" alt="image-20211030121230343"></p><p>看来Hackergame真的是萌新友好，明年一定再来玩。</p><h2 id="做出了来的的小题目"><a href="#做出了来的的小题目" class="headerlink" title="做出了来的的小题目"></a>做出了来的的小题目</h2><p>还是有不少对我很友好的题目的</p><h3 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h3><blockquote><p>为了能让大家顺利签到，命题组把每一秒的 flag 都记录下来制成了日记本的一页。你只需要打开日记，翻到 Hackergame 2021 比赛进行期间的任何一页就能得到 flag！</p></blockquote><p>打开题目，秒是从1970年开始计算的，这就是UNIX时间戳呗。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">date</span> +%s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<code>1635213339</code>，修改URL后缀，得到<code>flag&#123;HappyHacking2021-b0e5f6c9af&#125;</code>签到成功</p><h3 id="进制十六——参上"><a href="#进制十六——参上" class="headerlink" title="进制十六——参上"></a>进制十六——参上</h3><p>首先我们OCR识别一下</p><pre class="line-numbers language-none"><code class="language-none">456163682068657861646563696D616C20646967697420726570726573656E747320666F75722062697473202862696E61727920646967697473292C20616C736F206B6E6F776E2061732061206E6962626C6520286F72206E7962626C65292C20776869636820697320312F32206F66206120627974652E20666C61677B5930555F5348305531445F6B6E30775F4830575F74305F43306E763372745F4845585F746F5F546578547D20466F72206578616D706C652C20612073696E676C6520627974652063616E20686176652076616C7565732072616E67696E672066726F6D20303030303030303020746F20313131313131313120696E2062696E61727920666F726D2C2077686963682063616E20626520636F6E76656E69656E746C7920726570726573656E74656420617320303020746F20464620696E2068657861646563696D616C2E000000000000000000000000000000000000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个好办，打开Bless Hex Editor之类的Hex编辑器, flag的16进制是<code>66 6C 61 67</code>, 找到相应位置，得到flag为<code>flag&#123;Y0U_SH0U1D_kn0w_H0W_t0_C0nv3rt_HEX_to_TexT&#125;</code></p><h3 id="卖瓜"><a href="#卖瓜" class="headerlink" title="卖瓜"></a>卖瓜</h3><p>F12想直接修改放瓜数量为负是不可以的，我们没有办法放上一个负数或者小数的瓜</p><pre class="line-numbers language-none"><code class="language-none">&lt;p&gt;放上 6 斤的瓜 &lt;input type&#x3D;&quot;number&quot; class&#x3D;&quot;number&quot; name&#x3D;&quot;b6&quot; value&#x3D;&quot;0&quot; min&#x3D;&quot;0&quot;&gt; 个&lt;&#x2F;p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后开始填一个很大的数尝试溢出，果然。</p><p><img src="/hackergame-2021-write-up/image-20211026131723641-16352255218271.png" alt="image-20211026131723641"></p><p>然后就是打开WolframAlpha, 一边算一边试，试出了一个正好二十。</p><h3 id="旅行照片"><a href="#旅行照片" class="headerlink" title="旅行照片"></a>旅行照片</h3><p>一开始没什么头绪，但是看到左下角那个彩色方块的小房子实在是太显眼了，可能是什么地标建筑。我们以图搜图找一下呗。</p><p>Google搜图没有结果，TineEye也没有。算了算了，打开我最讨厌的百度（毕竟这可能是一个国内的位置）</p><p><span class="exturl" data-url="aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcGNwYWdlL3NpbWlsYXI/b3JpZ2luU2lnbj0xMjZjMGQ1YjgyZjIzMmYzMDY5YjkwMTYzNTMxMTc1OSZzcmNwPWNyc19wY19zaW1pbGFyJnRuPXBjJmlkY3RhZz1neiZzaWRzPTEwMDA3XzEwNTEyXzEwNTIxXzEwOTE0XzEwOTEzXzExMDA2XzEwOTI0XzEwOTA1XzEwMDE4XzEwOTAxXzEwOTQyXzEwOTA3XzExMDEyXzEwOTcwXzEwOTY4XzEwOTc0XzExMDMyXzE3ODUxXzE3MDcwXzE4MDEzXzE4MTAxXzE3MjAwXzE3MjAyXzE4MzAxXzE4MzExXzE4MzMwXzE5MzAwXzE5MTkxXzE5MTYyXzE5MjIwXzE5MjEwXzE5MjEyXzE5MjE0XzE5MjE3XzE5MjE5XzE5MjU2XzE5MjMwXzE5MjY4XzE5MjgwXzE5NTUwXzE5NjcwXzEwMDAwJmxvZ2lkPTI0Mzg0MjcwMDgmZW50cmFuY2U9Z2VuZXJhbCZ0cGxfZnJvbT1wYyZwYWdlRnJvbT1ncmFwaF91cGxvYWRfcGNzaGl0dSZpbWFnZT1odHRwOi8vaW1nMS5iYWlkdS5jb20vaXQvdT0zODI1MzQwMjIwLDkyNzYwNTA0NiZmbT0yNTMmYXBwPTEzOCZmPUpQRUc/dz02NDAmaD00ODAmY2Fyb3VzZWw9NTAzJmluZGV4PTEmcGFnZT0xJnNoaXR1VG9rZW49YzkyM2Qz">百度搜图的结果<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcGNwYWdlL3NpbWlsYXI/b3JpZ2luU2lnbj0xMjZjMGQ1YjgyZjIzMmYzMDY5YjkwMTYzNTMxMTc1OSZzcmNwPWNyc19wY19zaW1pbGFyJnRuPXBjJmlkY3RhZz1neiZzaWRzPTEwMDA3XzEwNTEyXzEwNTIxXzEwOTE0XzEwOTEzXzExMDA2XzEwOTI0XzEwOTA1XzEwMDE4XzEwOTAxXzEwOTQyXzEwOTA3XzExMDEyXzEwOTcwXzEwOTY4XzEwOTc0XzExMDMyXzE3ODUxXzE3MDcwXzE4MDEzXzE4MTAxXzE3MjAwXzE3MjAyXzE4MzAxXzE4MzExXzE4MzMwXzE5MzAwXzE5MTkxXzE5MTYyXzE5MjIwXzE5MjEwXzE5MjEyXzE5MjE0XzE5MjE3XzE5MjE5XzE5MjU2XzE5MjMwXzE5MjY4XzE5MjgwXzE5NTUwXzE5NjcwXzEwMDAwJmxvZ2lkPTI0Mzg0MjcwMDgmZW50cmFuY2U9Z2VuZXJhbCZ0cGxfZnJvbT1wYyZwYWdlRnJvbT1ncmFwaF91cGxvYWRfcGNzaGl0dSZpbWFnZT1odHRwOi8vaW1nMi5iYWlkdS5jb20vaXQvdT0zMjUxMjkwNzY1LDE0NjUyMzc0ODkmZm09MjUzJmFwcD0xMzgmZj1KUEVHP3c9MjQ5Jmg9MjQ5JmNhcm91c2VsPTUwMyZpbmRleD01JnBhZ2U9MSZzaGl0dVRva2VuPTlkMDk3OA==">百度搜图的结果<i class="fa fa-external-link-alt"></i></span></p><p>搜到了，是秦皇岛西浴场。这个彩色方块的小房子是海边的救助亭。</p><p>秦皇岛西沙滩，附近有酒店和KFC，而且旁边就是海，应该就是这里了。</p><p>旁边甚至还有一个停车场。和一个秦皇岛国际大酒店（最后根据位置发现酒店应该不是这个）</p><p>然后查找一下周围的KFC（这种事情应该让馒狗来），果不其然有一个网红Tiffany KFC,一群人在小红书打卡。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL2Rpc2NvdmVyeS9pdGVtLzVlOTZjOTE5MDAwMDAwMDAwMTAwNTdjMQ==">https://www.xiaohongshu.com/discovery/item/5e96c91900000000010057c1<i class="fa fa-external-link-alt"></i></span></p><p>高德地图上可以找到电话：0335-7168800</p><p>大众点评的照片上可以看到左侧建筑的三个字为：<strong>海豚馆</strong></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5kaWFucGluZy5jb20vc2hvcC8yNDQzNDA4Nw==">http://www.dianping.com/shop/24434087<i class="fa fa-external-link-alt"></i></span></p><p>从地图上看可能是东南方向，从阳光照射方向看可能是傍晚。</p><p>然后就剩下了楼层数，大概有15、16层左右的样子，随便试几个。结果是16，好的，得到flag</p><h3 id="去吧！追寻自由的电波"><a href="#去吧！追寻自由的电波" class="headerlink" title="去吧！追寻自由的电波"></a>去吧！追寻自由的电波</h3><p>这个是我精通八门乐器的校艺术团室友秒掉的，听了一遍就说修改采样率（大概从48000调到了18000的样子），就可以听到正常的声音了。<br>是一串北约音标字母。</p><p>真好，虽然找不到中科大少年班的神通口算口算RSA，但是我有精通乐理的室友。</p><h3 id="喵咪问答-Pro-Max"><a href="#喵咪问答-Pro-Max" class="headerlink" title="喵咪问答 Pro Max"></a>喵咪问答 Pro Max</h3><p>这个没啥好说的，Google搜就完事了（已经关闭的网站看Web Archive的快照就好了）</p><p>report地址是<code>/dev/null</code>可还行</p><h3 id="图之上的信息"><a href="#图之上的信息" class="headerlink" title="图之上的信息"></a>图之上的信息</h3><p>graphql查询，这个也比较简单，没做什么严格的限制去卡你，直接查就完事了</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    user(id<span class="token operator">:</span><span class="token number">1</span>)<span class="token punctuation">&#123;</span>        username        privateEmail    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>url接口是<code>/graphql?query=&#123;.....&#125;</code>, 会得到一个：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span><span class="token property">"data"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token property">"user"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token property">"username"</span><span class="token operator">:</span><span class="token string">"admin"</span><span class="token punctuation">,</span><span class="token property">"privateEmail"</span><span class="token operator">:</span><span class="token string">"flag&#123;dont_let_graphql_l3ak_data_dad4053dd4@hackergame.ustc&#125;"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>收工。。。</p><h3 id="Amnesia-轻度失忆（第一个flag）"><a href="#Amnesia-轻度失忆（第一个flag）" class="headerlink" title="Amnesia 轻度失忆（第一个flag）"></a>Amnesia 轻度失忆（第一个flag）</h3><blockquote><p>编译后 ELF 文件的 .data 和 .rodata 段会被清零。</p></blockquote><p>唯一整出来的binary题目（避免了binary和math双双爆零的惨状），虽然这个好像也不算binary，更像是在考我编译原理。使劲浑身解数。。。。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;malloc.h></span></span><span class="token keyword">char</span> <span class="token operator">*</span> hello<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    hello <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'H'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'e'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'l'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'l'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'o'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">','</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'w'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'o'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'r'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'l'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'d'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'!'</span><span class="token punctuation">;</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>    <span class="token string">"mov $4,%eax;"</span>    <span class="token string">"mov $1,%ebx;"</span>    <span class="token string">"mov hello ,%ecx;"</span>    <span class="token string">"mov $13,%edx;"</span>    <span class="token string">"int $0x80"</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//free(hello);</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有个小问题是它会内存泄漏，但是想不出什么更好的解答了。</p><h3 id="赛博厨房"><a href="#赛博厨房" class="headerlink" title="赛博厨房"></a>赛博厨房</h3><p>level0 简单，level1 也简单，就是实现一个循环呗。</p><p>剩下两个给我整不会了，人都傻了。</p><h3 id="p😭q"><a href="#p😭q" class="headerlink" title="p😭q"></a>p😭q</h3><p>我也不知道这道题何德何能排在倒数第三个，甚至还有400分的分值。在学了信号与系统、数字信号处理、数字图像处理、生物医学信号处理的我看来，这应该属于送分题。（不过之前都是用matlab做的，python的库都没用过）</p><p>先将gif每一帧转成图像再转成numpy的array再转成一维数组得到功率谱，傅立叶反变换回去得到音频信号……</p><p>等等。。。。它只有功率谱的幅度没有相位信息我可怎么恢复。难道要我猜一个相位吗？</p><p>搜了一下librosa，有一个自带的恢复库，用的是一个迭代估计的算法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token punctuation">,</span> ImageSequence<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> librosa<span class="token keyword">import</span> soundfile <span class="token keyword">as</span> sfsample_rate <span class="token operator">=</span> <span class="token number">22050</span>num_freqs <span class="token operator">=</span> <span class="token number">32</span>quantize <span class="token operator">=</span> <span class="token number">2</span>min_db <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">60</span>max_db <span class="token operator">=</span> <span class="token number">30</span>fft_window_size <span class="token operator">=</span> <span class="token number">2048</span>frame_step_size <span class="token operator">=</span> <span class="token number">512</span>window_function_type <span class="token operator">=</span> <span class="token string">'hann'</span>im <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'flag.gif'</span><span class="token punctuation">)</span><span class="token builtin">iter</span> <span class="token operator">=</span> ImageSequence<span class="token punctuation">.</span>Iterator<span class="token punctuation">(</span>im<span class="token punctuation">)</span>index <span class="token operator">=</span> <span class="token number">1</span>spec <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">for</span> frame <span class="token keyword">in</span> <span class="token builtin">iter</span><span class="token punctuation">:</span>    <span class="token comment"># print("image %d: mode %s, size %s" % (index, frame.mode, frame.size))</span>    frame<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">"./imgs/frame%d.png"</span> <span class="token operator">%</span> index<span class="token punctuation">)</span>    index <span class="token operator">+=</span> <span class="token number">1</span>    image_arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>frame<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">)</span>    image_list <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>image_arr<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># print(image_list)</span>    image_list <span class="token operator">=</span> image_list<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>    <span class="token comment"># print(image_list)</span>    <span class="token comment"># print(image_list.shape)</span>    spec <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">(</span>spec<span class="token punctuation">,</span> image_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>spec<span class="token punctuation">)</span>np<span class="token punctuation">.</span>savetxt<span class="token punctuation">(</span><span class="token string">'output1.txt'</span><span class="token punctuation">,</span> spec<span class="token punctuation">,</span> fmt<span class="token operator">=</span><span class="token string">"%d"</span><span class="token punctuation">)</span>spec <span class="token operator">=</span> np<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>spec<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>melspectrogram <span class="token operator">=</span> librosa<span class="token punctuation">.</span>db_to_power<span class="token punctuation">(</span>spec<span class="token punctuation">.</span>T<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token comment"># print(melspectrogram.shape)</span>audio_signal <span class="token operator">=</span> librosa<span class="token punctuation">.</span>feature<span class="token punctuation">.</span>inverse<span class="token punctuation">.</span>mel_to_audio<span class="token punctuation">(</span>    melspectrogram<span class="token punctuation">,</span>    n_iter<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span>    sr<span class="token operator">=</span>sample_rate<span class="token punctuation">,</span>    n_fft<span class="token operator">=</span>fft_window_size<span class="token punctuation">,</span>    hop_length<span class="token operator">=</span>frame_step_size<span class="token punctuation">,</span>    window<span class="token operator">=</span>window_function_type<span class="token punctuation">)</span><span class="token comment"># print(audio_signal, audio_signal.shape)</span>sf<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'test.wav'</span><span class="token punctuation">,</span> audio_signal<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好的，秒了。（怎么有种回到本科写课堂作业的感觉）</p><p>声音是有了，但是这个相位好像还是不太对的样子。我超，回声不绝于耳。。。</p><p>调一下参数，让他多迭代几轮<code>n_iter=8192,</code>，行了，现在清晰度有个高中大喇叭放英语早读听力的样子。</p><p><strong>衬衫的价格是九磅十五便士，现在你有十秒钟时间，将Flag填到输入框上</strong>…….</p><h2 id="看起来有点头绪但是没做的题目"><a href="#看起来有点头绪但是没做的题目" class="headerlink" title="看起来有点头绪但是没做的题目"></a>看起来有点头绪但是没做的题目</h2><p>懒癌又犯了，周六休息一会，周五天气太好了，还有其他事情要做，算了</p><h3 id="Easy-RSA"><a href="#Easy-RSA" class="headerlink" title="Easy RSA"></a>Easy RSA</h3><p>由于我找不到中科大少年班的神通，而我自己的数论还停留在高中水平（当年数竞还过了校队选拔，然后上来就听了好几节数论和组合，直接退出了（后悔，现在就是非常后悔））</p><p>只能找山大网安的大二学弟来帮帮我看看这个密码学的问题，问问这种形式该怎么解(已知n, p, q, c)</p><p>$$<br>a^n mod(p*q) &#x3D; c<br>$$</p><p>他当场就给我秒了，还随手写了3页。</p><p>然后问题是怎么跑出这个p来，这次学弟也没什么好办法了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span>    y <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span>    value_p <span class="token operator">=</span> sympy<span class="token punctuation">.</span>nextprime<span class="token punctuation">(</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>factorial<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span>                              x<span class="token punctuation">)</span>  <span class="token comment"># Hint：这里直接计算会溢出，请你仔细观察 x 和 y 的特征</span>    <span class="token keyword">return</span> value_p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一开始我是这样跑的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span>y <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token operator">*</span>i<span class="token punctuation">)</span> <span class="token operator">%</span> x    <span class="token comment"># print(sum)</span>    <span class="token keyword">if</span> <span class="token builtin">sum</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sum的值是"</span><span class="token punctuation">,</span> <span class="token builtin">sum</span><span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sum的值是"</span><span class="token punctuation">,</span> <span class="token builtin">sum</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果一跑就是一天，看到我的5600g只有1个CPU在跑，我决定整个multiprocessing（本来想用Golang整一个，但是Golang的数值计算库不太行，还得去用那个难用的<code>math/big</code>包）</p><p>结果再次发现，甚至上了multiprocessing，反而更慢了。</p><p>于是我决定搜一下，结果就找到了这个网站的两种算法：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvY29tcHV0ZS1uLXVuZGVyLW1vZHVsby1wLw==">Compute n! under modulo p<i class="fa fa-external-link-alt"></i></span></p><p>哦，有个复杂度$O((p-n)*Logn)$的算法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Python3 program to comput</span><span class="token comment"># n! % p using Wilson's Theorem</span><span class="token comment"># Utility function to do modular</span><span class="token comment"># exponentiation. It returns (x^y) % p</span><span class="token keyword">def</span> <span class="token function">power</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># Initialize result</span>    x <span class="token operator">=</span> x <span class="token operator">%</span> p  <span class="token comment"># Update x if it is more</span>    <span class="token comment"># than or equal to p</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>y <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># If y is odd, multiply</span>        <span class="token comment"># x with result</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">%</span> p        <span class="token comment"># y must be even now</span>        y <span class="token operator">=</span> y <span class="token operator">>></span> <span class="token number">1</span>  <span class="token comment"># y = y/2</span>        x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">%</span> p    <span class="token keyword">return</span> res<span class="token comment"># Function to find modular inverse</span><span class="token comment"># of a under modulo p using Fermat's</span><span class="token comment"># method. Assumption: p is prime</span><span class="token keyword">def</span> <span class="token function">modInverse</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> power<span class="token punctuation">(</span>a<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token comment"># Returns n! % p using</span><span class="token comment"># Wilson's Theorem</span><span class="token keyword">def</span> <span class="token function">modFact</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># n! % p is 0 if n >= p</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token comment"># Initialize result as (p-1)!</span>    <span class="token comment"># which is -1 or (p-1)</span>    res <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># Multiply modulo inverse of</span>    <span class="token comment"># all numbers from (n+1) to p</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> modInverse<span class="token punctuation">(</span>i<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> p    <span class="token keyword">return</span> res<span class="token comment"># Driver code</span>x <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span>y <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span><span class="token comment"># y = 10</span>n <span class="token operator">=</span> yp <span class="token operator">=</span> x<span class="token keyword">print</span><span class="token punctuation">(</span>modFact<span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># This code is contributed by ihritik</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>只用了1分钟</strong>就跑了出来。这算法好强！</p><p>我把这个做法发给学弟，学弟表示：</p><p>“可以，回头我看看”<br>“<strong>我比较关心这个是怎么构造出来和怎么证明的</strong>”<br>“<strong>初等数论比较巧妙</strong>”<br>“<strong>可以看一下</strong>”  </p><p>听完学弟的话，接下来的内容我不太想做了。<br>我这样数理基础不扎实的菜狗（尤其是数论，一窍不通），做出来也<strong>改变不了我是个数论白痴的事实</strong>。都是些trival的东西了，<strong>有这个时间折腾这些应该去系统的补习一下数论</strong>。</p><h3 id="拼多多砍一刀"><a href="#拼多多砍一刀" class="headerlink" title="拼多多砍一刀"></a>拼多多砍一刀</h3><p>FLAG 助力大红包，这个东西应该挂一个爬虫代理池能做。但是这个方法好像太暴力了点，而且我不想再爬东西了，免费的那几个IP池都不太好用，要钱的又不想掏钱。</p><h3 id="minecraft"><a href="#minecraft" class="headerlink" title="minecraft"></a>minecraft</h3><p>随便乱走亮了两盏灯，还有一盏。看起来应该F12找找线索，有一个flag.js的东西，但是它一堆16进制的变量和函数名，看起来挺费劲，算了，不看了。</p><h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>应该就是根据奇偶校验和他给的打码过程的那个python文件。上一次做二维码和奇偶校验的东西还是大二上数字电路的时候。</p><p>看起来像是第十版二维码，结果打开qrazybox想手动修复一下最高只有ver.9</p><p>然后写了十几行发现好像这个东西要枚举遍历？？可能的二维码团还不止一种。（不知道是不是我漏了什么条件，但看起来还原出来确实不止一种）</p><p>周五周六天气真好，成都难得出太阳，不做了，出去玩。</p><h2 id="以为会做然而被乱杀到怀疑人生的题"><a href="#以为会做然而被乱杀到怀疑人生的题" class="headerlink" title="以为会做然而被乱杀到怀疑人生的题"></a>以为会做然而被乱杀到怀疑人生的题</h2><h3 id="Amnsia记忆清除"><a href="#Amnsia记忆清除" class="headerlink" title="Amnsia记忆清除"></a>Amnsia记忆清除</h3><p>抹除掉ELF文件的<code>.text</code>段，完全不会</p><h3 id="LUKS"><a href="#LUKS" class="headerlink" title="LUKS"></a>LUKS</h3><p>就觉得我这么长时间的Linux白用了，整不出来。我只会hashcat爆破，Hashcat爆破又没啥意思，算了，放弃。</p><h3 id="RAID修复"><a href="#RAID修复" class="headerlink" title="RAID修复"></a>RAID修复</h3><p>文件系统白学了，直接不会，白给。RAID-0做不出来，RAID-5也做不出来。</p><h3 id="赛博厨房后两问"><a href="#赛博厨房后两问" class="headerlink" title="赛博厨房后两问"></a>赛博厨房后两问</h3><p>直接人都傻了，找不到规律，根本找不到。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在是周六中午12点，总排名187&#x2F;2679，很幸运没有掉出200名。</p><blockquote><p>当前分数：1600， 总排名：187 &#x2F; 2679<br>binary：150 ， general：1050 ， math：0 ， web：400</p></blockquote><p>今年是第一次参见Hackergame，玩的很开心。binary的题比往年多了很多，不过我一个都不会，好在有个打印<code>Hello, world!</code>的题，很幸运没有爆零。  </p><p>当然，general和web题还是给了我一点信心，让我有种我上我也行的感觉，不过打开排行榜看到mcfx乱秒的样子，嗯，我是傻逼。</p><p>主要感想就是数理基础太差，数论是真的是一窍不通，这几个月正好有空，准备去恶补一下数学。    </p><p>当然进前100名和CTF师傅们以及天神下凡的mcfx合影留念是无望了，明年再来玩耍吧。欢度周末去了，再见。   </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;吃瓜群众第一次参赛，从LUG过来的，打酱油路过，没学过信安和密码学，然而很遗憾，跟Linux有关的那几个题全都没做出来。。。。&lt;br&gt;很意外自己能挤进200名的，事前完全没有准备，也没接触过CTF之类的东西，甚至比赛开始3天，进行到一半了我才突然发现这比赛它已经开始了，如果早知道 p😭q&lt;br&gt;对，今年这个Hackergame就是UTF-8比赛，对萌新可友好了（确信  &lt;/p&gt;</summary>
    
    
    
    <category term="不务正业系列" scheme="https://zhangjk98.xyz/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="hackergame" scheme="https://zhangjk98.xyz/tags/hackergame/"/>
    
    <category term="UTF-8" scheme="https://zhangjk98.xyz/tags/UTF-8/"/>
    
  </entry>
  
  <entry>
    <title>VSCode Neovim插件配置——将VSCode作为Neovim的GUI客户端</title>
    <link href="https://zhangjk98.xyz/vscode-neovim-setting/"/>
    <id>https://zhangjk98.xyz/vscode-neovim-setting/</id>
    <published>2021-10-29T16:00:00.000Z</published>
    <updated>2021-10-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本来不报希望的试了试这套不伦不类的缝合怪配置，结果缝合出了很好的效果，可以拿这套配置在VSCode下养老了。</p><span id="more"></span><p>VSCodevim这个插件和原生Vim的体验差距很大，Vim的很多操作都不支持，而且大文件会特别卡。VSCode Neovim这个插件是在Insert模式几乎和正常的VSCode编辑一样，在Normal模式有满血的Vim体验（不像VSCodevim那样是体验是残血的，只是一个Vim键位和操作的模拟器）</p><p>这个插件直接将Neovim作为后端，在Normal模式下由Neovim控制（直接将内容缓存发往Neovim处理），可以使用Vim的各种键位操作<br>在Insert模式下，操作和渲染由VSCode处理，编辑体验几乎和VSCode完全一致。色彩高亮和代码补全等都由VSCode实现（所以不要装Neovim的LSP等插件，没用，而且可能影响速度）当你保存的时候更改会从VSCode同步到Neovim。  </p><p>VSCode在编辑模式下的舒服体验和插件、Vim在Normal模式下的操作，同时得到了保留，而且性能和速度还可以接受。</p><p>与其说这是VSCode的一个Vim键位插件，不如说是将VSCode直接改造成了Neovim的一个GUI客户端。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>VSCode插件市场装VSCode Neovim，安装neovim<code>sudo pacman -S neovim</code><br>然后在设置里面填上路径</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"vscode-neovim.neovimExecutablePaths.linux"</span><span class="token operator">:</span> <span class="token string">"/usr/bin/nvim"</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以用了</p><h2 id="中文输入法和Neovim插件Normal模式下冲突"><a href="#中文输入法和Neovim插件Normal模式下冲突" class="headerlink" title="中文输入法和Neovim插件Normal模式下冲突"></a>中文输入法和Neovim插件Normal模式下冲突</h2><p>VSCode的Neovim插件在Normal模式下，如果fcitx5等输入法处于中文模式，那么输入的字符会被输入法全部捕获（就像平时在VSCode里打字一样）</p><p>ArchWiki 给出了下面这种方法，试了一下速度比较慢</p><pre class="line-numbers language-vimrc" data-language="vimrc"><code class="language-vimrc">autocmd InsertLeave * :silent !fcitx5-remote -c &quot; 退出插入模式时禁用输入法autocmd BufCreate *  :silent !fcitx5-remote -c &quot; 创建 Buf 时禁用输入法autocmd BufEnter *  :silent !fcitx5-remote -c &quot; 进入 Buf 时禁用输入法autocmd BufLeave *  :silent !fcitx5-remote -c &quot; 离开 Buf 时禁用输入法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>比较快的方法是装插件，比如依云的fcitx.vim插件，但是这个插件在neovim下面好像没有效果。</p><p>本来想自己移植一个neovim的插件的，但是看了一下已经有人干了：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2gtaGcvZmNpdHgubnZpbS5naXQ=">fcitx.nvim<i class="fa fa-external-link-alt"></i></span></p><p>我用的vim-plug管理插件，放到<code>~/.config/nvim/init.vim</code>下面就可以了</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">call</span> plug#<span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>Plug <span class="token string">'https://github.com/h-hg/fcitx.nvim.git'</span><span class="token keyword">call</span> plug#<span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="一些按键绑定设置"><a href="#一些按键绑定设置" class="headerlink" title="一些按键绑定设置"></a>一些按键绑定设置</h2><p>首先我不要hjkl这几个上下左右键（根本无法接受，我的肌肉记忆明明是键盘上上下左右四个经典方向键，玩空洞骑士和Ballance用的极其熟练，其次是WASD这个4399键位，其次是鼠标，我鼠标可熟练了）<br>我知道hjkl移动距离短而且移动后方便按距离近的i键进入Insert模式，但是我的肌肉记忆是上下左右，你再给我十年我也改不过来。</p><p>然后我将Casplock映射为ESC，这个万年不用的键放在这么重要的位置还有一个比Tab键还大的键帽，简直浪费。编辑<code>～/Xmodmap</code>修改键盘映射就可以了。</p><p>或者如果喜欢也可以将<code>jj</code>（连按两次）绑定成ESC<code>inoremap jj &lt;Esc&gt;</code>^&#96;</p><p>然后是VSCode里面正常的<code>Ctrl+F</code>当前搜索，这个我们找回来（<code>Ctrl+F</code>在Vim里是向上翻页，我完全用不到，我用PgDn和PgUp）</p><p>然后是VSCode的<code>Ctrl+B</code>展开&#x2F;收起侧边栏，这个我也留着VSCode的设置。</p><p>编辑<code>~/.config/Code/User/keybindings.json</code></p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>        <span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"ctrl+f"</span><span class="token punctuation">,</span>        <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"-vscode-neovim.escape"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>        <span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"ctrl+b"</span><span class="token punctuation">,</span>        <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"-vscode-neovim.escape"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token punctuation">&#123;</span>        <span class="token property">"key"</span><span class="token operator">:</span> <span class="token string">"ctrl+a"</span><span class="token punctuation">,</span>        <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"-vscode-neovim.escape"</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制和粘贴我大部分时间直接用linux下x默认的鼠标点击和中键。但是全选等操作的时候我还是习惯<code>Ctrl-A</code>加<code>Ctrl-C</code></p><p>偶尔使用<code>Ctrl-C</code>的人，把<code>Ctrl-C</code>和<code>Ctrl-A</code>找回来还是有必要的，偶尔在<code>insert</code>模式下<code>Ctrl-C</code>会进入normal模式，<code>Ctrl-A</code>会输入<code>。sd</code>，很烦。</p><p>所以我也直接在json设置里面排除了<code>Ctrl-A</code>。ps：如果你想使用mswin.vim那样在neovim里面绑定，那可能会报错<code>nvim_call_function: Vim(let):E684: list index out of range: 0</code>。注意在Neovim的扩展设置里面（Keyboard shortcuts）删掉<code>Ctrl+A</code></p><p>然后在<code>settings.json</code>中设置</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"vscode-neovim.useCtrlKeysForInsertMode"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token property">"vscode-neovim.useCtrlKeysForNormalMode"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这样就基本上把Ctrl的功能还给VSCode了。</p><h2 id="Neovim插件默认instert模式"><a href="#Neovim插件默认instert模式" class="headerlink" title="Neovim插件默认instert模式"></a>Neovim插件默认instert模式</h2><p>这个样子平时就像正常使用VSCode一样，当用到normal mode的功能时才打开normal mode，可以少按很多次i</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">if</span> <span class="token function">has</span><span class="token punctuation">(</span><span class="token string">'nvim'</span><span class="token punctuation">)</span>    <span class="token builtin">autocmd</span> TermOpen <span class="token builtin">term</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">*</span> <span class="token keyword">startinsert</span><span class="token keyword">endif</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="在使用VSCode时选择性启用Neovim插件"><a href="#在使用VSCode时选择性启用Neovim插件" class="headerlink" title="在使用VSCode时选择性启用Neovim插件"></a>在使用VSCode时选择性启用Neovim插件</h2><p>Vim&#x2F;Neovim的插件和VSCode的插件有功能重叠，我目前各选了一部分。目前我的LSP插件用VSCode的插件，其他像Markdown插件、LaTeX插件和各种杂七杂八不常用的功能也都是用的VSCode插件。我装了EasyMotion的替代品MetaJump（VSCode插件），用于进行跳转。Neovim插件我保留了<code>vim-surround</code>等键盘操作的插件。</p><p>但是很多时候我要在终端用Neovim的时候要启用一些插件，使用VSCode的时候要禁用Neovim部分插件。</p><p>推荐按照官方文档在使用VSCode时禁用Neovim的自动补全、LSP类、语法高亮等插件</p><blockquote><p>You don’t need any code, highlighting, completion, lsp plugins as well any plugins that spawn windows&#x2F;buffers (nerdtree and similar), fuzzy-finders, etc.</p></blockquote><p>具体参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZzY29kZS1uZW92aW0vdnNjb2RlLW5lb3ZpbSNjb25kaXRpb25hbC1pbml0dmlt">官方文档<i class="fa fa-external-link-alt"></i></span>, 我用的vim-plug可以这样设置</p><pre class="line-numbers language-none"><code class="language-none">&quot; inside plug#begin:&quot; 在使用neovim的时候启用vim-easymotion插件Plug &#39;easymotion&#x2F;vim-easymotion&#39;, Cond(!exists(&#39;g:vscode&#39;))&quot; 在vscode-neovim插件模式下启用另一个插件Plug &#39;asvetliakov&#x2F;vim-easymotion&#39;, Cond(exists(&#39;g:vscode&#39;), &#123; &#39;as&#39;: &#39;vsc-easymotion&#39; &#125;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不过后来我的画风逐渐变成了这样：<br>Neovim专心给vscode当backend用，terminal里面用vim，这样就不用管插件何时启用了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>之前只在编辑小文件的时候临时用Vim, 这两年内Vim使用次数逐渐增多，Vim也逐渐熟练，一度产生过将主力编辑器从VSCode换成Vim的想法。VSCode在Linux平台上频繁内存泄漏、VSCode的渲染速度比Vim慢很多（尤其是打开大文件的时候），这些原因导致VSCode在某些时候的体验比Vim差了好多。</p><p>但是Vim我没有找到合适的GUI界面来打造一个对我而言比较舒服的编辑器，gvim在当年上嵌入式课的时候在Ubuntu下就试过一次了，感觉体验不是很好。</p><p>SpaceVim试过，装了一堆插件之后太卡，性能不是太好，性能表现几乎和VSCode不相上下，在我的超低配七年老电脑上失去了Vim流畅的优势，而且这一套界面的颜值和使用体验远不如VSCode。</p><p>Neovim的GUI界面有<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FraXlvc2kvZ29uZW92aW0=">goneovim<i class="fa fa-external-link-alt"></i></span>和neovide，体验也不如VSCode。（go居然能拿来写Qt还写成这种样子，哇偶）</p><p>最舒服的Vim体验还是在Alacritty里面，GPU加速渲染速度很快，非常丝滑。</p><p>而且VSCode在我从18年开始使用它的三年内，肉眼可见的进步。未来的前景也很光明，微软掏钱养着也不用担心倒闭的问题，除非微软倒闭（真倒闭了那不是更好吗，还有这种好事，苏联笑话.jpg）<br>现在我除了要写一万行以上的屎山项目才会打开Goland等全家桶IDE，编辑100行以下的配置文件等会打开vim。<br>剩下的绝大多数编辑都是用VSCode,用VSCode来写Go、C、Python、shell，用VSCode来写Markdown和LaTeX, 逐渐抛弃了typora和Word，也放弃了曾经很喜欢的sublime text（但是这个好看、比VSCode丝滑，VSCode的渲染和响应速度没有那种丝滑的感觉）</p><h3 id="2022-4更新"><a href="#2022-4更新" class="headerlink" title="2022.4更新"></a>2022.4更新</h3><p>用VSCode Neovim插件半年了，多多少少有点小bug，偶尔出现一些光标不灵和Neovim后端没有启动的小问题。大部分时候reload一下就好了。大多数时候编辑小文件的体验都是alacritty中打开vim更好，打开速度飞快而且打字延迟低、渲染都比VSCode舒服。但是vim&#x2F;neovim要想配置出vscode&#x2F;sublime写大一点的项目的工作界面来比较麻烦，所以大多数时间还在用VSCode，没啥迁移的动力。</p><p>用久了发现VSCode的很多图形界面实在没有必要，很多边框和按钮基本用不到还占地方那个。比如最上面的边框（用i3wm等wm不要边框就好了），然后是那个<code>Menu Bar</code>，用鼠标点<code>Menu Bar</code>是很浪费时间的，建议隐藏了。需要进行什么操作建议<code>F1</code>搜索，比拿鼠标点点点舒服。</p><p>然后比较讨厌的的是下方terminal和编辑界面中间宽大的框，左侧边栏（Side Bar）也特别宽（这个间距还不能调，只能<code>Ctrl+“-“</code>进行zoom缩放变相调小）。这个特别难受，当时我刚用VSCode的时候我就觉得VSCode的界面比sublime和jetbrains家的IDE浪费空间好多。</p><p>这个极为浪费空间的UI布局就像新版firefox的proton和新版gnome的移动平板风格，太讨厌了。大概就是这个对比的感觉：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JsYWNrNzM3NS9GaXJlZm94LVVJLUZpeA==">Firefox-UI-Fix<i class="fa fa-external-link-alt"></i></span>  </p><p>我最早一直看VSCode的界面不顺眼，换上atom或者sublime的主题也不行。后来想了很久这是为什么，最后发现就是这个布局太不紧凑了，太浪费空间了。<br>我心目中好的界面是像大部分QT应用那样的，虽然第一眼颜值没有electron高，但是紧凑高效。比如WPS、Photoshop、Krita这样的，没有特别宽的没用边框出来浪费空间。AutoCAD、Altium Designer和JB家的编辑器也比较紧凑。就连VSCode的竞品atom和sublime也远比VSCode紧凑。</p><p>不过我在找VSCode紧凑布局的办法的时候，发现VSCode有像Vim差不多的 Zen Mode，<code>Ctrl+k z</code>切换为禅意模式，临时进入一个全屏的清爽的编辑界面，默认只有一个居中的编辑界面。有点像typora的全屏+专注模式，感觉还行。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYWhvbm4ubWUvYmxvZy90aGUtdmltLWd1aWRlLWZvci12cy1jb2RlLXVzZXJz">从VSCode到Vim到……两个都用？<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhaXBlaWh1c3QvaW0tc2VsZWN0I2luc3RhbGxhdGlvbg==">https://github.com/daipeihust/im-select#installation<i class="fa fa-external-link-alt"></i></span> Windows和Mac以及使用vscodevim插件用户可以用这个解决中文输入法冲突的问题<br><span class="exturl" data-url="aHR0cHM6Ly9kZGFkYWFsLm1lL2FydGljbGVzL2Zyb20tdnNjb2RlLXRvLXZpbS10by1ib3Ro">https://ddadaal.me/articles/from-vscode-to-vim-to-both<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9qZGhhby5naXRodWIuaW8vMjAyMC8wMS8xMi92aW1fbnZpbV9oaXN0b3J5X2RldmVsb3BtZW50Lw==">Vim 和 Neovim 的前世今生<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hYzczOWM2ZWE1NDE=">vscode 集成 Neovim<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1nNGRYWjBSUVdkdw==">VSCode with embedded Neovim<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dsZXBuaXIvbnZpbS1sdWEtZ3VpZGUtemg=">在 neovim 中使用 Lua<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ZzY29kZS1uZW92aW0vdnNjb2RlLW5lb3ZpbQ==">vscode-neovim<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVuYXJ2aW0ub3JnLw==">LunarVim<i class="fa fa-external-link-alt"></i></span> 这个项目不错，从这学了不少Neovim的配置<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVuYXJ2aW0ub3JnL3BsdWdpbnMvI2NvbmZpZ3VyYXRpb24=">LunarVim Core plugins<i class="fa fa-external-link-alt"></i></span> 这里面的插件质量都还不错，挑几个拿过来用挺好的<br><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1jdEgtYS0xZVVNRQ==">Neovim IDE from Scratch - Introduction (100% lua config)<i class="fa fa-external-link-alt"></i></span> LunarVim作者的教程<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0x1bmFyVmltL05lb3ZpbS1mcm9tLXNjcmF0Y2g=">Neovim from Scratch<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本来不报希望的试了试这套不伦不类的缝合怪配置，结果缝合出了很好的效果，可以拿这套配置在VSCode下养老了。&lt;/p&gt;</summary>
    
    
    
    <category term="不务正业系列" scheme="https://zhangjk98.xyz/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="VSCode" scheme="https://zhangjk98.xyz/tags/VSCode/"/>
    
    <category term="Neovim" scheme="https://zhangjk98.xyz/tags/Neovim/"/>
    
    <category term="Vim" scheme="https://zhangjk98.xyz/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Archlinux下VSCode+Latex+Zotero的论文写作方案</title>
    <link href="https://zhangjk98.xyz/paper-with-latex-zotero-vscode/"/>
    <id>https://zhangjk98.xyz/paper-with-latex-zotero-vscode/</id>
    <published>2021-09-24T10:44:24.000Z</published>
    <updated>2021-09-24T10:44:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>开源拖拉机将就着用吧，又不是不能用，再见Word、EndNote和Windows。顺便说一下你电的LaTeX模板怎么用。不定期更新到毕业。</p><span id="more"></span><p>又遇到了Lamport老爷子的东西，上一次看到Lamport<del>还是上次</del>还是看Paxos算法的时候。</p><p>Office很强，但是微软不给Linux开发桌面版（好吧，我有在线的教育版，在线版写写文档还行，但是排版有一些捉襟见肘）。好吧，虚拟机或者wine是可以的但是我不想用。wps的Linux版倒是很不错，但是调格式放到office上又乱了，对数学公式的支持也不是特别好。<br>另一个让我放弃word和wps的重要原因是我想要用git做版本控制，手动命名一个个v0.0.8、v0.2.1版本的论文初稿实在是太蠢了。<br>最近放弃WPS的原因是新版本实在太糊了，我在Archlinux上试图降级旧版又失败了。本来以为新版WPS字体模糊是因为没有配适4k分辨率的屏幕，这个文章<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTU5OTM1NzY=">WPS For Linux个人版更新（Qt5版本）<i class="fa fa-external-link-alt"></i></span>的评论去也确实是这么说的。结果我打开1080p的笔记本，发现字体更糊了。<br>overleaf应该是我用过最好用的Latex在线编辑，但是我对在线的东西不是很信得过。TexStudio又不是太好看，高分屏下还比较糊，键位也不习惯，放弃了。lyx是很好用，但是我不太喜欢所见即所得，还是习惯左边源码右边编辑结果pdf这种。  </p><p>最终又回到了VSCode，目前的方案是ArchLinux下Zotero+textlive+VSCode（LaTeX Workshop插件）</p><h2 id="安装texlive"><a href="#安装texlive" class="headerlink" title="安装texlive"></a>安装texlive</h2><p>我用对中文支持比较好的xelatex，在Arch下我们装texlive的包就可以了。pdflatex也包含在里面，但是这个对中文支持没有那么好，一般用xelatex生成中文pdf。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S texlive-core texlive-langchinese  texlive-fontsextra<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>texlive的不少宏包在Arch上都有系统的包，你可以用<code>yay</code>等AUR helper装，如果想用<code>tlmgr</code>装，那就用<span class="exturl" data-url="aHR0cHM6Ly9hdXIuYXJjaGxpbnV4Lm9yZy9wYWNrYWdlcy90bGxvY2FsbWdyLWdpdC8=">tllocalmgr-git<i class="fa fa-external-link-alt"></i></span>这个AUR包。</p><h2 id="Zotero配置"><a href="#Zotero配置" class="headerlink" title="Zotero配置"></a>Zotero配置</h2><h3 id="参考文献抓取和管理"><a href="#参考文献抓取和管理" class="headerlink" title="参考文献抓取和管理"></a>参考文献抓取和管理</h3><p>首先是中文论文网站引用和pdf抓取的问题，可以用下面这个插件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2wwbzAvdHJhbnNsYXRvcnNfQ04=">Zotero translators 中文维护小组<i class="fa fa-external-link-alt"></i></span></p><p>知网文献可以用这个插件：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2wwbzAvamFzbWludW0=">jasminum<i class="fa fa-external-link-alt"></i></span></p><p>下载并放到translater文件夹中(Linux下默认应该是<code>~/Zotero/translators</code>)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/l0o0/translators_CN.git <span class="token function">cp</span> -r translators_CN/translators/* ~/Zotero/translators<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参照README更新插件的translater就行了。</p><p>VSCode有一个Zotero LaTeX插件，可以用快捷键直接插入文献。安装后报错<code>Error adding citation: HTTPError: Response code 404 (Not Found)</code>，见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21ibG9kZS92c2NvZGUtem90ZXJvL2lzc3Vlcy8y">Zotero Citations: could not connect to<i class="fa fa-external-link-alt"></i></span>。安装beta版本后成功解决。<code>yay -S zotero-beta</code></p><p>使用这个插件需要安装zotero插件<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JldG9ycXVlcmUvem90ZXJvLWJldHRlci1iaWJ0ZXg=">zotero-better-bibtex<i class="fa fa-external-link-alt"></i></span></p><p>具体使用请参考：<span class="exturl" data-url="aHR0cDovL3h1Z2VlLmNvbS9pbWFnZXMvMy8zYS9WU2NvZGUlRTQlQkQlQkYlRTclOTQlQTglRTglQUYlQjQlRTYlOTglOEUucGRm">VScode使用说明(Zotero插件) 刘再华<i class="fa fa-external-link-alt"></i></span></p><p>安装好之后按<code>Alt+z</code>就可以方便的插入参考文献了。</p><p>然后要插入GB&#x2F;T 7714格式化的参考文献，可以参考<span class="exturl" data-url="aHR0cHM6Ly9jdGFuLm1hdGguaWxsaW5vaXMuZWR1L21hY3Jvcy9sYXRleC9jb250cmliL2JpYmxhdGV4LWNvbnRyaWIvYmlibGF0ZXgtZ2I3NzE0LTIwMTUvYmlibGF0ZXgtZ2I3NzE0LTIwMTUucGRm">符合 GB&#x2F;T 7714-2015 标准的 biblatex 参考文献样式<i class="fa fa-external-link-alt"></i></span></p><p>有模板可以直接套模板，模板应该会处理参考文献格式。没有特殊喜好可以用 等支持GB&#x2F;T格式的模板。</p><p>ps：如果单纯为了插入GB&#x2F;T格式的参考文献可以用一点脏办法: <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDE4MDU3MDQ=">电子科技大学LaTeX模板参考文献问题解决<i class="fa fa-external-link-alt"></i></span> (不得已的办法)</p><h3 id="自建同步"><a href="#自建同步" class="headerlink" title="自建同步"></a>自建同步</h3><p>Zotero的文件同步免费的只有300M，而且很慢。</p><p>我们可以自建文件同步，只要支持WebDAV协议就行了。这个好办，Nginx就能做到。</p><h2 id="VSCode配置"><a href="#VSCode配置" class="headerlink" title="VSCode配置"></a>VSCode配置</h2><h3 id="LaTex插件选择"><a href="#LaTex插件选择" class="headerlink" title="LaTex插件选择"></a>LaTex插件选择</h3><p>通常推荐装Latex Workshop这个插件。配置可以参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phbWVzLVl1L0xhVGVYLVdvcmtzaG9wL3dpa2k=">官方文档<i class="fa fa-external-link-alt"></i></span>, wiki写的很全。功能当然没有TeXStudio全，但是已经满足我的日常需求了（一般只装这一个插件就够了）</p><p>另一个插件叫LaTeX。LaTeX Workshop功能比LaTeX插件多一点，如果只想把VSCode当一个普通的文本编辑器不想要额外的snippet等功能的话，装LaTeX这个插件就可以了。</p><h4 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h4><p>编译配置推荐使用<code>latexmk</code>的方案，可以省去xelatex-bibtex-xelatex*2的多次编译。  </p><p>比如你电的毕业论文模板，完整的编译需要</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xelatex main.texbibtex main.auxbibtex accomplish.auxxelatex main.texxelatex main.tex<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译的时候需要先latexmk编译一遍，再bibtex编译一遍，再latexmk编译一遍，见<a href="https://liam.page/2016/01/23/using-bibtex-to-generate-reference/"></a></p><p>或者参考这篇文章：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjk5MzgwMDc=">我们该如何优雅地使用LaTeX in 2020<i class="fa fa-external-link-alt"></i></span></p><p>编辑<code>settings.json</code>, 加上能够编译参考文献的配置，就可以在左侧边栏点击运行了。（其实我还是喜欢在命令行里<code>alias</code>将这三个命令指定一个短命令）</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"latex-workshop.latex.recipes"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"xelatex -> bibtex -> xelatex*2"</span><span class="token punctuation">,</span>        <span class="token property">"tools"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"xelatex"</span><span class="token punctuation">,</span>            <span class="token string">"bibtex"</span><span class="token punctuation">,</span>            <span class="token string">"xelatex"</span><span class="token punctuation">,</span>            <span class="token string">"xelatex"</span>        <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>这样需要编译四次，有一个更好的方法是<code>latexmk</code>增量编译</strong></p><p>我们将<code>settings.json</code><strong>改成这个样子</strong>（方案来自<span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAyMC8wNC8yNC91c2luZy1MYVRlWG1rLXdpdGgtTGFUZVh3b3Jrc2hvcC13aXRoLVZTQ29kZS8=">在 VSCode 的 LaTeXworkshop 插件中使用 LaTeXmk<i class="fa fa-external-link-alt"></i></span>）</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"latex-workshop.latex.tools"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"LaTeXmk"</span><span class="token punctuation">,</span>        <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"latexmk"</span><span class="token punctuation">,</span>        <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"-xelatex"</span><span class="token punctuation">,</span>            <span class="token string">"-synctex=1"</span><span class="token punctuation">,</span>            <span class="token string">"-shell-escape"</span><span class="token punctuation">,</span>            <span class="token string">"-interaction=nonstopmode"</span><span class="token punctuation">,</span>            <span class="token string">"-file-line-error"</span><span class="token punctuation">,</span>            <span class="token string">"%DOC%"</span><span class="token punctuation">,</span>            <span class="token string">"-outdir=%OUTDIR%"</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token property">"latex-workshop.latex.recipes"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"LaTeXmk"</span><span class="token punctuation">,</span>        <span class="token property">"tools"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"XeLaTeXmk"</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样只需要<code>latexmk</code>一个编译命令，<code>latexmk</code>的增量编译也比原来快了。</p><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><p>LaTeX Workshop 左侧边栏可以查看字数统计<br>可以自定义snippest快捷命令<br>可以插入参考文献（需要手打&#96;\cite{}，支持搜索bib文件里的文献（可以用zotero导出并开启同步））, 这样就不用装zotero latex插件了。</p><h3 id="json配置"><a href="#json配置" class="headerlink" title="json配置"></a>json配置</h3><p>这是我的<code>settings.json</code>配置：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">//双向搜索</span><span class="token property">"latex-workshop.view.pdf.viewer"</span><span class="token operator">:</span> <span class="token string">"tab"</span><span class="token punctuation">,</span><span class="token comment">//将编译生成的文件放到build文件夹</span><span class="token property">"latex-workshop.latex.outDir"</span><span class="token operator">:</span> <span class="token string">"build"</span><span class="token punctuation">,</span><span class="token comment">//使用latexmk解决插入文献bibtex需要多次编译的问题</span><span class="token property">"latex-workshop.latex.tools"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"LaTeXmk"</span><span class="token punctuation">,</span>        <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"latexmk"</span><span class="token punctuation">,</span>        <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"-xelatex"</span><span class="token punctuation">,</span>            <span class="token string">"-synctex=1"</span><span class="token punctuation">,</span>            <span class="token string">"-shell-escape"</span><span class="token punctuation">,</span>            <span class="token string">"-interaction=nonstopmode"</span><span class="token punctuation">,</span>            <span class="token string">"-file-line-error"</span><span class="token punctuation">,</span>            <span class="token string">"%DOC%"</span><span class="token punctuation">,</span>            <span class="token string">"-outdir=%OUTDIR%"</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token property">"latex-workshop.latex.recipes"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"LaTeXmk"</span><span class="token punctuation">,</span>        <span class="token property">"tools"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            <span class="token string">"XeLaTeXmk"</span><span class="token punctuation">,</span>        <span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token comment">//去掉右下角烦人的警告</span><span class="token property">"latex-workshop.message.error.show"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token property">"latex-workshop.message.warning.show"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token property">"latex-workshop.latex.clean.fileTypes"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token comment">//设定清理文件的类型(ctrl+alt+c：清除辅助文件)</span>    <span class="token string">"*.aux"</span><span class="token punctuation">,</span>    <span class="token string">"*.bbl"</span><span class="token punctuation">,</span>    <span class="token string">"*.blg"</span><span class="token punctuation">,</span>    <span class="token string">"*.idx"</span><span class="token punctuation">,</span>    <span class="token string">"*.ind"</span><span class="token punctuation">,</span>    <span class="token string">"*.lof"</span><span class="token punctuation">,</span>    <span class="token string">"*.lot"</span><span class="token punctuation">,</span>    <span class="token string">"*.out"</span><span class="token punctuation">,</span>    <span class="token string">"*.toc"</span><span class="token punctuation">,</span>    <span class="token string">"*.acn"</span><span class="token punctuation">,</span>    <span class="token string">"*.acr"</span><span class="token punctuation">,</span>    <span class="token string">"*.alg"</span><span class="token punctuation">,</span>    <span class="token string">"*.glg"</span><span class="token punctuation">,</span>    <span class="token string">"*.glo"</span><span class="token punctuation">,</span>    <span class="token string">"*.gls"</span><span class="token punctuation">,</span>    <span class="token string">"*.ist"</span><span class="token punctuation">,</span>    <span class="token string">"*.fls"</span><span class="token punctuation">,</span>    <span class="token string">"*.log"</span><span class="token punctuation">,</span>    <span class="token string">"*.fdb_latexmk"</span><span class="token punctuation">,</span>    <span class="token string">"*.nav"</span><span class="token punctuation">,</span>    <span class="token string">"*.snm"</span><span class="token punctuation">,</span>    <span class="token string">"*.bcf"</span><span class="token punctuation">,</span>    <span class="token string">"*.run.xml"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token property">"extensions.ignoreRecommendations"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span><span class="token property">"zotero.latexCommand"</span><span class="token operator">:</span> <span class="token string">"cite"</span><span class="token punctuation">,</span><span class="token property">"[latex]"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"editor.formatOnPaste"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token property">"editor.suggestSelection"</span><span class="token operator">:</span> <span class="token string">"recentlyUsedByPrefix"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="电子科技大学论文模板"><a href="#电子科技大学论文模板" class="headerlink" title="电子科技大学论文模板"></a>电子科技大学论文模板</h2><p>Github上有一个不错的模板是<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NoaWZ1anVuL1VFU1RDdGhlc2lz">shifujun&#x2F;UESTCthesis<i class="fa fa-external-link-alt"></i></span>，但是时老师的这个模板很久没更新了。<br>另一个是还在一直更新的模板，本硕博都有，直接clone下来改一下就好了（你电图书馆推荐的，勉强算是半官方的吧）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/x-magus/ThesisUESTC<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>网上有一些教程，包括：<br>知乎上的一篇文章<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMjY3MTI5ODI=">UESTC 本科Latex毕设论文模板 无痛上手指南<i class="fa fa-external-link-alt"></i></span>，这个我本科写毕设的时候就看到同学在朋友圈转过。这个教程我不是很推荐，因为：</p><blockquote><p>但是这里为了减少小伙伴们的学习成本达到“快速无痛上手”的目的（同时考虑到有些小伙伴用word写的很熟练），这里引用电子科大图书馆嵇灵老师的方法：用mathtype编辑，然后转化为latex代码。</p></blockquote><p>河畔现任站长的介绍帖子：<span class="exturl" data-url="aHR0cHM6Ly9iYnMudWVzdGMuZWR1LmNuL2ZvcnVtLnBocD9tb2Q9dmlld3RocmVhZCZ0aWQ9MTc4NjIzMSZleHRyYT0mcGFnZT0x">LaTeX 学校官方模板-2019年11月发<i class="fa fa-external-link-alt"></i></span> （需要登陆查看）<br>以及上一个帖子附件中嵇灵老师的PPT： 使用Latex模板撰写毕业论文（2019)<br>ps：个人不推荐这个PPT，里面推荐使用被思杰克马丁代理的Mathtype，推荐直接使用Office 2019的<code>Alt+=</code>手打公式（比LaTeX的公式甚至还舒服一点，也直接支持LaTeX的公式），实在想用图形界面输入公式就用AxMath吧，正版30多，还算良心不。  </p><p>上面那些教程的安装和使用几乎都是Windows环境，编辑器是overleaf和texstudio，而且操作偏向图形化界面点点点（Linux用户应该不会喜欢连LaTeX打公式都要点点点再粘贴上去）</p><p>注意要安装下面这些额外的包，不然会报<code>! LaTeX Error: File &#39;multirow.sty&#39; not found</code>等错误。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pacman -S texlive-latexextra texlive-science texlive-bibtexextra<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Archlinux下字体问题"><a href="#Archlinux下字体问题" class="headerlink" title="Archlinux下字体问题"></a>Archlinux下字体问题</h3><p>一种选择是装win10字体，然后修改<code>thesis-uestc.cls</code>的Default字体设置。AUR有个包<code>ttf-ms-win10-auto-zh_cn</code>，但是这个包由于再分发的版权原因要下载整个win10的iso，然后解压只保留ttf字体文件。身边有win10的建议直接将ttf文件拷贝过来（只要<code>simhei.ttf</code>，<code>simsong.ttf</code>，<code>simkai.ttf</code>就可以了）。<br>或者安装方正字体（默认的），AUR有个包<code>ttf-fangzheng</code>由于版权原因，也不能直接yay安装，只提供PKGBUILD，需要到官网下载ttf然后手动<code>makepkg</code></p><p>另一种选择是找到模板的字体设置，直接修改<code>thesis-uestc.cls</code>文件（反正毕业论文只要求宋体和黑体，又没说什么宋体和黑体，用系统默认的黑体和宋体就行了）</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex"><span class="token function selector">\else</span><span class="token function selector">\iflinux</span>  <span class="token function selector">\setCJKmainfont</span><span class="token punctuation">[</span>BoldFont=FandolSong-Bold.otf,ItalicFont=FandolKai-Regular.otf<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>FandolSong-Regular.otf<span class="token punctuation">&#125;</span>  <span class="token function selector">\newCJKfontfamily</span><span class="token punctuation">&#123;</span><span class="token function selector">\heiti</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>FandolHei-Regular.otf<span class="token punctuation">&#125;</span>  <span class="token function selector">\newfontfamily</span><span class="token punctuation">&#123;</span><span class="token function selector">\heiti</span>@letter<span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>FandolHei-Regular.otf<span class="token punctuation">&#125;</span>  <span class="token function selector">\setallmainfonts</span><span class="token punctuation">&#123;</span>Times New Roman<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了中文字体还需要一个Times New Roman罗马字体，这个AUR的包可以直接装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay -S ttf-times-new-roman<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>直接运行<code>latexmk main.tex</code>就可以了。</p><p>在VSCode里面装了LaTeX Workshop可以点击左上角那个绿色的运行按钮。会弹出一个pdf，将pdf放到右边一栏</p><h3 id="关于你电的一些问题"><a href="#关于你电的一些问题" class="headerlink" title="关于你电的一些问题"></a>关于你电的一些问题</h3><p>什么？教务处非要收word怎么办？要不妥协用Word，要不用pdf转图片转Word随便交一个上去，要不就pandoc顶着格式乱掉硬转一个，反正这个就是规定留档，没人看。<br>（隔壁西电早都支持提交LaTeX论文呢，不会有的985连这都不支持吧，非要冒着被制裁的风险用微软家的Word？不会吧？）</p><p>老板要用Word批注功能怎么办？这个没办法，回去用Word吧。<br>推荐你畔现任站长的一篇文章：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0N1aWFDdWlTaGEvVXNlV29yZEluVGhlc2lz">适用于毕业论文的word排版技巧<i class="fa fa-external-link-alt"></i></span> 之前本科毕设论文排版就看的这个，比你电图书馆的讲座教程和PPT好多了。</p><p>知网查重LaTeX会查公式，查重率高怎么办？不好意思这个没办法。</p><h2 id="LaTeX教程和模板推荐"><a href="#LaTeX教程和模板推荐" class="headerlink" title="LaTeX教程和模板推荐"></a>LaTeX教程和模板推荐</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>LaTeX本来就是用于排版的专业排版工具，能做出很多相当漂亮和复杂的效果。LaTeX能做到什么程度可以看StackExchange上的这个问题：<span class="exturl" data-url="aHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzEzMTkvc2hvd2Nhc2UtJTIwJTIwb2YtYmVhdXRpZnVsLXR5cG9ncmFwaHktZG9uZS1pbi10ZXgtZnJpZW5kcw==">Showcase of beautiful typography done in TeX &amp; friends<i class="fa fa-external-link-alt"></i></span></p><p>想要自己从0设计排版成这样的效果是需要肝的。而我用LaTeX是因为不想花太多精力在排版上，想把它当成Markdown一样的东西用。所以我需要模板。</p><p>模板可以来这里找：<span class="exturl" data-url="aHR0cHM6Ly93d3cubGF0ZXhzdHVkaW8ubmV0Lw==">LaTeXStudio<i class="fa fa-external-link-alt"></i></span> 不过这个网站最近突然换了前端页面还多了不少广告（有种不详的预感）  </p><h3 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h3><p>教程这个不同人适合不同的教程，下面是我比较喜欢的一个：</p><p><span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAxNC8wOS8wOC9sYXRleC1pbnRyb2R1Y3Rpb24v">一份其实很短的 LaTeX 入门文档<i class="fa fa-external-link-alt"></i></span></p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="关闭LaTeX-Workshop右下角的烦人通知"><a href="#关闭LaTeX-Workshop右下角的烦人通知" class="headerlink" title="关闭LaTeX Workshop右下角的烦人通知"></a>关闭LaTeX Workshop右下角的烦人通知</h3><p>LaTeX WorkShop插件每次保存都会弹出通知<code>Formatting failed. Please refer to LaTeX Workshop Output for details.</code></p><p>关闭右下角每次都弹出的烦人提示</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"latex-workshop.message.error.show"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span class="token property">"latex-workshop.message.warning.show"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="双向跳转"><a href="#双向跳转" class="headerlink" title="双向跳转"></a>双向跳转</h3><p><del>双向奔赴了属于是</del></p><p>目前最新的LaTeX Workshop插件是无需配置可以直接跳转的。（插件内置的PDF.js，在VSCode内预览）<br>网上很多教程已经过时了，直接看官方文档。官方文档写的很清楚：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0phbWVzLVl1L0xhVGVYLVdvcmtzaG9wL3dpa2kvVmlldyNzeW5jdGV4">https://github.com/James-Yu/LaTeX-Workshop/wiki/View#synctex<i class="fa fa-external-link-alt"></i></span></p><p>从pdf跳转到tex文件使用<code>Ctrl+鼠标左键</code><br>从tex文件定位到pdf相应位置<code>Ctrl+Alt+J</code>  </p><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>插入图片可以放到相应位置然后手写<code>\includegraphics&#123;example.jpg&#125;</code>。<br>如果想从剪切板自动粘贴，和Markdown一样，用paste image插件就行了。我Markdown的paste image配置和latex的不一样，所以放到workspace的json文件里</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"pasteImage.defaultName"</span><span class="token operator">:</span> <span class="token string">"X"</span><span class="token punctuation">,</span>    <span class="token property">"pasteImage.encodePath"</span><span class="token operator">:</span> <span class="token string">"none"</span><span class="token punctuation">,</span>    <span class="token property">"pasteImage.path"</span><span class="token operator">:</span> <span class="token string">"$&#123;currentFileDir&#125;/pic"</span><span class="token punctuation">,</span>    <span class="token property">"pasteImage.showFilePathConfirmInputBox"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"pasteImage.insertPattern"</span><span class="token operator">:</span> <span class="token string">"\\includegraphics[scale =]&#123;$&#123;imageSyntaxPrefix&#125;$&#123;imageFilePath&#125;$&#123;imageSyntaxSuffix&#125;&#125;"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者我们在user的<code>settings.json</code>里加上</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"[latex]"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"pasteImage.insertPattern"</span><span class="token operator">:</span> .......<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>表示只对latex生效。</p><p>insertPattern选项请根据模板自己修改，比如你电的学位论文模板改成这样就可以了。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"pasteImage.insertPattern"</span><span class="token operator">:</span> <span class="token string">"\\begin&#123;figure&#125;[h]\n\t\\includegraphics[width= 6cm]&#123;$&#123;imageFileName&#125;&#125;\n\t\\caption&#123;$&#123;imageFileNameWithoutExt&#125;&#125;\n\t\\label&#123;fig:$&#123;imageFileNameWithoutExt&#125;&#125;\n\\end&#123;figure&#125;"</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另外需要注意的是paste image插件的快捷键<code>ctrl+alt+v</code>和LaTeX Workshop冲突，要在<code>Keyboard Shortcuts</code>里面换掉一个，不然快捷键粘贴图片不起作用。</p><h3 id="参考文献报错"><a href="#参考文献报错" class="headerlink" title="参考文献报错"></a>参考文献报错</h3><p>设置参考文献这两行要放在<code>\end&#123;document&#125;</code>前面</p><pre class="line-numbers language-latex" data-language="latex"><code class="language-latex"><span class="token function selector">\bibliography</span><span class="token punctuation">&#123;</span>export.bib<span class="token punctuation">&#125;</span><span class="token function selector">\bibliographystyle</span><span class="token punctuation">&#123;</span>plain<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>不然会报错</p><pre class="line-numbers language-log" data-language="log"><code class="language-log">I found no \bibdata command<span class="token separator comment">---</span>while reading file <span class="token domain constant">test.aux</span>I found no \bibstyle command<span class="token separator comment">---</span>while reading file test<span class="token punctuation">.</span>aux<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="某些知网文献bibtex编译报错"><a href="#某些知网文献bibtex编译报错" class="headerlink" title="某些知网文献bibtex编译报错"></a>某些知网文献bibtex编译报错</h3><p>垃圾知网不仅弄出了天价查重、caj格式这些天怒人怨的东西，中文文献的引用格式也挺乱的，经常缺这个少那个，而且不支持bibtex。如果用zotero转出来也会因为缺少各种字段而报错。查了一下没什么太好的解决办法。<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2Mzk4OTA5L2Fuc3dlci8zMjY0Mzc4OA==">如何使用BibTeX引用中文参考文献？ - 刘海洋的回答 - 知乎<i class="fa fa-external-link-alt"></i></span> 刘海洋老师推荐自己写bibtex，但是我给这些东西写这些，我用LaTeX就是因为不想在word的排版上纠缠过多。  </p><p>百度好歹干了点人事，能导出bibtex格式。但是有很多学位论文，百度学术也没有万方也没有，就知网有。  </p><p>之前说过，如果单纯为了插入GB&#x2F;T格式的参考文献可以用一点脏办法: <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDE4MDU3MDQ=">电子科技大学LaTeX模板参考文献问题解决<i class="fa fa-external-link-alt"></i></span> (不得已的办法)。比如插入知网文献的时候可以用这个。<strong>一开始觉得这是不太好的脏办法</strong>，在被知网的一些参考文献格式整麻了以后，觉得<strong>这才是最好的方法</strong>。直接粘贴纯文本，反正最后排版效果一样就行了。bibtex的理念不适合处理脏东西，脏东西要用脏办法。</p><p>编辑<code>thesis-uestc.bst</code>, 新建一个参看文献格式</p><pre class="line-numbers language-bst" data-language="bst"><code class="language-bst">FUNCTION &#123;biaoti&#125;&#123;    bibitem.begin    title write$    newline$&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在<code>reference.bib</code>里面粘贴复制粘贴的文本就可以了，相当于引用纯文本</p><h3 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h3><p>只对Latex开启自动换行</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token property">"[latex]"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token property">"editor.wordWrap"</span><span class="token operator">:</span> <span class="token string">"on"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="电子科技大学论文模板识别不了linux环境"><a href="#电子科技大学论文模板识别不了linux环境" class="headerlink" title="电子科技大学论文模板识别不了linux环境"></a>电子科技大学论文模板识别不了linux环境</h4><p>编译的时候加参数<code>-shell-escape</code>。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3p1aWN5L1VFU1RDX3JlcG9ydF9sYXRleC90cmVlL21hc3Rlci9VRVNUQ19yZXBvcnQ=">https://github.com/zuicy/UESTC_report_latex/tree/master/UESTC_report<i class="fa fa-external-link-alt"></i></span> 电子科技大学实验报告的LaTeX模板，是你电信软学院的同学做的，看起来似乎全校通用（改一下学院名字就好了）。<br>LaTeXStudio上那个是比较老的模板：<span class="exturl" data-url="aHR0cHM6Ly93d3cubGF0ZXhzdHVkaW8ubmV0L2FyY2hpdmVzLzUxNTQxLmh0bWw=">电子科大的实验报告 LaTeX 模板 - 用户投稿<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMTE4ODkyNTI=">Linux 下的 LaTex 写作工具链（1）<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3h1Z2VlLmNvbS9pbWFnZXMvMy8zYS9WU2NvZGUlRTQlQkQlQkYlRTclOTQlQTglRTglQUYlQjQlRTYlOTglOEUucGRm">VScode使用说明(Zotero插件) 刘再华<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21ibG9kZS92c2NvZGUtem90ZXJv">https://github.com/mblode/vscode-zotero<i class="fa fa-external-link-alt"></i></span> vscode zotero的Markdown引用文献插件。  </p><p><span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAxNi8wMS8yMy91c2luZy1iaWJ0ZXgtdG8tZ2VuZXJhdGUtcmVmZXJlbmNlLw==">使用 BibTeX 生成参考文献列表<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvTGFUZVg=">https://en.wikibooks.org/wiki/LaTeX<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1c2hpZG9uZy9iaWJsYXRleC16aC1jbg==">https://github.com/hushidong/biblatex-zh-cn<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2h1c2hpZG9uZy9iaWJsYXRleC1zb2x1dGlvbi10by1sYXRleC1iaWJsaW9ncmFwaHk=">https://github.com/hushidong/biblatex-solution-to-latex-bibliography<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9saWFtLnBhZ2UvMjAyMC8wNC8yNC91c2luZy1MYVRlWG1rLXdpdGgtTGFUZVh3b3Jrc2hvcC13aXRoLVZTQ29kZS8=">https://liam.page/2020/04/24/using-LaTeXmk-with-LaTeXworkshop-with-VSCode/<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2Rkc3dodS5tZS9wb3N0cy8yMDE4LTA0L3ZzLWNvZGUtZm9yLWxhdGV4Lw==">http://ddswhu.me/posts/2018-04/vs-code-for-latex/<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cudHVnLm9yZy90ZXhsaXZlL2RvYy90ZXhsaXZlLXpoLWNuL3RleGxpdmUtemgtY24ucGRm">https://www.tug.org/texlive/doc/texlive-zh-cn/texlive-zh-cn.pdf<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开源拖拉机将就着用吧，又不是不能用，再见Word、EndNote和Windows。顺便说一下你电的LaTeX模板怎么用。不定期更新到毕业。&lt;/p&gt;</summary>
    
    
    
    
    <category term="LaTeX" scheme="https://zhangjk98.xyz/tags/LaTeX/"/>
    
    <category term="Zotero" scheme="https://zhangjk98.xyz/tags/Zotero/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Syscall 笔记</title>
    <link href="https://zhangjk98.xyz/6.s081-lab-syscall/"/>
    <id>https://zhangjk98.xyz/6.s081-lab-syscall/</id>
    <published>2021-09-15T12:01:25.000Z</published>
    <updated>2021-09-15T12:01:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>暑假摸了一个月的鱼，回来接着做Lab。2021 spring 的6.S081已经开始了，直接做2021的吧（看了一下好像没有太大变化）。而且xv6-labs-2021这个repo貌似修复了Archlinux上新版gdb不兼容的问题，不用再降级包或者去用Ubuntu 20了。</p><span id="more"></span><p>注：目前现在2021的repo由于进度原因只有riscv、util和syscall三个分支，没有master分支，所以会报警告：<code>warning: remote HEAD refers to nonexistent ref, unable to checkout.</code>这个不用管。</p><h2 id="关于syscall"><a href="#关于syscall" class="headerlink" title="关于syscall"></a>关于syscall</h2><p>syscall一般很少直接用，用c语言写东西的时候大部分都是通过wrapper函数间接调用syscall。其他语言里用到系统调用的就更少了，我就只在某次用golang的网络库实现traceroute的时候调用过一次。</p><p>之前对syscall的印象是x86下<code>int 80</code>中断，从用户空间切到内核空间。常用的比如read, write, open, close啊，以及mmap等等。</p><p>6.S081改用risc-v, 不太一样。<br>risc-v中有三种模式：<br>User-mode，用户模式。普通应用会在这个模式下运行。<br>Supervisor-mode， 特权模式。<br>Machine-mode，机器模式，需要的权限比supervisor模式还要高。一些嵌入式几乎整个都运行在这种模式下，完整的操作系统就只有bootloader等是在M模式下，大部分任务都在U和S模式下。<br>关于risc-v的特权模式可以参考手册：The RISC-V Instruction Set Manual<br>Volume II: Privileged Architecture</p><p>进入syscall是通过ecall（环境调用）指令，从u模式进入s模式，结束后使用<code>sret</code>指令返回。</p><p>还有就是讲义中将异常（exception）和中断（interrupt）都算做陷阱（trap），一开始看讲义的时候一直以为这是三个不同的东西。后来发现涉及到supervisor和machine模式的都算做trap。</p><h2 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h2><p>Lab2就两个，简单熟悉一下系统调用，不难。</p><h3 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (moderate)</h3><p>这个不是很难，不过要改的东西很多，按照提示一点一点做就行了。</p><h2 id="Linux下的syscall"><a href="#Linux下的syscall" class="headerlink" title="Linux下的syscall"></a>Linux下的syscall</h2><p>这里说一下linux中系统调用相关的东西，6.S081的课和Lab没怎么提到，但是这一部分写业务用到的比较多。linux下的syscall一般直接用glibc提供的，现在一般x86下也不用<code>int 0x80</code>了。由于syscall的调用消耗很高，所以有vsyscall和vDSO等技术。</p><p>以date命令为例，我们用strace看一下系统调用，可以看到clock_gettime调用花了0.000006s</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$strace</span> -cTstrace: -T/--syscall-times has no effect with -c/--summary-onlyTue Mar <span class="token number">22</span> 07:16:09 PM CST <span class="token number">2022</span>% <span class="token function">time</span>     seconds  usecs/call     calls    errors syscall------ ----------- ----------- --------- --------- ---------------- <span class="token number">22.18</span>    <span class="token number">0.000057</span>           <span class="token number">6</span>         <span class="token number">9</span>           mmap <span class="token number">12.45</span>    <span class="token number">0.000032</span>           <span class="token number">5</span>         <span class="token number">6</span>           close <span class="token number">12.45</span>    <span class="token number">0.000032</span>           <span class="token number">5</span>         <span class="token number">6</span>           newfstatat <span class="token number">11.67</span>    <span class="token number">0.000030</span>           <span class="token number">7</span>         <span class="token number">4</span>           mprotect  <span class="token number">7.00</span>    <span class="token number">0.000018</span>           <span class="token number">4</span>         <span class="token number">4</span>           openat  <span class="token number">4.28</span>    <span class="token number">0.000011</span>           <span class="token number">3</span>         <span class="token number">3</span>           <span class="token builtin class-name">read</span>  <span class="token number">4.28</span>    <span class="token number">0.000011</span>          <span class="token number">11</span>         <span class="token number">1</span>           munmap  <span class="token number">4.28</span>    <span class="token number">0.000011</span>           <span class="token number">3</span>         <span class="token number">3</span>           brk  <span class="token number">2.72</span>    <span class="token number">0.000007</span>           <span class="token number">7</span>         <span class="token number">1</span>           <span class="token function">write</span>  <span class="token number">2.33</span>    <span class="token number">0.000006</span>           <span class="token number">1</span>         <span class="token number">4</span>           pread64  <span class="token number">2.33</span>    <span class="token number">0.000006</span>           <span class="token number">6</span>         <span class="token number">1</span>           clock_gettime  <span class="token number">2.33</span>    <span class="token number">0.000006</span>           <span class="token number">6</span>         <span class="token number">1</span>           getrandom  <span class="token number">1.95</span>    <span class="token number">0.000005</span>           <span class="token number">5</span>         <span class="token number">1</span>           lseek  <span class="token number">1.95</span>    <span class="token number">0.000005</span>           <span class="token number">2</span>         <span class="token number">2</span>         <span class="token number">1</span> arch_prctl  <span class="token number">1.95</span>    <span class="token number">0.000005</span>           <span class="token number">5</span>         <span class="token number">1</span>           set_tid_address  <span class="token number">1.95</span>    <span class="token number">0.000005</span>           <span class="token number">5</span>         <span class="token number">1</span>           set_robust_list  <span class="token number">1.95</span>    <span class="token number">0.000005</span>           <span class="token number">5</span>         <span class="token number">1</span>           prlimit64  <span class="token number">1.95</span>    <span class="token number">0.000005</span>           <span class="token number">5</span>         <span class="token number">1</span>           rseq  <span class="token number">0.00</span>    <span class="token number">0.000000</span>           <span class="token number">0</span>         <span class="token number">1</span>         <span class="token number">1</span> access  <span class="token number">0.00</span>    <span class="token number">0.000000</span>           <span class="token number">0</span>         <span class="token number">1</span>           execve------ ----------- ----------- --------- --------- ----------------<span class="token number">100.00</span>    <span class="token number">0.000257</span>           <span class="token number">4</span>        <span class="token number">52</span>         <span class="token number">2</span> total<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>vsyscall是将频繁使用的syscall从kernelsapce映射到userspace的页，这样就不需要切换usersapce和kernelspace了。这样对<code>gettimeofday</code>这样的对时间很敏感的系统调用好处很大。但是vsyscall将kernelspace一段固定的地址映射到userspace，存在安全问题。现在已经不常用vsyscall了，基本都改用vDSO了。</p><p>vDSO（virtual dynamic shared object）是一个虚拟的动态库(linux-vdso.so.1)，同样运行在userspace，这样就不需要软中断了。vDSO一个好处是利用ASLR（address space layout randomization）减少了vsyscall的安全问题。现在linux发行版一般都开了地址随机化（可以看<code>/proc/sys/kernel/randomize_va_space</code>），调试内核的时候我建议临时把这个关掉。另一个好处是把不同平台的syscall封装了，给了一套统一的ABI，动态链接库的ABI从kernel的libc独立出去了。</p><p>另一个加快系统调用的技术是快速系统调用（fast system call），这个是x86的一些  指令，直接切换特权，也不需要中断。 </p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9zeXNjYWxscy4yLmh0bWw=">https://man7.org/linux/man-pages/man2/syscalls.2.html<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9maWxpcHBvLmlvL2xpbnV4LXN5c2NhbGwtdGFibGUv">https://filippo.io/linux-syscall-table/<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzYwNDI4Ny8=">Anatomy of a system call, part 1<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzYwNDUxNS8=">Anatomy of a system call, part 2<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzQ0NjUyOC8=">On vsyscalls and the vDSO<i class="fa fa-external-link-alt"></i></span> 这个文章有点老，不感兴趣不用看<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1saW51eC1zeXN0ZW0tY2FsbHMv">The Definitive Guide to Linux System Calls<i class="fa fa-external-link-alt"></i></span> 相当详细的一片文章，强烈推荐<br><span class="exturl" data-url="aHR0cHM6Ly9hcnRodXJjaGlhby5hcnQvYmxvZy9zeXN0ZW0tY2FsbC1kZWZpbml0aXZlLWd1aWRlLXpoLyMxLSVFNyVCMyVCQiVFNyVCQiU5RiVFOCVCMCU4MyVFNyU5NCVBOCVFNiU5OCVBRiVFNCVCQiU4MCVFNCVCOSU4OA==">[译] Linux 系统调用权威指南（2016）<i class="fa fa-external-link-alt"></i></span> 上面那篇的中文翻译  </p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL01pbnRDTi9saW51eC1pbnNpZGVzLXpo">linux-insides-zh<i class="fa fa-external-link-alt"></i></span> 中文翻译<br><span class="exturl" data-url="aHR0cHM6Ly92dmwubWUvMjAxOS8wNi9saW51eC1zeXNjYWxsLWFuZC12c3lzY2FsbC12ZHNvLWluLXg4Ni8=">x86 架构下 Linux 的系统调用与 vsyscall, vDSO<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;暑假摸了一个月的鱼，回来接着做Lab。2021 spring 的6.S081已经开始了，直接做2021的吧（看了一下好像没有太大变化）。而且xv6-labs-2021这个repo貌似修复了Archlinux上新版gdb不兼容的问题，不用再降级包或者去用Ubuntu 20了。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="syscall" scheme="https://zhangjk98.xyz/tags/syscall/"/>
    
  </entry>
  
  <entry>
    <title>Earlyoom和oomd使用，解决Linux内存耗尽的一点尝试</title>
    <link href="https://zhangjk98.xyz/early-oom-and-oomd-for-out-of-memory/"/>
    <id>https://zhangjk98.xyz/early-oom-and-oomd-for-out-of-memory/</id>
    <published>2021-09-14T08:08:11.000Z</published>
    <updated>2021-09-14T08:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>太长不看：就是把原来内核的OOM killer挪到用户空间（userspace）去，这样就可以在系统卡住之前（通常桌面卡住的时候OOM killer认为还不用kill）提前kill掉占内存最大的一个，让桌面和鼠标可以正常工作。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先来看phoronix的一个报道：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PUxpbnV4LURvZXMtQmFkLUxvdy1SQU0=">Yes, Linux Does Bad In Low RAM &#x2F; Memory Pressure Situations On The Desktop<i class="fa fa-external-link-alt"></i></span>  </p><p>Linux桌面在小内存、内存紧张的情况下表现很差。（用过Linux现在桌面的相信都有这种感受）</p><p>解决内存不足、内存耗尽的<strong>最好办法还是加钱多装几根内存条</strong>，什么swap、zram还有本文的earlyoom和oomd都是权宜之计。 </p><h2 id="OOM简介"><a href="#OOM简介" class="headerlink" title="OOM简介"></a>OOM简介</h2><p>OOM很多人应该都很熟悉了，服务器上跑的任务申请内存超过了可用内存就会发生OOM（其实是可以Overcommit的，这个以后再说）</p><p>为了避免内存耗尽（Out of Memory，OOM），OOM-killer在内存将要耗尽的时候杀掉<code>oom_score</code>最大的进程。（如果连OOM-killer都没能及时kill掉，那就会触发kernel panic）</p><p>但是内核默认的OOM策略比较保守，如果你是桌面用户，那么还没等到OOM killer工作，图形界面就已经卡死（handling， 有的时候也被称为freeze）了。Earlyoom和oomd等工具运行在用户空间，让一些任务提前崩溃，让图形界面还能正常工作。</p><p>OOM killer和Overcommit等更详细的介绍我写到<a href="https://zhangjk98.xyz/linux-out-of-memory">这里</a>, 这里不多说了。</p><h2 id="Earlyoom"><a href="#Earlyoom" class="headerlink" title="Earlyoom"></a>Earlyoom</h2><p>EarlyOOM</p><p>Earlyoom在桌面系统的表现比较成功，Fedora 32 已经默认启用了EarlyOOM。</p><h2 id="oomds"><a href="#oomds" class="headerlink" title="oomds"></a>oomds</h2><p>oomd是Facebook做的，后来和systemd一起做了一个sysytemd-oomd守护进程，现已加入systemd全家桶。</p><h2 id="在Archlinux上安装和使用"><a href="#在Archlinux上安装和使用" class="headerlink" title="在Archlinux上安装和使用"></a>在Archlinux上安装和使用</h2><p>Earlyoom已经在community源里了。oomd这个包目前是orphand，我们用Earlyoom就好了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pacman -S earlyoom<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接terminal里执行<code>earlyoom</code>就可以了。（可能需要root权限，不然会报<code>Could not lock memory - continuing anyway: Cannot allocate memory</code>）</p><p>或者使用systemd守护进程</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> earlyoom --now<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后又到了调参环节，编辑<code>/etc/default/earlyoom</code>，根据你的机器配置和使用习惯改改参数。</p><p>默认10秒检查一次，当可用内存小于10%和swap小于10的时候执行<code>SIGTERM</code>，当可用内存小于5%和swap小于5%的时候执行<code>SIGKILL</code>。</p><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>一开始我笔记本和台式机都8G内存，当时那个版本的VSCode有严重的内存泄漏，经常泄漏到我桌面连鼠标都动不了了。只能切到tty杀掉VSCode的进程或者魔术键重启，烦的我一度想投奔vim。<br>后来买了两根16G的笔记本内存条，又把教研室的台式内存（拆了4根8G ddr3的杂牌内存条下来）加到了32G，开着一个虚拟机好多Docker一个Goland还有Chrome，再也没遇到过内存不够用的问题。<br>最近要在另一个8G内存的电脑上和只有2g内存的VPS上面干点活，又回到了当初只有8G内存的时候vscode频繁内存泄漏导致整个桌面直接卡死的拮据状态。Ubuntu 16.04 那个版本的GNOME内存泄漏和内部错误也相当讨厌。换了lxde好了一点。然后试了试swap，效果不好。然后用了zram, 效果比swap好不少。  </p><p>最后用了Earlyoom，好多了，不用频繁手动处理桌面卡死了。（注意4G以下这种小内存不推荐用这些，会浪费不少可用内存）</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JmamFrb2IvZWFybHlvb20=">https://github.com/rfjakob/earlyoom<i class="fa fa-external-link-alt"></i></span>  </p><p>Fedora默认启用Earlyoom的一些讨论：</p><p><span class="exturl" data-url="aHR0cHM6Ly9mZWRvcmFwcm9qZWN0Lm9yZy93aWtpL0NoYW5nZXMvRW5hYmxlRWFybHlvb20jRW5hYmxlX0Vhcmx5T09N">https://fedoraproject.org/wiki/Changes/EnableEarlyoom#Enable_EarlyOOM<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9wYWd1cmUuaW8vZmVkb3JhLXdvcmtzdGF0aW9uL2lzc3VlLzExOQ==">https://pagure.io/fedora-workstation/issue/119<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PUZlZG9yYS0zMi1EZWZhdWx0LUVhcmx5T09N">https://www.phoronix.com/scan.php?page=news_item&amp;px=Fedora-32-Default-EarlyOOM<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvbWVtb3J5X21hbmFnZW1lbnQvb29tLmh0bWw=">Linux vm运行参数之（二）：OOM相关的参数<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;太长不看：就是把原来内核的OOM killer挪到用户空间（userspace）去，这样就可以在系统卡住之前（通常桌面卡住的时候OOM killer认为还不用kill）提前kill掉占内存最大的一个，让桌面和鼠标可以正常工作。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="OOM" scheme="https://zhangjk98.xyz/tags/OOM/"/>
    
    <category term="earlyoom" scheme="https://zhangjk98.xyz/tags/earlyoom/"/>
    
    <category term="oomd" scheme="https://zhangjk98.xyz/tags/oomd/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程调度，从服务器到桌面</title>
    <link href="https://zhangjk98.xyz/linux-processing-scheduling/"/>
    <id>https://zhangjk98.xyz/linux-processing-scheduling/</id>
    <published>2021-08-30T03:26:55.000Z</published>
    <updated>2021-08-30T03:26:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>用了一周linux-ck和MuQSS，发现没有想象中的那么好。哦，这还要从一个麻醉师说起。</p><span id="more"></span><p>没仔细看调度器之前我以为Linux进程调度都是和内存管理一样很复杂的东西。实现比较简单的进程调度就几十行代码。CFS这种比较复杂的就不仔细说了、多核和分布式调度这些比较复杂的下面也不会多讲。（主要是我水平太菜了，怕讲错）</p><h2 id="进程调度简介"><a href="#进程调度简介" class="headerlink" title="进程调度简介"></a>进程调度简介</h2><p>进程是操作系统虚拟化出来的东西，</p><p>Linux里面基本不区分进程和线程，统称为task（任务）。下面的进程等词都指task。</p><p>CPU的资源是有限的，进程之间需要一个调度器来分配资源使用。最常见的调度器是Linux内核主线默认采用的CFS。</p><p>注：不要只盯着复杂度O(n), O(1), O(log n), 效果还是得看实测。引用一下cauche调度器readme里的一段话</p><p>O(n) sounds scary, but usually for a machine with 4 CPUS where it is used for desktop or mobile jobs, the maximum number of runnable tasks might not exceeds 10 (at the pick next run time) - the idle tasks are excluded since they are dequeued when sleeping and enqueued when they wake up.</p><p>在电脑桌面和手机、4核CPU使用场景，最多运行任务不超过10个。所以复杂度O(n)不一定比O(1)调度速度快。</p><h3 id="关于进程"><a href="#关于进程" class="headerlink" title="关于进程"></a>关于进程</h3><p>在<code>include/linux/sched.h</code>头文件里面有进程的定义（一个结构体来表示的task）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">task_struct</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Linux系统在启动的时候会首先执行<code>start_kernel()</code>函数<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvdjUuNy1yYzEvc291cmNlL2luaXQvbWFpbi5j">init&#x2F;main.c<i class="fa fa-external-link-alt"></i></span>。</p><p>首先是<code>set_task_stack_end_magic(&amp;init_task)</code>创建一个叫<code>init_task</code>的进程，一般管它叫0号进程（也就是后面的idle进程）。</p><p>然后调用<code>sched_init();</code>函数初始化进程调度。</p><p>然后在<code>start_kernel()</code>函数最后调用<code>rest_init</code>, 两个<code>kernel_thread</code>分别创建了一号进程（<code>init</code>）和二号进程(<code>kthreadd</code>)。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">noinline <span class="token keyword">void</span> __ref <span class="token function">rest_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tsk<span class="token punctuation">;</span><span class="token keyword">int</span> pid<span class="token punctuation">;</span><span class="token function">rcu_scheduler_starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pid <span class="token operator">=</span> <span class="token function">kernel_thread</span><span class="token punctuation">(</span>kernel_init<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> CLONE_FS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>pid <span class="token operator">=</span> <span class="token function">kernel_thread</span><span class="token punctuation">(</span>kthreadd<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> CLONE_FS <span class="token operator">|</span> CLONE_FILES<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般1号进程是用户态进程，整个用户态的进程树都是它<code>fork</code>出来的。关于1号进程的介绍可以看看systemd作者写的<a href="http://0pointer.de/blog/projects/systemd.html"><span class="exturl" data-url="aHR0cDovLzBwb2ludGVyLm5ldC9ibG9nL3Byb2plY3RzL3N5c3RlbWQuaHRtbA==">Rethinking PID 1<i class="fa fa-external-link-alt"></i></span></a> 中文翻译: <span class="exturl" data-url="aHR0cDovL2thaXdhbmdjaGVuLmdpdGh1Yi5pby8yMDE0LzEwLzA4L3N5c3RlbWQuaHRtbA==">重新思考 1 号进程<i class="fa fa-external-link-alt"></i></span></p><p>2号进程是内核进程，负责管理和调度内核线程。</p><p>进程描述符里面有一些调度需要的信息，比如。</p><h3 id="初代调度器"><a href="#初代调度器" class="headerlink" title="初代调度器"></a>初代调度器</h3><p>初代调度器非常简单，就是一个runqueue（运行队列），源码在<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvMC4xMS9zb3VyY2Uva2VybmVsL3NjaGVkLmM=">kernel&#x2F;sched.c<i class="fa fa-external-link-alt"></i></span>,   我们忽略掉系统调用和printk日志以及floppy之类的，只看调度部分：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* *  'schedule()' is the scheduler function. This is GOOD CODE! There * probably won't be any reason to change this, as it should work well * in all circumstances (ie gives IO-bound processes good response etc). * The one thing you might take a look at is the signal-handler code here. * *   NOTE!!  Task 0 is the 'idle' task, which gets called when no other * tasks can run. It can not be killed, and it cannot sleep. The 'state' * information in task[0] is never used. */</span><span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">,</span>next<span class="token punctuation">,</span>c<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token comment">/* check alarm, wake up any interruptible tasks that have got a signal */</span><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">&lt;</span> jiffies<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>SIGALRM<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>alarm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>signal <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>_BLOCKABLE <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>blocked<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">==</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state<span class="token operator">=</span>TASK_RUNNING<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/* this is the scheduler proper: */</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">=</span> NR_TASKS<span class="token punctuation">;</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>task<span class="token punctuation">[</span>NR_TASKS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span><span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>state <span class="token operator">==</span> TASK_RUNNING <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">></span> c<span class="token punctuation">)</span>c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter<span class="token punctuation">,</span> next <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>LAST_TASK <span class="token punctuation">;</span> p <span class="token operator">></span> <span class="token operator">&amp;</span>FIRST_TASK <span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>counter <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">-></span>priority<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">switch_to</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>就只有这么几行。也没有nice值和多核，甚至没有生命周期，还是很容易理解的。</p><p>jiffies是系统开机以来tick的次数（alarm&gt;jiffies说明过期了，重置为0）</p><p>counter是时间片，单位是tick（时钟滴答），调度器根据couter大小决定优先级（couter越大优先级越高）</p><p>NR_TASKS是task（进程）总数。</p><p>第一个循环是检查一遍<span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9hbGFybS4yLmh0bWw=">alarm()<i class="fa fa-external-link-alt"></i></span>函数，唤醒任何收到alarm传来的signal的没有被阻塞的tasks，将<code>TASK_INTERRUPTIBLE</code>（挂起）改为<code>TASK_RUNNING</code>可执行。</p><p>然后<code>while(1)</code> 这个死循环一直执行到关机，每次循环先<code>while (--i)</code>找出counter（时间片）最大的task。（couter越大说明）</p><p><code>if (c) break;</code>和下面的这些是说如果c为0（所有进程的counter用完了），就重新分配counter。</p><p>最后调用<code>switch_to(next)</code>切换进程。（切换到counter最大的一个）</p><p>然后还有几个函数，是几个状态的转换，也很简单。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sys_pause</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_INTERRUPTIBLE<span class="token punctuation">;</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sleep_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"task[0] trying to sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tmp <span class="token operator">=</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token operator">*</span>p <span class="token operator">=</span> current<span class="token punctuation">;</span>current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_UNINTERRUPTIBLE<span class="token punctuation">;</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>小tmp<span class="token operator">-></span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">interruptible_sleep_on</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span>tmp<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>init_task<span class="token punctuation">.</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"task[0] trying to sleep"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tmp<span class="token operator">=</span><span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token operator">*</span>p<span class="token operator">=</span>current<span class="token punctuation">;</span>repeat<span class="token operator">:</span>current<span class="token operator">-></span>state <span class="token operator">=</span> TASK_INTERRUPTIBLE<span class="token punctuation">;</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>p <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> current<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">goto</span> repeat<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>tmp<span class="token operator">-></span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">wake_up</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">task_struct</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个调度器复杂度是O(n)的（复杂度没啥用，因为NR_TASKS早期特别小）。只有分配的counter值作为调度优先级</p><p>0号进程的优先级是最低的（最后被调度）。在后面的调度器中0号进程根本不参与调度。</p><h3 id="O-n-调度器"><a href="#O-n-调度器" class="headerlink" title="O(n)调度器"></a>O(n)调度器</h3><p>早期的调度器是和UNIX的差不多，就是O(n)调度器。</p><p>O(n)调度器是用runqueue（运行队列），和初代调度器不同的是CPU每个核都有一个runqueue。</p><h3 id="O-1-调度器"><a href="#O-1-调度器" class="headerlink" title="O(1)调度器"></a>O(1)调度器</h3><p>2.6版本</p><p>O(1)调度器比较适合服务器，基本上做到了将I&#x2F;O利用率最大化。</p><p>静态优先级（一般叫nice值）</p><h3 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h3><p>CFS调度器（Completely Fair Scheduler），用的最广的一个（从2.6开始Linux内核主线默认就是他）。CFS的意思是完全公平调度器，完全公平是说每一个进程在一个周期时间内运行相同的时间。在一个生命周期<code>T</code>内，<code>N</code>个task占用CPU的时间均为$T&#x2F;N$</p><p>CFS是一个红黑树实现的。是几种调度器中实现很复杂的一个调度器，源码在这里：<span class="exturl" data-url="aHR0cHM6Ly9lbGl4aXIuYm9vdGxpbi5jb20vbGludXgvbGF0ZXN0L3NvdXJjZS9rZXJuZWwvc2NoZWQvZmFpci5j">sched_fair.c Linux Kernel Source<i class="fa fa-external-link-alt"></i></span></p><p>文档在这里：<span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvRG9jdW1lbnRhdGlvbi9zY2hlZHVsZXIvc2NoZWQtZGVzaWduLUNGUy50eHQ=">https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt<i class="fa fa-external-link-alt"></i></span></p><p>调度实体sched_entity，虚拟运行时间vruntime</p><h3 id="RT调度器"><a href="#RT调度器" class="headerlink" title="RT调度器"></a>RT调度器</h3><p>实时调度器，Real Time Scheduler。一般使用优先级队列（priority queue）实现的</p><p>进程根据优先级（priority）</p><p>实时调度器调度的实时进程的优先级通常很高（优先级0-99，不同内核可能不太一样）</p><p>非实时的进程优先级在100-139</p><p>执行<code>ps</code>命令可以查看优先级，PRI这一列是优先级（priority），NI这一列是NICE值</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$ps</span> -elF S   <span class="token environment constant">UID</span>     PID    <span class="token environment constant">PPID</span>  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD<span class="token number">4</span> R     <span class="token number">0</span>       <span class="token number">1</span>       <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> - <span class="token number">25249</span> -      ?        00:00:07 systemd<span class="token number">1</span> S     <span class="token number">0</span>       <span class="token number">2</span>       <span class="token number">0</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:00 kthreadd<span class="token number">1</span> I     <span class="token number">0</span>       <span class="token number">3</span>       <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">60</span> -20 -     <span class="token number">0</span> -      ?        00:00:00 rcu_gp<span class="token number">1</span> I     <span class="token number">0</span>       <span class="token number">4</span>       <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">60</span> -20 -     <span class="token number">0</span> -      ?        00:00:00 rcu_par_gp<span class="token number">1</span> I     <span class="token number">0</span>       <span class="token number">6</span>       <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">60</span> -20 -     <span class="token number">0</span> -      ?        00:00:00 kworker/0:0H-events_highpri<span class="token number">1</span> I     <span class="token number">0</span>       <span class="token number">8</span>       <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">60</span> -20 -     <span class="token number">0</span> -      ?        00:00:00 mm_percpu_wq<span class="token number">1</span> S     <span class="token number">0</span>       <span class="token number">9</span>       <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:00 rcu_tasks_rude_<span class="token number">1</span> S     <span class="token number">0</span>      <span class="token number">10</span>       <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:00 rcu_tasks_trace<span class="token number">1</span> S     <span class="token number">0</span>      <span class="token number">11</span>       <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:08 ksoftirqd/0<span class="token number">1</span> I     <span class="token number">0</span>      <span class="token number">12</span>       <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:18 rcu_sched<span class="token number">1</span> S     <span class="token number">0</span>      <span class="token number">13</span>       <span class="token number">2</span>  <span class="token number">0</span> -40   - -     <span class="token number">0</span> -      ?        00:00:00 migration/0<span class="token number">1</span> S     <span class="token number">0</span>      <span class="token number">14</span>       <span class="token number">2</span>  <span class="token number">0</span>   <span class="token number">9</span>   - -     <span class="token number">0</span> -      ?        00:00:00 idle_inject/0<span class="token number">1</span> S     <span class="token number">0</span>      <span class="token number">16</span>       <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:00 cpuhp/0<span class="token number">5</span> S     <span class="token number">0</span>      <span class="token number">17</span>       <span class="token number">2</span>  <span class="token number">0</span>  <span class="token number">80</span>   <span class="token number">0</span> -     <span class="token number">0</span> -      ?        00:00:00 cpuhp/1<span class="token number">1</span> S     <span class="token number">0</span>      <span class="token number">18</span>       <span class="token number">2</span>  <span class="token number">0</span>   <span class="token number">9</span>   - -     <span class="token number">0</span> -      ?        00:00:00 idle_inject/1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多核"><a href="#多核" class="headerlink" title="多核"></a>多核</h3><p>CPU的每个核都有一个runqueue</p><h3 id="组调度"><a href="#组调度" class="headerlink" title="组调度"></a>组调度</h3><p>本来打算先跳过这一部分的，以后写cgroup的时候再说。但是这个东西对桌面的优化很重要，比如这个很老的补丁。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9YXJ0aWNsZSZpdGVtPWxpbnV4XzI2MzdfdmlkZW8mbnVtPTE=">The ~200 Line Linux Kernel Patch That Does Wonders<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJjLmluZm8vP2w9bGludXgta2VybmVsJm09MTI4OTc4MzYxNzAwODk4Jnc9Mg==">Re: [RFC&#x2F;RFT PATCH v3] sched: automated per tty task groups<i class="fa fa-external-link-alt"></i></span> </p><p>现在Linux的调度策略比较多，不同用户通过组调度进行资源的分配和隔离。说到这里你是不是想起了cgroup，对，这个东西就是用cgroup实现的。</p><h3 id="其他的调度器"><a href="#其他的调度器" class="headerlink" title="其他的调度器"></a>其他的调度器</h3><p>官方不支持调度器像kernel module一样做成可插拔的，所以其他魔改的调度策略通常单独做一个内核。</p><h2 id="适合桌面的进程调度"><a href="#适合桌面的进程调度" class="headerlink" title="适合桌面的进程调度"></a>适合桌面的进程调度</h2><p>Linux的一些设计和参数偏向服务器、嵌入式设备等用途，毕竟普通桌面用户的意见加起来都比不上半个红帽。<br>IO调度没关系，反正有个SSD就完全够了，用NOOP调度甚至直接不要IO调度都没关系。<br>进程调度就不太行了，默认的CFS (Completely Fair Scheduler)调度非常不适合日常桌面使用。<br>通常服务器多是I&#x2F;O密集型任务，而桌面（Desktop Enviroment，比如KDE和GNOME这种）需要快速响应（低延迟）和不断切换任务，CFS就不适合了（没法做到不断的切换优先级和抢占）。</p><p>比如编译、看视频CPU硬解码、玩游戏，负载高了之后，如果用CFS调度桌面会非常卡，极大影响体验。</p><p>好吧这不太符合Unix哲学，你在terminal里面用管道</p><p>麻醉师Con Kolivas针对桌面系统做的BFS（后来改名叫MuQSS了）</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXgtbWFnYXppbmUuY29tL3Zhci9saW51eF9tYWdhemluL3N0b3JhZ2UvaW1hZ2VzL21lZGlhL2xpbnV4LW1hZ2F6aW5lLWVuZy11cy9pbWFnZXMvbmV3cy1pbWFnZXMvY2FydG9vbi1mZWF0dXJlcy8zNjc5MDgtMS1lbmctVVMvQ2FydG9vbi1GZWF0dXJlc19tZWRpdW0ucG5n">https://www.linux-magazine.com/var/linux_magazin/storage/images/media/linux-magazine-eng-us/images/news-images/cartoon-features/367908-1-eng-US/Cartoon-Features_medium.png<i class="fa fa-external-link-alt"></i></span></p><h2 id="服务器进程调度"><a href="#服务器进程调度" class="headerlink" title="服务器进程调度"></a>服务器进程调度</h2><p>大多数服务器默认的CFS以及足够合适了。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1RlbmNlbnQvVGVuY2VudE9TLWtlcm5lbCMlRTclQTYlQkIlRTclQkElQkYlRTglQjAlODMlRTUlQkElQTYlRTclQUUlOTclRTYlQjMlOTVidA==">https://github.com/Tencent/TencentOS-kernel#离线调度算法bt<i class="fa fa-external-link-alt"></i></span></p><h2 id="更改进程调度"><a href="#更改进程调度" class="headerlink" title="更改进程调度"></a>更改进程调度</h2><h3 id="chrt更改调度策略"><a href="#chrt更改调度策略" class="headerlink" title="chrt更改调度策略"></a>chrt更改调度策略</h3><p>使用见<span class="exturl" data-url="aHR0cDovL2Jsb2cubHVqdW45OTcyLndpbi9ibG9nLzIwMTgvMDgvMjgvJUU0JUJEJUJGJUU3JTk0JUE4Y2hydCVFNCVCRiVBRSVFNiU5NCVCOSVFOCVCRiU5QiVFNyVBOCU4QiVFOCVCMCU4MyVFNSVCQSVBNiVFNyVBRCU5NiVFNyU5NSVBNSVFNSU4RiU4QSVFNCVCQyU5OCVFNSU4NSU4OCVFNyVCQSVBNy9pbmRleC5odG1s">使用chrt修改进程调度策略及优先级<i class="fa fa-external-link-alt"></i></span></p><h3 id="内核选择"><a href="#内核选择" class="headerlink" title="内核选择"></a>内核选择</h3><p><em>选择非官方支持的内核请谨慎，因为可能有很多不兼容的问题。</em>没有特别需求和强迫症还是推荐使用有官方支持的内核，比如Archlinux官方源支持维护&#96;&#96;linux<code>（没啥特殊偏好就这个呗），</code>linux-lts<code>（lts版，不想天天更新内核就用这个）， </code>linux-zen<code>（跟AMD的zen关系不太大，主要是针对桌面的），</code>linux-harended&#96;（有安全加固，会牺牲一定性能）</p><p><code>linux</code>这个包的调度器是CFS，大多数情况下表现都不差。（lts当然也是喽）</p><p>如果你是桌面用户，对性能和延迟有需求，可以试试linux-ck、linux-zen、linux-xanmod、linux-tgk等一堆针对桌面和性能优化的内核。<code>linux-ck</code>的调度器是MuQSS。xanmod的调度器可以选cauche。</p><p>我个人体验是xanmod内核的延迟最低（直接拯救了我玩空洞骑士时肉眼可见的延迟）。玩OSU音游的喜欢用linux-zen，这个包是官方维护，比较省心，xanmod延迟虽然跑分上比这个低，对延迟要求不苛刻、反应慢的，可能体验不出来太大区别。</p><p>（音游在Linux上的声音延迟应该是PulseAudio的锅，但是现在Pipewire又不稳，实际效果还不如PulseAudio,等pipewire稳定下来不知道要多久，只有打点补丁才能维持的了生活的样子。感谢这位玩家给wine-osu打的补丁<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnRoZXBvb24uZnIvb3N1TGludXhBdWRpb0xhdGVuY3kv">Low-latency osu! on Linux<i class="fa fa-external-link-alt"></i></span>）<br><em>关于游戏的题外话</em><br>Archlinux可以装gamemode和performance-tweaks（这个在chaotic-aur里面）。</p><p>xanmod实测见：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9YXJ0aWNsZSZpdGVtPXhhbm1vZC1saXF1b3JpeC01MTA=">XanMod’s Linux 5.10 Kernel Helping Tap Extra Performance With The AMD Ryzen 9 5900X<i class="fa fa-external-link-alt"></i></span><br>cuache相关讨论：<span class="exturl" data-url="aHR0cHM6Ly9mb3J1bS5lbmRlYXZvdXJvcy5jb20vdC9pbnRyb2R1Y2luZy10aGUtY2FjdWxlLXNjaGVkdWxlci1hLWNmcy1yZXBsYWNlbWVudC8xMzY0NA==">https://forum.endeavouros.com/t/introducing-the-cacule-scheduler-a-cfs-replacement/13644<i class="fa fa-external-link-alt"></i></span></p><p>如果要用btrfs或者cgroups，请注意MuQSS兼容性不太好。</p><p>Archlinux直接AUR编译就行了。不过很多人换ck内核是因为老机器性能不好，找一个编译好的源（比如repo-ck）或者在别的机子上编译一个吧。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzcyMDIyNy8=">https://lwn.net/Articles/720227/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXgtbWFnYXppbmUuY29tL09ubGluZS9OZXdzL0Nvbi1Lb2xpdmFzLUludHJvZHVjZXMtTmV3LUJGUy1TY2hlZHVsZXI=">https://www.linux-magazine.com/Online/News/Con-Kolivas-Introduces-New-BFS-Scheduler<i class="fa fa-external-link-alt"></i></span></p><p>为什么Linux CFS调度器没有带来惊艳的碾压效果<br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RvZzI1MC9hcnRpY2xlL2RldGFpbHMvOTY1MDAxODY=">Linux桌面GUI系统的调度器应该怎么做才不卡顿呢？<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RvZzI1MC9hcnRpY2xlL2RldGFpbHMvOTYzNjI3ODk=">为什么Windows&#x2F;iOS操作很流畅而Linux&#x2F;Android却很卡顿呢<i class="fa fa-external-link-alt"></i></span> dog250这位博主在CSDN上从2009年开始，一直在写，文章还不错（不要因为CSDN就不看啊，这是早期良心用户）。这样的稀有博主是我一直没舍得狠下心屏蔽CSDN的原因（颇有一种在垃圾坑里淘宝的感觉）</p><p><span class="exturl" data-url="aHR0cHM6Ly9kcmF2ZW5lc3MubWUvc3lzdGVtLWRlc2lnbi1zY2hlZHVsZXIv">调度系统设计精要 - 面向信仰编程<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2NrLmtvbGl2YXMub3JnLw==">http://ck.kolivas.org/<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9saXF1b3JpeC5uZXQv">https://liquorix.net/<i class="fa fa-external-link-alt"></i></span> 这个内核是基于zen内核加了一些其他的补丁和改动（有ck补丁，但是没有MuQSS，原因<code>I&#39;m severely prejudiced against MuQSS, so it will continue &quot;giving a null&quot;.</code>, 见这里<span class="exturl" data-url="aHR0cHM6Ly9idWdzLmFyY2hsaW51eC5vcmcvdGFzay81NjMxMiVFRiVCQyU4OQ==">https://bugs.archlinux.org/task/56312）<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9wZW9wbGUuZWNlLnViYy5jYS9zYXNoYS9wYXBlcnMvZXVyb3N5czE2LWZpbmFsMjkucGRm">The Linux Scheduler: a Decade of Wasted Cores<i class="fa fa-external-link-alt"></i></span> 讲多核的</p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmloeXBvLm5ldC8xNTI3OTU1NzcwOTY4NS5odG1s">https://blog.ihypo.net/15279557709685.html<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cDovL2xpbnV4cGVyZi5jb20vP3A9NDI=">http://linuxperf.com/?p=42<i class="fa fa-external-link-alt"></i></span></p><!-- https://blog.csdn.net/XD_hebuters/article/details/79623130https://cloud.tencent.com/developer/article/1603970https://cloud.tencent.com/developer/article/1603974 --><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaGVsbG9raXR0eTIvcC8xNDE5OTc0MS5odG1s">https://www.cnblogs.com/hellokitty2/p/14199741.html<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZWFuYXJraC9yZWFkLWxpbnV4LTAuMTE=">https://github.com/theanarkh/read-linux-0.11<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cDovL3d3dy53b3dvdGVjaC5uZXQvcHJvY2Vzc19tYW5hZ2VtZW50LzQ0OS5odG1s">http://www.wowotech.net/process_management/449.html<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTG95ZW5XYW5nL3AvMTI0NTkwMDAuaHRtbA==">Linux进程调度-组调度及带宽控制<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;用了一周linux-ck和MuQSS，发现没有想象中的那么好。哦，这还要从一个麻醉师说起。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="Linux" scheme="https://zhangjk98.xyz/tags/Linux/"/>
    
    <category term="scheduler" scheme="https://zhangjk98.xyz/tags/scheduler/"/>
    
  </entry>
  
</feed>
