<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>止息的博客</title>
  
  <subtitle>唯见月寒日暖，来煎人寿</subtitle>
  <link href="https://zhangjk98.xyz/atom.xml" rel="self"/>
  
  <link href="https://zhangjk98.xyz/"/>
  <updated>2022-05-07T08:38:17.000Z</updated>
  <id>https://zhangjk98.xyz/</id>
  
  <author>
    <name>Zhang.j.k</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS144 Lab0 笔记：环境配置和热身</title>
    <link href="https://zhangjk98.xyz/cs144-note/"/>
    <id>https://zhangjk98.xyz/cs144-note/</id>
    <published>2022-05-07T08:38:17.000Z</published>
    <updated>2022-05-07T08:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>写习惯了go之后c&#x2F;cpp水平直线下滑，每三行都有一行忘了加分号。麻了，全靠clang-tidy和报错clang报错救我狗命</p><span id="more"></span><h2 id="关于cs144"><a href="#关于cs144" class="headerlink" title="关于cs144"></a>关于cs144</h2><p>cs144的Lab是实现一个TCP协议栈，可惜是用C++写的，而且那个代码风格我也不怎么喜欢。我C++水平很菜，基本写东西都是C with Class 风格的。而且我不怎么喜欢 Modern C++， 所以不会按照Lab的要求（比如用迭代器代替循环、不使用malloc&#x2F;free之类的东西、使用智能指针等）</p><h3 id="做了几个Lab之后的更新"><a href="#做了几个Lab之后的更新" class="headerlink" title="做了几个Lab之后的更新"></a>做了几个Lab之后的更新</h3><p>做了三个Lab了回来说一下，这个课程的讲解和Lab的参考材料非常不详细，不像6.S081那样有不少Hints，各种讲解和助教的大作业FAQ什么的也把容易踩坑的地方都提到了。于是CS144的Lab做起来就很麻，颇有一种<code>fly bitch!</code>的感觉。</p><p><img src="/cs144-note/1652191785.png"></p><p>我做这个东西人麻了的程度甚至比6.824那一堆race条件debug找不出来还要麻。6.824实现Raft好好看论文和资料，大概知道Raft的状态转移和实现思路，剩下的是漫长的debug和race条件抓虫。这个不一样，这个好多思路和细节Lab根本不告诉你，然后实现的时候脑子是懵的，经常不知道干嘛，完全没有思路。然后翻了半天《TCP&#x2F;IP详解：卷2》，然后各种乱找资料</p><p>而且golang我用的比c++，尤其是modern c++熟太多了。然后这个Lab的各种命名也不像xv6那种unix和POSIX风格的精简</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>Archlinux下装这些包很简单，直接把<span class="exturl" data-url="aHR0cHM6Ly9zdGFuZm9yZC5lZHUvY2xhc3MvY3MxNDQvdm1faG93dG8vdm0taG93dG8tYnlvLmh0bWw=">BYO Linux installation<i class="fa fa-external-link-alt"></i></span> 列出来的包用pacman装一遍就好了</p><p>需要注意的是NetworkManger要配置一下忽略实验用的虚拟设备。</p><h2 id="Lab-0"><a href="#Lab-0" class="headerlink" title="Lab 0"></a>Lab 0</h2><p>前面几个Lab是用一下telnet和nc玩，跳过（nc用的不多，我还是习惯nmap）</p><h3 id="webget"><a href="#webget" class="headerlink" title="webget"></a>webget</h3><p>准备环境：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/cs144/sponge <span class="token builtin class-name">cd</span> sponge<span class="token function">mkdir</span> build<span class="token builtin class-name">cd</span> build<span class="token comment"># 我比较喜欢用clang，报错比较舒服</span><span class="token assign-left variable">CC</span><span class="token operator">=</span>clang <span class="token assign-left variable">CXX</span><span class="token operator">=</span>clang++ cmake <span class="token punctuation">..</span><span class="token function">make</span> -j12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个很简单，直接照着<code>TCPSocket</code>的文档改就可以了， 见 <span class="exturl" data-url="aHR0cHM6Ly9jczE0NC5naXRodWIuaW8vZG9jL2xhYjAvY2xhc3NfdF9jX3Bfc29ja2V0Lmh0bWw=">https://cs144.github.io/doc/lab0/class_t_c_p_socket.html<i class="fa fa-external-link-alt"></i></span></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">get_URL</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>host<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Your code here.</span>    TCPSocket sock1<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    sock1<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token function">Address</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> <span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock1<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"GET "</span> <span class="token operator">+</span> path <span class="token operator">+</span> <span class="token string">" HTTP/1.1\r\nHost: "</span> <span class="token operator">+</span> host <span class="token operator">+</span> <span class="token string">"\r\n\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    sock1<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span>SHUT_WR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>sock1<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        cout <span class="token operator">&lt;&lt;</span> sock1<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    sock1<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后编译并测试</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">make</span> webget<span class="token function">make</span> check_webget<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="An-in-memory-reliable-byte-stream"><a href="#An-in-memory-reliable-byte-stream" class="headerlink" title="An in-memory reliable byte stream"></a>An in-memory reliable byte stream</h3><p>实现一个内存中有序的字节流。这个算是开胃菜，TCP是在不可靠的网络下实现有序的字节流。这里不要求并发和加锁，所以只要一个非常简单的队列+buffer缓冲就可以了。</p><blockquote><p>Your byte stream is for use in a single thread—you don’t have to worry about concurrent writers&#x2F;readers, locking, or race conditions.</p></blockquote><p>看到这句话之前我还以为这个Lab要折腾menory barrier那些东西，这样就好办了。</p><p>第一反应是整一个像kqueue那样的循环队列，可是这个Lab的C++风格他不让我用指针，习惯了c风格好难受。算了算了上stl吧。字节流那就直接用队列吧。然后这个类里面再加上是容量（capacity），写入字节，读取字节、是否结束，就差不多了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ByteStream</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">private</span><span class="token operator">:</span>    <span class="token comment">// Your code here -- add private members as necessary.</span>    std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> _buffer<span class="token punctuation">;</span>    size_t _capacity<span class="token punctuation">;</span>    <span class="token keyword">bool</span> _input_end<span class="token punctuation">;</span>    size_t _byte_written<span class="token punctuation">;</span>    size_t _byte_read<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们分别实现这几个类的方法，write好办，注意一下长度就行了。这里要求编码规范是Modern C++, 但是我Modern C++ 不熟，也没怎么用迭代器，蠢蠢的扔了好多for循环之类的东西</p><p>write就是一个简单的队尾出队，然后<code>_byte_written</code>计数增加</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">size_t <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_input_end <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    size_t _data_length <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_data_length <span class="token operator">+</span> _buffer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> _capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        _data_length <span class="token operator">=</span> _capacity <span class="token operator">-</span> _buffer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    _byte_written <span class="token operator">+=</span> _data_length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _data_length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        _buffer<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> _data_length<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>peek好办，直接拼成字符串就行了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// peek的时候输出是一个string</span><span class="token comment">//! \param[in] len bytes will be copied from the output side of the buffer</span>string <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">peek_output</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t len<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>    size_t _length <span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_length <span class="token operator">></span> _buffer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        _length <span class="token operator">=</span> _buffer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    string <span class="token function">str</span><span class="token punctuation">(</span>_buffer<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> _buffer<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> _length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pop_output</code>也简单，注意一下长度然后从队列头部pop就好了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// buffer里面弹出长度为len的字节，需要考虑len > _buffer.size()的情况</span><span class="token comment">//! \param[in] len bytes will be removed from the output side of the buffer</span><span class="token keyword">void</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">pop_output</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    size_t _data_length <span class="token operator">=</span> len<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>_data_length <span class="token operator">></span> _buffer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        _data_length <span class="token operator">=</span> _buffer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> _data_length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        _buffer<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        _byte_read<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后read就是先<code>peek_output</code>再<code>pop_output</code>，</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 写端的read，注意需要pop_ouput, 读出来之后需要pop的</span>std<span class="token double-colon punctuation">::</span>string <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    string output <span class="token operator">=</span> <span class="token function">peek_output</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">pop_output</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> output<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后这一堆方法就直接返回相应的值就好了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">end_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> _input_end <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">input_ended</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _input_end<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>size_t <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _buffer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">buffer_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _buffer<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token keyword">bool</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _input_end<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>size_t <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_written</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _byte_written<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>size_t <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">bytes_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _byte_read<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>size_t <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">remaining_capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _capacity <span class="token operator">-</span> _buffer<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>emmmmm, 然后<code>make check_lab0</code>有两个test没过，看一下报错<code>Failure message:        The ByteStream should have had eof equal to 0 but instead it was 1</code></p><p>哦，忘了设置EOF了。不对我设了，那是哪出问题了。。。找了五分钟发现EOF要加上队列empty的条件，我是傻逼</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">ByteStream</span><span class="token double-colon punctuation">::</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _input_end <span class="token operator">&amp;&amp;</span> <span class="token function">buffer_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样测试就过了</p><h2 id="链接和参考材料"><a href="#链接和参考材料" class="headerlink" title="链接和参考材料"></a>链接和参考材料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9jczE0NC5naXRodWIuaW8v">https://cs144.github.io/<i class="fa fa-external-link-alt"></i></span> 课程主页<br>还有视频录像不过我不喜欢看视频，没看，直接上的Lab<br>《TCP&#x2F;IP详解 卷2》 这个有不少实现的细节, Lab讲的不详细我基本上都是跑到这里面翻的<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z6eXo5OTkvQW5hbHlzaXNfVENQX2luX0xpbnV4">Linux 4.4.0内核源码分析——TCP实现<i class="fa fa-external-link-alt"></i></span> 太感动了这个资料，注释极为详细（不过linux协议栈的实现很复杂，适合没思路的时候偶尔翻翻找找灵感，这个Lab的实现一般都很Naive，差别很大不适合照抄）  </p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NhbWluaWlyL2xldmVsLWlw">level-ip<i class="fa fa-external-link-alt"></i></span> 一个用户态玩具TCP&#x2F;IP协议栈，c写的<br>我最开始先看的这个，对TCP&#x2F;IP协议栈有个大概的概念，感觉这个看过一遍有了点头绪，CS144的Lab指导看完对整个TCP&#x2F;IP协议栈是啥样的没啥头绪<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stMS1ldGhlcm5ldC1hcnAv">Let’s code a TCP&#x2F;IP stack, 1: Ethernet &amp; ARP<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stMi1pcHY0LWljbXB2NC8=">Let’s code a TCP&#x2F;IP stack, 2: IPv4 &amp; ICMPv4<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stMy10Y3AtaGFuZHNoYWtlLw==">Let’s code a TCP&#x2F;IP stack, 3: TCP Basics &amp; Handshake<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stNC10Y3AtZGF0YS1mbG93LXNvY2tldC1hcGkv">Let’s code a TCP&#x2F;IP stack, 4: TCP Data Flow &amp; Socket API<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2FtaW5paXIuY29tL2xldHMtY29kZS10Y3AtaXAtc3RhY2stNS10Y3AtcmV0cmFuc21pc3Npb24v">Let’s code a TCP&#x2F;IP stack, 5: TCP Retransmission<i class="fa fa-external-link-alt"></i></span>  </p><p>然后是对写这门课的Lab可能帮助不是特别大的书和资料(资料本身其实都还不错)</p><p>《TCP&#x2F;IP详解 卷1》 这个主要讲概念，看完一遍之后还是不知道怎么实现，如果是为了做Lab找资料推荐直接翻卷2<br>《计算机网络: 自顶向下方法》这个书好是好，但是讲的太简略了，看完想实现没啥头绪，还得去TCP&#x2F;IP协议卷2翻细节，这本书的协议栈实现讲的是<code>4.4BSD-Lite</code>，<br>《深入理解LINUX网络技术内幕》大量的章节都在讲网络驱动，和这门课的Lab的TCP协议栈的内容关系不是特别大<br>《Effective Modern C++ 中文版》 这本书我研一买的，彩色印刷，包装很烂。我当时就想看看modern c++，然后看到一半彻底对C++喜欢不起来了。当时我唯一的想法就是不要把有限的生命浪费在一个充斥着语言律师的语言上。那个时候还在看《The Little Schemer》，看那些优雅连贯的递归的奇妙感觉，和同时在看的c++的繁杂形成了鲜明的对比。也是在那会，被C++坑的多了突然喜欢上go了。  </p><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby9lbmcvMjAxNy8wMi8wNi9tb25pdG9yaW5nLXR1bmluZy1saW51eC1uZXR3b3JraW5nLXN0YWNrLXNlbmRpbmctZGF0YQ==">Monitoring and Tuning the Linux Networking Stack: Sending Data<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnBhY2thZ2VjbG91ZC5pby9lbmcvMjAxNi8wNi8yMi9tb25pdG9yaW5nLXR1bmluZy1saW51eC1uZXR3b3JraW5nLXN0YWNrLXJlY2VpdmluZy1kYXRhLw==">Monitoring and Tuning the Linux Networking Stack: Receiving Data<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2FydGh1cmNoaWFvLmFydC9ibG9nL3R1bmluZy1zdGFjay10eC16aC8=">[译] Linux 网络栈监控和调优：发送数据（2017）<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2FydGh1cmNoaWFvLmFydC9ibG9nL3R1bmluZy1zdGFjay1yeC16aC8=">[译] Linux 网络栈监控和调优：接收数据（2016）<i class="fa fa-external-link-alt"></i></span>  这两篇文章适合做完Lab再看，很容易迷失在细节里面  </p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzExODAudHh0">A TCP&#x2F;IP Tutorial<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cDovL2FydGh1cmNoaWFvLmFydC9ibG9nL3JmYzExODAtYS10Y3AtaXAtdHV0b3JpYWwtemgv">[译] RFC 1180：朴素 TCP&#x2F;IP 教程（1991）<i class="fa fa-external-link-alt"></i></span><br>我一开始还以为是实现一个TCP协议栈的，点开才发现很老的一个简短介绍，大概相当于TCP&#x2F;IP卷1的太长不看版。其实讲的还可以，没有一点废话，不过对Lab没啥帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写习惯了go之后c&amp;#x2F;cpp水平直线下滑，每三行都有一行忘了加分号。麻了，全靠clang-tidy和报错clang报错救我狗命&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="network" scheme="https://zhangjk98.xyz/tags/network/"/>
    
    <category term="cs144" scheme="https://zhangjk98.xyz/tags/cs144/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Networking 笔记，完结撒花</title>
    <link href="https://zhangjk98.xyz/6-S081-lab-network-driver/"/>
    <id>https://zhangjk98.xyz/6-S081-lab-network-driver/</id>
    <published>2022-05-05T09:15:11.000Z</published>
    <updated>2022-05-05T09:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个Lab就是补全一个DMA收发的驱动, 不要被Lab标的Hard难度吓到，我感觉这是6.S081这几个Lab最简单的几个Lab之一。写个驱动都不用上板子调试，没啥意思，怎么感觉比当年你电PPT吹水课程微嵌的实验大作业给FPGA的板子写个驱动还水。。。<br>最后一个Lab放水，愉快的完结撒花。等等，这个Lab还有附加内容，实现一个TCP&#x2F;UDP协议栈。。。</p><span id="more"></span><h2 id="Lab内容"><a href="#Lab内容" class="headerlink" title="Lab内容"></a>Lab内容</h2><p>做起来这个Lab挺没意思的，e1000这种远古网卡</p><blockquote><p>Your job is to complete e1000_transmit() and e1000_recv(), both in kernel&#x2F;e1000.c, so that the driver can transmit and receive packets</p></blockquote><p>这个好办，我们直接扒拉e1000的手册就可以了。</p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>又是讨厌的驱动，勾起了我当年痛苦的。上一次写驱动的大作业还是本科的时候，当时换了两块xilinx的阴间开发板全都是坏的，害得我还以为是我自己写的有问题，找了一周没找到bug。本来是抱着人又麻了的</p><p>好久之前写的Lab，由于懒癌发作一直没有写笔记，现在把Lab的笔记补上。这个Lab比较玩具，没啥好讲的。驱动和网络单独拿出来都是一个大坑，水平有限不多讲了。</p><p>这个Lab的Optional Challenges比较麻烦，其中最后两个challenge是：</p><blockquote><p>Implement a UDP server for xv6. (moderate)<br>Implement a minimal TCP stack and download a web page. (hard)</p></blockquote><p>由于懒癌发作我当然又是没做，我的菜鸡计网水平和对TCP的熟悉程度应该一时半会做不出来。听说有cs144这门课就是实现一个TCP协议栈，等研三有空了回头把这个做了把这个大坑填上。</p><p>6.S081这个课从去年7月开始，断断续续做了将近一年把Lab做了，xv6的源码看了不到一半。xv6作为一个教学的系统，挺精简挺小巧，能比较顺利的看下去。像linux源码那种看不太动，拿着赵炯那本《linux内核完全注释》看早期内核也比较麻烦。xv6-book写的真的好，推荐做Lab和读xv6源码的时候好好把xv6-book看一下：</p><p><em>xv6: a simple, Unix-like teaching operating system</em><br>作者Russ Cox, Frans Kaashoek, Robert Morris 应该都听过，Russ Cox是争议比较大的go现任掌门，喜欢在go的issue区开喷，Morris是6.824这门课的主讲，就是那个蠕虫病毒的作者。</p><p>一开始我没在意，觉得这本书就是跟手册一样，偶尔翻一翻。后来发现这本册子写的是真的好，几乎没有一点废话，比课程讲义好多了。早应该看这个的。</p><p>更新：不等研三了，直接上CS144了。之前没事喜欢摆弄nmap、wireshark这些东西瞎玩，却没好好看过TCP的细节，再这样不思进取下去就要沦为脚本小子了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个Lab就是补全一个DMA收发的驱动, 不要被Lab标的Hard难度吓到，我感觉这是6.S081这几个Lab最简单的几个Lab之一。写个驱动都不用上板子调试，没啥意思，怎么感觉比当年你电PPT吹水课程微嵌的实验大作业给FPGA的板子写个驱动还水。。。&lt;br&gt;最后一个Lab放水，愉快的完结撒花。等等，这个Lab还有附加内容，实现一个TCP&amp;#x2F;UDP协议栈。。。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="network" scheme="https://zhangjk98.xyz/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>又被Docker坑了（这次是内存</title>
    <link href="https://zhangjk98.xyz/aware-docker-memory/"/>
    <id>https://zhangjk98.xyz/aware-docker-memory/</id>
    <published>2022-04-24T14:07:46.000Z</published>
    <updated>2022-04-24T14:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>好端端一个Docker container，怎么就内存占用过高被kill了呢</p><span id="more"></span><p>好吧这好像也不全算Docker的锅，罪魁祸首竟是dentry</p><h2 id="dentry还我内存"><a href="#dentry还我内存" class="headerlink" title="dentry还我内存"></a>dentry还我内存</h2><p>发现是dentry的锅</p><h2 id="Docker的一些替代品"><a href="#Docker的一些替代品" class="headerlink" title="Docker的一些替代品"></a>Docker的一些替代品</h2><p>说起来当时把那几台老的Ubuntu16.04和远古版本的</p><p>Docker看起来简单但是坑真的不算少，要用好Docker（很多人是图方便才来用Docker的）</p><p>如果只是日常使用为了装一些软件或依赖方便呢，装一个Archlinux显然更方便（这比搞懂Docker那一堆网络、layer、）</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYXJkYW5sYWJzLmNvbS9ibG9nLzIwMjAvMDIvZG9ja2VyLWltYWdlcy1wYXJ0MS1yZWR1Y2luZy1pbWFnZS1zaXplLmh0bWw=">https://www.ardanlabs.com/blog/2020/02/docker-images-part1-reducing-image-size.html<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MzEzMzA4NQ==">https://zhuanlan.zhihu.com/p/43133085<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmFyc3RlcmN6LmNvbS9jZW50b3MtJUU3JUIzJUJCJUU3JUJCJTlGLXNsYWItZGVudHJ5LSVFOCVCRiU4NyVFOSVBQiU5OCVFNSVCQyU5NSVFOCVCNSVCNyVFNyVCMyVCQiVFNyVCQiU5RiVFNSU4RCVBMSVFOSVBMSVCRiVFNSU4OCU4NiVFNiU5RSU5MCVFNSVBNCU4NCVFNyU5MCU4Ni8=">https://blog.arstercz.com/centos-系统-slab-dentry-过高引起系统卡顿分析处理/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9oYWNrZXJub29uLmNvbS9hbm90aGVyLXJlYXNvbi13aHkteW91ci1kb2NrZXItY29udGFpbmVycy1tYXktYmUtc2xvdy1kMzcyMDdkZWMyN2Y=">https://hackernoon.com/another-reason-why-your-docker-containers-may-be-slow-d37207dec27f<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZ2FvZ2FvNjcvYXJ0aWNsZXMvMTU1NjgzNzguaHRtbA==">https://www.cnblogs.com/gaogao67/articles/15568378.html<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;好端端一个Docker container，怎么就内存占用过高被kill了呢&lt;/p&gt;</summary>
    
    
    
    
    <category term="Docker" scheme="https://zhangjk98.xyz/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Multithreading 笔记</title>
    <link href="https://zhangjk98.xyz/6-S081-lab-multithreading/"/>
    <id>https://zhangjk98.xyz/6-S081-lab-multithreading/</id>
    <published>2022-04-20T11:27:58.000Z</published>
    <updated>2022-04-20T11:27:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个用户态线程uthread，就照着xv6的内核态线程抄呗。怎么什么FUSE啊、UIO啊，什么东西都想往用户态搬啊，连RCU都有人想往用户态搬。</p><span id="more"></span><h2 id="xv6中的process"><a href="#xv6中的process" class="headerlink" title="xv6中的process"></a>xv6中的process</h2><h3 id="process的状态"><a href="#process的状态" class="headerlink" title="process的状态"></a>process的状态</h3><p>xv6的线程状态包括 UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE</p><p><img src="/6-S081-lab-multithreading/1650459636.png"></p><h3 id="process调度"><a href="#process调度" class="headerlink" title="process调度"></a>process调度</h3><p>用户态进程的切换是需要内核态的 kstack scheduler的</p><p><img src="/6-S081-lab-multithreading/1650459961.png"></p><p>我们下面来看调度过程，相比linux里面的调度器这个简单多了。就是一个最简单的时间片轮转。</p><p>首先我们看proc这个结构体（就相当于linux里面的task这个结构体）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Per-process state</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> lock<span class="token punctuation">;</span>  <span class="token comment">// p->lock must be held when using these:</span>  <span class="token keyword">enum</span> <span class="token class-name">procstate</span> state<span class="token punctuation">;</span>        <span class="token comment">// Process state</span>  <span class="token keyword">void</span> <span class="token operator">*</span>chan<span class="token punctuation">;</span>                  <span class="token comment">// If non-zero, sleeping on chan</span>  <span class="token keyword">int</span> killed<span class="token punctuation">;</span>                  <span class="token comment">// If non-zero, have been killed</span>  <span class="token keyword">int</span> xstate<span class="token punctuation">;</span>                  <span class="token comment">// Exit status to be returned to parent's wait</span>  <span class="token keyword">int</span> pid<span class="token punctuation">;</span>                     <span class="token comment">// Process ID</span>  <span class="token comment">// wait_lock must be held when using this:</span>  <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>parent<span class="token punctuation">;</span>         <span class="token comment">// Parent process</span>  <span class="token comment">// these are private to the process, so p->lock need not be held.</span>  uint64 kstack<span class="token punctuation">;</span>               <span class="token comment">// Virtual address of kernel stack</span>  uint64 sz<span class="token punctuation">;</span>                   <span class="token comment">// Size of process memory (bytes)</span>  <span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">;</span>       <span class="token comment">// User page table</span>  <span class="token keyword">struct</span> <span class="token class-name">trapframe</span> <span class="token operator">*</span>trapframe<span class="token punctuation">;</span> <span class="token comment">// data page for trampoline.S</span>  <span class="token keyword">struct</span> <span class="token class-name">context</span> context<span class="token punctuation">;</span>      <span class="token comment">// swtch() here to run process</span>  <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span>ofile<span class="token punctuation">[</span>NOFILE<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// Open files</span>  <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>cwd<span class="token punctuation">;</span>           <span class="token comment">// Current directory</span>  <span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token comment">// Process name (debugging)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在process切换的时候，保存proc的trapframe和context用来恢复，然后还有proc的状态（STATE）、pid等。</p><p>在切换的时候主要的工作是context和trapframe的保存和恢复。context被翻译成上下文，然后当年书里说半天我也没搞懂这到底是个啥玩意。后来看了xv6的源码才知道这是个啥。到底是谁最先把context翻译成上下文的啊？？？？ 我们直接看源码， <code>kernel/proc.h</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Saved registers for kernel context switches.</span><span class="token keyword">struct</span> <span class="token class-name">context</span> <span class="token punctuation">&#123;</span>  uint64 ra<span class="token punctuation">;</span> # <span class="token keyword">return</span> address<span class="token punctuation">,</span> 返回地址  uint64 sp<span class="token punctuation">;</span> # stack pointer，栈指针寄存器  <span class="token comment">// callee-saved</span>  uint64 s0<span class="token punctuation">;</span>  uint64 s1<span class="token punctuation">;</span>  uint64 s2<span class="token punctuation">;</span>  uint64 s3<span class="token punctuation">;</span>  uint64 s4<span class="token punctuation">;</span>  uint64 s5<span class="token punctuation">;</span>  uint64 s6<span class="token punctuation">;</span>  uint64 s7<span class="token punctuation">;</span>  uint64 s8<span class="token punctuation">;</span>  uint64 s9<span class="token punctuation">;</span>  uint64 s10<span class="token punctuation">;</span>  uint64 s11<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>context是一个结构体，里面是寄存器的值（用来保存和恢复process的状态）</p><p>trapframe也是一个结构体，放的东西更多了点。比如process的内核页表、比如kernel_sp寄存器，比如epc寄存器</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">trapframe</span> <span class="token punctuation">&#123;</span>  <span class="token comment">/*   0 */</span> uint64 kernel_satp<span class="token punctuation">;</span>   <span class="token comment">// kernel page table</span>  <span class="token comment">/*   8 */</span> uint64 kernel_sp<span class="token punctuation">;</span>     <span class="token comment">// top of process's kernel stack</span>  <span class="token comment">/*  16 */</span> uint64 kernel_trap<span class="token punctuation">;</span>   <span class="token comment">// usertrap()</span>  <span class="token comment">/*  24 */</span> uint64 epc<span class="token punctuation">;</span>           <span class="token comment">// saved user program counter</span>  <span class="token comment">/*  32 */</span> uint64 kernel_hartid<span class="token punctuation">;</span> <span class="token comment">// saved kernel tp</span>  <span class="token comment">/*  40 */</span> uint64 ra<span class="token punctuation">;</span>  <span class="token comment">/*  48 */</span> uint64 sp<span class="token punctuation">;</span>  <span class="token comment">/*  56 */</span> uint64 gp<span class="token punctuation">;</span>  <span class="token comment">/*  64 */</span> uint64 tp<span class="token punctuation">;</span>  <span class="token comment">/*  72 */</span> uint64 t0<span class="token punctuation">;</span>  <span class="token comment">/*  80 */</span> uint64 t1<span class="token punctuation">;</span>  <span class="token comment">/*  88 */</span> uint64 t2<span class="token punctuation">;</span>  <span class="token comment">/*  96 */</span> uint64 s0<span class="token punctuation">;</span>  <span class="token comment">/* 104 */</span> uint64 s1<span class="token punctuation">;</span>  <span class="token comment">/* 112 */</span> uint64 a0<span class="token punctuation">;</span>  <span class="token comment">/* 120 */</span> uint64 a1<span class="token punctuation">;</span>  <span class="token comment">/* 128 */</span> uint64 a2<span class="token punctuation">;</span>  <span class="token comment">/* 136 */</span> uint64 a3<span class="token punctuation">;</span>  <span class="token comment">/* 144 */</span> uint64 a4<span class="token punctuation">;</span>  <span class="token comment">/* 152 */</span> uint64 a5<span class="token punctuation">;</span>  <span class="token comment">/* 160 */</span> uint64 a6<span class="token punctuation">;</span>  <span class="token comment">/* 168 */</span> uint64 a7<span class="token punctuation">;</span>  <span class="token comment">/* 176 */</span> uint64 s2<span class="token punctuation">;</span>  <span class="token comment">/* 184 */</span> uint64 s3<span class="token punctuation">;</span>  <span class="token comment">/* 192 */</span> uint64 s4<span class="token punctuation">;</span>  <span class="token comment">/* 200 */</span> uint64 s5<span class="token punctuation">;</span>  <span class="token comment">/* 208 */</span> uint64 s6<span class="token punctuation">;</span>  <span class="token comment">/* 216 */</span> uint64 s7<span class="token punctuation">;</span>  <span class="token comment">/* 224 */</span> uint64 s8<span class="token punctuation">;</span>  <span class="token comment">/* 232 */</span> uint64 s9<span class="token punctuation">;</span>  <span class="token comment">/* 240 */</span> uint64 s10<span class="token punctuation">;</span>  <span class="token comment">/* 248 */</span> uint64 s11<span class="token punctuation">;</span>  <span class="token comment">/* 256 */</span> uint64 t3<span class="token punctuation">;</span>  <span class="token comment">/* 264 */</span> uint64 t4<span class="token punctuation">;</span>  <span class="token comment">/* 272 */</span> uint64 t5<span class="token punctuation">;</span>  <span class="token comment">/* 280 */</span> uint64 t6<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说一下trapframe和context的区别，context保存的是线程切换（比如调度器切换线程）时候的数据（寄存器），trapframe保存的是trap的时候（切换内核态时候）的数据</p><h4 id="运行状态切换"><a href="#运行状态切换" class="headerlink" title="运行状态切换"></a>运行状态切换</h4><p>进入RUNNING是由<code>scheduler</code>处理的，这里就直接是一个简单的for循环，加锁找到可用的直接将状态变成RUNNING释放锁。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token function">scheduler</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">cpu</span> <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">mycpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c<span class="token operator">-></span>proc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// Avoid deadlock by ensuring that devices can interrupt.</span>    <span class="token function">intr_on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>state <span class="token operator">==</span> RUNNABLE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Switch to chosen process.  It is the process's job</span>        <span class="token comment">// to release its lock and then reacquire it</span>        <span class="token comment">// before jumping back to us.</span>        p<span class="token operator">-></span>state <span class="token operator">=</span> RUNNING<span class="token punctuation">;</span>        c<span class="token operator">-></span>proc <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token function">swtch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token operator">-></span>context<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p<span class="token operator">-></span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 保存context（上下文）</span>        <span class="token comment">// Process is done running for now.</span>        <span class="token comment">// It should have changed its p->state before coming back.</span>        c<span class="token operator">-></span>proc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里swtch是保存并切换context。<code>swtch(&amp;c-&gt;context, &amp;p-&gt;context);</code>表示保存c的context, 加载p的context。我们直接看一下<code>swtch.S</code>的代码就明白了：</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">.globl swtchswtch:        sd ra<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd sp<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s0<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        .......        ld ra<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>        ld sp<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>        ld s0<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>        .......        ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>退出的过程是调用了<code>yield</code>，从RUNNING进入RUNNABLE</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Give up the CPU for one scheduling round.</span><span class="token keyword">void</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里也要加一个自旋锁，如果不加，在yield过程中来一个中断之类的会出问题</span>  p<span class="token operator">-></span>state <span class="token operator">=</span> RUNNABLE<span class="token punctuation">;</span>  <span class="token function">sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这里调用sched切换进程（恢复上下文等操作）</span>  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>yield 调用了 sched</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token function">sched</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> intena<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">holding</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 必须持有锁</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"sched p->lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">mycpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>noff <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">//中断是关的</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"sched locks"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>state <span class="token operator">==</span> RUNNING<span class="token punctuation">)</span>   <span class="token comment">//之前已经设为RUNNABLE，肯定不能是RUNNING</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"sched running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">intr_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// 中断不能是enabled</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"sched interruptible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  intena <span class="token operator">=</span> <span class="token function">mycpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>intena<span class="token punctuation">;</span> <span class="token comment">//将itena置为当前CPU的itena</span>  <span class="token function">swtch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>context<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token function">mycpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//恢复context（上下文）</span>  <span class="token function">mycpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>intena <span class="token operator">=</span> intena<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说一下这个itena，定义在<code>kernel/proc.h</code>中，就是中断（interrupt）是否在push_off之前enable了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Per-CPU state.</span><span class="token keyword">struct</span> <span class="token class-name">cpu</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>proc<span class="token punctuation">;</span>          <span class="token comment">// The process running on this cpu, or null.</span>  <span class="token keyword">struct</span> <span class="token class-name">context</span> context<span class="token punctuation">;</span>     <span class="token comment">// swtch() here to enter scheduler().</span>  <span class="token keyword">int</span> noff<span class="token punctuation">;</span>                   <span class="token comment">// Depth of push_off() nesting.</span>  <span class="token keyword">int</span> intena<span class="token punctuation">;</span>                 <span class="token comment">// Were interrupts enabled before push_off()?</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从RUNNING退出到别的状态可能是收到了中断，也可能是进入SLEEPING（比如耗时较长的文件IO），也可能是被kill了或者父进程被kill了进入了ZOMBIE状态</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token function">kill</span><span class="token punctuation">(</span><span class="token keyword">int</span> pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pid <span class="token operator">==</span> pid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      p<span class="token operator">-></span>killed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>state <span class="token operator">==</span> SLEEPING<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// Wake process from sleep().</span>        p<span class="token operator">-></span>state <span class="token operator">=</span> RUNNABLE<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h4><p>wakeup比较简单，就正常的加锁然后置为RUNNABLE就好了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Wake up all processes sleeping on chan.</span><span class="token comment">// Must be called without any p->lock.</span><span class="token keyword">void</span><span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>chan<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>state <span class="token operator">==</span> SLEEPING <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>chan <span class="token operator">==</span> chan<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        p<span class="token operator">-></span>state <span class="token operator">=</span> RUNNABLE<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sleep这里要注意！这个spinlock是为了保证在执行sleep的时候没有别的进程调用wakeup。开始执行sleep之后lk就可以释放掉了。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Atomically release lock and sleep on chan.</span><span class="token comment">// Reacquires lock when awakened.</span><span class="token keyword">void</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>chan<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> <span class="token operator">*</span>lk<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Must acquire p->lock in order to</span>  <span class="token comment">// change p->state and then call sched.</span>  <span class="token comment">// Once we hold p->lock, we can be</span>  <span class="token comment">// guaranteed that we won't miss any wakeup</span>  <span class="token comment">// (wakeup locks p->lock),</span>  <span class="token comment">// so it's okay to release lk.</span>  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//DOC: sleeplock1</span>  <span class="token function">release</span><span class="token punctuation">(</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Go to sleep.</span>  p<span class="token operator">-></span>chan <span class="token operator">=</span> chan<span class="token punctuation">;</span>  p<span class="token operator">-></span>state <span class="token operator">=</span> SLEEPING<span class="token punctuation">;</span>  <span class="token function">sched</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Tidy up.</span>  p<span class="token operator">-></span>chan <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// Reacquire original lock.</span>  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">acquire</span><span class="token punctuation">(</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><p>这个Lab有点意思，实现可以直接照抄内核态线程，做一个naive的用户态线程</p><h3 id="Uthread-switching-between-threads-moderate"><a href="#Uthread-switching-between-threads-moderate" class="headerlink" title="Uthread: switching between threads (moderate)"></a>Uthread: switching between threads (moderate)</h3><p>用户态线程的状态只有三种，FREE, RUNNING, RUNNABLE。状态机比较简单。<code>thread_init</code>初始化的时候状态设为RUNNING</p><p>创建a,b,c三个用户态thread,然后每个线程打印一次后就执行<code>thread_yield</code>切换线程，并将当前线程的状态设置为RUNNABLE</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">thread_yield</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    current_thread<span class="token operator">-></span>state <span class="token operator">=</span> RUNNABLE<span class="token punctuation">;</span>    <span class="token function">thread_schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后在线程结束的时候将状态置为FREE, <code>current_thread-&gt;state = FREE;</code>，调用</p><p><code>thread_create</code>传进来的参数是一个函数指针（比如thread_a）, 我们把函数指针存入ra寄存器，用来做恢复。<code>thread_create</code>实现可以参考<code>kernel/proc.c</code>里面的<code>allcproc()</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">thread_create</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">thread</span> <span class="token operator">*</span>t<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> all_thread<span class="token punctuation">;</span> t <span class="token operator">&lt;</span> all_thread <span class="token operator">+</span> MAX_THREAD<span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-></span>state <span class="token operator">==</span> FREE<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    t<span class="token operator">-></span>state <span class="token operator">=</span> RUNNABLE<span class="token punctuation">;</span>    t<span class="token operator">-></span>thread_context<span class="token punctuation">.</span>ra <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>func<span class="token punctuation">;</span>    t<span class="token operator">-></span>thread_context<span class="token punctuation">.</span>sp <span class="token operator">=</span> t<span class="token operator">-></span>stack <span class="token operator">+</span> STACK_SIZE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把<code>kernel/proc.h</code>中的context抄过来</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Saved registers for user context switches.</span><span class="token keyword">struct</span> <span class="token class-name">user_context</span> <span class="token punctuation">&#123;</span>  uint64 ra<span class="token punctuation">;</span>  uint64 sp<span class="token punctuation">;</span>  <span class="token comment">// callee-saved</span>  uint64 s0<span class="token punctuation">;</span>  uint64 s1<span class="token punctuation">;</span>  uint64 s2<span class="token punctuation">;</span>  uint64 s3<span class="token punctuation">;</span>  uint64 s4<span class="token punctuation">;</span>  uint64 s5<span class="token punctuation">;</span>  uint64 s6<span class="token punctuation">;</span>  uint64 s7<span class="token punctuation">;</span>  uint64 s8<span class="token punctuation">;</span>  uint64 s9<span class="token punctuation">;</span>  uint64 s10<span class="token punctuation">;</span>  uint64 s11<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">thread</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> stack<span class="token punctuation">[</span>STACK_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* the thread's stack */</span>    <span class="token keyword">int</span> state<span class="token punctuation">;</span>              <span class="token comment">/* FREE, RUNNING, RUNNABLE */</span>    <span class="token keyword">struct</span> <span class="token class-name">user_context</span> thread_context<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后<code>user/uthread_switch.S</code>中的<code>thread_switch</code>照抄<code>kernel/swtch.S</code>实现状态切换，不过<code>thread_switch</code>这里的上下文只保存Callee-saved的寄存器就可以了，所以我们删掉<code>sd ra, 0(a0)</code>和<code>ld ra, 0(a1)</code></p><p><strong>sp寄存器是callee寄存器，只有ra寄存器是caller寄存器</strong>，这个不能删，删了之后用户线程没法切换了！一开始记错了把sp寄存器也记成caller寄存器了，没输出调了好久</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm"><span class="token operator">#</span> void thread_switch<span class="token punctuation">(</span>struct context <span class="token operator">*</span>old<span class="token punctuation">,</span> struct context <span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token comment">;</span>thread_switch:    sd sp<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s0<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s1<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s2<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s3<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s4<span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s5<span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s6<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s7<span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s8<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s9<span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s10<span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    sd s11<span class="token punctuation">,</span> <span class="token number">104</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>    ld sp<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s0<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s1<span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s2<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s3<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s4<span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s5<span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s6<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s7<span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s8<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s9<span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s10<span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>    ld s11<span class="token punctuation">,</span> <span class="token number">104</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span>ret    <span class="token operator">/</span><span class="token operator">*</span> return to ra <span class="token operator">*</span><span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在<code>thread_switch</code>里面直接调用<code>thread_switch((uint64)t, (uint64)current_thread);</code></p><p>然后。。。报错了。调了一下午没找到哪出问题了，gdb打出来的调试信息看不出来。这个报错跟当初页表那个很像，debug的时候被误导了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ uthreadusertrap<span class="token punctuation">(</span><span class="token punctuation">)</span>: unexpected scause 0x000000000000000f <span class="token assign-left variable">pid</span><span class="token operator">=</span><span class="token number">3</span>            <span class="token assign-left variable">sepc</span><span class="token operator">=</span>0x0000000000000002 <span class="token assign-left variable">stval</span><span class="token operator">=</span>0xfffffffffffffff8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>调了半天发现是我thread_switch的函数参数传错了，传进去的应该是context，寄存器a0是第一个参数，寄存器a1是参数，放的是寄存器的struct，然后按照地址偏移分别对应s0，s1等Callee寄存器的值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">thread_switch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token operator">&amp;</span>t<span class="token operator">-></span>thread_context<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token operator">&amp;</span>current_thread<span class="token operator">-></span>thread_context<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>终于正常了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">$ uthread<span class="token number">310514718</span>thread_a startedthread_b startedthread_c startedthread_c <span class="token number">0</span>thread_a <span class="token number">0</span>thread_b <span class="token number">0</span>thread_c <span class="token number">1</span>thread_a <span class="token number">1</span>thread_b <span class="token number">1</span>thread_c <span class="token number">2</span>thread_a <span class="token number">2</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>thread_c <span class="token number">99</span>thread_a <span class="token number">99</span>thread_b <span class="token number">99</span>thread_c<span class="token operator">:</span> exit after <span class="token number">100</span>thread_a<span class="token operator">:</span> exit after <span class="token number">100</span>thread_b<span class="token operator">:</span> exit after <span class="token number">100</span>thread_schedule<span class="token operator">:</span> no runnable threads<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Using-threads-moderate"><a href="#Using-threads-moderate" class="headerlink" title="Using threads (moderate)"></a>Using threads (moderate)</h3><p>这个就是学一下怎么用pthread（这个是在unix&#x2F;linux里面，不是在qemu里），练习一下加mutex锁。<code>ph.c</code>里面有一个并发不安全的哈希表，就是一个简单的取模，然后放到相应的bucket里面，bucket中有重复的key就依次加到链表的后面。实现就和leetcode 706 设计哈希映射的官方题解差不多。这里bucket数量是5，所以很容易发生冲突，缓解hash冲突的一般做法是bucket去一个更大的质数，或者设计其他更好的hash函数减少hash冲突，或者我们不要链表，用开放定址或者rehash去解决hash冲突</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$make</span> ph$./ph <span class="token number">1</span><span class="token number">100000</span> puts, <span class="token number">5.690</span> seconds, <span class="token number">17573</span> puts/second<span class="token number">0</span>: <span class="token number">0</span> keys missing<span class="token number">100000</span> gets, <span class="token number">5.491</span> seconds, <span class="token number">18211</span> gets/second<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们把线程开多一点</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$./ph <span class="token number">10</span><span class="token number">100000</span> puts, <span class="token number">0.333</span> seconds, <span class="token number">300217</span> puts/second<span class="token number">2</span>: <span class="token number">63594</span> keys missing<span class="token number">7</span>: <span class="token number">63594</span> keys missing<span class="token number">1</span>: <span class="token number">63594</span> keys missing<span class="token number">9</span>: <span class="token number">63594</span> keys missing<span class="token number">5</span>: <span class="token number">63594</span> keys missing<span class="token number">8</span>: <span class="token number">63594</span> keys missing<span class="token number">6</span>: <span class="token number">63594</span> keys missing<span class="token number">4</span>: <span class="token number">63594</span> keys missing<span class="token number">0</span>: <span class="token number">63594</span> keys missing<span class="token number">3</span>: <span class="token number">63594</span> keys missing<span class="token number">1000000</span> gets, <span class="token number">5.871</span> seconds, <span class="token number">170320</span> gets/second<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后我们把线程开到100，现在打字都卡了, 成千上万个 key missng。这里的hashmap在并发写的时候会冲突，就像go的map一样并发写的时候会直接报<code>fatal error: concurrent map writes</code>。读是没有关系的，但是<code>ph.c</code>第26行那个insert在写的时候是向entry（存key和value的链表后面加），并发写会把同时正在插入的覆盖掉。</p><p>Go map in actions 中有一个非常简单的给map加锁的例子</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    sync<span class="token punctuation">.</span>RWMutex    m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span>m<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>counter<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>n <span class="token operator">:=</span> counter<span class="token punctuation">.</span>m<span class="token punctuation">[</span><span class="token string">"some_key"</span><span class="token punctuation">]</span>counter<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"some_key:"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>counter<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>counter<span class="token punctuation">.</span>m<span class="token punctuation">[</span><span class="token string">"some_key"</span><span class="token punctuation">]</span><span class="token operator">++</span>counter<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们仿照go的map写入加<code>sync.Mutex</code>，给insert加互斥锁。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pthread_mutex_t</span> lock<span class="token punctuation">;</span> <span class="token comment">// declare a lock</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">put_thread</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>xa<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>xa<span class="token punctuation">;</span> <span class="token comment">// thread number</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> NKEYS <span class="token operator">/</span> nthread<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">put</span><span class="token punctuation">(</span>keys<span class="token punctuation">[</span>b <span class="token operator">*</span> n <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就没有missing了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$make</span> ph$./ph <span class="token number">2</span><span class="token number">100000</span> puts, <span class="token number">5.522</span> seconds, <span class="token number">18111</span> puts/second<span class="token number">1</span>: <span class="token number">0</span> keys missing<span class="token number">0</span>: <span class="token number">0</span> keys missing<span class="token number">200000</span> gets, <span class="token number">5.628</span> seconds, <span class="token number">35535</span> gets/second<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是这样有一个问题，速度没什么优势，把nthread开到10，puts用时6.094 seconds，还不如单线程。<code>make grade</code>的时候只能跑过<code>ph_safe</code>，没法通过<code>ph_fast</code>的。</p><p>想要速度我们需要更细粒度的锁，我们仿照go的concurrent-map那样分片加锁的方案在insert插入的时候给对应的bucket加锁。（go的sync.Map的那个加锁比较适合读多写少的方案，这里大量写入优势不大）这里我们只要对每个bucket单独加锁就可以了，问题转换为对entry链表加锁，我们用NBUCKET把小锁分别对NBUCKET个entry链表加锁。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">pthread_mutex_t</span> lock<span class="token punctuation">[</span>NBUCKET<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// declare a lock</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key <span class="token operator">%</span> NBUCKET<span class="token punctuation">;</span>    <span class="token comment">// is the key already present?</span>    <span class="token keyword">struct</span> <span class="token class-name">entry</span> <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// update the existing key.</span>        e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// the new is new.</span>        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">[</span>NBUCKET<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$./ph <span class="token number">10</span><span class="token number">100000</span> puts, <span class="token number">0.684</span> seconds, <span class="token number">146180</span> puts/second<span class="token punctuation">..</span><span class="token punctuation">..</span><span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样就足以跑过<code>ph_fast</code>的测试了（其实如果想偷鸡直接将NBUCKET改成一个大点的质数减少一下hash冲突就能用大锁跑过测试）</p><p>还有更细粒度的加锁方案，就是对链表（entry）的节点加锁，不过通常设计比较好的hashmap的拉链，链表不会很长。这里就不这么加了。</p><p>还有一种链表并发的方案就是rcu，不过这个是在内核态实现的，想要在userspace模仿一个有点难。</p><h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>这个也是在Unix&#x2F;linux真机下面，练习一下条件变量。这个barrier是用<code>pthread_cond</code>实现的，<code>a point in an application at which all participating threads must wait until all other participating threads reach that point too. </code></p><p>让执行完的线程wait(睡眠)，然后面足条件的时候调用signal唤醒，这里全部唤醒用broadcast就好了。</p><p>注意使用条件变量的时候需要加锁，参考Three Easy Piecies第30章。某些情况下signal可以不加锁，但是wait必须要加锁。<code>hold the lock when calling signal</code>，不然会发生race，书里给了一个例子：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">thr_exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  done <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token function">Pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">thr_join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>done <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">Pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个时候如果一个thread执行<code>thr_join</code>，满足done为0，开始wait睡眠，但是在判断完if到执行wait睡眠的期间，<code>thr_exit()</code>开始执行唤醒全部全部线程，那么这个thread执行wait就会一直sleep醒不过来了（书里面是用的parent和child的例子）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Block until all threads have called barrier() and</span>    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    bstate<span class="token punctuation">.</span>nthread<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bstate<span class="token punctuation">.</span>nthread <span class="token operator">&lt;</span> nthread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这个锁也要加上，不然唤醒的时候如果有线程睡眠会睡死</span>    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bstate<span class="token punctuation">.</span>nthread <span class="token operator">==</span> nthread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        bstate<span class="token punctuation">.</span>nthread <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        bstate<span class="token punctuation">.</span>round<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样<code>./barrier 100</code>就pass了。如果我们不加mutex锁，那么<code>./barrier 100</code>是会一直卡在那里结束不了的。如果我们执行strace看一下<code>strace ./barrier 100</code>，会发现卡在这个地方</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">futex</span><span class="token punctuation">(</span><span class="token number">0x7f0a8b7a1910</span><span class="token punctuation">,</span> FUTEX_WAIT_BITSET<span class="token operator">|</span>FUTEX_CLOCK_REALTIME<span class="token punctuation">,</span> <span class="token number">219673</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FUTEX_BITSET_MATCH_ANY<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">?</span> <span class="token function">ERESTARTSYS</span> <span class="token punctuation">(</span>To be restarted <span class="token keyword">if</span> SA_RESTART is set<span class="token punctuation">)</span><span class="token operator">--</span><span class="token operator">-</span> SIGWINCH <span class="token punctuation">&#123;</span>si_signo<span class="token operator">=</span>SIGWINCH<span class="token punctuation">,</span> si_code<span class="token operator">=</span>SI_KERNEL<span class="token punctuation">&#125;</span> <span class="token operator">--</span><span class="token operator">-</span><span class="token function">futex</span><span class="token punctuation">(</span><span class="token number">0x7f0a8b7a1910</span><span class="token punctuation">,</span> FUTEX_WAIT_BITSET<span class="token operator">|</span>FUTEX_CLOCK_REALTIME<span class="token punctuation">,</span> <span class="token number">219673</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> FUTEX_BITSET_MATCH_ANY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>用<code>valgrind --tool=helgrind ./barrier 2</code>检查了一下，应该这样也是可以的，都加到一把锁里面</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">barrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Block until all threads have called barrier() and</span>    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    bstate<span class="token punctuation">.</span>nthread<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bstate<span class="token punctuation">.</span>nthread <span class="token operator">&lt;</span> nthread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_cond<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>bstate<span class="token punctuation">.</span>nthread <span class="token operator">==</span> nthread<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        bstate<span class="token punctuation">.</span>nthread <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        bstate<span class="token punctuation">.</span>round<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">pthread_cond_broadcast</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_cond<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bstate<span class="token punctuation">.</span>barrier_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这次看题目本来以为很简单的，用户态thread就照着内核线程抄一个呗，剩下两个就是用一下pthread和锁呗。然后写起来debug就花了很久的时间，对寄存器不太熟，频繁翻车。然后折腾了两天才整出来</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> gradeuthread: OK <span class="token punctuation">(</span><span class="token number">2</span>.5s<span class="token punctuation">)</span> <span class="token operator">==</span> Test answers-thread.txt <span class="token operator">==</span> answers-thread.txt: OK <span class="token operator">==</span> Test ph_safe <span class="token operator">==</span> make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/zhixi/codes/xv6-labs-2021'</span>gcc -o ph -g -O2 -DSOL_THREAD -DLAB_THREAD notxv6/ph.c -pthreadmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/zhixi/codes/xv6-labs-2021'</span>ph_safe: OK <span class="token punctuation">(</span><span class="token number">8</span>.0s<span class="token punctuation">)</span> <span class="token operator">==</span> Test ph_fast <span class="token operator">==</span> make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/zhixi/codes/xv6-labs-2021'</span>make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: <span class="token string">'ph'</span> is up to date.make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/zhixi/codes/xv6-labs-2021'</span>ph_fast: OK <span class="token punctuation">(</span><span class="token number">19</span>.7s<span class="token punctuation">)</span> <span class="token operator">==</span> Test barrier <span class="token operator">==</span> make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Entering directory <span class="token string">'/home/zhixi/codes/xv6-labs-2021'</span>gcc -o barrier -g -O2 -DSOL_THREAD -DLAB_THREAD notxv6/barrier.c -pthreadmake<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/home/zhixi/codes/xv6-labs-2021'</span>barrier: OK <span class="token punctuation">(</span><span class="token number">2</span>.7s<span class="token punctuation">)</span> <span class="token operator">==</span> Test <span class="token function">time</span> <span class="token operator">==</span> time: OK Score: <span class="token number">60</span>/60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi5TMDgxLzIwMjAvbGFicy90aHJlYWQuaHRtbA==">https://pdos.csail.mit.edu/6.S081/2020/labs/thread.html<i class="fa fa-external-link-alt"></i></span>   </p><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQxMC9ob3ctZG8teW91LXBhc3MtYS1mdW5jdGlvbi1hcy1hLXBhcmFtZXRlci1pbi1j">How do you pass a function as a parameter in C?<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvYmxvZy9tYXBz">Go Map in Actions<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL21hc3Rlci9zcmMvc3luYy9tYXAuZ28=">https://github.com/golang/go/blob/master/src/sync/map.go<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9wa2cuZ28uZGV2L3N5bmM/dXRtX3NvdXJjZT1nb2RvYyNNYXA=">https://pkg.go.dev/sync?utm_source=godoc#Map<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jb2xvYnUuY29tLzIwMTcvMDcvMTEvZGl2ZS1pbnRvLXN5bmMtTWFwLw==">Go 1.9 sync.Map揭秘<i class="fa fa-external-link-alt"></i></span> 鸟窝大大写的sync.Mutex介绍  </p><p><span class="exturl" data-url="aHR0cHM6Ly9wYWdlcy5jcy53aXNjLmVkdS9+cmVtemkvT1NURVAv">Operating Systems Three Easy Pices<i class="fa fa-external-link-alt"></i></span>，中文就是那个蓝皮的操作系统导论<br>第29章，讲并发链表、并发队列和并发散列表<br>第20章，讲条件变量  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;实现一个用户态线程uthread，就照着xv6的内核态线程抄呗。怎么什么FUSE啊、UIO啊，什么东西都想往用户态搬啊，连RCU都有人想往用户态搬。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="thread" scheme="https://zhangjk98.xyz/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Filesystem 笔记</title>
    <link href="https://zhangjk98.xyz/6-S081-lab-filesystem/"/>
    <id>https://zhangjk98.xyz/6-S081-lab-filesystem/</id>
    <published>2022-04-13T03:22:50.000Z</published>
    <updated>2022-04-13T03:22:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>鸽了有点日子的6.S081的filesystem笔记，主要是看到ZFS和Btrfs之类的现代文件系统，再看看自己做的Lab，感觉跟幼儿园哄小孩玩的一样</p><p><img src="https://imgs.xkcd.com/comics/dark_arts.png"></p><p>不过，如果你只是一个路过的普通用户，懂的越少越幸福。在我接触Btrfs之前，我根本没担心过我电脑的文件系统。<br>THERE POWER LEADS ONLY TO RUIN.  </p><span id="more"></span><h2 id="文件系统笔记"><a href="#文件系统笔记" class="headerlink" title="文件系统笔记"></a>文件系统笔记</h2><p>经典的文件系统网上各种资料和介绍太多了，也无外乎inode、多级索引、引用计数、权限这些。现代文件系统比较复杂，像Btrfs的那些日志、秒级快照、COW我又不太懂不敢讲，像Ceph这些分布式的文件系统我也不太懂。我感觉像Btrfs这样的文件系统已经很像数据库了，你看b-tree索引啊日志啊COW事物啊。</p><p>这一篇写的比较凌乱，而且大部分内容都和Lab没关系，随便说说吧</p><h3 id="Btrfs"><a href="#Btrfs" class="headerlink" title="Btrfs"></a>Btrfs</h3><p>Btrfs我不太敢讲，相比ext4比较复杂、资料也更少。把台式主力的文件系统换成Btrfs后我都有些提心吊胆的，一直害怕哪一天Boom-tree-fs炸了。还好，快一年了，依然存活。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$sudo</span> btrfs device stats /dev/nvme0n1p1<span class="token punctuation">[</span>/dev/nvme0n1p1<span class="token punctuation">]</span>.write_io_errs    <span class="token number">0</span><span class="token punctuation">[</span>/dev/nvme0n1p1<span class="token punctuation">]</span>.read_io_errs     <span class="token number">0</span><span class="token punctuation">[</span>/dev/nvme0n1p1<span class="token punctuation">]</span>.flush_io_errs    <span class="token number">0</span><span class="token punctuation">[</span>/dev/nvme0n1p1<span class="token punctuation">]</span>.corruption_errs  <span class="token number">0</span><span class="token punctuation">[</span>/dev/nvme0n1p1<span class="token punctuation">]</span>.generation_errs  <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>普通用户用Btrfs的一些好处是透明压缩、快照、COW。不过，Btrfs的问题是真要是出了什么问题会修的人不多，用ext4什么的坏了实在不行可以花钱找数据恢复，btrfs就自求多福吧（或者你在群里大喊fc老师救我，fc老师没空就自求多福吧）。而且市面上的磁盘修复工具几乎也都不怎么支持btrfs。</p><p>Btrfs可以直接添加、删除设备、调整大小（增加和缩小都行，XFS暂时还不支持缩）。我用Btrfs将两个500G的固态硬盘拼成了一个1T的逻辑分区（这个东西有点像LVM的逻辑卷）<br>Btrfs可以直接热插拔增删设备，比如我要加一快硬盘，直接添加然后balance一下就可以了。我要移除一块硬盘，直接remove就可以了。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> btrfs device <span class="token function">add</span> /dev/nvme0n1p1 / -f   <span class="token comment"># 添加设备</span><span class="token function">sudo</span> btrfs balance start /  <span class="token comment"># 开始平衡</span><span class="token function">sudo</span> btrfs device remove /dev/nvme0n1p1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>之前用ext4等文件系统很多都习惯<code>/</code>，<code>/home</code>, <code>/var</code>，Btrfs一般不分那么多区，而是用子卷。一般对<code>var</code>这样的目录单独建一个子卷，然后禁用COW。</p><h4 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h4><p>b-tree有三种结构：keys, items, and a block header</p><p>block header 包括uuid和checksum之类的东西</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">btrfs_header</span> <span class="token punctuation">&#123;</span>    u8 csum<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    u8 fsid<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    __le64 bytenr<span class="token punctuation">;</span>    __le64 flags<span class="token punctuation">;</span>    u8 chunk_tree_uid<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    __le64 generation<span class="token punctuation">;</span>    __le64 owner<span class="token punctuation">;</span>    __le32 nritems<span class="token punctuation">;</span>    u8 level<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>key中包括了存储的数据类型</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">btrfs_disk_key</span> <span class="token punctuation">&#123;</span>    __le64 objectid<span class="token punctuation">;</span>    u8 type<span class="token punctuation">;</span>    __le64 offset<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>item的大小是可变的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">btrfs_item</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">btrfs_disk_key</span> key<span class="token punctuation">;</span>    __le32 offset<span class="token punctuation">;</span>    __le32 size<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件系统的struct放在 item data 里面，比如objectid、inode和offset这些。每个文件都有一个objectid，然后根据objectid组成了一个B-tree的索引。inode放在<code>btrfs_inode_item</code>结构体里面。</p><p>Btrfs的索引是b树（free space tree），每个子卷（subvolume）有一颗b-tree索引，大概长这个样子<br><img src="/6-S081-lab-filesystem/1649948946.png"></p><p>Btrfs中有很多的树索引，包括FS Tree(包括Extent tree, Root tree)，Chunk tree(区块索引)，Checksum tree， Device Tree。</p><p><img src="/6-S081-lab-filesystem/1649988331.png"></p><p>其中文件树（FS Tree）长这样</p><p><img src="/6-S081-lab-filesystem/1649949073.png"></p><p>Btrfs的snapshot是类似COW的操作，增量备份节点</p><p><img src="/6-S081-lab-filesystem/1649992014.png"></p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>大多数比较新的文件系统都对SSD存储的优化。这里简单说一下Btrfs的文件存储。Btrfs的一个对小文件的优化是直接塞进Metadata里面，这样就不用占一个块（block）了。大文件存在将block合并的Extent中，这样就不用每个block一个Metadata占空间了。<br>Btrfs还有一个很出名的特性是透明压缩，此外还有COW的reflink（这个不能），de-duplicaiton，这个之前写过不多说了</p><h4 id="关于Btrfs的性能问题"><a href="#关于Btrfs的性能问题" class="headerlink" title="关于Btrfs的性能问题"></a>关于Btrfs的性能问题</h4><p>Btrfs性能不好的说法主要来源于跑分跑不过ext4等等。不过跑分这种事情对于普通的桌面用户意义不大，以下引用fc老师的话</p><blockquote><p>phoronix 測文件系統性能的最大問題在於容易讓讀者以為文件系統是左右存儲性能的關鍵，實際上文件系統只是夾在內存子系統和塊IO子系統中間的決策層，通常瓶頸不會在文件系統，除非文件系統過度簡化設計，對存儲性能影響更大的是別的層面的東西，按他們的方式測試文件系統只能測出一堆難以預計到的副作用的結果，沒法對文件系統優化提供可供參考的提示<br>要測純讀寫做對比肯定不考慮 reflink 和透明壓縮，但是實際幹活的時候這些新特性很節省時間（</p></blockquote><p>当然Btrfs在重io的情况下桌面特别卡，那很有可能是quota的问题，把quota关掉吧，quota有已知的性能问题，尤其是在ssd上。（关了这个磁盘配额你就看不到快照大小、指定不了每个子卷的大小）</p><h2 id="简单说一下Lab"><a href="#简单说一下Lab" class="headerlink" title="简单说一下Lab"></a>简单说一下Lab</h2><p>这个Lab很简单，一个是让给xv6的文件系统做一个二级索引用来支持大文件，一个是让你给xv6实现一下软链接。xv6作为一个教学的系统，文件系统索引很简单，并没有像Btrfs等文件系统那样采用b-tree等树形结构。软链接的实现也很简单，就类似一个指针+引用计数嘛，不像一些现代文件系统的reflink那样类似COW的操作实现de-duplication很麻烦。</p><p>其实没啥好说的，但是这一篇一开始是6.S081的Lab笔记，一点Lab的内容都没有有点挂羊头卖狗肉的嫌疑。还是写点吧。</p><h2 id="xv6中的文件系统"><a href="#xv6中的文件系统" class="headerlink" title="xv6中的文件系统"></a>xv6中的文件系统</h2><p>这里简化起见不讲磁盘结构了。不考虑底层差异，磁盘直接被文件系统视为一连串块（block），xv6中block大小是1024k。block0一般是引导块，然后block1是superblock，然后是log, inodes，bitmap，这些统称为Metadata block。再后面都是 data block</p><p><img src="/6-S081-lab-filesystem/1650031214.png"></p><p>这里xv6的精简实现比较简单，不像linux那样很复杂，我们直接看源码好了。超级块superblock用来记录总共有多少个block、inode block、log block，以及它们的开始位置</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// super block describes the disk layout:</span><span class="token keyword">struct</span> <span class="token class-name">superblock</span> <span class="token punctuation">&#123;</span>  uint magic<span class="token punctuation">;</span>        <span class="token comment">// Must be FSMAGIC</span>  uint size<span class="token punctuation">;</span>         <span class="token comment">// Size of file system image (blocks)</span>  uint nblocks<span class="token punctuation">;</span>      <span class="token comment">// Number of data blocks</span>  uint ninodes<span class="token punctuation">;</span>      <span class="token comment">// Number of inodes.</span>  uint nlog<span class="token punctuation">;</span>         <span class="token comment">// Number of log blocks</span>  uint logstart<span class="token punctuation">;</span>     <span class="token comment">// Block number of first log block</span>  uint inodestart<span class="token punctuation">;</span>   <span class="token comment">// Block number of first inode block</span>  uint bmapstart<span class="token punctuation">;</span>    <span class="token comment">// Block number of first free map block</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>inode的定义也非常简单，inode在磁盘中大概就记录文件类型、大小、链接数量这些信息。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// On-disk inode structure</span><span class="token keyword">struct</span> <span class="token class-name">dinode</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">short</span> type<span class="token punctuation">;</span>           <span class="token comment">// File type</span>  <span class="token keyword">short</span> major<span class="token punctuation">;</span>          <span class="token comment">// Major device number (T_DEVICE only)</span>  <span class="token keyword">short</span> minor<span class="token punctuation">;</span>          <span class="token comment">// Minor device number (T_DEVICE only)</span>  <span class="token keyword">short</span> nlink<span class="token punctuation">;</span>          <span class="token comment">// Number of links to inode in file system</span>  uint size<span class="token punctuation">;</span>            <span class="token comment">// Size of file (bytes)</span>  uint addrs<span class="token punctuation">[</span>NDIRECT<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// Data block addresses</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// in-memory copy of an inode</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token punctuation">&#123;</span>  uint dev<span class="token punctuation">;</span>           <span class="token comment">// Device number</span>  uint inum<span class="token punctuation">;</span>          <span class="token comment">// Inode number</span>  <span class="token keyword">int</span> ref<span class="token punctuation">;</span>            <span class="token comment">// Reference count</span>  <span class="token keyword">struct</span> <span class="token class-name">sleeplock</span> lock<span class="token punctuation">;</span> <span class="token comment">// protects everything below here</span>  <span class="token keyword">int</span> valid<span class="token punctuation">;</span>          <span class="token comment">// inode has been read from disk?</span>  <span class="token keyword">short</span> type<span class="token punctuation">;</span>         <span class="token comment">// copy of disk inode</span>  <span class="token keyword">short</span> major<span class="token punctuation">;</span>  <span class="token keyword">short</span> minor<span class="token punctuation">;</span>  <span class="token keyword">short</span> nlink<span class="token punctuation">;</span>  uint size<span class="token punctuation">;</span>  uint addrs<span class="token punctuation">[</span>NDIRECT<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在内存中inode有 refernce conut，这个就是引用计数，删除文件的时候只有当引用计数减为0的时候才会真正删除</p><p><img src="/6-S081-lab-filesystem/1650032123.png"></p><h2 id="sleeplock"><a href="#sleeplock" class="headerlink" title="sleeplock"></a>sleeplock</h2><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Long-term locks for processes</span><span class="token keyword">struct</span> <span class="token class-name">sleeplock</span> <span class="token punctuation">&#123;</span>  uint locked<span class="token punctuation">;</span>       <span class="token comment">// Is the lock held? 0是没有， 1是hold</span>  <span class="token keyword">struct</span> <span class="token class-name">spinlock</span> lk<span class="token punctuation">;</span> <span class="token comment">// spinlock protecting this sleep lock</span>    <span class="token comment">// For debugging:</span>  <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>        <span class="token comment">// Name of lock.</span>  <span class="token keyword">int</span> pid<span class="token punctuation">;</span>           <span class="token comment">// Process holding lock</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>xv6的文件系统用的是睡眠锁而不是spinlock，因为读写这种io操作耗时很长。相关定义在<code>kernel/sleeplock.c</code>，其中<code>wakeup</code>和<code>sleep</code>定义在<code>kernel/proc.c</code>， 这里就简单认为sleep操作干了<code>p-&gt;state = SLEEPING;</code>这一件事，而<code>wakeup</code>干了<code>p-&gt;state = RUNNABLE;</code>，作用是让process睡眠和唤醒</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Wake up all processes sleeping on chan.</span><span class="token comment">// Must be called without any p->lock.</span><span class="token keyword">void</span><span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>chan<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> p<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>state <span class="token operator">==</span> SLEEPING <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>chan <span class="token operator">==</span> chan<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        p<span class="token operator">-></span>state <span class="token operator">=</span> RUNNABLE<span class="token punctuation">;</span>  <span class="token comment">// 这里我们只关注这一行就行了</span>      <span class="token punctuation">&#125;</span>      <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">initsleeplock</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sleeplock</span> <span class="token operator">*</span>lk<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">initlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lk<span class="token operator">-></span>lk<span class="token punctuation">,</span> <span class="token string">"sleep lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  lk<span class="token operator">-></span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  lk<span class="token operator">-></span>locked <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//locked = 0 没上锁，= 1 表示被锁住了</span>  lk<span class="token operator">-></span>pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">acquiresleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sleeplock</span> <span class="token operator">*</span>lk<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lk<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取spinlock</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>lk<span class="token operator">-></span>locked<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 如果其他pid持有锁</span>    <span class="token function">sleep</span><span class="token punctuation">(</span>lk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lk<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//睡眠</span>  <span class="token punctuation">&#125;</span>  lk<span class="token operator">-></span>locked <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token comment">// 上锁</span>  lk<span class="token operator">-></span>pid <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">;</span>  <span class="token comment">//拿锁进程的pid</span>  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lk<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//释放spinlock</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">releasesleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sleeplock</span> <span class="token operator">*</span>lk<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lk<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>  lk<span class="token operator">-></span>locked <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 释放锁</span>  lk<span class="token operator">-></span>pid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token function">wakeup</span><span class="token punctuation">(</span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 唤醒</span>  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lk<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 检查是否持有sleeplock锁</span><span class="token keyword">int</span> <span class="token function">holdingsleep</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sleeplock</span> <span class="token operator">*</span>lk<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> r<span class="token punctuation">;</span>  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lk<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>  r <span class="token operator">=</span> lk<span class="token operator">-></span>locked <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>lk<span class="token operator">-></span>pid <span class="token operator">==</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// r表示当前proc的pid是否持有锁</span>  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lk<span class="token operator">-></span>lk<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sleeplock是用spinlock实现的，在中断（IO）操作的时候可以持有锁。实现比较精简，我加了点注释，不多说了。</p><p>ps：睡眠锁类似linux里面的信号量semaphore（后来改用mutex了）</p><h3 id="xv6的日志"><a href="#xv6的日志" class="headerlink" title="xv6的日志"></a>xv6的日志</h3><p>xv6的日志实现比较简单，在磁盘上有一段固定的block。<br>日志这里不多说了，log-structured的文件系统和COW这些有点跑题了。掉电恢复什么的建议买个UPS电源。</p><h3 id="block-cache"><a href="#block-cache" class="headerlink" title="block cache"></a>block cache</h3><p>这里就是经典的LRU和睡眠锁</p><h2 id="Lab内容"><a href="#Lab内容" class="headerlink" title="Lab内容"></a>Lab内容</h2><h3 id="Large-Files"><a href="#Large-Files" class="headerlink" title="Large Files"></a>Large Files</h3><blockquote><p>In this assignment you’ll increase the maximum size of an xv6 file. Currently xv6 files are limited to 268 blocks, or 268*BSIZE bytes (BSIZE is 1024 in xv6). This limit comes from the fact that an xv6 inode contains 12 “direct” block numbers and one “singly-indirect” block number, which refers to a block that holds up to 256 more block numbers, for a total of 12+256&#x3D;268 blocks.</p></blockquote><p>ext3支持4TB的大文件，ext4支持16TB的大文件，ZFS、Btrfs等现代文件系统支持16EB（如果你执行<code>ulimit -a</code>会显示file size (blocks)，其实这个数字是64位操作系统的上限（16EB&#x3D;2^64））</p><p>这里让xv6的文件系统支持大文件的做法很naive，做一个二级索引，让inode有更多block就行了。</p><h3 id="Symbolic-Links"><a href="#Symbolic-Links" class="headerlink" title="Symbolic Links"></a>Symbolic Links</h3><p>这个也很简单，实现一个符号链接就行了。之前看了醉卧沙场写的XFS的符号链接的实现，这里做的很顺利。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wZWtvcGVrbzExLnNha3VyYS5uZS5qcC91bml4X3Y2L3h2Ni1ib29rL2VuL0ZpbGVfc3lzdGVtLmh0bWw=">Chapter 6 File system<i class="fa fa-external-link-alt"></i></span>  </p><p>下面放的链接是一些文件系统相关的文章，跟这个Lab关系并不是特别大，适合无聊的时候读着玩</p><p><span class="exturl" data-url="aHR0cHM6Ly9mYXJzZWVyZmMubWUvemhzL3RhZy9mc2JpLWppLmh0bWw=">fc老师的fs笔记<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hcnhpdi5vcmcvcGRmLzE3MDcuMDg1MTQucGRm">Analyzing IO Amplification in Linux File Systems<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzYzODU0Ni8=">XFS: There and back … and there again?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9mYXJzZWVyZmMubWUvemhzL2J0cmZzLXZzLXpmcy1kaWZmZXJlbmNlLWluLWltcGxlbWVudGluZy1zbmFwc2hvdHMuaHRtbA==">Btrfs vs ZFS 实现 snapshot 的差异<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NzY4NjgxNw==">醉卧沙场 README - 计算机专业性文章及回答总索引<i class="fa fa-external-link-alt"></i></span> 这个知乎答主写了好多XFS的文章  </p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGF0aG5hbWUuY29tL2Zocy8yLjIvaW5kZXguaHRtbA==">Filesystem Hierarchy Standard<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy5yZWFkdGhlZG9jcy5pby8=">BTRFS documentation<i class="fa fa-external-link-alt"></i></span> 偏向使用文档，没怎么介绍原理<br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL1RyZWVz">Btrfs Trees<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL0J0cmZzX2Rlc2lnbg==">Btrfs Design<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMjAwMjI2MTMzNzQ3L2h0dHBzOi8vd3d3LmlibS5jb20vZGV2ZWxvcGVyd29ya3MvY24vbGludXgvbC1jbi1idHJmcy9pbmRleC5odG1s">新一代 Linux 文件系统 btrfs 简介<i class="fa fa-external-link-alt"></i></span>  比较老的一篇文章<br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL0ZBUQ==">Btrfs FAQ<i class="fa fa-external-link-alt"></i></span> 希望你用不到这些东西，有一天要翻这那你Btrfs多半是出问题了  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;鸽了有点日子的6.S081的filesystem笔记，主要是看到ZFS和Btrfs之类的现代文件系统，再看看自己做的Lab，感觉跟幼儿园哄小孩玩的一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgs.xkcd.com/comics/dark_arts.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;不过，如果你只是一个路过的普通用户，懂的越少越幸福。在我接触Btrfs之前，我根本没担心过我电脑的文件系统。&lt;br&gt;THERE POWER LEADS ONLY TO RUIN.  &lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="fs" scheme="https://zhangjk98.xyz/tags/fs/"/>
    
    <category term="btrfs" scheme="https://zhangjk98.xyz/tags/btrfs/"/>
    
  </entry>
  
  <entry>
    <title>Vim中的宏：自动化魔法</title>
    <link href="https://zhangjk98.xyz/vim-macros/"/>
    <id>https://zhangjk98.xyz/vim-macros/</id>
    <published>2022-04-01T12:21:15.000Z</published>
    <updated>2022-04-01T12:21:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>清明节闲着没事写点Vim的东西。我对Vim有诸多怨念，不过Vim有几个地方我很喜欢，最重要的一个就是操作可以组合和自动化。</p><span id="more"></span><h2 id="宏的魔法世界"><a href="#宏的魔法世界" class="headerlink" title="宏的魔法世界"></a>宏的魔法世界</h2><p>宏可以完成很多自动化的操作，不过相比自动化，更迷人的是像写代码一样编辑文本。有一点元编程的画风，不过相比于模板元那种黑魔法，vim里的宏是人见人爱的白魔法。而且vim编辑文本的操作命令很简单，你要打印1000个 Hello, World!，不使用循环等高级功能，只需要将print这一行复制999次</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用vim这很简单，只需要<code>yy1000p</code>这种组合命令就可以了。用别的编程语言生成这么1000行print都比把print直接放在循环里麻烦。</p><p>如果是很简单的重复操作，也不需要专门录制宏。比如：</p><p><code>.</code>重复上一个edit命令<br><code>;</code> 重复上一个查找命令<br><code>&amp;</code> 替换下一个文本<br><code>@:</code> 命令重复上一个Editor Command，这个我不常用，我喜欢上箭头选上一个然后回车</p><p>但是如果想连续执行一段<code>;.</code>, 就需要用宏了（<code>11;.</code>的结果是先执行11次;再执行11次.）</p><p>如果要输出从1到1000，用vim的循环也可以完成</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token punctuation">:</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token keyword">call</span> <span class="token function">setline</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token operator">.</span><span class="token string">' '</span><span class="token operator">.</span><span class="token function">getline</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">endfor</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果用宏来操作是这样的，<code>Ctrl+a</code>和<code>Ctrl+x</code>分别是对数字自增和自减，我们可以将操作分解成复制粘贴自增，然后重复998次就可以了</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim">第一行输入<span class="token number">1</span><span class="token keyword">qa</span> 开始宏录制yyp 复制并粘贴第一行C<span class="token operator">-</span>a 自增<span class="token number">1</span><span class="token keyword">q</span>   结束宏录制<span class="token number">998</span>@ 重复<span class="token number">998</span>次，输出<span class="token number">1</span><span class="token operator">-</span><span class="token number">1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="稍微正经点的用途的例子"><a href="#稍微正经点的用途的例子" class="headerlink" title="稍微正经点的用途的例子"></a>稍微正经点的用途的例子</h2><p>注释几行文本：</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">qa</span>  开始宏录制I#  insert模式行首加#Esc 退出insert<span class="token keyword">j</span>   下一行<span class="token keyword">q</span>   完成宏录制<span class="token number">7</span>@a 注释<span class="token number">7</span>行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同理，我们想要把开头序号<code>1.</code>都变成<code>1)</code>的样子</p><pre class="line-numbers language-vim" data-language="vim"><code class="language-vim"><span class="token keyword">qa</span><span class="token keyword">q</span>开始录制，保存到a寄存器中0f<span class="token operator">.</span> 跳转到开头并查找第一个<span class="token operator">.</span><span class="token keyword">j</span>跳转到下一行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>大多数时候这种情况正则更方便，但是有的时候一堆混乱的文本容易误伤，宏的操作加入了位置信息等操作比较容易控制</p><pre class="line-numbers language-none"><code class="language-none">1. X1..XX2. SN.1FN3. PIN.GF4. 12 3.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>这里举例子用宏加注释什么的，其实有很多操作并不需要宏来完成，比如注释有插件。</p><h2 id="关于Vim的使用姿势"><a href="#关于Vim的使用姿势" class="headerlink" title="关于Vim的使用姿势"></a>关于Vim的使用姿势</h2><p>曾经几年前我对Vim实在说不上喜欢，当时我还在Windows上（Windows上的vim体验你也知道），经常要连到linux上改改东西的时候我日常使用nano（后来发现了micro）。如果只是将Vim当成一套键盘操作，那效率可能并不比IDE的快捷键+鼠标操作更好。（而且vim的hjkl的键位等操作，对很多人是极大的劝退）<br>Vim的键位用好了可以形成肌肉记忆将操作交给小脑解放大脑，而宏这些操作是要开动大脑的。<br>我觉得吸引玩家入坑vim就应该从录制宏等操作讲起，这些才是图形界面的点击操作不具备的优势。  </p><p>宏适合干的就是重复的动作，比较适合处理一些枯燥的工作。比如经典的某些大道至简的语言sublime多光标实现泛型这样的事情，我们可以写一个宏去完成它。（其实我个人还是喜欢多光标）</p><p><img src="/uploads/generic.gif" alt="Go Type Parameters in Sublime"></p><p><span class="exturl" data-url="aHR0cHM6Ly9tYWNwbGF5LmdpdGh1Yi5pby9wb3N0cy92aW0tYnUteHUteWFvLWR1by1ndWFuZy1iaWFvLWJpYW4tamktZ29uZy1uZW5nLw==">【译】Vim 不需要多光标编辑功能<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BzY2h0b2VmZmVsL3lvdS1kb24tdC1uZWVkLW1vcmUtdGhhbi1vbmUtY3Vyc29yLWluLXZpbS0yYzQ0MTE3ZDUxZGI=">You don’t need more than one cursor in vim<i class="fa fa-external-link-alt"></i></span>   </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;清明节闲着没事写点Vim的东西。我对Vim有诸多怨念，不过Vim有几个地方我很喜欢，最重要的一个就是操作可以组合和自动化。&lt;/p&gt;</summary>
    
    
    
    <category term="不务正业系列" scheme="https://zhangjk98.xyz/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="Vim" scheme="https://zhangjk98.xyz/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Vim的寄存器与复制粘贴</title>
    <link href="https://zhangjk98.xyz/vim-registers-copy-and-paste/"/>
    <id>https://zhangjk98.xyz/vim-registers-copy-and-paste/</id>
    <published>2022-04-01T12:19:37.000Z</published>
    <updated>2022-04-01T12:19:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>清明节假期写点Vim相关的东西，说一下寄存器。在此之前我眼中的复制粘贴从未如此复杂，就像我从未</p><span id="more"></span><p>另一个比我想象中复杂和有用的是Vim的undotree，有点git那种branch的味道（装上gnudo插件就更像了）。</p><h2 id="Linux下的复制粘贴"><a href="#Linux下的复制粘贴" class="headerlink" title="Linux下的复制粘贴"></a>Linux下的复制粘贴</h2><p>首先说一下linux下面的复制粘贴，一般linux桌面的复制粘贴是<code>x11</code>负责的，复制粘贴的时候和<code>X Server</code>通信（一般管复制粘贴叫selections），有两个常见的selections：</p><p>PRIMARY：鼠标左键选中复制，鼠标中键粘贴<br>CLIPBOARD： <code>Ctrl + Shift + C</code>和<code>Ctrl + Shift + V</code></p><p>这两个保存的内容是不同的，而且当你复制粘贴的时候两个应用必须同时开着，x11本身不全局保存复制的内容，应用关了就没了。所以如果你想要只有一个全局的剪切板，你得装一个<code>clipboard manager</code>（大多数桌面都贴心的自带了，可惜某些suck的wm并没有这个东西，曾经搞得我好几次弄丢了复制的东西不知道怎么回事）</p><p>推荐鼠标操作的时候尝试适应鼠标中键的操作，这样只要一只手控制鼠标就行了，比一只手鼠标一只手<code>Ctrl+C Ctrl+V</code>节省了一只手。在x11下的terminal中复制东西我一般用<code>xclip</code>。</p><h2 id="如果你只是简简单单复制粘贴"><a href="#如果你只是简简单单复制粘贴" class="headerlink" title="如果你只是简简单单复制粘贴"></a>如果你只是简简单单复制粘贴</h2><p>如果你不得不用vim，那还是鼠标选中和的复制粘贴更适合你，进入insert模式粘贴即可。简单的命令可以在normal模式下使用y和p即可（yank和paste， c命令被change占了）。y和p两个命令和其他的命令组合，可以覆盖绝大多数的用途。  </p><h2 id="精细组合操作"><a href="#精细组合操作" class="headerlink" title="精细组合操作"></a>精细组合操作</h2><p>比如<code>yw</code>复制一个单词，<code>yy</code>复制一行，<code>y$</code>复制当前光标到结尾, <code>y^</code>复制当前光标到开头， 同理，<code>yG</code>复制当前行到结尾。<br>这些命令还可以和数字继续组合，比如<code>y3w</code>复制3个单词， <code>2yy</code>复制三个单词。<br>还可以用来复制配对的括号的内容， 比如<code>yi&#123;</code>复制大括号<code>&#123;</code>中的内容，<code>ya&#123;</code>连括号一起复制。    </p><h2 id="寄存器的进阶用法"><a href="#寄存器的进阶用法" class="headerlink" title="寄存器的进阶用法"></a>寄存器的进阶用法</h2><h3 id="多种多样的寄存器"><a href="#多种多样的寄存器" class="headerlink" title="多种多样的寄存器"></a>多种多样的寄存器</h3><p>使用<code>:reg</code>查看寄存器，Vim的寄存器可以让复制粘贴玩出更多的花样， 下面介绍这些寄存器。<br>Vim的0-9寄存器是普通的寄存器，y命令默认会放到0，然后每次y会把最新的放到0，0放到1，依次保存结果。 如果你想粘贴哪个寄存器的值，在insert模式下<code>Ctrl+R 寄存器</code>， 比如粘贴寄存器3：<code>Ctrl+R 3</code>。</p><p>比较有用的是4个只读寄存器和搜索寄存器：</p><p><code>.</code>  最近插入的文本<br><code>:</code>  最近执行的命令<br><code>%</code>  存放当前文件名（相对）<br><code>#</code>  交替文件（这个好像没啥用, 就是你在当前terminal打开的上一个文件的文件名）<br><code>/</code> 搜索寄存器，可以设置默认的搜索内容。比如<code>:let @/ = &quot;package main&quot;</code>, 下次搜索的时候只要输入<code>/</code>， 会自动查找<code>package main</code>这段文本</p><h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><p><code>xp</code> 交换两个单词，x将一个单词剪切到寄存器，p复制（利用错位交换）<br>（交换两个单词建议用abloish插件）  </p><p>如果你删了东西后悔了可以去小删除寄存器里面找</p><h3 id="Vim剪切板和x11的剪切板交互"><a href="#Vim剪切板和x11的剪切板交互" class="headerlink" title="Vim剪切板和x11的剪切板交互"></a>Vim剪切板和x11的剪切板交互</h3><p>在设置中<code>set clipboard^=unnamed,unnamedplus</code>，开启系统的剪切板，就会多出来两个寄存器<code>*</code>和<code>+</code>。一般<code>*</code>是PRIMARY，<code>+</code>是CLIPBOARD。（开系统剪切板功能你可能需要gvim或者neovim，vim这个包可能不支持）  </p><p>当然这么干会把匿名寄存器“”的值和系统的CLIPBOARD复制粘贴绑定，不过比起少打几个<code>+</code>， 可以接受。<br>（并没有绑定PRIMARY，<code>*p</code>会粘贴CLIPBOARD的内容，PRIMARY直接鼠标中键粘贴就可以了。所以复制同步的过程并不会在每次鼠标选中文本的时候发生，只有在手动<code>Ctrl+Shitf+C</code>的时候才有，可以接受）</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvQ2xpcGJvYXJk">https://wiki.archlinux.org/title/Clipboard<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cudW5pbmZvcm1hdGl2LmRlL2Jsb2cvcG9zdGluZ3MvMjAxNy0wNC0wMi8wL1BPU1RJTkctZW4uaHRtbA==">X11: How does “the” clipboard work?<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJpYW5zdG9ydGkuY29tL3ZpbS1yZWdpc3RlcnMv">Vim registers: The basics and beyond<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;清明节假期写点Vim相关的东西，说一下寄存器。在此之前我眼中的复制粘贴从未如此复杂，就像我从未&lt;/p&gt;</summary>
    
    
    
    <category term="不务正业系列" scheme="https://zhangjk98.xyz/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="vim" scheme="https://zhangjk98.xyz/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>VSCode C/C++ 开发环境和调试配置：Clangd+Codelldb</title>
    <link href="https://zhangjk98.xyz/vscode-c-and-cpp-develop-and-debug-setting/"/>
    <id>https://zhangjk98.xyz/vscode-c-and-cpp-develop-and-debug-setting/</id>
    <published>2022-03-20T12:02:25.000Z</published>
    <updated>2022-03-20T12:02:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>卸了cpptools和C++ Intelligence吧，来试试clangd或者ccls</p><span id="more"></span><h2 id="太长不看版"><a href="#太长不看版" class="headerlink" title="太长不看版"></a>太长不看版</h2><p>别用微软官方的那个C&#x2F;C++扩展（cpptools）和 C++ intelligence 扩展，用 clangd 和 CodeLLDB。<br><strong>全文完。我们下次再见</strong></p><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>寻找保姆级教程、习惯鼠标操作、想将VSCode打造成一个C&#x2F;C++ IDE的读者建议立刻退出并寻找其他教程。以下操作以Archlinux为例，如果你是Windos用户请去用尊贵的宇宙第一IDE Visual Studio 或者通过WSL和VSCode Remote获得一个linux的开发环境。以下假定读者有一定的基础和使用搜索引擎查资料的能力。<strong>这不是一个保姆级教程、详细教程</strong>。  </p><p>配置环境本应该是一件很简单的事情，然而M$的官方文档在推自己的cpptools塞私货，大量配置教程不是太啰嗦就是教你用cpptools，已经造成了信息污染。于是有了这篇clangd和Codelldb安利文。</p><p>事实上这是很简单的，你只需要干这些事：</p><h3 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h3><p>通常一条命令就可以了，已安装用户请略过</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装code-oss版本，和插件市场</span>yay -S code code-marketplace<span class="token comment"># 如果你想装闭源的VSCode</span>yay -S visual-studio-code-bin <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装编译器"><a href="#安装编译器" class="headerlink" title="安装编译器"></a>安装编译器</h3><p>想用gcc就用gcc，无特殊需求系统自带的gcc已经足矣（有特殊版本和交叉编译请自行安装对应版本）。想用clang就装clang。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay -S llvm lld lldb clang<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>点击安装就可以</p><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWxsdm0tdnMtY29kZS1leHRlbnNpb25zLnZzY29kZS1jbGFuZ2Q=">clangd插件<i class="fa fa-external-link-alt"></i></span>  用于高亮、自动补全、跳转<br><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXZhZGltY24udnNjb2RlLWxsZGI=">CodeLLDB插件<i class="fa fa-external-link-alt"></i></span>  如果你需要图形界面debug</p><p>ps: 如果你用闭源的VSCode，那就直接在M$的插件市场装。Code-OSS版本可以修改<code>product.json</code>使用插件市场。如果你使用或者VSCodium版本，请从OpenVSX安装<span class="exturl" data-url="aHR0cHM6Ly9vcGVuLXZzeC5vcmcvZXh0ZW5zaW9uL2xsdm0tdnMtY29kZS1leHRlbnNpb25zL3ZzY29kZS1jbGFuZ2Q=">clangd插件<i class="fa fa-external-link-alt"></i></span>（或者手动下载）</p><h3 id="安装clangd-LSP"><a href="#安装clangd-LSP" class="headerlink" title="安装clangd LSP"></a>安装clangd LSP</h3><p>然后按<code>F1</code>，选<code>clangd:Download Language Server</code>, 下载clangd LSP （如果你想用系统包管理器装clangd也可以, Archlinux在<code>llvm</code>这个包里，Debian等发行版有单独的<code>clangd</code>包）</p><h2 id="Debug和运行"><a href="#Debug和运行" class="headerlink" title="Debug和运行"></a>Debug和运行</h2><p>编译运行这个就没必要装插件了吧，单个文件我使用gcc&#x2F;g++命令或者clang&#x2F;clang++命令，编译并运行。一个项目那就写个Makefile或者cmake之类的东西呗。</p><h3 id="使用gdb和lldb命令Debug"><a href="#使用gdb和lldb命令Debug" class="headerlink" title="使用gdb和lldb命令Debug"></a>使用gdb和lldb命令Debug</h3><p>如果你需要Debug，在终端使用gdb和lldb即可， over～</p><h3 id="使用VSCode提供的图形界面Debugger"><a href="#使用VSCode提供的图形界面Debugger" class="headerlink" title="使用VSCode提供的图形界面Debugger"></a>使用VSCode提供的图形界面Debugger</h3><p>哦，你要图形界面啊，安装Codelldb插件。<code>Ctrl+Shift+D</code>点左边栏的debug按钮，然后应该会自动生成一个<code>launch.json</code>，然后自行配置你的debug命令、参数和环境变量，参考：<span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9lZGl0b3IvZGVidWdnaW5n">VSCode Debugging<i class="fa fa-external-link-alt"></i></span></p><p><code>tasks.json</code>如下，我以c语言为例，设置输出到<code>build</code>文件夹下同名<code>.out</code>文件，有需要请自行修改。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"2.0.0"</span><span class="token punctuation">,</span>    <span class="token property">"tasks"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"label"</span><span class="token operator">:</span> <span class="token string">"Compile"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"process"</span><span class="token punctuation">,</span>            <span class="token property">"command"</span><span class="token operator">:</span> <span class="token string">"clang"</span><span class="token punctuation">,</span>            <span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                <span class="token string">"$&#123;file&#125;"</span><span class="token punctuation">,</span>                <span class="token string">"-g"</span><span class="token punctuation">,</span>                <span class="token string">"-o"</span><span class="token punctuation">,</span>                <span class="token string">"$&#123;fileDirname&#125;/build/$&#123;fileBasenameNoExtension&#125;.out"</span><span class="token punctuation">,</span> <span class="token comment">// 输出到build文件夹下</span>                <span class="token string">"-Wall"</span><span class="token punctuation">,</span>                <span class="token string">"-std=c11"</span><span class="token punctuation">,</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"group"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"kind"</span><span class="token operator">:</span> <span class="token string">"build"</span><span class="token punctuation">,</span>                <span class="token property">"isDefault"</span><span class="token operator">:</span> <span class="token boolean">true</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>            <span class="token property">"options"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;fileDirname&#125;"</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>launch.json</code>如下，注意<code>preLaunchTask</code>要先执行<code>task.json</code>的label为<code>Compile</code>的任务</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"version"</span><span class="token operator">:</span> <span class="token string">"0.2.0"</span><span class="token punctuation">,</span>    <span class="token property">"configurations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>            <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"LLDB Debug"</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"lldb"</span><span class="token punctuation">,</span>            <span class="token property">"request"</span><span class="token operator">:</span> <span class="token string">"launch"</span><span class="token punctuation">,</span>            <span class="token property">"program"</span><span class="token operator">:</span> <span class="token string">"$&#123;fileDirname&#125;/build/$&#123;fileBasenameNoExtension&#125;.out"</span><span class="token punctuation">,</span>            <span class="token property">"cwd"</span><span class="token operator">:</span> <span class="token string">"$&#123;fileDirname&#125;"</span><span class="token punctuation">,</span>            <span class="token property">"preLaunchTask"</span><span class="token operator">:</span> <span class="token string">"Compile"</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好了，这样就可以了。</p><h2 id="其他的配置"><a href="#其他的配置" class="headerlink" title="其他的配置"></a>其他的配置</h2><h3 id="调试时使用命令操作"><a href="#调试时使用命令操作" class="headerlink" title="调试时使用命令操作"></a>调试时使用命令操作</h3><p>按F5进行调试，此时按<code>Ctrl+Shift+Y</code>调出Debug Console REPL就可以用gdb&#x2F;lldb的命令进行调试了。这样就又回到了熟悉的gdb&#x2F;lldb的命令，就可以不需要鼠标点点点进行调试了，一些Codelldb不支持显示在图形界面的调试功能也可以用了。</p><h3 id="每次调试都多产生一个Debug-Console"><a href="#每次调试都多产生一个Debug-Console" class="headerlink" title="每次调试都多产生一个Debug Console"></a>每次调试都多产生一个Debug Console</h3><p>给<code>launch.json</code>加上</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token comment">//args的这个设置是为了防止每次Debug都会多弹出一个Debug Console</span><span class="token property">"args"</span><span class="token operator">:</span> <span class="token punctuation">[</span>       <span class="token string">"&amp;&amp;"</span><span class="token punctuation">,</span>    <span class="token string">"exit"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="随便说说"><a href="#随便说说" class="headerlink" title="随便说说"></a>随便说说</h2><h3 id="关于C-x2F-C-的LSP其他选择"><a href="#关于C-x2F-C-的LSP其他选择" class="headerlink" title="关于C&#x2F;C++的LSP其他选择"></a>关于C&#x2F;C++的LSP其他选择</h3><p>目前用的比较多的C&#x2F;C++的LSP是ccls和clangd，各有优劣。我的体验是ccls没有clangd的补全和错误提示那么舒服，就一直在用clangd，有兴趣可以试试ccls。<br><del>反正这两个都比cpptools好用就是了</del></p><h3 id="关于VSCode和插件"><a href="#关于VSCode和插件" class="headerlink" title="关于VSCode和插件"></a>关于VSCode和插件</h3><p>本来是不想写这个的。但是看到你们官方文档闭口不提clangd，网上各路教程也都在教大家用cpptools和C++ intelligence这两个插件，我蚌埠住了。昨天一个小学弟配vscode的c&#x2F;c++环境，折腾了一整天，然后跟我吐槽vscode又慢又卡，我心里暗叫不好，这不会是又用了cpptools和C++ intelligence这两个插件吧。我问小学弟为什么不用clangd，他表示官方文档也没说啊，他明明按照官方文档来的。好吧，这也不怪小学弟，连官方文档都在叫你用M$那两个又吃内存又难用的插件。Google能搜到的也都在让你装这个。甚至你从EXTENSOINS的搜索栏里面搜c或者c++，前两个插件就是这两个，至于clangd，已经排在无数个名字里有c&#x2F;c++插件的后面找不着了。</p><p><strong>我的操作逐渐转为快捷键和terminal，图形界面主要用来展示而不是用来点点点完成操作</strong>。我主要是将VSCode作为一个neovim&#x2F;gdb&#x2F;lldb的展示前端来用，<a href="https://zhangjk98.xyz/vscode-neovim-setting/">Neovim插件配置见上一篇博客</a>。目前用习惯了VSCode还真没动力换别的，几次试图切到纯Neovim最后又滚回了VSCode+Neovim插件。  </p><p>VSCode正在变得臃肿，而且打字延迟比Sublime和Neovim高。VSCode丝滑的感觉远不如Sublime Text，也不如高配电脑上的Jetbrains家的全家桶。我比较喜欢VSCode一个是LSP，一个是没有太多捆绑功能+丰富的插件生态和开箱即用。但是最近这两年总感觉它不再想好好做一个编辑器了，总想抢IDE的活，可能是风头压过atom和sublime之后也失去了方向。单纯作为一个文本编辑器，VSCode的打磨和细节体验和Vim、Sublime都有还有不小的差距，但是现在眼看着要向一个IDE的方向狂奔了。</p><p>VSCode的插件良莠不齐，而VSCode本体也逐渐和我想要的编辑器差距越来越大。但是毕竟用习惯了。现在很多网上的教程都是把VSCode配置成IDE，装了一大堆插件，最后又慢又卡。大多数复杂的功能学习所用的时间很有可能赶不上学会以后帮你节省的时间，尤其是点点点的图形界面，每次更新按钮换位置又要从头找起。就算学也学一点一些不怎么变的快捷键和Vim操作，那些在肌肉记忆可以一直用下去。</p><p>我觉得如果VSCode你要用的开心，<strong>不要当IDE用，就当一个编辑器用</strong>。要有一种又不是不能用的<strong>摆烂</strong>心态，不要刻意去配置。简单配置到<strong>能用就行</strong>。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9vcGVuLXZzeC5vcmcv">https://open-vsx.org/<i class="fa fa-external-link-alt"></i></span> M$的VSCode插件市场的开源替代<br><span class="exturl" data-url="aHR0cHM6Ly9jbGFuZ2QubGx2bS5vcmcv">https://clangd.llvm.org<i class="fa fa-external-link-alt"></i></span> clangd项目</p><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9lZGl0b3IvZGVidWdnaW5n">https://code.visualstudio.com/docs/editor/debugging<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9pbnRyb3ZpZGVvcy9kZWJ1Z2dpbmc=">https://code.visualstudio.com/docs/introvideos/debugging<i class="fa fa-external-link-alt"></i></span></p><h2 id="番外：linux源码阅读环境配置"><a href="#番外：linux源码阅读环境配置" class="headerlink" title="番外：linux源码阅读环境配置"></a>番外：linux源码阅读环境配置</h2><p>一般看这种源码几乎都是Vim下用gtags或者在vscode下用 gnu global 插件，不过clangd配置完成后有语义分析，体验更好一点（虽然clangd会对一些注释和宏报Warning）。  </p><p>看这种大项目的代码，首先不能卡，然后要有语法高亮和跳转。然后各种头文件和宏不要一堆飘红报错。我之前一直以为VSCode打开这种特别大的项目的表现不堪大任，后来发现只是插件的问题，clangd表现相当不错。 </p><p>下载kernel的源码，如果只是阅读的话推荐只下载当前版本的，不要下整个 git repo，vscode打开repo会比打开普通文件夹要吃内存。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.16.15.tar.xz<span class="token function">tar</span> xf linux-5.16.15.tar.xz<span class="token builtin class-name">cd</span> linux-5.16.15<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们需要生成<code>compile_commands.json</code>，这个可以用bear或者<code>scripts/clang-tools/gen_compile_commands.py</code>这个自带的脚本。不过这两种方法都需要你编译一遍内核。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zcat /proc/config.gz <span class="token operator">></span> .config  <span class="token comment"># 复制本机的config作为编译的config，有需要请自行定制</span>bear -- <span class="token function">make</span> -j <span class="token number">12</span>  <span class="token comment"># 生成compile_commands.json</span><span class="token comment">## 或者用提供的python脚本生成</span><span class="token function">make</span>    <span class="token comment"># 编译</span>python scripts/clang-tools/gen_compile_commands.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>编译要等一段时间，我用5600G编译大概40分钟。然后clangd会自动开始indexing，我这里有两万多个index，indexing大概花了20多分钟。到这里头文件和自动跳转都正常了，此时浏览代码的时候vsc内存占用占用大概1-2G左右。<br>我还加了这几个参数: 采用gnu89标准（新版的linux 5.18 要升到c11了，如果你是master，换成<code>-std=gnu11</code>）、将预编译头文件放到内存里、关闭 clangd format （这个挺吃资源的，就看个源码不需要自动format）</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"clangd.arguments"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token string">"-std=gnu89"</span><span class="token punctuation">,</span>        <span class="token string">"--pch-storage=memory"</span><span class="token punctuation">,</span>        <span class="token string">"-j=12"</span><span class="token punctuation">,</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token property">"editor.formatOnSave"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于这里只是阅读源码，所以 clangd-tidy 和全局自动补全这些参数（”–clang-tidy”,”–all-scopes-completion”,）我都没有启用。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;卸了cpptools和C++ Intelligence吧，来试试clangd或者ccls&lt;/p&gt;</summary>
    
    
    
    
    <category term="VSCode" scheme="https://zhangjk98.xyz/tags/VSCode/"/>
    
    <category term="clangd" scheme="https://zhangjk98.xyz/tags/clangd/"/>
    
  </entry>
  
  <entry>
    <title>Go Workspace：本地可以愉快的replace了</title>
    <link href="https://zhangjk98.xyz/go-multi-module-workspace/"/>
    <id>https://zhangjk98.xyz/go-multi-module-workspace/</id>
    <published>2022-03-18T02:45:03.000Z</published>
    <updated>2022-03-18T02:45:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天go2:1.18终于发布了，万众期待的泛型终于来了。不过我一直期待的是 go mod 的改动，新增了workspace和go vendor那几个命令不再默认更新<code>go.mod</code>和<code>go.sum</code>，不用再苦哈哈的replace和固定版本了。<br><del>然而这并不能改变go包管理器依旧鸡肋的现状</del></p><span id="more"></span><h2 id="终于等到workspace"><a href="#终于等到workspace" class="headerlink" title="终于等到workspace"></a>终于等到workspace</h2><p>之前用 go module 我们有各种奇奇怪怪的理由要用replace：</p><ol><li>我在本地新建了一个项目，然后我<code>go mod init github/archaeoraptor/XXX</code>， 但是我暂时不想push上去</li><li>写的比较乱我暂时不想commit</li><li>用到了别人的依赖但是我魔改了点内容</li><li>哎哎哎，go mod tidy 怎么自动把我modules版本升上去了，我不想升啊</li><li>我想把github上面的私有项目迁移到gitea，想把url换成这个</li></ol><p>我自己写就在<code>go.mod</code>里面replace就好了，手写几行 replace 又不是太麻烦的事情。<br>然而我和我室友一起写点项目的时候麻烦就来了，replace 的本地路径不一样，我是<code>/home/xxx/xxx</code>，他是<code>C:\XXX\XXX</code>，这样在 commit 的时候就有问题。但是把<code>go.mod</code>放到<code>.gitignore</code>里面忽略掉又不好。</p><p>如果有一个像vscode那样的workspace，workspace中的本地json设置可以覆盖全局的json设置就好了。</p><h2 id="go-work-使用"><a href="#go-work-使用" class="headerlink" title="go work 使用"></a>go work 使用</h2><p>举例说明一下, 新建一个叫hello的repo, hello.go和main.go内容:</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//hello.go</span><span class="token keyword">package</span> hello<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello, World!"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// main.go</span><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"github.com/archaeoraptor/hello"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    hello<span class="token punctuation">.</span><span class="token function">Hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果你想不commit和push, 也不想修改go.mod文件加入replace，在本地能跑，那么需要将这两个文件放到同一个 go module 里面：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ go mod init github.com/archaeoraptor/hello_repo$ tree<span class="token builtin class-name">.</span>├── go.mod├── hello│   ├── go.mod│   └── hello.go└── main.go<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>repo根目录的<code>go.mod</code>:</p><pre class="line-numbers language-none"><code class="language-none">module github.com&#x2F;archaeoraptor&#x2F;hello_repogo 1.18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这个时候不commit并push到远程，直接执行<code>go run main.go</code>是可以正常运行出<code>Hello, World!</code>的。</p><p>不过有的时候我们想要设置嵌套模块(nested modules)或者一个repo里面多个module（<strong>比如万恶的grpc，一个项目里面可能要依赖不同版本的grpc</strong>, 这时候就需要一个项目中多个<code>go.mod</code>来兼容不同的版本）</p><p>如果你想给hello单独设为嵌套模块<br>目录结构变成这样:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">module github.com/archaeoraptor/hellogo <span class="token number">1.18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时：hello目录的<code>go.mod</code>长这样：</p><pre class="line-numbers language-none"><code class="language-none">module github.com&#x2F;archaeoraptor&#x2F;hello&#x2F;hellogo 1.18<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>此时我们还没有上传，就会报错<code>go: finding module for package github.com/archaeoraptor/hello/hello  ... fatal: repository &#39;https://github.com/archaeoraptor/hello/&#39; not found</code>或者<code>can&#39;t request version &quot;latest&quot; of the main module (github.com/archaeoraptor/hello)</code></p><p>这个时候我们以前会改<code>go.mod</code>用replace替换成本地的：</p><pre class="line-numbers language-config" data-language="config"><code class="language-config">module github.com&#x2F;archaeoraptor&#x2F;hellogo 1.18require github.com&#x2F;archaeoraptor&#x2F;hello&#x2F;hello v0.0.0-20220318143722-96fbd621879dreplace github.com&#x2F;archaeoraptor&#x2F;hello&#x2F;hello &#x3D;&gt; ..&#x2F;hello&#x2F;hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了workspace，可以将replace写在<code>go.work</code>中，然后将<code>go.work</code>添加到<code>.gitignore</code>。这样不同人对replace的更改就不会影响repo中的<code>go.mod</code>了</p><p>新建workspace(在module的外层目录)</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">cd <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">go</span> work init <span class="token punctuation">.</span><span class="token operator">/</span>hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>会产生一个<code>go.work</code>文件夹，加入replace</p><pre class="line-numbers language-none"><code class="language-none">go 1.18use .&#x2F;helloreplace github.com&#x2F;archaeoraptor&#x2F;hello&#x2F;hello &#x3D;&gt; .&#x2F;hello&#x2F;hello<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="终于不再默认更新依赖"><a href="#终于不再默认更新依赖" class="headerlink" title="终于不再默认更新依赖"></a>终于不再默认更新依赖</h2><p>1.18终于更改了之前<code>go mod vendor</code>等命令默认更新<code>go.mod</code>和<code>go.sum</code>的迷惑行为。</p><p>什么？这难道不好吗？理论上来说这很好，如果这些包都按照语义化版来。但是有的包它不讲武德，小版本升级有breaking changes，最爱干这种事的还不是那些野鸡包，<strong>就是是谷歌自家的grpc</strong></p><p>按照语义化版本号一般的习惯，只有大版本更新（v1更新到v2, v2更新到v3）才有 breaking changes， 小版本的更新是向下兼容的（v1.1更新到v1.2），grpc基本每次小版本更新总有 breaking changes。我好几次arch滚出问题都是因为grpc。</p><p>每次想执行<code>go mod vendor</code>等命令的时候，之前为了不让它自动更新<code>go.mod</code>的依赖版本，只能用各种扭曲的办法，比如加<code>-mod=readonly</code>参数。</p><h2 id="闲话包管理器"><a href="#闲话包管理器" class="headerlink" title="闲话包管理器"></a>闲话包管理器</h2><p>相比广为诟病的错误处理啊，没有泛型啊，我一直觉得go的包管理器是个更麻烦的问题。包管理器的问题很容易成为历史包袱的。包管理器一开始留下的问题，再想改就很麻烦，有兴趣可以看看npm之类的历史包袱。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9nby5kZXYvZG9jL3R1dG9yaWFsL3dvcmtzcGFjZXM=">Tutorial: Getting started with multi-module workspaces<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvNDU3MTM=">https://github.com/golang/go/issues/45713<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZXB1ZGRzL2dvLW1vZHVsZS1rbm9icy9ibG9iL21hc3Rlci9SRUFETUUubWQ=">go-module-knobs<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9lbmNvcmUuZGV2L2d1aWRlL2dvLm1vZA==">Go modules cheat sheet<i class="fa fa-external-link-alt"></i></span>  </p><h3 id="包管理器相关"><a href="#包管理器相关" class="headerlink" title="包管理器相关"></a>包管理器相关</h3><p><span class="exturl" data-url="aHR0cHM6Ly93eHNtLnNwYWNlLzIwMjEvbnBtLWhpc3Rvcnkv">Node.js 包管理器发展史<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9nby5nb29nbGVzb3VyY2UuY29tL3Byb3Bvc2FsLysvbWFzdGVyL2Rlc2lnbi80NTcxMy13b3Jrc3BhY2UubWQ=">Proposal: Multi-Module Workspaces in cmd&#x2F;go<i class="fa fa-external-link-alt"></i></span>   </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天go2:1.18终于发布了，万众期待的泛型终于来了。不过我一直期待的是 go mod 的改动，新增了workspace和go vendor那几个命令不再默认更新&lt;code&gt;go.mod&lt;/code&gt;和&lt;code&gt;go.sum&lt;/code&gt;，不用再苦哈哈的replace和固定版本了。&lt;br&gt;&lt;del&gt;然而这并不能改变go包管理器依旧鸡肋的现状&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Concurrency&amp;Go" scheme="https://zhangjk98.xyz/categories/Concurrency-Go/"/>
    
    
    <category term="go" scheme="https://zhangjk98.xyz/tags/go/"/>
    
    <category term="workspace" scheme="https://zhangjk98.xyz/tags/workspace/"/>
    
  </entry>
  
  <entry>
    <title>6.824 Lab1 MapReduce 经典老番</title>
    <link href="https://zhangjk98.xyz/map-reduce/"/>
    <id>https://zhangjk98.xyz/map-reduce/</id>
    <published>2022-03-01T12:57:10.000Z</published>
    <updated>2022-03-01T12:57:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Long Live Map Reduce</p><span id="more"></span><p>MapReduce的影响挺大的</p><h2 id="Map和Reduce操作"><a href="#Map和Reduce操作" class="headerlink" title="Map和Reduce操作"></a>Map和Reduce操作</h2><p>MapReduce 最早是函数式编程里的概念，我一开始也是在python里面最听到这两个词的。map用来映射，reduce用来聚合。</p><p>python里面是这样的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> <span class="token builtin">reduce</span><span class="token keyword">def</span> <span class="token function">f1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token operator">*</span>x<span class="token keyword">def</span> <span class="token function">f2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token operator">*</span>ynums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>suqare <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">//</span><span class="token builtin">reduce</span>作用于一个序列，效果相当于阶乘factorial <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">reduce</span><span class="token punctuation">(</span>f2<span class="token punctuation">,</span> nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>求阶乘的操作用循环也可以做到，但是我们注意到这些操作有很好的性质，可以分离开计算再求总和，这样就可以拆解为一些小的并行计算。（循环也可以被SIMD指令并行，这里先不多说了）</p><p>遍历使用迭代器完成的</p><h2 id="分布式的MapReduce"><a href="#分布式的MapReduce" class="headerlink" title="分布式的MapReduce"></a>分布式的MapReduce</h2><p><img src="/map-reduce/1647509929.png"></p><p>Map和Reduce两种操作和上面python的例子用法一样</p><p><img src="/map-reduce/1647509989.png"></p><p>论文以 wc （单词统计）为例。master会分出M个Map任务和N个Reduce任务，然后分配给worker。</p><p>Map任务执行用户自定义的map函数，输出一个&lt;key, value&gt;。</p><p>Reduce执行用户自定义的reduce函数，用来聚合相同的&lt;key, value&gt;。</p><p>要注意Map和Reduce是有先后顺序的，需要完成Map操作</p><h2 id="Lab1-实现一个玩具MapReduce"><a href="#Lab1-实现一个玩具MapReduce" class="headerlink" title="Lab1 实现一个玩具MapReduce"></a>Lab1 实现一个玩具MapReduce</h2><p>注：看起来这个Lab和去年的一样，把去年做的直接拿过来了，当时实现的时候不少地方挺粗糙的。</p><p>6.824的Lab1是做一个MapReduce，例子就是当年Google经典论文里面的那个 word count。wc和阶乘、求和一样有很好的性质，能够并行。</p><p>这个Lab很简单，<code>src/main/mrapps/wc.go</code>给好了一个单机版的例子，实现这样的效果：<code>cat mr-out-* | sort | more</code></p><p>仿照单机版本用rpc通信做一个并行版本就可以了。（这里没有真正的集群，用多个goroutine模拟并行）</p><p>我们需要补全3个文件：coordinator.go, worker.go, rpc.go。这里的coordinator就是论文里的master，因为<del>黑命贵</del>某些原因惨遭和谐，你打开以前的Lab就可以看到它本来就是master.go</p><p>rpc.go 里面已经给了一个例子，我们仿照着写就可以了（其实本来我是想直接用grpc来着）。注意PRC的struct要大写。</p><p>worker很容易，向master发送RPC请求然后接任务并返回就可以了。将Map任务分配到对应的worker中可以直接使用给好的<code>ihash</code>函数</p><p>master要产生并分配map任务和reduce任务，然后接收的时候判断一下是否可以合并。这里一个比较麻烦的地方是处理worker超时、停机等情况。不过这里提示我们用一个简单的方法：For this lab, have the master wait for ten seconds; after that the master should assume the worker has died (of course, it might not have). 不区分超时和宕机，直接等待10s，10s后如果没收到就直接不要这个worker的任务了。</p><h3 id="race问题"><a href="#race问题" class="headerlink" title="race问题"></a>race问题</h3><p>我去年做的时候是给channel加Mutex锁来保证没有race。go的风格是尽量用channel避免加锁，我试着全用channel但是更乱了，可能是我的操作不对，最后还是用了锁。</p><h3 id="reduce需要在每个map全部完成后再开始"><a href="#reduce需要在每个map全部完成后再开始" class="headerlink" title="reduce需要在每个map全部完成后再开始"></a>reduce需要在每个map全部完成后再开始</h3><p>Map任务和Reduce任务是不能并行的，Reduce需要等待所有Map任务完成之后才能开始。</p><p>之前做的时候是傻呼呼的让reduce任务的节点发rpc给master，然后等到map完成数为M了才开始。这次翻了翻Lab的Hints，原来可以用<code>sync.Cond</code> (条件变量)，大概像下面这样</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// w.cond = sync.NewCond(w)</span><span class="token comment">// master</span><span class="token keyword">func</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>Worker<span class="token punctuation">)</span> BeginReduceWork <span class="token punctuation">&#123;</span>    w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">&#123;</span>        all_map_task_finish <span class="token boolean">true</span>    <span class="token punctuation">&#125;</span>    w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span><span class="token function">Broadcast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">//广播，开始每一个Reduce任务</span><span class="token punctuation">&#125;</span><span class="token comment">//worker</span><span class="token keyword">func</span> <span class="token punctuation">(</span>w <span class="token operator">*</span>Worker<span class="token punctuation">)</span> doReduce <span class="token punctuation">&#123;</span>    w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token operator">!</span>all_map_task_finish <span class="token punctuation">&#123;</span>        w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// start Reduce Task</span>    w<span class="token punctuation">.</span><span class="token function">startReduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    w<span class="token punctuation">.</span>cond<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>sync.Cond</code>这个讨论串挺有意思的<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9pc3N1ZXMvMjExNjU=">proposal: Go 2: sync: remove the Cond type<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="写入的原子性"><a href="#写入的原子性" class="headerlink" title="写入的原子性"></a>写入的原子性</h3><p>Lab的提示告诉你，写入新建一个副本，然后应用更改的时候重命名</p><blockquote><p>To ensure that nobody observes partially written files in the presence of crashes, the MapReduce paper mentions the trick of using a temporary file and atomically renaming it once it is completely written. You can use ioutil.TempFile to create a temporary file and os.Rename to atomically rename it.</p></blockquote><h3 id="master挂了怎么办"><a href="#master挂了怎么办" class="headerlink" title="master挂了怎么办"></a>master挂了怎么办</h3><p>我做Lab的时候没有考虑这个问题，假设它不会挂。</p><p>如果真的挂了那就再来一遍吧（可以保存中间文件，这样已经产生的中间文件就不用从Map操作再产生一遍了）</p><h3 id="输入在变怎么办"><a href="#输入在变怎么办" class="headerlink" title="输入在变怎么办"></a>输入在变怎么办</h3><p>如果输入（比如需要wc的单词）一直在改变，这样也是不适合用MapReduce处理的。这种可以去用storm和flink。实时计算这些我也不不懂，不管了。</p><h3 id="网络问题和恶意篡改"><a href="#网络问题和恶意篡改" class="headerlink" title="网络问题和恶意篡改"></a>网络问题和恶意篡改</h3><p>一般我们部署在内网集群，不考虑网络带宽问题。TB级别的文件分为总文件大小除以64M的Map<br>同理假定所有节点不存在恶意篡改，也不考虑Paxos等算法考虑的拜占庭问题。</p><!-- ## Push一下老板老板给本科生讲课讲王珊《数据库系统概论》，基本就还是老一套。除了上机和作业，一半的时间在讲约束和范式，一半的课时在讲触发器、游标、存储过程，还是有两把刷子的。好吧，老板的课我当年都没从头到尾好好听，只听了和看了书里面范式、约束、隔离级别和锁那些。老板讲的那一套用面向对象那一套建好多个表和约束、多表联结查询、逻辑都写在存储过程里面，做一个传统的金融、HIS系统那种对约束要求严格业务繁多的不过上周组会还是出乎我的意料。老板他老人家最近又有了奇思妙想，虽然他组会上说下周找一个毕业的师兄过来给我们讲一下联邦学习的时候，一口一个大数据，啊，开始吹什么大公司都在用啊这个很有前景啊。我一脸懵，联邦学习是什么？老板：巴拉巴拉....我：这不就跟MapReduce那一套东西差不多老板：MapReduce是什么？我：巴拉巴拉老板：不是的，不是这个东西老板大概是多年没有亲自写过代码了，技术水平和概念还停留在sql server 2000、Oracle那一堆逻辑写在存储过程里面和上个世纪在金蝶公司用C++写图形界面。（**年轻帅气的老板在写代码的时候我甚至还没有出生**，Google经典三篇发布都已经是零几年的事了，当时老板做的东西也还是Oracle单机那一套，没听过可能也正常）咳咳，不黑老板了老板你要是看到我这篇博客，少玩点手机啊，看看DDIA吧 --><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p> GFS的经典论文</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Long Live Map Reduce&lt;/p&gt;</summary>
    
    
    
    <category term="Concurrency&amp;Go" scheme="https://zhangjk98.xyz/categories/Concurrency-Go/"/>
    
    
    <category term="6.824" scheme="https://zhangjk98.xyz/tags/6-824/"/>
    
    <category term="MapReduce" scheme="https://zhangjk98.xyz/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Traps 笔记</title>
    <link href="https://zhangjk98.xyz/6.S081-lab-trap/"/>
    <id>https://zhangjk98.xyz/6.S081-lab-trap/</id>
    <published>2022-01-12T11:19:30.000Z</published>
    <updated>2022-01-12T11:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个Lab跟其他的比起来挺简单的，主要是汇编要去翻翻手册，简单说一下吧。顺便讲一下中断之类的东西。</p><span id="more"></span><h2 id="xv6的Trap"><a href="#xv6的Trap" class="headerlink" title="xv6的Trap"></a>xv6的Trap</h2><p>xv6的trap包括interrupt这些，就是大部分切入内核态的东西都算作中断。以<code>write</code>系统调用为例，一般是<code>ecall</code>指令进入特权模式，然后<code>uservec</code>保存 寄存器进入内核态，然后<code>usertrap</code>, 然后syscall执行16号<code>sys_write</code>, 执行完之后<code>usertrapret</code>调用<code>userret</code>返回用户空间</p><h3 id="相关的寄存器和指令"><a href="#相关的寄存器和指令" class="headerlink" title="相关的寄存器和指令"></a>相关的寄存器和指令</h3><p>RISC-V的汇编指令和ARM的还是有挺多不一样的地方，我一开始凭着本科学的那点ARM汇编的印象，搞错了好几次（最后还是翻手册的时候才意识到我错了，太坑了，说好的RISC-V和ARM指令差不多呢）</p><p><img src="/6.S081-lab-trap/1651803380.png"></p><p>通用寄存器和ARM差不多，a0-a2这些是函数的参数，t0-t9和s0-s7这些都是保存临时值的（saved registers），区别是t开头的是caller-saved，可以被其他函数返回值更改，s开头的是callee-saved，不会被函数返回值之类的的东西更改。</p><p>ECALL会进入特权模式，这个syscall的时候讲过了不多说了。risc-v跟中断有关的寄存器比较多，建议下面看到什么直接去翻手册：<span class="exturl" data-url="aHR0cDovL3Jpc2N2Ym9vay5jb20vY2hpbmVzZS9SSVNDLVYtUmVhZGVyLUNoaW5lc2UtdjJwMS5wZGY=">RISC-V 手册<i class="fa fa-external-link-alt"></i></span>  </p><p><img src="/6.S081-lab-trap/1651762525.png"></p><p>在RISC-V中，下面这些跟中断有关的寄存器属于CSR（Control and Status Registers）寄存器</p><p>SP寄存器： 栈寄存器，不说了<br>PC寄存器： 程序计数器，不说了<br>SATP寄存器： 用来控制分页的特权模式<br>STVEC寄存器：中断向量基址寄存器<br>SEPC寄存器：记录触发中断的向量地址，用来trap返回时恢复<br>SSRATCH寄存器：一般通过csrrw指令交换，在用户态保存内核栈的地址，在内核态值为0（可以通过这个判断是否处于内核态）<br>SCAUSE寄存器：中断类型和原因<br>STVAL寄存器：用来存储其他异常有关的东西</p><p>SIE寄存器：Supervisor Interrupt Enable， 中断使能<br>SIP寄存器：记录每种中断是否被触发<br>SSTAUTS寄存器：也是记录状态  </p><p>再简单说一下用到的指令：</p><p>sd指令（Store Double）<br>sd rs2, offset(rs1)<br>将 x[rs2]中的 8 字节存入内存地址 x[rs1]+sign-extend(offset)。</p><p>ld指令（load double，双字加载）<br>ld rd, offset(rs1) x[rd] &#x3D; M[x[rs1] + sext(offset)][63:0]<br>双字加载 (Load Doubleword). I-type, RV32I and RV64I.<br>从地址 x[rs1] + sign-extend(offset)读取八个字节，写入 x[rd]。</p><p><img src="/6.S081-lab-trap/1651803349.png"></p><p>读写CSR寄存器的指令：</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm"><span class="token operator">#</span> 控制状态寄存器<span class="token operator">#</span> CSR Read Write<span class="token punctuation">,</span> 将csr读入rd， 同时将zimm写入csr（原子操作）csrrw rd<span class="token punctuation">,</span> csr<span class="token punctuation">,</span> zimm <span class="token operator">#</span> Control ans Status Register Read<span class="token punctuation">,</span> 读控制状态寄存器<span class="token punctuation">,</span> 读取csrcsrr rd<span class="token punctuation">,</span> csr<span class="token operator">#</span> CSR Write， 写控制状态寄存器<span class="token punctuation">,</span> 作用相当于将rs1的值写入csrcsrw csr<span class="token punctuation">,</span> rs1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有csrs和csrc，用来将csr指定位置的值置为0或1。此外还有csrrs、csrrc这些，用来读取（read）一个csr的值然后, 将csr中特定的bit置为0&#x2F;1，trap的相关操作没有涉及到，暂时不用管。</p><p>然后是中断切换的指令</p><p>ecall：切换特权模式触发中断<br>sret：从S MODE（内核态）返回用户态，将PC的值设置为SEPC<br>ebreak：断点（调试的时候用）<br>mret：从M MODE（机器态）返回内核态，将PC置为MEPC（这个不用管，这个Lab没涉及到）</p><p>然后是用来保证内存屏障的指令，用来在更改页表的时候刷新内存屏障的</p><p>sfemce.vma rs1, rs2<br>虚拟内存屏障(Fence Virtual Memory). R-type, RV32I and RV64I 特权指令。<br>根据后续的虚拟地址翻译对之前的页表存入进行排序。当 rs2&#x3D;0 时，所有地址空间的翻译都<br>会受到影响；否则，仅对 x[rs2]标识的地址空间的翻译进行排序。当 rs1&#x3D;0 时，对所选地址<br>空间中的所有虚拟地址的翻译进行排序；否则，仅对其中包含虚拟地址 x[rs1]的页面地址翻<br>译进行排序。</p><h3 id="Trap种类"><a href="#Trap种类" class="headerlink" title="Trap种类"></a>Trap种类</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// xv6中用户态trap的代码</span><span class="token comment">// handle an interrupt, exception, or system call from user space.</span><span class="token comment">// called from trampoline.S</span><span class="token comment">//</span><span class="token keyword">void</span><span class="token function">usertrap</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> which_dev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">r_sstatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> SSTATUS_SPP<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"usertrap: not from user mode"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// send interrupts and exceptions to kerneltrap(),</span>  <span class="token comment">// since we're now in the kernel.</span>  <span class="token function">w_stvec</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>kernelvec<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// save user program counter.</span>  p<span class="token operator">-></span>trapframe<span class="token operator">-></span>epc <span class="token operator">=</span> <span class="token function">r_sepc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// system call</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>killed<span class="token punctuation">)</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// sepc points to the ecall instruction,</span>    <span class="token comment">// but we want to return to the next instruction.</span>    p<span class="token operator">-></span>trapframe<span class="token operator">-></span>epc <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token comment">// an interrupt will change sstatus &amp;c registers,</span>    <span class="token comment">// so don't enable until done with those registers.</span>    <span class="token function">intr_on</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">syscall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>which_dev <span class="token operator">=</span> <span class="token function">devintr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// ok</span>  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"usertrap(): unexpected scause %p pid=%d\n"</span><span class="token punctuation">,</span> <span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token operator">-></span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"            sepc=%p stval=%p\n"</span><span class="token punctuation">,</span> <span class="token function">r_sepc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p<span class="token operator">-></span>killed <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>killed<span class="token punctuation">)</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// give up the CPU if this is a timer interrupt.</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>which_dev <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">usertrapret</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Trap在xv6里面指的是用户空间和内核空间的切换，包括系统调用、page fault、中断等。（<strong>xv6这里的Trap是一个统称</strong>，跟其他地方的称呼习惯不一样，比如CSAPP和一些linux的书习惯把syscall之类的东西叫trap，而把键盘I&#x2F;O这种interrupt叫做中断，<strong>大部分其他的书认为trap、interrupt、fault是三种不同的东西</strong>）</p><p>一般Trap干了这些事：</p><p>保存32个用户寄存器<br>保存pc和sp寄存器<br>切到supervisor mode<br>从user page table切到kernel page table<br>进入内核态执行程序</p><p>完成这些过程的就是<code>kernel/trampoline.S</code>中的<code>uservec</code>函数，加了点注释，直接看注释吧。</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">.globl uservecuservec:    <span class="token operator">#</span>        <span class="token operator">#</span> trap.c sets stvec to point here<span class="token punctuation">,</span> so        <span class="token operator">#</span> traps from user space start here<span class="token punctuation">,</span>        <span class="token operator">#</span> in supervisor mode<span class="token punctuation">,</span> but with a        <span class="token operator">#</span> user page table.        <span class="token operator">#</span>        <span class="token operator">#</span> sscratch points to where the process's p<span class="token operator">-</span><span class="token operator">></span>trapframe is        <span class="token operator">#</span> mapped into user space<span class="token punctuation">,</span> at TRAPFRAME.        <span class="token operator">#</span>        <span class="token operator">#</span> swap a0 and sscratch        <span class="token operator">#</span> so that a0 is TRAPFRAME        csrrw a0<span class="token punctuation">,</span> sscratch<span class="token punctuation">,</span> a0        <span class="token operator">#</span> save the user registers in TRAPFRAME        <span class="token operator">#</span> sd（store指令<span class="token punctuation">)</span>，sd  rs2<span class="token punctuation">,</span> offset<span class="token punctuation">(</span>rs1<span class="token punctuation">)</span>  ，将rs1寄存器的值加上offset偏移存入rs2        sd ra<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> return address<span class="token punctuation">,</span> 返回地址        sd sp<span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> stack pointer， 栈指针        sd gp<span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> gloabl pointer，全局指针寄存器        sd tp<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> thread pointer，线程指针        sd t0<span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> t0<span class="token operator">-</span>t2 是临时寄存器        sd t1<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd t2<span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s0<span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> saved register        sd s1<span class="token punctuation">,</span> <span class="token number">104</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd a1<span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>  <span class="token operator">#</span> a0<span class="token operator">-</span>a7是function arguements，函数参数        sd a2<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd a3<span class="token punctuation">,</span> <span class="token number">136</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd a4<span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd a5<span class="token punctuation">,</span> <span class="token number">152</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd a6<span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd a7<span class="token punctuation">,</span> <span class="token number">168</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s2<span class="token punctuation">,</span> <span class="token number">176</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> saved registers，        sd s3<span class="token punctuation">,</span> <span class="token number">184</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s4<span class="token punctuation">,</span> <span class="token number">192</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s5<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s6<span class="token punctuation">,</span> <span class="token number">208</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s7<span class="token punctuation">,</span> <span class="token number">216</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s8<span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s9<span class="token punctuation">,</span> <span class="token number">232</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s10<span class="token punctuation">,</span> <span class="token number">240</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd s11<span class="token punctuation">,</span> <span class="token number">248</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd t3<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd t4<span class="token punctuation">,</span> <span class="token number">264</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd t5<span class="token punctuation">,</span> <span class="token number">272</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        sd t6<span class="token punctuation">,</span> <span class="token number">280</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span><span class="token operator">#</span> save the user a0 in p<span class="token operator">-</span><span class="token operator">></span>trapframe<span class="token operator">-</span><span class="token operator">></span>a0        csrr t0<span class="token punctuation">,</span> sscratch        sd t0<span class="token punctuation">,</span> <span class="token number">112</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        <span class="token operator">#</span> restore kernel stack pointer from p<span class="token operator">-</span><span class="token operator">></span>trapframe<span class="token operator">-</span><span class="token operator">></span>kernel_sp        ld sp<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        <span class="token operator">#</span> make tp hold the current hartid<span class="token punctuation">,</span> from p<span class="token operator">-</span><span class="token operator">></span>trapframe<span class="token operator">-</span><span class="token operator">></span>kernel_hartid        ld tp<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        <span class="token operator">#</span> load the address of usertrap<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token operator">-</span><span class="token operator">></span>trapframe<span class="token operator">-</span><span class="token operator">></span>kernel_trap        ld t0<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        <span class="token operator">#</span> restore kernel page table from p<span class="token operator">-</span><span class="token operator">></span>trapframe<span class="token operator">-</span><span class="token operator">></span>kernel_satp        ld t1<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        csrw satp<span class="token punctuation">,</span> t1        sfence.vma zero<span class="token punctuation">,</span> zero        <span class="token operator">#</span> a0 is no longer valid<span class="token punctuation">,</span> since the kernel page        <span class="token operator">#</span> table does not specially map p<span class="token operator">-</span><span class="token operator">></span>tf.        <span class="token operator">#</span> jump to usertrap<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> which does not return        jr t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与之对应的是<code>userret</code>，用来在返回userspace的时候恢复这些寄存器</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">.globl userretuserret:        <span class="token operator">#</span> userret<span class="token punctuation">(</span>TRAPFRAME<span class="token punctuation">,</span> pagetable<span class="token punctuation">)</span>        <span class="token operator">#</span> switch from kernel to user.        <span class="token operator">#</span> usertrapret<span class="token punctuation">(</span><span class="token punctuation">)</span> calls here.        <span class="token operator">#</span> a0: TRAPFRAME<span class="token punctuation">,</span> in user page table.        <span class="token operator">#</span> a1: user page table<span class="token punctuation">,</span> for satp.        <span class="token operator">#</span> switch to the user page table.        将a1的值写入satp，切换到user page table        csrw satp<span class="token punctuation">,</span> a1        <span class="token operator">#</span>  sfence是虚拟内存屏障的指令，sfence.vma是用来通知处理器页表已经更改，需要刷新TLB缓存        sfence.vma zero<span class="token punctuation">,</span> zero        <span class="token operator">#</span> put the saved user a0 in sscratch<span class="token punctuation">,</span> so we        <span class="token operator">#</span> can swap it with our a0 <span class="token punctuation">(</span>TRAPFRAME<span class="token punctuation">)</span> in the last step.        ld t0<span class="token punctuation">,</span> <span class="token number">112</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        csrw sscratch<span class="token punctuation">,</span> t0        <span class="token operator">#</span> restore all but a0 from TRAPFRAME        <span class="token operator">#</span> ld a0<span class="token punctuation">,</span> a1 是将a1的值load进a0，方向不要搞反了        ld ra<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> return address<span class="token punctuation">,</span> 返回地址        ld sp<span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> stack pointer， 栈指针        ld gp<span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> gloabl pointer，全局指针寄存器        ld tp<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> thread pointer，线程指针        ld t0<span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> t0<span class="token operator">-</span>t2 是临时寄存器        ld t1<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld t2<span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld s0<span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> saved register        ld s1<span class="token punctuation">,</span> <span class="token number">104</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld a1<span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>  <span class="token operator">#</span> a0<span class="token operator">-</span>a7是function arguements，函数参数        ld a2<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld a3<span class="token punctuation">,</span> <span class="token number">136</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld a4<span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld a5<span class="token punctuation">,</span> <span class="token number">152</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld a6<span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld a7<span class="token punctuation">,</span> <span class="token number">168</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld s2<span class="token punctuation">,</span> <span class="token number">176</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span> <span class="token operator">#</span> saved registers        ld s3<span class="token punctuation">,</span> <span class="token number">184</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>         ld s4<span class="token punctuation">,</span> <span class="token number">192</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld s5<span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld s6<span class="token punctuation">,</span> <span class="token number">208</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld s7<span class="token punctuation">,</span> <span class="token number">216</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld s8<span class="token punctuation">,</span> <span class="token number">224</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld s9<span class="token punctuation">,</span> <span class="token number">232</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld s10<span class="token punctuation">,</span> <span class="token number">240</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld s11<span class="token punctuation">,</span> <span class="token number">248</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld t3<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>  <span class="token operator">#</span> 临时寄存器        ld t4<span class="token punctuation">,</span> <span class="token number">264</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld t5<span class="token punctuation">,</span> <span class="token number">272</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>        ld t6<span class="token punctuation">,</span> <span class="token number">280</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span><span class="token operator">#</span> restore user a0<span class="token punctuation">,</span> and save TRAPFRAME in sscratch  <span class="token operator">#</span> csrrw 是同时读写的原子操作，将sscratch的值写入a0，将a0写入sscratch  <span class="token operator">#</span> csrrw 这里的效果是将sscratch和a0两个寄存器的值交换（原子的）        csrrw a0<span class="token punctuation">,</span> sscratch<span class="token punctuation">,</span> a0                <span class="token operator">#</span> return to user mode and user pc.        <span class="token operator">#</span> usertrapret<span class="token punctuation">(</span><span class="token punctuation">)</span> set up sstatus and sepc.        <span class="token operator">#</span> sert 从S MODE（内核态）返回用户态，将PC的值设置为SEPC        sret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了上面的usertrap，还有内核态引发的trap</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// interrupts and exceptions from kernel code go here via kernelvec,</span><span class="token comment">// on whatever the current kernel stack is.</span><span class="token keyword">void</span> <span class="token function">kerneltrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">int</span> which_dev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  uint64 sepc <span class="token operator">=</span> <span class="token function">r_sepc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  uint64 sstatus <span class="token operator">=</span> <span class="token function">r_sstatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  uint64 scause <span class="token operator">=</span> <span class="token function">r_scause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sstatus <span class="token operator">&amp;</span> SSTATUS_SPP<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kerneltrap: not from supervisor mode"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">intr_get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kerneltrap: interrupts enabled"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>which_dev <span class="token operator">=</span> <span class="token function">devintr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"scause %p\n"</span><span class="token punctuation">,</span> scause<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"sepc=%p stval=%p\n"</span><span class="token punctuation">,</span> <span class="token function">r_sepc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">r_stval</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"kerneltrap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// give up the CPU if this is a timer interrupt.</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>which_dev <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-></span>state <span class="token operator">==</span> RUNNING<span class="token punctuation">)</span>    <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// the yield() may have caused some traps to occur,</span>  <span class="token comment">// so restore trap registers for use by kernelvec.S's sepc instruction.</span>  <span class="token function">w_sepc</span><span class="token punctuation">(</span>sepc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">w_sstatus</span><span class="token punctuation">(</span>sstatus<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一个trap就是时钟，这个东西做过单片机的应该非常熟悉，就是用来做时钟嘀嗒的（ticks）。一般板子上有晶振等东西产生时钟信号，然后在固定的时间每次都出发一个时钟中断，用来做基准时间。（在linux里面就是会变成我们熟悉的那个jiffies）<br>这个比较特殊，直接用的比较少，不多说了。</p><p>详见<code>kernel/kernelvec.S</code>中的timervec函数。需要注意的是这个玩意虽然也算作interrupt，但是它是不归中断处理函数管的。我们在一些spinlock等操作关中断的时候<code>intr_off</code>是不会把时钟中断也关掉的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span><span class="token function">clockintr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tickslock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 自旋锁</span>  ticks<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token function">wakeup</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ticks<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tickslock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外还有来自设备的trap，就是别的系统习惯成为外部中断（external interrupt）的东西，定义在<code>kernel/trap.c</code>的<code>devintr</code>函数，这个后面说道驱动的时候再讲。</p><p>ps：外部中断的优先级是很高的，比syscall等其他的trap都高</p><h2 id="Lab"><a href="#Lab" class="headerlink" title="Lab"></a>Lab</h2><h3 id="RISC-V-assembly-easy"><a href="#RISC-V-assembly-easy" class="headerlink" title="RISC-V assembly (easy)"></a>RISC-V assembly (easy)</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> x<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">int g<span class="token punctuation">(</span>int x<span class="token punctuation">)</span> &#123;   <span class="token number">0</span>:<span class="token number">1141</span>                addisp<span class="token punctuation">,</span>sp<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">16</span>   <span class="token number">2</span>:e422                sds0<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span>   <span class="token number">4</span>:<span class="token number">0800</span>                addis0<span class="token punctuation">,</span>sp<span class="token punctuation">,</span><span class="token number">16</span>  return x<span class="token operator">+</span><span class="token number">3</span><span class="token comment">;</span>&#125;   <span class="token number">6</span>:250d                addiwa0<span class="token punctuation">,</span>a0<span class="token punctuation">,</span><span class="token number">3</span>   <span class="token number">8</span>:<span class="token number">6422</span>                lds0<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span>   a:<span class="token number">0141</span>                addisp<span class="token punctuation">,</span>sp<span class="token punctuation">,</span><span class="token number">16</span>   c:<span class="token number">8082</span>                ret000000000000000e <span class="token operator">&lt;</span>f<span class="token operator">></span>:int f<span class="token punctuation">(</span>int x<span class="token punctuation">)</span> &#123;   e:<span class="token number">1141</span>                addisp<span class="token punctuation">,</span>sp<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">16</span>  <span class="token number">10</span>:e422                sds0<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span>  <span class="token number">12</span>:<span class="token number">0800</span>                addis0<span class="token punctuation">,</span>sp<span class="token punctuation">,</span><span class="token number">16</span>  return g<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment">;</span>&#125;  <span class="token number">14</span>:250d                addiwa0<span class="token punctuation">,</span>a0<span class="token punctuation">,</span><span class="token number">3</span>  <span class="token number">16</span>:<span class="token number">6422</span>                lds0<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span>  <span class="token number">18</span>:<span class="token number">0141</span>                addisp<span class="token punctuation">,</span>sp<span class="token punctuation">,</span><span class="token number">16</span>  1a:<span class="token number">8082</span>                ret000000000000001c <span class="token operator">&lt;</span>main<span class="token operator">></span>:void main<span class="token punctuation">(</span>void<span class="token punctuation">)</span> &#123;  1c:<span class="token number">1141</span>                addisp<span class="token punctuation">,</span>sp<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">16</span>  1e:e406                sdra<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span>  <span class="token number">20</span>:e022                sds0<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">(</span>sp<span class="token punctuation">)</span>  <span class="token number">22</span>:<span class="token number">0800</span>                addis0<span class="token punctuation">,</span>sp<span class="token punctuation">,</span><span class="token number">16</span>  printf<span class="token punctuation">(</span><span class="token string">"%d %d\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token comment">;</span>  <span class="token number">24</span>:<span class="token number">4635</span>                lia2<span class="token punctuation">,</span><span class="token number">13</span>  <span class="token number">26</span>:45b1                lia1<span class="token punctuation">,</span><span class="token number">12</span>  <span class="token number">28</span>:<span class="token number">00000517</span>          auipca0<span class="token punctuation">,</span><span class="token number">0x0</span>  2c:7a050513          addia0<span class="token punctuation">,</span>a0<span class="token punctuation">,</span><span class="token number">1952</span> <span class="token operator">#</span> 7c8 <span class="token operator">&lt;</span>malloc<span class="token operator">+</span><span class="token number">0xe8</span><span class="token operator">></span>  <span class="token number">30</span>:<span class="token number">00000097</span>          auipcra<span class="token punctuation">,</span><span class="token number">0x0</span>  <span class="token number">34</span>:5f8080e7          jalr<span class="token number">1528</span><span class="token punctuation">(</span>ra<span class="token punctuation">)</span> <span class="token operator">#</span> <span class="token number">628</span> <span class="token operator">&lt;</span>printf<span class="token operator">></span>  exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment">;</span>  <span class="token number">38</span>:<span class="token number">4501</span>                lia0<span class="token punctuation">,</span><span class="token number">0</span>  3a:<span class="token number">00000097</span>          auipcra<span class="token punctuation">,</span><span class="token number">0x0</span>  3e:<span class="token number">274080e7</span>          jalr<span class="token number">628</span><span class="token punctuation">(</span>ra<span class="token punctuation">)</span> <span class="token operator">#</span> 2ae <span class="token operator">&lt;</span>exit<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>给你一个<code>call.c</code>，然后<code>make fs.img</code>之后会生成一个<code>call.asm</code>，下面问了你几个汇编的问题（然而我懒，我直接掏出gdb回答）</p><p>这个简单，翻手册就完事了</p><blockquote><p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to printf?</p></blockquote><p>a0-a7这些a开头的呗，没啥好说的。第二问， 我们直接打开<code>call.asm</code>，然后找到<code>main</code>函数，发现main函数第45行赫然写着<code>li a2,13</code> 那就是a2呗。</p><p>（这直接<code>cat user/call.asm | rg 13</code>搜索13不就好了, 逃）</p><blockquote><p>Where is the call to function f in the assembly code for main? Where is the call to g? (Hint: the compiler may inline functions.)</p></blockquote><p>我一开始傻乎乎的找调用没找到，一看提示才发现直接内联了。第46行，<code>li a1,12</code>，紧挨刚才那个13，f(8)+1 &#x3D; 8 + 3 + 1 &#x3D; 12，这个12就是了。（你比编译器聪明系列</p><blockquote><p>At what address is the function printf located?</p></blockquote><p>就是pc的address，就是ra寄存器的值呗，gdb看一下就知道了。算了算了不偷懒了，看一下汇编，接着刚才的12向下面找，</p><p>查手册发现<code>auipc rd, immediate</code>，是左移12 immediate立即数加到rd上<br>jalr指令： <code>jalr rd, offset(rs1)</code>， 把 pc 设置为 x[rs1] + sign-extend(offset),把计算出的地址的最低有效位设为 0,并将原 pc+4的值写入 f[rd]。rd 默认为 x1。 大概就是跳转到rs1, 然后将下一条指令（pc+4）保存到rd里面。</p><p>auipc和jalr这一对指令就相当于jal跳转，参见stackoverflow的这个问题<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDM5NTY2MTIvdW5kZXJzdGFuZGluZy10aGUtYXVpcGNqYWxyLXNlcXVlbmNlLXVzZWQtZm9yLWZ1bmN0aW9uLWNhbGxz">Understanding the auipc+jalr sequence used for function calls<i class="fa fa-external-link-alt"></i></span>  </p><p>说人话就是<code>jalr1528(ra) # 628 &lt;printf&gt;</code>，在jalr这个无条件跳转的时候，将printf的pc的值（628）放到了ra里面</p><p>答案就是628</p><blockquote><p>Run the following code.<br>unsigned int i &#x3D; 0x00646c72;<br>printf(“H%x Wo%s”, 57616, &amp;i);</p><p>What is the output? </p></blockquote><p>这一看就是hello, world啦</p><p>结果<code>HE110 World</code>。直接查表就好了（唯一的小坑是大小端的问题，我这是小端，所以你还得倒过来查，不过这个坑很隐蔽，因为57616不管是大端还是小端结果都是一样的<code>e110</code>，所以第二问的回答是不需要改57616，i要倒过来，改成<code>0x00726c64</code>）</p><blockquote><p>In the following code, what is going to be printed after ‘y&#x3D;’? (note: the answer is not a specific value.) Why does this happen?<br>printf(“x&#x3D;%d y&#x3D;%d”, 3);</p></blockquote><p><code>call.asm</code>是这样，对比<code>printf(&quot;x=%d y=%d&quot;, 3, 4);</code>, 只少了一行<code>li a2，4</code>, 推测这个printf函数打印出的y的值是寄存器a2中的值，由于我们没有赋值所以打印出来是原来的a2</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x=%d, y=%d"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token number">8</span><span class="token operator">:</span><span class="token number">458</span>d                lia1<span class="token punctuation">,</span><span class="token number">3</span> a<span class="token operator">:</span><span class="token number">00000517</span>          auipca0<span class="token punctuation">,</span><span class="token number">0x0</span> e<span class="token operator">:</span><span class="token number">79e50513</span>          addia0<span class="token punctuation">,</span>a0<span class="token punctuation">,</span><span class="token number">1950</span> # <span class="token number">7</span>a8 <span class="token operator">&lt;</span>malloc<span class="token operator">+</span><span class="token number">0xe6</span><span class="token operator">></span><span class="token number">12</span><span class="token operator">:</span><span class="token number">00000097</span>          auipcra<span class="token punctuation">,</span><span class="token number">0x0</span><span class="token number">16</span><span class="token operator">:</span><span class="token number">5f</span><span class="token number">8080e7</span>          jalr<span class="token number">1528</span><span class="token punctuation">(</span>ra<span class="token punctuation">)</span> # <span class="token number">60</span>a <span class="token operator">&lt;</span>printf<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果y&#x3D;5301，然后我们用gdb验证一下呗，断点打到<code>file user/_call.c</code>, 然后<code>b mian</code>， 然后<code>info registers</code>发现a2寄存器是5301，好了，问答环节结束，我们看下面的Lab</p><p><img src="/6.S081-lab-trap/1651825910.png"></p><p>多说一下printf的实现，这个在csapp的第八章里面有讲，大概就是 调用 vspringf 然后调用sys_write, 然后去跟显示驱动打交道</p><h3 id="Backtrace-moderate"><a href="#Backtrace-moderate" class="headerlink" title="Backtrace (moderate)"></a>Backtrace (moderate)</h3><p>实现这个方便panic的时候看到backtrace结果，这个搞懂他想让我们干什么就很简单了，我们只要读出fp寄存器然后打印就好了。</p><p>怎么读 frame poiner提示已经告诉我们了，编辑<code>kernel/riscv.h</code>:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">inline</span> uint64<span class="token function">r_fp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  uint64 x<span class="token punctuation">;</span>  <span class="token keyword">asm</span> <span class="token keyword">volatile</span><span class="token punctuation">(</span><span class="token string">"mv %0, s0"</span> <span class="token operator">:</span> <span class="token string">"=r"</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>kernel/printf.c</code>那里加一个backtrace函数，然后输出照抄<code>printint</code>和<code>printptr</code>用consputc就好了。</p><p>提示甚至连栈顶和栈底怎么获取都告诉你了（PGROUNDDOWN(fp) and PGROUNDUP(fp)）， 那就直接把这一段地址中间的所有东西打印出来就好了</p><h3 id="Alarm-hard"><a href="#Alarm-hard" class="headerlink" title="Alarm (hard)"></a>Alarm (hard)</h3><blockquote><p>In this exercise you’ll add a feature to xv6 that periodically alerts a process as it uses CPU time. This might be useful for compute-bound processes that want to limit how much CPU time they chew up, or for processes that want to compute but also want to take some periodic action. More generally, you’ll be implementing a primitive form of user-level interrupt&#x2F;fault handlers; you could use something similar to handle page faults in the application, for example. Your solution is correct if it passes alarmtest and usertests.</p></blockquote><p>这个也不是很难，有点繁琐。就是添加一个syscall而已，做法跟syscall那个Lab的内容差不多。大概思路就是先trap进内核态看中断然后返回用户态打印，搞清楚流程照着做就行了。</p><p>保存和恢复寄存器这个我一开始是照抄uservec,全部保存的，后来看到Lab的Hints, 又看了一遍讲义</p><blockquote><p>Your solution will require you to save and restore registers—what registers do you need to save and restore to resume the interrupted code correctly? (Hint: it will be many).</p></blockquote><p>这里只要保存那些caller寄存器就可以了，像s开头的callee寄存器可以不管。Caller寄存器需要调用者主动保存，不然会被函数返回值覆盖（比如临时寄存器），Callee寄存器在函数调用的过程中不需要调用者保存，会由被调用者保存 。</p><p><img src="/6.S081-lab-trap/1651827112.png"></p><p>只保存和恢复这些就可以了（注意sp寄存器也是callee寄存器）</p><pre class="line-numbers language-armasm" data-language="armasm"><code class="language-armasm">sd ra<span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd gp<span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd tp<span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd t0<span class="token punctuation">,</span> <span class="token number">72</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd t1<span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd t2<span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd a1<span class="token punctuation">,</span> <span class="token number">120</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd a2<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd a3<span class="token punctuation">,</span> <span class="token number">136</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd a4<span class="token punctuation">,</span> <span class="token number">144</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd a5<span class="token punctuation">,</span> <span class="token number">152</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd a6<span class="token punctuation">,</span> <span class="token number">160</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd a7<span class="token punctuation">,</span> <span class="token number">168</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd t3<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd t4<span class="token punctuation">,</span> <span class="token number">264</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd t5<span class="token punctuation">,</span> <span class="token number">272</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span>sd t6<span class="token punctuation">,</span> <span class="token number">280</span><span class="token punctuation">(</span>a0<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那s0-s11是谁保存的？是被调用者保存的，比如进程的context上下文保存的就是这些callee寄存器，保存和恢复context就是操作这些callee-saved registers。哦，扯远了，到multithreading那个Lab再说</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// Saved registers for kernel context switches.</span><span class="token keyword">struct</span> <span class="token class-name">context</span> <span class="token punctuation">&#123;</span>  uint64 ra<span class="token punctuation">;</span>  uint64 sp<span class="token punctuation">;</span>  <span class="token comment">// callee-saved</span>  uint64 s0<span class="token punctuation">;</span>  uint64 s1<span class="token punctuation">;</span>  uint64 s2<span class="token punctuation">;</span>  uint64 s3<span class="token punctuation">;</span>  uint64 s4<span class="token punctuation">;</span>  uint64 s5<span class="token punctuation">;</span>  uint64 s6<span class="token punctuation">;</span>  uint64 s7<span class="token punctuation">;</span>  uint64 s8<span class="token punctuation">;</span>  uint64 s9<span class="token punctuation">;</span>  uint64 s10<span class="token punctuation">;</span>  uint64 s11<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个Lab跟其他的比起来挺简单的，主要是汇编要去翻翻手册，简单说一下吧。顺便讲一下中断之类的东西。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="trap" scheme="https://zhangjk98.xyz/tags/trap/"/>
    
  </entry>
  
  <entry>
    <title>6.S081 Lab Page table 笔记：虚拟内存、页表和MMU</title>
    <link href="https://zhangjk98.xyz/6.S081-lab-page-table/"/>
    <id>https://zhangjk98.xyz/6.S081-lab-page-table/</id>
    <published>2022-01-12T09:56:03.000Z</published>
    <updated>2022-01-12T09:56:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个Lab前几个月写的，最近比较闲整理一下之前做的Lab。内存管理这块比较复杂，当时做Lab的时候对内存这块理解也浅，实现有些挺蠢的地方，重新整理了一下。接下来的笔记会多一点和Lab作业关系不是特别大的东西，闲着没事看OS相关的东西觉得有意思就一起记到笔记里了。</p><span id="more"></span><h2 id="从单片机的内存和MMU说起"><a href="#从单片机的内存和MMU说起" class="headerlink" title="从单片机的内存和MMU说起"></a>从单片机的内存和MMU说起</h2><p>早期的操作系统是就像现在的一些单片机一样没有虚拟内存、页表这些东西的。以前我一开始用ARM的STM32的单片机的时候，用的是cortex-m系列，没有MMU（Memory Management Unit，内存管理单元）的，直接访问物理地址。当时我上嵌入式的课上也不讲这些东西，上课、做实验讲到内存的时候都直接访问物理地址的（Keil里面直接看物理地址的值确实比较简单）。</p><p>这个时候内存的管理方式挺简单的，<strong>可能为数不多的坑就是大小端</strong>，有一次被坑了挺久</p><p>下面这张图很熟悉了，堆、栈，数据段、代码段</p><p>访问栈就直接用sp去寻址就可以了，简单直接。</p><p>没有MMU也有好处，这样便宜、功耗低、而且比较简单。有的对实时性要求比较高的东西，也没有MMU（比如Cortex-R系列）</p><p>注：嵌入式的soc芯片，如果能跑操作系统的大概率有MMU，但是两者之前没有必然关系。比如uCLinux，就是为了在没有MMU上的设备跑。有MMU，当然也可以不用操作系统，直接跑裸机（MMU其实可以关掉，但是我们一般不关，手动指定映射，因为MMU的cache对性能提升很大）。（uClinux要小心内存碎片，而且由于MMU没了，内存保护、内存置换、COW基本都没了，大部分时候还是用mmap和内存直接打交道）</p><p>单片机可以不要MMU，但是一个运行着很多任务的操作系统需要对内存进行抽象和封装，提供给应用。于是后来诞生了虚拟内存&#x2F;虚拟存储器（Virtual Memory），虚拟内存可以比物理内存大，可以让每个程序都认为自己拥有一段连续独立的内存，还可以权限控制（内存保护），虚拟内存在硬件上是MMU实现的。操作系统的虚拟内存几乎都依赖MMU。（当然，操作系统有自己的页表，这个一会再说）<br>像Cortex-A系列的soc芯片，是有mmu的，上面能跑一些完整的操作系统，有页表等一系列完整的内存管理机制。下图来自xv6 book，每个进程都有自己独立的虚拟内存，这样主要的好处一个是安全隔离，一个是让进程操作一段连续的内存，即使映射到物理内存上是不连续的（你可以<strong>试试在Cortex-A系列soc的板子上跑个uClinux这种没有虚拟内存的，很容易搞出内存碎片然后OOM了</strong>）。</p><p><img src="/6.S081-lab-page-table/1642081823.png"></p><p>下面这是ARM的图，RISC-V和x86我不熟，就没找RISC的图。下面这些图来自：<span class="exturl" data-url="aHR0cHM6Ly9jczE0MGUuc2VyZ2lvLmJ6L2RvY3MvQVJNdjgtQS1Qcm9ncmFtbWVyLUd1aWRlLnBkZg==">ARMv8-A-Programmer-Guide<i class="fa fa-external-link-alt"></i></span></p><p><img src="/6.S081-lab-page-table/1642057127.png"></p><p>MMU以页为最小单位将内存从物理地址映射到虚拟地址，页表大小一般是4k。除了地址映射MMU还实现了内存保护。每个页有读、写、执行三种权限。</p><p>MMU里有TLB（Translation Lookaside Buffer），专门用来缓存页表，CPU要访问内存的时候会先去TLB里面找，没有命中再去遍历找物理地址（Translation Table Walk）。</p><p>图中的Caches就是我们熟悉的L1、L2、L3缓存，l1一般有ICache和DCache，分别用来缓存指令和数据。</p><p><img src="/6.S081-lab-page-table/1642057382.png"></p><p>一部分ARM的芯片是将L1的ICache做成逻辑地址的（不经过MMU），有的芯片是逻辑地址（Cache缓存的是经过MMU转换后的虚拟地址），这个和芯片的实现有关，不是这里的重点。我们就简单的认为，Cache一般速度远比主存快，用于缓存最常用的内存数据（页）。</p><p><img src="/6.S081-lab-page-table/1642057536.png"></p><p>当L1、L2、L3都没有命中（Write Miss）的时候，会走总线去内存里面找。至于L1、L2、L3缓存的置换、一致性这些问题，我们也简单的认为芯片已经帮我们做好了，这里我们不去管它。</p><h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p>以页为单位完成了物理内存到虚拟内存的映射，要访问这些页我们需要查表，于是就有了页表（Page Table）。但是如果把每个页都映射成一张页表，这一个页表是很大的，于是就有了多级页表。多级页表中每一级都有index和offset用于定位页和页中的偏移量。</p><p><img src="/6.S081-lab-page-table/1642065542.png"></p><p>上图中的PPN是物理page号（PPN，Physical Page Number）。</p><h3 id="进程页表和内核页表"><a href="#进程页表和内核页表" class="headerlink" title="进程页表和内核页表"></a>进程页表和内核页表</h3><p>xv6里面有，内核页表和用户页表（进程页表），每个进程都有自己独立的页表。内核页表只有一个。一般进程页表都有一份内核页表的直接copy，但是一些开了内核页表隔离（KPTI, Kernel Page Table Isolation）的，情况会比较复杂。</p><p><img src="/6.S081-lab-page-table/1642124957.png"></p><p>我们这里先不考虑这些复杂情况，做Lab的时候只需要知道进程地址空间是<code>exec</code>创建的，进程页表是<code>proc_pagetable</code>创建的</p><h2 id="页表放在哪"><a href="#页表放在哪" class="headerlink" title="页表放在哪"></a>页表放在哪</h2><p>放在内存里面（是虚拟内存）。准确的说，是在内存的内核空间（kernel address space）里。在RISC-V中，SATP寄存器保存当前进程的页表地址，通过切换SATP的值来切换进程页表，MMU通过这个地址去找页表（先去TLB找，那里放的是页表的缓存）。<br>x86的寄存器是CR3，作用类似。</p><h2 id="这么多年过去了页大小怎么还是4K"><a href="#这么多年过去了页大小怎么还是4K" class="headerlink" title="这么多年过去了页大小怎么还是4K"></a>这么多年过去了页大小怎么还是4K</h2><p>如果你执行<code>getconf PAGE_SIZE</code>看一下，大概率还是<code>4096</code>。<br>页表的级数一直在增加，ARM的嵌入式soc（比如Cortex-A系列）一般是二级页表，Linux一开始也是二级，后来有了3级和4级页表。然而这么多年过去了，页表大小基本还是4k。</p><p>透明大页</p><h2 id="Lab作业笔记"><a href="#Lab作业笔记" class="headerlink" title="Lab作业笔记"></a>Lab作业笔记</h2><p>这个Lab是第四章内存管理的配套Lab，做之前推荐还是看一下第四章的讲义。涉及到的几个函数在<code>vm.c</code>中</p><h3 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h3><blockquote><p>Some operating systems (e.g., Linux) speed up certain system calls by sharing data in a read-only region between userspace and the kernel. This eliminates the need for kernel crossings when performing these system calls.</p></blockquote><p>仿照Linux通过共享内存来加快syscall。一开始看lwm这篇：<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzE4NDExLw==">How to speed up system calls<i class="fa fa-external-link-alt"></i></span> 02年的文章和<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzE4NDE0Lw==">Patch<i class="fa fa-external-link-alt"></i></span>没看懂是要干嘛，后来搜了一下vsyscall才明白这个Lab想让我们做什么。  </p><blockquote><p>vsyscall 或 virtual system call 是第一种也是最古老的一种用于加快系统调用的机制。 vsyscall 的工作原则其实十分简单。Linux 内核在用户空间映射一个包含一些变量及一些系统调用的实现的内存页。<br>不过后来vsyscall几乎都换成vDSO和vvar了（安全原因），现在不少发行版默认禁用这个的。  </p></blockquote><p>知道干什么就好办了，我们照着课程提示先看<code>user/ulib.c</code>中的<code>ugetpid()</code>，这里已经将共享地址<code>USYSCALL</code>转成usyscall结构体，然后返回pid</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span><span class="token function">ugetpid</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span>u <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span><span class="token punctuation">)</span>USYSCALL<span class="token punctuation">;</span>  <span class="token keyword">return</span> u<span class="token operator">-></span>pid<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们只要在<code>kernel/proc.h</code>中补全USYSCALL的映射（mapping），这个仿照trapframe就好了，在<code>proc.h</code>中</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span>usyscall    <span class="token comment">// data page for getpid syscall</span><span class="token keyword">struct</span> <span class="token class-name">trapframe</span> <span class="token operator">*</span>trapframe<span class="token punctuation">;</span> <span class="token comment">// data page for trampoline.S</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后在<code>proc.c</code>设置映射和读权限（PTE_U、PTE_R，详见xv6文档）。我们继续照着trapframe的写法加上：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// map the getpid (for systemcall return)</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span>            <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usyscall<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后在<code>allocproc()</code>中分配，在<code>freeproc()</code>中释放内存（这个直接照抄trapframe的分配和释放就可以了）。注意还要在<code>proc.c</code>中的<code>proc_freepagetable</code>释放一下<code>uvmunmap(pagetable, USYSCALL, 1, 0);</code></p><h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><p>这个也简单，实现一个打印页表方便下面调试。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9uaWV5b25nLmdpdGh1Yi5pby93aWtpX2NwdS9DUFUlRTQlQkQlOTMlRTclQjMlQkIlRTYlOUUlQjYlRTYlOUUlODQtTU1VLmh0bWw=">CPU体系架构-MMU<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vTG95ZW5XYW5nL3AvMTE0MDY2OTMuaHRtbA==">（一）ARMv8 MMU及Linux页表映射<i class="fa fa-external-link-alt"></i></span>  </p><p>阅读更多</p><p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzE4NDExLw==">How to speed up system calls<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly92dmwubWUvMjAxOS8wNi9saW51eC1zeXNjYWxsLWFuZC12c3lzY2FsbC12ZHNvLWluLXg4Ni8=">x86 架构下 Linux 的系统调用与 vsyscall, vDSO<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QveDg2L3B0aS5odG1s">17. Page Table Isolation (PTI)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9jdGYtd2lraS5vcmcvcHduL2xpbnV4L2tlcm5lbC1tb2RlL2RlZmVuc2UvaXNvbGF0aW9uL3VzZXIta2VybmVsL2twdGk=">KPTI - Kernel Page Table Isolation CTF-Wiki<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这个Lab前几个月写的，最近比较闲整理一下之前做的Lab。内存管理这块比较复杂，当时做Lab的时候对内存这块理解也浅，实现有些挺蠢的地方，重新整理了一下。接下来的笔记会多一点和Lab作业关系不是特别大的东西，闲着没事看OS相关的东西觉得有意思就一起记到笔记里了。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="6.S081" scheme="https://zhangjk98.xyz/tags/6-S081/"/>
    
    <category term="page table" scheme="https://zhangjk98.xyz/tags/page-table/"/>
    
  </entry>
  
  <entry>
    <title>用Markdown制做PPT</title>
    <link href="https://zhangjk98.xyz/make-ppt-with-markdown/"/>
    <id>https://zhangjk98.xyz/make-ppt-with-markdown/</id>
    <published>2022-01-09T12:42:16.000Z</published>
    <updated>2022-01-09T12:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>纯文本好，富文本坏。这是一个劝你放弃PowerPoint和Wps演示的安利文，回归简陋，回归开源。</p><span id="more"></span><p>这是迫于毕业不得不向PPT低头才干出来的事情，在PPT上浪费时光真没意思。能不做PPT还是不做PPT最好。（没推荐Beamer是因为LaTeX这种专业排版工具还是太复杂了，还是会浪费不少时间在排版上。）</p><h2 id="喧宾夺主的PPT"><a href="#喧宾夺主的PPT" class="headerlink" title="喧宾夺主的PPT"></a>喧宾夺主的PPT</h2><p><del>但是根据约翰霍普金斯大学的研究，喜欢做PPT的大概率是个传销分子</del></p><p>Office三件套里面，我对word只是喜欢不起来（真要做到内容样式分离还是可以的，而且把富文本的所见即所得做到了地表最强），对Excel有点厌恶（谁让你多管闲事把身份者号给我改成科学计数法了？），PPT我真的心力憔悴了。Beamer一类的Slides演示还比较重视内容，你软家的</p><p>如果不是生活所迫谁愿意做PPT呢，直接拿Markdown写文档呗。（我们现在确实除了毕业答辩这种迫不得已的事情，都用Markdown给老板讲东西了。PPT？当年老板嫌弃小胡师兄PPT做的烂，反正PPT不好好做看起来甚至不如Markdown在typora里面或者hexo里面好看）。好在毕业答辩类的学术PPT不用做的太好看，简陋一点反而显得比较朴实无华，Markdown生成的PPT也够看了。而且我前期给老板交差的调研材料什么的基本都是用Markdown写的，改一改就成PPT了。其实如果不是开题、毕设答辩要求PPT，我真的想用Markdown列一个大纲讲。</p><p>至于为什么不用LaTeX的Beamer，那是我对LaTeX不熟，而我对CSS和HTML比较熟，Markdown做不到的可以伤感CSS魔改。<br>功能简陋也好，这样免得我在PPT上面调格式浪费很多时间。<strong>而且可以用键盘操作</strong>。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>作为一个毕业答辩之类的PPT，Marp的功能已经足够做一个丐版的学术简陋风格PPT了，Beamer的功能Marp几乎都有。这个东西有VSCode插件，直接装就好了。网页版也可以直接用。</p><p>当然这个东西没有什么惊艳的动画效果和对布局细致的控制和调整，Markdown本来就不适合干这个事情呢。如果是做传销风格的PPT那还请<del>直接用Office</del>试试隔壁的reveal.js，像写前端一样写你的演示，各种漂亮的动画效果全都有。</p><p>直接新建一个Markdown，在开头启用marp就好了。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token front-matter-block"><span class="token punctuation">---</span><span class="token front-matter yaml language-yaml"><span class="token key atrule">marp</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></span><span class="token punctuation">---</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>语法都是markdown的语法，每一张PPT之间隔断就用<code>---</code>就可以了（最好在<code>---</code>前面空一行）</p><p>为了更符合传统的PPT界面的布局，VSCode打开Preview，然后将preview调到左边侧栏。好，它现在看起来和wps演示和PowerPoint完全一致。</p><p><img src="/make-ppt-with-markdown/1641736904.png"></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>图片的支持当然没有PowerPoint那么好。Markdown本来就不支持调整图片的大小、图片缩放、指定图片位置这种操作。对于博客文章或者文档可以统一用css去设置居中、边框这些，但是PPT的图片几乎每页的布局和位置都不太一样。Marp对Markdown提供了一些扩展，能基本满足我对图片的位置调整需求。如果不满足要求可以用html标签去调图片。</p><p>下面的操作是一些粗略调整宽度高度的语法、以及上下左右、居中、背景图片。</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token url"><span class="token operator">!</span>[<span class="token content">bg right vertical weight:600</span>](<span class="token url">zhixi.png</span>)</span><span class="token comment">&lt;!-- 将图片置于右上，宽度600px --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>Marp自带的模板合适可以自己定制，只需要一点CSS就可以了</p><p>定制可以参考：<span class="exturl" data-url="aHR0cHM6Ly9tYXJwaXQubWFycC5hcHAvdGhlbWUtY3Nz">https://marpit.marp.app/theme-css<i class="fa fa-external-link-alt"></i></span></p><p>太长不看版：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hcnAtdGVhbS9tYXJwL2Rpc2N1c3Npb25zLzExNQ==">How to create a theme?<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;纯文本好，富文本坏。这是一个劝你放弃PowerPoint和Wps演示的安利文，回归简陋，回归开源。&lt;/p&gt;</summary>
    
    
    
    
    <category term="ppt" scheme="https://zhangjk98.xyz/tags/ppt/"/>
    
    <category term="markdown" scheme="https://zhangjk98.xyz/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>RCU，读多写少的锁实现</title>
    <link href="https://zhangjk98.xyz/rcu-and-userspace-rcu/"/>
    <id>https://zhangjk98.xyz/rcu-and-userspace-rcu/</id>
    <published>2022-01-07T02:34:18.000Z</published>
    <updated>2022-01-07T02:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前做的垃圾骗钱项目有很多都是读多写少，而且不怎么需要实时。一直比较好奇应该用什么锁，读写锁总是不满意，最近看6.S081看到rcu，咦，是我想要找的东西。</p><span id="more"></span><h2 id="水平超低预警"><a href="#水平超低预警" class="headerlink" title="水平超低预警"></a>水平超低预警</h2><p>一年前就开始看DDIA和做6.824 Raft 那些东西，不过当时水平太菜了。一直不太敢写并发和分布式相关的东西。并发有很多反直觉的地方，我写出来总是踩坑。好在golang的channel什么的写起来都很舒服。<br>一年过去了，自认水平总没有当初那么菜了，鼓起勇气开始写一点关于并发和Go的东西，所以新开了一个分类。（结果发现一年前看的好多东西都忘了。。。记住的好多也是错的。。。）<br><strong>这个系列肯定有很多丢人现眼的地方，路过的朋友看到我说的不对的地方请在评论告诉我</strong></p><h2 id="用途和概念"><a href="#用途和概念" class="headerlink" title="用途和概念"></a>用途和概念</h2><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><img src="/2022-01-08-22-40-18.png"></p><p>我们可以用读写锁来保证读取和写入的一致性。在大量读取、少量写入的场景，读写锁的效率会比较低，用RCU可以提高读的性能。使用RCU，读的时候可以不加锁，也不用去管什么内存屏障和原子性了，直接读就完事了。<br>而且如果写入很少，几乎没有同时写入的情况，RCU的写入速度是很快的，写并不一定比读写锁慢（Grace Period其实很短）</p><p><img src="/2022-01-08-22-34-22.png"></p><p>典型场景包括：路由表、DNS查询、内核</p><blockquote><p>The basic form of such “Pure RCU” designs is as follows:</p><ol><li>Make a change, for example, to the way that the OS reacts to an NMI.</li><li>Wait for all pre-existing read-side critical sections to completely finish (for example,by using the synchronize_sched() primitive). The key observation here is that subsequent RCU read-side critical sections are guaranteed to see whatever change was made.</li><li>Clean up, for example, return status indicating that the change was successfully made</li></ol></blockquote><p>在内核里面主要是处理中断、代替读写锁、订阅发布、代替引用计数等。在内核中应用的介绍可以看文章：<span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAxOC9yZWFkaW5ncy9yY3UtZGVjYWRlLWxhdGVyLnBkZg==">RCU Usage In the Linux Kernel: One Decade Later<i class="fa fa-external-link-alt"></i></span><br>下面是一个NMI的例子（不可打断中断应该也不会被抢占，正适合RCU）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">rcu_list_t</span> nmi_list<span class="token punctuation">;</span><span class="token class-name">spinlock_t</span> nmi_list_lock<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">handle_nmi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">rcu_read_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rcu_list_for_each</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list<span class="token punctuation">,</span> <span class="token class-name">handler_t</span> cb<span class="token punctuation">)</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rcu_read_unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">register_nmi_handler</span><span class="token punctuation">(</span><span class="token class-name">handler_t</span> cb<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rcu_list_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list<span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">unregister_nmi_handler</span><span class="token punctuation">(</span><span class="token class-name">handler_t</span> cb<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">spin_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rcu_list_remove</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nmi_list_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">synchronize_rcu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>RCU在用户态用的比较少，远不如mutex和spinlock普遍。<br>当然，用户态一般不怎么用这个东西，像数据库那种（用redis上内存用cache硬抗.jpg）</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>reader很简单，就是<code>rcu_read_lock</code>和<code>rcu_read_unlock</code>。<code>rcu_read_lock</code>和<code>rcu_read_unlock</code>中间的这一段通常叫读侧临界区 (read-side critical sections)</p><p>writer的要复杂一点</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>rcu的实现有很多，比如实时性比较好的srcu（sleepable rcu）、嵌入式用的比较多的tinyrcu、用于CPU核数非常多的tree-rcu；这里只说一下简单经典的rcu实现，其他具体的实现可以去看Paul的文章。<br>这里大部分都是从lwn那里抄来的，建议英文好的直接看原文：<br><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzI2MzEzMC8=">What is RCU? Part 2: Usage<i class="fa fa-external-link-alt"></i></span></p><p>如果想看详细实现可以去看linux rcu主要作者Paul的文章和书：<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmVkZ2Uua2VybmVsLm9yZy9wdWIvbGludXgva2VybmVsL3Blb3BsZS9wYXVsbWNrL3BlcmZib29rL3BlcmZib29rLmh0bWw=">Is Parallel Programming Hard, And, If So, What Can You Do About It?<i class="fa fa-external-link-alt"></i></span></p><p><strong>Linux对于指针的load和store都是原子的</strong>，所以在链表读取的时候，指针要么指向新插入完成的，要么指向旧的还没被删的链表，不会出现正在修改链表的时候刚删除指针还没来得及插入产生<code>segmentation fault</code>。</p><p>以链表为例，写入（Write）的时候先复制（copy）一个副本，然后在读取（read）较少的合适时间执行插入操作。当然，我们可以等到完全没有写入的间隙。但是读取（reader）很多一直没用空闲，写入会非常慢；一直都有reader的极端情况会导致一直无法写入。rcu用宽限期（grace period）巧妙的解决了这个问题。</p><h3 id="怎么知道copy之前的读取全部完成可以reclaim了"><a href="#怎么知道copy之前的读取全部完成可以reclaim了" class="headerlink" title="怎么知道copy之前的读取全部完成可以reclaim了"></a>怎么知道copy之前的读取全部完成可以reclaim了</h3><p>我看rcu之前的第一反应是引用计数，当引用计数降到0就说明copy的副本可以reclaim了。但是引用计数效率太低了，而且多核的时候引用计数更麻烦了。</p><p>经典的rcu模型是不允许抢占的。当读取完成进入临界区，我们认为这个CPU进入一次<strong>静止状态（quiescent state）</strong>，以下简称QS。linux里面用cpumask来记录这个状态，我们就简单的当成是用一个bitmap来保存每个cpu的状态好了。显然，从bitmap得知copy之后每个CPU都经历过一次QS后，那在copy之前的读操作都已经完成了，这个时候就可以reclaim了。</p><h3 id="多个writer怎么处理"><a href="#多个writer怎么处理" class="headerlink" title="多个writer怎么处理"></a>多个writer怎么处理</h3><p>如果有多个writer，那通常会给不同的writer加spin_lock来处理</p><h3 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h3><p>无锁是对于读来说的，写入的时候锁比较多。在修改bitmap的时候是需要加锁的（一般是spin_lock）。太多的写入同时对bitmap加锁效率很低，于是就有了tree-rcu。tree-rcu是将不同的CPU状态分组加锁，然后树状结构向上汇总状态。</p><p><img src="/2022-01-08-22-35-28.png"></p><p>如果你的逻辑CPU数量（就是你在htop里看到的，比如6核12线程的5600x是12）小于16，那它会退化成单个rcu_node。<br>tree-rcu详见[A Tour Through TREE-RCU’s DataStructures]</p><p>多个writer的情况下也要加锁，一般是spin_lock锁。</p><h2 id="用户态"><a href="#用户态" class="headerlink" title="用户态"></a>用户态</h2><p>rcu的实现依赖了很多内核态的东西，移植到用户态比较困难。比较出名的一个用户态rcu是<code>liburcu</code></p><p>模仿rcu的思想可以实现一点读多写少的优化，比如<code>sonic</code>的map<br><span class="exturl" data-url="aHR0cHM6Ly9oYW5zaGFuZ2xpbi5zcGFjZS90ZWNoL3JjdS8=">如何实现一个超快读的map<i class="fa fa-external-link-alt"></i></span></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2VybmVsLm9yZy9kb2MvaHRtbC9sYXRlc3QvUkNVL3doYXRpc1JDVS5odG1s">What is RCU? – “Read, Copy, Update”<i class="fa fa-external-link-alt"></i></span> Linux Kernel文档的介绍<br><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjgvMjAxOC9yZWFkaW5ncy9yY3UtZGVjYWRlLWxhdGVyLnBkZg==">RCU Usage In the Linux Kernel: One Decade Later<i class="fa fa-external-link-alt"></i></span> MIT 6.828课 RCU的阅读材料，我就是在这个课上看到rcu的，看起来还挺有意思<br><span class="exturl" data-url="aHR0cDovL3d3dy5yZHJvcC5jb20vdXNlcnMvcGF1bG1jay9SQ1Uv">Introduction to RCU<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLmVkZ2Uua2VybmVsLm9yZy9wdWIvbGludXgva2VybmVsL3Blb3BsZS9wYXVsbWNrL3BlcmZib29rL3BlcmZib29rLmh0bWw=">Is Parallel Programming Hard, And, If So, What Can You Do About It?<i class="fa fa-external-link-alt"></i></span> 我对于rcu的不少疑惑是看了这个才懂，推荐（本书主要作者Paul也是linux rcu的主要实现者）<br><span class="exturl" data-url="aHR0cDovL2lmZXZlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxMy8wNS8lRTYlQjclQjElRTUlODUlQTUlRTclOTAlODYlRTglQTclQTMlRTUlQjklQjYlRTglQTElOEMlRTclQkMlOTYlRTclQTglOEJWMS4wLnBkZg==">深入理解并行编程<i class="fa fa-external-link-alt"></i></span> 上面那本书的中文翻译<br>谢宝友 深入理解RCU系列文章<br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzQ5MDIyODI=">Linux锁机制：可抢占RCU原理<i class="fa fa-external-link-alt"></i></span><br>[CPU masks - linux-insiders] linux-insiders的CPU masks介绍（这本书也挺不错的，我好几次查资料翻到，讲的比较易懂）<br><span class="exturl" data-url="aHR0cHM6Ly94aW5xaXUuZ2l0Ym9va3MuaW8vbGludXgtaW5zaWRlcy1jbi9jb250ZW50L0NvbmNlcHRzL2xpbnV4LWNwdS0yLmh0bWw=">CPU masks 介绍<i class="fa fa-external-link-alt"></i></span> 中文翻译  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前做的垃圾骗钱项目有很多都是读多写少，而且不怎么需要实时。一直比较好奇应该用什么锁，读写锁总是不满意，最近看6.S081看到rcu，咦，是我想要找的东西。&lt;/p&gt;</summary>
    
    
    
    <category term="Concurrency&amp;Go" scheme="https://zhangjk98.xyz/categories/Concurrency-Go/"/>
    
    
    <category term="rcu" scheme="https://zhangjk98.xyz/tags/rcu/"/>
    
  </entry>
  
  <entry>
    <title>新年开箱一个 Canokey Pigeon</title>
    <link href="https://zhangjk98.xyz/canokey-pigeon-unboxing/"/>
    <id>https://zhangjk98.xyz/canokey-pigeon-unboxing/</id>
    <published>2022-01-02T06:05:36.000Z</published>
    <updated>2022-01-02T06:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>迟来的开箱，本来以为快递1号当天能到的，结果晚了一点。不管怎么说，元旦快落！</p><span id="more"></span><h2 id="开箱"><a href="#开箱" class="headerlink" title="开箱"></a>开箱</h2><p>Canokey就是tuna那一帮人弄的重置版yubikey啦，stm32版本完全开源，发售的版本固件开源加密算法没开。至于后门和售后这些问题，由子安人格担保。这一批的500个比以前更贵了，169大洋，小贵。（据说以前是亏本买的）和之前透明探索版不同，这次虽然有壳，但是似乎更脆弱了，总担心一不小心掉水里。然而还是买了，看到群友人均有一个key我也想整一个。虽然小贵，但是飞天的key又怕有后门不太敢要。其他的产品算上跨国邮费还是比这个贵了。（虽然我有个stm32的，找嘉立创打样整了一个，不过做工一般（毕竟白嫖的嘉立创打样，有就不错了），不太适合挂钥匙扣上一直带着）</p><p>子安29号从深圳发的，去快递的时候货架上还放着不少连号的相同包装，应该都是群友的。外包装有点脏，里面完好，附带一个绳子和USB-A转type-c的转接头。插上以后chromium浏览器会自动弹出管理界面（Firefox不支持Webusb所以用不了）<br><img src="/canokey-pigeon-unboxing/canokey2.webp"><br>好，然后生成个ed25519的密钥换掉我原来用于ssh登陆的rsa（这个对我来说好处是密钥不像rsa那么长，可以用笔抄在纸上一份，不要paperkey一类的工具把它变短了）。按照惯例找个liveusb，装好gpg，断网，生成公钥密钥子密钥。然后将子密钥导入CanoKey，主密钥抄下来。</p><p>感觉还是原来的透明探索版看起来耐用一点，这个的壳子不怎么防水容易进灰。上几张图给大家看一下灯光亮度。亮度和罗技G102鼠标最亮的蓝光大致相当，远高于我的键盘（dell kb522）指示灯和机箱电源的蓝光。（建议在管理页面调成默认关闭LED）</p><p><img src="/canokey-pigeon-unboxing/canokey3.webp"><br><img src="/canokey-pigeon-unboxing/canokey4.webp"></p><p>一个惊喜是这个功率比较低，在我的键盘USB插槽上可以正常使用。我的键盘USB插槽功率连U盘都带不动，也带不动g102等大部分鼠标，闲置了许久终于有了用途。</p><h2 id="用途和体验"><a href="#用途和体验" class="headerlink" title="用途和体验"></a>用途和体验</h2><p>1.两步验证</p><p>这个没有FIDO认证，因为没交保护费。所以YubiKey能干的一些事他干不了，比如可以跳过验证的<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZGZsYXJlY2hhbGxlbmdlLmNvbS8=">cloudflarechallenge<i class="fa fa-external-link-alt"></i></span>。<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzc2MzE4NjE=">互联网上消防栓的消亡-Cloudflare 无图 CAPTCHA 的应运而生<i class="fa fa-external-link-alt"></i></span> 想不要CAPTCHA那得交保护费。 </p><p>国内大多数网站不支持，不过Google帐号之类的还是可以的。Webauthn有FIDO2会用FIDO2,没有会去用U2F。</p><p>2.NFC</p><p>打开了一直关闭的iphone NFC功能试了一下，然而没有成功。据说这一批的确不太行，可能还不如之前的透明探索版。见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhbm9rZXlzL2Nhbm9rZXktcGlnZW9uL2Rpc2N1c3Npb25zLzQ=">对 NFC 的一些说明和建议<i class="fa fa-external-link-alt"></i></span>。</p><p>更新：读取成功了！弹出提示 网站NFC标签 “在Safari浏览器中打开”canokeys.org””（当然，没有webUSB，console用不了），NFC Tools成功读到标签类型和序列号。试了一下Google的两步验证，登陆成功。<br>iphone读NFC的位置非常靠上，大概在刘海屏的背面那里，其他位置读不到。 </p><p>更新：如果NFC不好使请试试：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhbm9rZXlzL2Nhbm9rZXktcGlnZW9uL2Rpc2N1c3Npb25zLzY=">NFC修复指南<i class="fa fa-external-link-alt"></i></span></p><p>3.sudo免密码</p><p>可以装<code>pam_u2f</code>实现，配置方式见<span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvVW5pdmVyc2FsXzJuZF9GYWN0b3I=">Universal_2nd_Factor ArchWiki<i class="fa fa-external-link-alt"></i></span>。不过还是建议不要sudo免密，在恍惚走神的状态下使用sudo容易酿成大祸。有的时候确认处在清醒状态直接<code>sudo su -</code>临时操作一下就好了。</p><p>4.放密钥</p><p>终于说到了我买这个key的主要目的了，拿来放密钥。体验还不错，有些时候跑到别人的电脑上或者在公共电脑上用ssh登陆的时候终于不用担心密钥泄漏了。 </p><p>5.加密LUKS之类的</p><p>去年systemd-homed刚出的那个时候我写过一篇博客，还说等我有了YubiKey试试LUKS加密home分区。不过到今年我已经很不喜欢systemd了（底裤，注意底裤！）。更重要的是我终于想明白了我home分区里面那点破玩意价值不足10元，用一个几百元的key去保护一个连key的零头都不到的破数据没必要。是时候停止我的被迫害妄想症了。</p><p>对于防止普通人直接把你硬盘扣了插到别的电脑上读数据，Arch可以直接装<code>mkinitcpio-tpm2-encrypt</code>和<code>luks-tpm2</code>这两个包配置TPM2+LUKS加密。systemd 248以上版本用systemd-cryptenroll也行。不过dell、hp几家的国行没有TPM的，有TPM的联想之类的也是有后门的TPM，所以你如果想拿来对付非普通人士还是算了吧。</p><h2 id="推不推荐买"><a href="#推不推荐买" class="headerlink" title="推不推荐买"></a>推不推荐买</h2><p>这要看你拿它来干什么，如果你很在乎体验又不缺钱也对开源没有特殊的感情，那去买YubiKey吧。如果不是很想掏钱或者对安全没那么在乎，那没必要买类似的产品。如果你想找一个足够方便的两步验证设备，那建议去用给FIDO2交了保护费的FIDO2之类的。  </p><p>我只是用它放个密钥啥的，倒也够用了。其实三年前我第一次开始用密钥是因为不想每次输入密码，后来逐渐变成了被迫害妄想症，一发不可收拾（倒也不全是杞人忧天，至少我大四的时候经历过一次被盗，由于出租屋家徒四壁幸免于难，合租的两位损失过万）<br>设置密码或者加密文件到底是防谁呢？</p><blockquote><p>There are two types of encryption: one that will prevent your sister from reading your diary and one that will prevent your government.   —-Bruce Schneier</p></blockquote><p>一顿操作下来，突然有一天发现密码忘了、钥匙无了、LUKS损坏了。<strong>防的竟是我自己</strong><br>第一种我身边的人用密码挡一下就已经够了，第二种暂时没有这个需求。现在除了你姐姐和gov，更多的是一些大小公司的流氓软件，扫描你的目录上传你的相册。现在已经懒得和它们斗智斗用了，流氓软件扔进虚拟机，密钥扔进CanoKey。   </p><p>说说局限<br>1.NFC不太灵<br>2.蓝色的灯光比较刺眼（设置里可以关）<br>3.由于芯片性能原因不能直接在CanoKey里面生成rsa4096（不过可以导入）<br>4.加密算法不开源（不过有子安人格担保）<br>5.这次一个Yubikey的价格没法买5个CanoKey了症<br>6.送的type-c转接头短一截看着逼死强迫</p><p><img src="/canokey-pigeon-unboxing/canokey5.webp"></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnplbml0aGFsLm1lLzIwMjEvMDIvMTUvQW50LURlc2lnbi1HaXRIdWItMkZBLXVuYXZhaWxhYmxlLWluLUNoaW5hLw==">从Ant Design GitHub失窃案谈开去：国内有可用的2FA吗<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMVBQNmFrU3RMX3hIVFk2OHpETW1LYkpyQnFRaE4zRkU5TXdMRG9NR3hiYXMvZWRpdCNnaWQ9MA==">Comparison of security keys<i class="fa fa-external-link-alt"></i></span> 群友整理的关于隔壁各家类似产品的功能对比<br><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmNhbm9rZXlzLm9yZy8=">CanoKeys官方文档<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RyZHVoL1l1YmlLZXktR3VpZGU=">YubiKey Guide<i class="fa fa-external-link-alt"></i></span> CanoKey的资料比较少，一些用法可以参考yubikey<br><span class="exturl" data-url="aHR0cHM6Ly9pYW10d3ouZ2l0Ym9va3MuaW8veXViaWtleS1oYW5kYm9vay1jaGluZXNlLw==">YubiKey 使用手册<i class="fa fa-external-link-alt"></i></span> 中文资料<br><span class="exturl" data-url="aHR0cHM6Ly9ud24ubW9lL3Bvc3RzL3l1YmlrZXktZXhhbXBsZXM=">应用 Yubikey 的N种方法<i class="fa fa-external-link-alt"></i></span>   </p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FnaGVyemFuL3l1YmlrZXktZnVsbC1kaXNrLWVuY3J5cHRpb24=">yubikey full disk encryption<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9ud24ubW9lL3Bvc3RzL2J0cmZzLW9uLWx1a3Mv">让系统更安全 - 系统分区加密 (Btrfs on LUKS) 操作实录<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTI1ODYyMTU4">Unlocking LUKS2 Volumes with TPM2, FIDO2, PKCS#11 Security HW on Systemd 248<i class="fa fa-external-link-alt"></i></span>  如果只是想电脑被偷之后，不让普通小偷&#x2F;电脑城修电脑的&#x2F;脚本小子看你的数据，用tpm2加密home分区增加的破解成本差不多能够保护你不太之前的数据了。  </p><p><span class="exturl" data-url="aHR0cHM6Ly9mbHloaWdoZXIudG9wL2RldmVsb3AvMjE2MC5odG1s">谈谈 WebAuthn<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93ZWJhdXRobi5tZS8=">webauth.me<i class="fa fa-external-link-alt"></i></span> 用于测试webauthn的网站    </p><p><span class="exturl" data-url="aHR0cHM6Ly93aWtpLmFyY2hsaW51eC5vcmcvdGl0bGUvUGFwZXJrZXk=">Paperkey Archwiki<i class="fa fa-external-link-alt"></i></span> paperkey用来减少密钥长度方便抄下来<br><span class="exturl" data-url="aHR0cHM6Ly91bHljLmdpdGh1Yi5pby8yMDIxLzAxLzEzLzIwMjElRTUlQjklQjQtJUU3JTk0JUE4JUU2JTlCJUI0JUU3JThFJUIwJUU0JUJCJUEzJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUJEJUJGJUU3JTk0JUE4UEdQLSVFNCVCOCU4QS8=">2021年，用更现代的方法使用PGP（上）<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly91bHljLmdpdGh1Yi5pby8yMDIxLzAxLzE4LzIwMjElRTUlQjklQjQtJUU3JTk0JUE4JUU2JTlCJUI0JUU3JThFJUIwJUU0JUJCJUEzJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUJEJUJGJUU3JTk0JUE4UEdQLSVFNCVCOCVBRC8=">2021年，用更现代的方法使用PGP（中）<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly91bHljLmdpdGh1Yi5pby8yMDIxLzAxLzI2LzIwMjElRTUlQjklQjQtJUU3JTk0JUE4JUU2JTlCJUI0JUU3JThFJUIwJUU0JUJCJUEzJUU3JTlBJTg0JUU2JTk2JUI5JUU2JUIzJTk1JUU0JUJEJUJGJUU3JTk0JUE4UEdQLSVFNCVCOCU4Qi8=">2021年，用更现代的方法使用PGP（下）<i class="fa fa-external-link-alt"></i></span>  </p><p>目前Pigeon暂时卖完了，你可以自己去嘉立创整一个stm32版本的</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nhbm9rZXlzL2Nhbm9rZXktc3RtMzI=">Canokey-stm32<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9sY2VkYS5jbi96NHl4L25mYy1wb3dlci10ZXN0">Canokey-NFC-A<i class="fa fa-external-link-alt"></i></span>   </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;迟来的开箱，本来以为快递1号当天能到的，结果晚了一点。不管怎么说，元旦快落！&lt;/p&gt;</summary>
    
    
    
    <category term="不务正业系列" scheme="https://zhangjk98.xyz/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="canokey" scheme="https://zhangjk98.xyz/tags/canokey/"/>
    
  </entry>
  
  <entry>
    <title>文件系统的Reflink</title>
    <link href="https://zhangjk98.xyz/reflink-hardlink-symlink/"/>
    <id>https://zhangjk98.xyz/reflink-hardlink-symlink/</id>
    <published>2021-12-19T05:24:54.000Z</published>
    <updated>2021-12-19T05:24:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>reflink暂且翻译成引用链接吧，新版coreutils的cp和mv的默认行为就是reflink（如果文件系统支持）。硬链接和软链接的</p><span id="more"></span><h2 id="Reflink"><a href="#Reflink" class="headerlink" title="Reflink"></a>Reflink</h2><p>如果你的coreutils&gt;9.0，而且装的是Btrfs或XFS等支持Reflink的文件系统，那么<code>cp</code>和<code>mv</code>的默认行为是使用reflink(mv应该是在不同子卷之间，when moving files across BTRFS subvols)，<code>cp --reflink=auto</code></p><p>最早是从Btrfs听说的reflink,以为这就是一个COW，后来发现它并不一定需要COW，而是和de-duplication（重复数据删除）有关。</p><h2 id="整理碎片对reflink的影响"><a href="#整理碎片对reflink的影响" class="headerlink" title="整理碎片对reflink的影响"></a>整理碎片对reflink的影响</h2><p>以Btrfs为例，defragment会打断reflink，于是你做完defrag以后会发现占用空间可能大了好多。不过像Btrfs之类的文件系统几乎都跑在SSD上，整理碎片不仅不会像机械那样提升性能，而且会增加写入。所以直接不整理碎片就好了。</p><h2 id="硬链接和软链接和Reflink的区别"><a href="#硬链接和软链接和Reflink的区别" class="headerlink" title="硬链接和软链接和Reflink的区别"></a>硬链接和软链接和Reflink的区别</h2><p>这两个东西的区别基本上网上都说烂了。这里再简单说一下。</p><p>硬链接（hardlink）的inode号和原来的一样</p><p>但是hardlink和symlink有一些问题，创建的时候很开心，修改和删除就比较麻烦。</p><h2 id="Reflink这个东西有啥用"><a href="#Reflink这个东西有啥用" class="headerlink" title="Reflink这个东西有啥用"></a>Reflink这个东西有啥用</h2><p>1.加快复制和移动速度<br>2.节省空间</p><p>比如wine的reflink补丁。比如你steam开proton下了很多游戏，你会发现<code>.local/share/Steam</code>下面每个游戏的目录都有一堆相同的ddl。reflink的补丁可以有效减小Wine应用的体积，很多重复的ddl文件都会以reflink的方式复制。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PVJlZmxpbmstRm9yLVdpbmUtUGF0Y2hlcw==">Proposed Reflink Support Would Provide Big Space Savings For Wine<i class="fa fa-external-link-alt"></i></span>， <span class="exturl" data-url="aHR0cHM6Ly93d3cucGhvcm9uaXguY29tL3NjYW4ucGhwP3BhZ2U9bmV3c19pdGVtJnB4PVdpbmUtUmVmbGluay1SZXZpc2Vk">Wine Reflink Support Continues To Be Worked On For Significant Space Savings<i class="fa fa-external-link-alt"></i></span>  </p><p>坏消息这玩意暂时不支持ext4，好消息Steam Deck将采用Btrfs。对于不支持的文件系统，可以通过OVerlayfs实现，不过好像没多少人这么干（Overlayfs这个名字你也在Docker那里听说过对罢？坑也不少）</p><p>那wine为什么不用符号链接呢？看起来这种情况下用symlink不是也挺合适的？</p><blockquote><p>Because most of the file WINE is running didn’t have symlink support in mind.They assumes that the open give them the file, not a symlink.After opening the file, they would just update it without replacing that symlink with an actual file.</p></blockquote><p>另一个麻烦的问题是相当多的游戏反作弊软件，他们在检查的时候不认符号链接。于是就认为你这ddl有问题，然后就封号了。用reflink就比较好解决了，在Wine应用和你看来是感觉不到链接存在的，reflink看起来就像是正常的文件一样；而symlink看起来就是一个link，如果Wine应用和外挂检测不去处理他会出问题。举一个不恰当的例子，reflink就像透明代理一样，用户和软件感觉不到它的存在。</p><p>要不我们叫它透明链接算了（逃</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9ncy5vcmFjbGUuY29tL2xpbnV4L3Bvc3QveGZzLWRhdGEtYmxvY2stc2hhcmluZy1yZWZsaW5r">https://blogs.oracle.com/linux/post/xfs-data-block-sharing-reflink<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9idHJmcy53aWtpLmtlcm5lbC5vcmcvaW5kZXgucGhwL0RlZHVwbGljYXRpb24=">Deduplication Btrfs Wiki<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3J1Y2lhbC5jb20vYXJ0aWNsZXMvYWJvdXQtc3NkL3Nob3VsZC15b3UtZGVmcmFnLWFuLXNzZA==">Should You Defrag an SSD? <i class="fa fa-external-link-alt"></i></span> </p><p><span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9pb2N0bF9maWNsb25lLjIuaHRtbA==">https://man7.org/linux/man-pages/man2/ioctl_ficlone.2.html<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzMzMTgwOC8=">https://lwn.net/Articles/331808/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;reflink暂且翻译成引用链接吧，新版coreutils的cp和mv的默认行为就是reflink（如果文件系统支持）。硬链接和软链接的&lt;/p&gt;</summary>
    
    
    
    
    <category term="fs" scheme="https://zhangjk98.xyz/tags/fs/"/>
    
    <category term="reflink" scheme="https://zhangjk98.xyz/tags/reflink/"/>
    
  </entry>
  
  <entry>
    <title>Linux from Scratch 编译笔记</title>
    <link href="https://zhangjk98.xyz/build-linux-from-scratch/"/>
    <id>https://zhangjk98.xyz/build-linux-from-scratch/</id>
    <published>2021-11-29T11:55:37.000Z</published>
    <updated>2021-11-29T11:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>久闻大名，然而真的编译了几圈下来，和想象中的不太一样。照着手册一步一步来并不难，但是特别繁琐。其实我更建议去看一看Alpine等更精简的Linux的构建过程。哦，对了，我等编译的时候通关了蔚蓝a面</p><span id="more"></span><p>LFS的主要目的是教你打造一个你自己的发行版，所以它特别繁琐。如果你想自己做一个优麒麟去骗钱那不妨看看。如果想了解一下Linux的依赖和编译过程，想看看一个特别精简版的Linux长什么样子，<strong>请试试Alpine而不是LFS</strong></p><p><strong>感觉Alpine更适合作为一个 玩具来学习，而LFS更适合作为正经用途。</strong> 大家不知为何都反着来。</p><p>推荐阅读：<span class="exturl" data-url="aHR0cHM6Ly90dHlzMy5kZXYvcG9zdC9kby1ub3QtdXNlLWFscGluZS1pbi1wcm9kdWN0aW9uLWVudmlyb25tZW50Lw==">不要在生产环境中使用alpine基础镜像 – 容器基础镜像的选择<i class="fa fa-external-link-alt"></i></span></p><p>之前觉得就是一个安装超麻烦版的Arch&#x2F;Gentoo，就没试过。最近终于试了一下，学到的东西倒不是很多，没有当时第一次完整安装Arch时的收获大。</p><p>这个东西告诉你linux里面glibc之类的依赖关系是什么样的。这个东西就像单片机最小系统一样，告诉你。你可以从头开始看一看系统是怎么从源码构建的，glibc那一堆依赖又是怎么鸡生蛋、蛋生鸡的。推荐想了解系统构建依赖的Linux用户看一看这个东西。</p><p>闲着没事的人最适合玩一玩这个了，不过不太推荐日常使用。虽然还是是有一些人真的把这个当日用主力的，比如fcitx输入法初代目鱼王（Yuking）就是在LFS上面写了早期的fcitx输入法。<br>LFS is free if your time is free.     </p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先去找一个好一点的机器用来编译。你要有一个宿主机，一般用Ubuntu 20的比较多一点，我用的Arch, 暂时没遇到什么大问题。</p><p>然后下载LFS的手册和源码，我用的是最新的r11.0-92这个版本：<span class="exturl" data-url="aHR0cHM6Ly93d3cubGludXhmcm9tc2NyYXRjaC5vcmcvbGZzL2Rvd25sb2Fkcy9kZXZlbG9wbWVudC8=">https://www.linuxfromscratch.org/lfs/downloads/development/<i class="fa fa-external-link-alt"></i></span></p><p>手册说的wget-list没有说在哪，wget-list 可以用香港的镜像： <span class="exturl" data-url="aHR0cHM6Ly9sZnMtaGsua29kZG9zLm5ldC9sZnMvdmlldy9yMTEuMC05Mi93Z2V0LWxpc3Q=">https://lfs-hk.koddos.net/lfs/view/r11.0-92/wget-list<i class="fa fa-external-link-alt"></i></span></p><p>如果想稳一点可以用stable版本，喜欢systemd可以用systemd版本（最近对systemd全家桶有点怨念，就不上systemd了）。</p><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>这里面绝大部分编译都是make那一套流程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./configure<span class="token function">make</span><span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="个人的改动"><a href="#个人的改动" class="headerlink" title="个人的改动"></a>个人的改动</h2><p>其实不太建议第一次就用dev版本还加上一大堆自己的改动。我自己乱改，前面几次都没有开机成功，反复编译了四五次才成功开机。</p><h3 id="我和手册有些出入的地方"><a href="#我和手册有些出入的地方" class="headerlink" title="我和手册有些出入的地方"></a>我和手册有些出入的地方</h3><p>手册里面要求使用bash，我在宿主机一直都用的zsh，好在没出什么大问题（主要是想接着用我习惯的那几个插件和语法，反正这个东西兼容sh，问题不大）（<strong>不要学我，坑特别多</strong>）</p><p>chroot之后用的是bash，然而看到那个没有自动补全和色彩高亮的bash, 我不能接受，于是配了半天的</p><p>分区我只分了一个100G的<code>/</code>分区，swap和boot都是和Arch共用的。（我懒）</p><h3 id="一些手册上有但我没编译和安装的东西"><a href="#一些手册上有但我没编译和安装的东西" class="headerlink" title="一些手册上有但我没编译和安装的东西"></a>一些手册上有但我没编译和安装的东西</h3><p>现在看文档基本都在浏览器上面搜了，很少看本地目录的文档，那些doc之类的东西我基本上都没装。没用默认的vim，参考BLFS的手册装了一个我习惯的neovim</p><p>Meson这个包编译报错了，这个是systemd和BLFS需要的，我就没管</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>lfs <span class="token function">chroot</span><span class="token punctuation">)</span> root:/sources/meson-0.60.2<span class="token comment"># python3 setup.py build</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span>:  File <span class="token string">"/sources/meson-0.60.2/setup.py"</span>, line <span class="token number">23</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    from setuptools <span class="token function">import</span> setup  File <span class="token string">"/usr/lib/python3.10/site-packages/setuptools/__init__.py"</span>, line <span class="token number">18</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    from setuptools.dist <span class="token function">import</span> Distribution  File <span class="token string">"/usr/lib/python3.10/site-packages/setuptools/dist.py"</span>, line <span class="token number">38</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    from setuptools <span class="token function">import</span> windows_support  File <span class="token string">"/usr/lib/python3.10/site-packages/setuptools/windows_support.py"</span>, line <span class="token number">2</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    <span class="token function">import</span> ctypes  File <span class="token string">"/usr/lib/python3.10/ctypes/__init__.py"</span>, line <span class="token number">8</span>, <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    from _ctypes <span class="token function">import</span> Union, Structure, ArrayModuleNotFoundError: No module named '_ctypes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="加快速度"><a href="#加快速度" class="headerlink" title="加快速度"></a>加快速度</h2><h3 id="多核编译"><a href="#多核编译" class="headerlink" title="多核编译"></a>多核编译</h3><p>通常可以直接拉满，比如我的宿主机最多能<code>-j20</code> 那就<code>export MAKEFLAGS=&#39;-j20&#39; </code>。<br>需要注意的是有的时候必须用<code>-j1</code>参数，比如编译<code>binutils</code></p><h3 id="多核压缩解压"><a href="#多核压缩解压" class="headerlink" title="多核压缩解压"></a>多核压缩解压</h3><p>xz压缩格式，使用最新版的tar看起来默认就是多核的。加上参数之后<code>XZ_OPT=&#39;-T0&#39; tar -xf linux-5.15.2.tar.xz</code>和直接<code>tar -xf linux-5.15.2.tar.xz</code>没有区别。<br>有几个gz后缀的使用<code>pizg</code>应该会快一点，但是这几个文件太小了，几乎没区别。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>第七章结尾会教你<code>tar -cJpf $HOME/lfs-temp-tools-r11.0.92.tar.xz .</code>进行备份，这个备份速度很慢，比上面那些解压慢不少。</p><p>我推荐使用Btrfs snapshot，在每次重要的make都建立一个snapshot，这样不用从头开始，而且备份和恢复的速度也很快。</p><h2 id="其他的一些小问题"><a href="#其他的一些小问题" class="headerlink" title="其他的一些小问题"></a>其他的一些小问题</h2><h3 id="i和l"><a href="#i和l" class="headerlink" title="i和l"></a>i和l</h3><p><code>Iana-etc</code>这里是大写的<code>i</code>，不是小写的<code>L</code>，另一个叫<code>Inetutils</code>的也是。</p><h3 id="chroot的时候PTY-allocation-request-failed"><a href="#chroot的时候PTY-allocation-request-failed" class="headerlink" title="chroot的时候PTY allocation request failed"></a>chroot的时候PTY allocation request failed</h3><p>我是ssh连的另一台电脑编译的（本地和远程都是Arch），结果有一天突然<code>PTY allocation request failed</code></p><p>我以为是chroot或者ssh的问题，穷尽毕生所学调试了半个小时，<strong>结果发现是那台服务器的校园网账户欠费了</strong>。</p><h3 id="一些编译报错"><a href="#一些编译报错" class="headerlink" title="一些编译报错"></a>一些编译报错</h3><p>编译findutils报错，但是装上去能用。</p><pre class="line-numbers language-log" data-language="log"><code class="language-log"><span class="token file-path string">/sources/findutils-4.8.0/find/pred.c</span><span class="token operator">:</span><span class="token number">751</span><span class="token operator">:</span> undefined reference to `rpl_fnmatch'<span class="token file-path string">/usr/bin/ld</span><span class="token operator">:</span> libfindtools<span class="token punctuation">.</span>a<span class="token operator">(</span>pred<span class="token punctuation">.</span>o<span class="token operator">)</span><span class="token operator">:</span><span class="token file-path string">/sources/findutils-4.8.0/find/pred.c</span><span class="token operator">:</span><span class="token number">1180</span><span class="token operator">:</span> more undefined references to `rpl_fnmatch' follow<span class="token property">collect2:</span> <span class="token property">error:</span> ld returned <span class="token number">1</span> exit status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译gzip时报错：</p><pre class="line-numbers language-log" data-language="log"><code class="language-log">In file included from <span class="token file-path string">./lib/getopt.h</span><span class="token operator">:</span><span class="token number">84</span><span class="token punctuation">,</span>                 from gzip<span class="token punctuation">.</span>c<span class="token operator">:</span><span class="token number">77</span><span class="token operator">:</span><span class="token file-path string">./lib/getopt-cdefs.h</span><span class="token operator">:</span><span class="token number">31</span><span class="token operator">:</span><span class="token number">5</span><span class="token operator">:</span> error<span class="token operator">:</span> <span class="token operator">#</span>if with no expression   <span class="token number">31</span> <span class="token operator">|</span> <span class="token operator">#</span>if      <span class="token operator">|</span>     <span class="token operator">^</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行<code>make clean</code>后错误消失。</p><p><code>make check</code>失败一项：<code>FAIL: help-version</code>，这个影响不大，忽略。</p><p>在编译Patch的时候发生了同样的报错，重新编译后成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">In <span class="token function">file</span> included from <span class="token punctuation">..</span>/lib/getopt.h:84,                 from patch.c:27:<span class="token punctuation">..</span>/lib/getopt-cdefs.h:32:5: error: <span class="token comment">#if with no expression</span>   <span class="token number">32</span> <span class="token operator">|</span> <span class="token comment">#if</span>      <span class="token operator">|</span>     ^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>怀疑是多线程编译的问题，采用<code>make -j1</code>和<code>make -j20</code>分别编译了10次，发现这个问题确实是在<code>-j20</code>多线程编译时才会发生。</p><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>接下来就是重头戏编译内核了。编译内核这个gentoo用户应该很熟悉了。可以自己选择编译参数，没有什么特殊喜好就默认吧。</p><p><img src="/build-linux-from-scratch/image-20211204142505342.png" alt="image-20211204142505342"></p><p>编译速度比想象中的快，我从下午2:49编译到3:17，大概半个小时左右。</p><p>魔改编译参数请量力而行。我前面几次都自己改了很多参数，编译虽然没报错，但是启动的时候CapsLock和ScrollLock同时闪烁，只能重新编译。</p><h3 id="编译时make-clean和make-mrproper的区别"><a href="#编译时make-clean和make-mrproper的区别" class="headerlink" title="编译时make clean和make mrproper的区别"></a>编译时make clean和make mrproper的区别</h3><p><code>make mrproper</code>相比<code>make clean</code>多删除了config文件。</p><h3 id="启动引导设置"><a href="#启动引导设置" class="headerlink" title="启动引导设置"></a>启动引导设置</h3><p><strong>设置Grub的时候记得备份你宿主机的grub！</strong></p><p>本来我是想用Arch的<code>os-prober</code>自动识别<code>grub-mkconfig -o /boot/grub/grub.cfg</code>，但是不行。这样会识别成<code>Arch Linux， with Linux 5.15.2.-lfs-r11.0.92</code></p><p>在Archlinux宿主机中编辑Grub，加上：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">menuentry <span class="token string">"GNU/Linux, Linux 5.15.2-lfs-r11.0-92"</span> <span class="token punctuation">&#123;</span>linux /boot/vmlinuz-5.15.2-lfs-r11.0-92 <span class="token assign-left variable">root</span><span class="token operator">=</span>/dev/sda2 ro<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Fly-Bitch！"><a href="#Fly-Bitch！" class="headerlink" title="Fly Bitch！"></a>Fly Bitch！</h2><p>到这里我已经累了，BLFS已经不打算再弄了，没啥意思。Nvidia驱动，折腾了好几次，想用dkms装驱动结果都失败了。最后我把Nvidia独显拆了，整个世界都美好了。<br>试图整个KDE桌面上去，结果一堆依赖没成功，结果发现最容易的反而是dwm。。。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>终于记住了tar命令解压时候哪个参数是压缩哪个是解压。<br>不过sed还是不太会用，已经被sd惯坏了。<br>发现了starship这个不错的prompt，bash上很舒服，体验接近powerlevel10k。<br>LFS的企鹅LOGO真的好丑啊，见过的最丑的企鹅。<br>bash里<code>+h</code>关闭hash查找。这个参数的意思是不使用当前hash表里面存放的路径，精确的使用现在给出的路径。使用<code>set +h</code>关闭hash，使用<code>set -h</code>启用hash。（我总觉得<code>+h</code>才是开启hash, 真是令人迷惑）  </p><p>断断续续折腾了四五天，等编译期的间隙里蔚蓝从3a跳到了到7a登顶。</p><h2 id="编译时无聊发现的其他东西"><a href="#编译时无聊发现的其他东西" class="headerlink" title="编译时无聊发现的其他东西"></a>编译时无聊发现的其他东西</h2><p>这几天在等编译的时候闲着没事发现了其他一些有意思的东西。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Rjam9uZXMvbWs=">https://github.com/dcjones/mk<i class="fa fa-external-link-alt"></i></span> plan9的mk</p><h3 id="bash和zsh的环境变量是怎么传递和继承的"><a href="#bash和zsh的环境变量是怎么传递和继承的" class="headerlink" title="bash和zsh的环境变量是怎么传递和继承的"></a>bash和zsh的环境变量是怎么传递和继承的</h3><p>login shell 和 nonlongin shell的读取环境变量方式不太一样</p><h3 id="zsh里面的‘-’命令是干什么的"><a href="#zsh里面的‘-’命令是干什么的" class="headerlink" title="zsh里面的‘-’命令是干什么的"></a>zsh里面的‘-’命令是干什么的</h3><p><span class="exturl" data-url="aHR0cHM6Ly96c2guc291cmNlZm9yZ2UuaW8vRG9jL1JlbGVhc2UvU2hlbGwtR3JhbW1hci5odG1sI1ByZWNvbW1hbmQtTW9kaWZpZXJz">zsh的文档<i class="fa fa-external-link-alt"></i></span>是这样说的：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">- The command is executed with a ‘-’ prepended to its argv[0] string.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看起来似乎它会在<code>argv[0]</code>前面加上一个<code>-</code>，可是这有什么用？</p><p>argv[0]你可以当作<span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuMi9leGVjdmUuMi5odG1s">execve<i class="fa fa-external-link-alt"></i></span>的第一个变量，通常是<code>\bin\bash</code>这样的可执行路径。</p><p>再看一下exec这个命令，参数<code>-l</code>的效果和zsh里面的<code>-</code>是一致的</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">exec [ -cl ] [ -a argv0 ]    The following command together with any arguments is run in place of the current process, rather than as a sub-process. The shell does not fork and is replaced. The shell does not invoke TRAPEXIT, nor does it source zlogout files. The options are provided for compatibility with other shells.    The -c option clears the environment.    The -l option is equivalent to the - precommand modifier, to treat the replacement command as a login shell; the command is executed with a - prepended to its argv[0] string. This flag has no effect if used together with the -a option.    The -a option is used to specify explicitly the argv[0] string (the name of the command as seen by the process itself) to be used by the replacement command and is directly equivalent to setting a value for the ARGV0 environment variable. <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>哦，就是把当前shell视为login shell，试了一下看起来的确是这样</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">❯ <span class="token builtin class-name">echo</span> <span class="token variable">$0</span>/bin/zsh❯ - <span class="token builtin class-name">echo</span> <span class="token variable">$0</span>/bin/zsh❯ - <span class="token function">zsh</span>❯ <span class="token builtin class-name">echo</span> <span class="token variable">$0</span>-zsh❯ <span class="token builtin class-name">exit</span>❯ <span class="token function">zsh</span>❯ <span class="token builtin class-name">echo</span> <span class="token variable">$0</span><span class="token function">zsh</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVtP2lkPTI4ODIwNjAy">Linux from Scratch with Training Wheels<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9hbHBpbmVsaW51eC5vcmcv">Alpine<i class="fa fa-external-link-alt"></i></span>  </p><p><span class="exturl" data-url="aHR0cHM6Ly91bml4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy84NjAxMi93aGF0LWlzLXRoZS1wdXJwb3NlLW9mLXRoZS1oYXNoLWNvbW1hbmQ=">What is the purpose of the hash command?<i class="fa fa-external-link-alt"></i></span>  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;久闻大名，然而真的编译了几圈下来，和想象中的不太一样。照着手册一步一步来并不难，但是特别繁琐。其实我更建议去看一看Alpine等更精简的Linux的构建过程。哦，对了，我等编译的时候通关了蔚蓝a面&lt;/p&gt;</summary>
    
    
    
    <category term="Linux&amp;Unix" scheme="https://zhangjk98.xyz/categories/Linux-Unix/"/>
    
    
    <category term="Linux" scheme="https://zhangjk98.xyz/tags/Linux/"/>
    
    <category term="LFS" scheme="https://zhangjk98.xyz/tags/LFS/"/>
    
  </entry>
  
  <entry>
    <title>从KDE迁移到i3，顺便说说Linux桌面(DE)和窗口管理器（WM）</title>
    <link href="https://zhangjk98.xyz/migrating-from-kde-to-i3/"/>
    <id>https://zhangjk98.xyz/migrating-from-kde-to-i3/</id>
    <published>2021-11-13T14:25:47.000Z</published>
    <updated>2021-11-13T14:25:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这样又将一部分鼠标干的活还给了键盘。</p><span id="more"></span><p>前一阵不是KDE 25周年吗，然后KDE推出了25周年纪念版，从这开始的几个版本，小问题不断。迫害GNOME是KDE群友的传统艺能，然而，最近似乎KDE用户受到的迫害比GNOME还多。KDE怎么会变成了这个样子？ 于是决定从KDE先迁移到i3之类的wm去。（当然，最主要的原因是我逐渐不需要一个完整DE的那么功能了）</p><h2 id="从KDE说起"><a href="#从KDE说起" class="headerlink" title="从KDE说起"></a>从KDE说起</h2><p>KDE一度是我最看好的Linux桌面，功能该有的都有，当时也比较稳定，那时我觉得最近3年应该不用换到其他的桌面去了。<br>KDE为什么是神，首先，要从Konqueror和KHTML的荣光说起…<br>KDE4时代虽然好看，但是因为不稳定而饱受诟病。自从KDE5以来，KDE也稳定了,<br>直到，KDE 25周年特供版……每次更新总有一些新问题，又开始不稳定了…..</p><h3 id="防火防盗防抄袭的配置文件"><a href="#防火防盗防抄袭的配置文件" class="headerlink" title="防火防盗防抄袭的配置文件"></a>防火防盗防抄袭的配置文件</h3><p>想抄一下我的KDE的桌面设置？不好意思KDE的设置我自己也不知道它给我保存到哪里去了。</p><p>KDE的配置文件在<code>config</code>里面扔的到处都是，实乃居家旅行防偷配置利器。</p><p><code>.config</code>目录下面有一个有一个小写的<code>kde</code>目录，还有一个大写的<code>KDE</code>目录,还有一个<code>kde.org</code>目录，下面有<code>systemsettings.conf</code>和<code>plasmashell.conf</code>这样的配置文件。如果你是祖传home目录，那八成还有个<code>kde4</code>。如果你是比较新的用户，你会开心的发现<code>~/.config</code>下面没有<code>kde4</code>，是的，他跑到<code>~/.kde4</code>这来了,<code>~/.kde4/share/config</code>下面有一些kde4的配置。<br>然后，<code>~/.config</code>下面，还有<code>plasmarc</code>，<code>kded5rc</code>，<code>plasmashellrc</code>，<code>kdeglobals</code>，天知道它们有什么区别。<br>然后是一堆散落在<code>.config</code>下面的KDE全家桶应用, 比如<code>kalarmrc</code>。这次看起来挺合理吧，你看别的应用好多不也都把配置文件扔在<code>~/.config</code>下面。</p><p>别急，比如KDE出品的和notepad3、vscode类似的文本编辑器kate，在<code>~/.config</code>下面有<code>katerc</code>, <code>kateschemarc</code>, <code>katevirc</code>等等，跟VSCode一个json文件比起来拆的还是太散了。在比如elisa这个音乐播放器，有一个<code>elisarc</code>，还有一个<code>kde.org/elisa.conf</code>。</p><p>更麻烦的是这些KDE的设置和其他应用都混在一起了。有一天你的配置崩溃了，KDE起不来，你想全部恢复默认设置，又不能直接全删了来恢复默认设置。（比较好的办法是挑出不是KDE的设置或者）。比如<code>trashrc</code>是KDE的配置文件，它看起来跟KDE毫无关系。</p><p>当然有一些第三方工具可以保存KDE的设置，比如<code>konsave</code>，我还给他打过一个AUR包。不过用了两天我立刻发现这并不能解决问题，我想抄别人的配置去改一改还是要打开KDE系统设置的图形界面。某一部分微小的改动，我还是要从茫茫的配置文件里面找到它们，KDE官方有没有说明，结果就是改起配置文件比手动在设置里面调整慢。</p><p>当然KDE有一个kcmshell5的命令工具可以在命令行配置，不过我想正常人没有用这个的。你以为他是命令行工具，实际上你执行他，他给你弹出一个和系统设置一样的图形界面。</p><p>估计KDE也没想让你使用<code>dotfiles</code>或者直接编辑配置文件，都给我用鼠标在设置里面点击选择的你设置！</p><h3 id="小而美的Baloo"><a href="#小而美的Baloo" class="headerlink" title="小而美的Baloo"></a>小而美的Baloo</h3><blockquote><p>baloo 是张小龙开发的吗</p></blockquote><p>哎，这index索引文件怎么50多个G？哎，我桌面怎么突然卡死了？哎，我CPU怎么突然100%了？哎，我内存怎么占用飙升？</p><p>Baloo这个用过KDE的应该都有体会，体验大概就是Windows装了个流氓全家桶的感觉。 </p><p>一个索引服务, 磁盘写入远超读取是怎样一种体验？</p><p>我建议每个每个KDE用户装上KDE立刻关闭Baloo，我也建议有良心的KDE发行版在KDE的默认设置里面禁用Baloo</p><pre class="line-numbers language-none"><code class="language-none">balooctl suspendbalooctl disablebalooctl purge #delete the index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你还想要一个搜索工具，推荐rg、fd、fzf。<br>如果你想要一个Baloo那样带索引的，试试plocate</p><h3 id="混成器"><a href="#混成器" class="headerlink" title="混成器"></a>混成器</h3><p>混成器（Compositer）造成了KDE4时代KDE不如GNOME稳定的传说，当时OpenGL导致画质撕裂。据说当时大部分不稳定的锅都是混成器的，KDE其他的部分还是挺稳定的。<br>就在10月份，KDE将Compositer的选项</p><p>Vulkan也不知道要等到什么时候，据说要KDE6了，到时候再试试KDE吧。</p><h2 id="使用平铺wm"><a href="#使用平铺wm" class="headerlink" title="使用平铺wm"></a>使用平铺wm</h2><p>最近一年来我对Desktop Enviroment的需求逐渐降低，很多操作都从鼠标点击过渡到了命令操作。我在KDE桌面上操作窗口也从鼠标点击变成了Win+上下左右平铺、Alt+Tab切换窗口、Win+Tab切换桌面。之前非常喜欢的yakuake也被我用tdrop+alacritty替代了。那些标题栏、桌面小组件、任务栏逐渐开始变得鸡肋，而且我也不想要那么多的桌面过渡特效。为了更好地移动窗口我试过krohnkite（一个模仿dwm操作的脚本）</p><p>在发现自己的需求基本上wm都能满足之后，好像没有什么用DE的必要了。</p><p>平铺的好处是比较充分的铺满整个桌面，而且可以省掉标题栏，对于比较小的笔记本屏幕可以省空间。（笔记本上用wm还比较省电，轻松撑过一整天）</p><p>关于wm的介绍可以看这个视频：<span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1BcGk2ZEZNbHhBQQ==">https://www.youtube.com/watch?v=Api6dFMlxAA<i class="fa fa-external-link-alt"></i></span></p><p>dwm是类似栈的操作，而i3wm的窗口是一棵树。不过轻度使用应该区别不大，我几乎只用将屏幕两等分或者四等分、或者竖着三等分。</p><h3 id="真的一定要那么依赖鼠标和GUI吗"><a href="#真的一定要那么依赖鼠标和GUI吗" class="headerlink" title="真的一定要那么依赖鼠标和GUI吗"></a>真的一定要那么依赖鼠标和GUI吗</h3><p>早些时候人们用键盘的快捷键和命令和计算机打交道，鼠标和GUI界面反而是比较后来的事情了。据说微软当年为了让用户习惯鼠标操作，推出了扫雷、空当接龙和蜘蛛纸牌让大家玩</p><p>我从第一次用Windows XP开始就是拿鼠标在图形界面上点点点，在小时候的相当长一段时间内键盘打字都不熟练，后来微机课教的也是Office、Flash、photoshop等拿着鼠标在一堆设置按钮里面选来选取的那种，甚至外的游戏也都是pvz、愤怒的小鸟等鼠标操作居多</p><h3 id="i3的一些问题"><a href="#i3的一些问题" class="headerlink" title="i3的一些问题"></a>i3的一些问题</h3><p>不管是i3还是sway，或者dwm之类的，都对浮动窗口支持很差。其实挺难受的，比如沙拉查词之类的翻译软件或者浏览器小窗播放、又比如输入法那个小菜单栏（虽然现在fcitx5没有浮在外面的菜单栏），不太适合平铺。</p><p>i3的浮动窗口必须置于平铺的下面，挺难受的。</p><p>另外这些平铺桌面</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 我装的cn源里面那个功能最多的开发版本，如果没什么特殊需求可以直接装i3wm或者i3-gaps（支持窗口缝隙）</span><span class="token comment"># yay -S i3-gaps</span>yay -S i3-gaps-next-git yay -S picom <span class="token comment"># 用来设置外观、锁屏什么的</span>yay -S lxappearance <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还有一些fcitx5的configtool、qt界面的设置软件，我用KDE的时候都装过了，这里略过。</p><h3 id="polybar作为状态栏"><a href="#polybar作为状态栏" class="headerlink" title="polybar作为状态栏"></a>polybar作为状态栏</h3><p>polybar比i3bar功能多一点而且好看，但是占用也高</p><p>polybar自己一点一点配置会很麻烦，比较懒的我直接用的这个：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkaTEwOTB4L3BvbHliYXItdGhlbWVz">polybar-themes<i class="fa fa-external-link-alt"></i></span>，一个awesome wm的polybar设置脚本，有相当多的主题可供选择。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone --depth<span class="token operator">=</span><span class="token number">1</span> https://github.com/adi1090x/polybar-themes.git<span class="token builtin class-name">cd</span> polybar-themes<span class="token function">chmod</span> +x setup.sh./setup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后选一个你喜欢的主题改一改就好了。</p><h3 id="picom配置"><a href="#picom配置" class="headerlink" title="picom配置"></a>picom配置</h3><p>其实我对阴影特效、模糊透明毛玻璃、圆角都没有什么需求。装picom主要是解决一下画面撕裂的问题（毕竟Nvidia f**k you, 混成器不要是不行的）</p><p>picom可选<code>xrender</code>和<code>glx</code>，以及&#96;&#96;<br>如果要用自带的毛玻璃效果请使用cn源里的<code>picom-git</code>并开启experimental-backends。然后在i3的<code>config</code>设置里面也加上<code>picom --experimental-backends</code></p><h3 id="i3lock-color锁屏"><a href="#i3lock-color锁屏" class="headerlink" title="i3lock-color锁屏"></a>i3lock-color锁屏</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yay -S i3lock-color<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="gtk主题配置"><a href="#gtk主题配置" class="headerlink" title="gtk主题配置"></a>gtk主题配置</h3><p>我用的是capitaine-cursors arc-gtk-theme。这个用lxappearance设置。</p><h3 id="HiDPI配置"><a href="#HiDPI配置" class="headerlink" title="HiDPI配置"></a>HiDPI配置</h3><p>大部分应用在<code>~/.Xresources</code>里面配置一下就可以了。但是polybar、rofi这几个都不吃</p><p>polybar</p><p>config里面</p><pre class="line-numbers language-none"><code class="language-none">dpi &#x3D; $&#123;xrdb:Xft.dpi:-1&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>rofi需要自己一点一点都调了，字体差不多16px，然后圆角和图标那都调大一点。绝大部分rofi主题都是1080p的，要自己调大小。</p><h2 id="KISS"><a href="#KISS" class="headerlink" title="KISS"></a>KISS</h2><blockquote><p>Keep it simple, stupid</p></blockquote><p>现在越来越喜欢简单的东西了</p><blockquote><p>keep it sufficiently sophisticated</p></blockquote><h2 id="其他的选择"><a href="#其他的选择" class="headerlink" title="其他的选择"></a>其他的选择</h2><p>1.Wayland</p><p>I use Nvidia…., so Nvidia f**k</p><p>最近某些媒体宣称KDE+Wayland+Nvidia已经差不多了，然而前几天我试了一下KDE的wayland还是有不少小问题的。暂时没有什么迁移到wayland的动力。而且不少应用在xwayland下面的HiDPI体验不是很好。最重要的是alacritty这个东西，在wayland会卡。而我现在对</p><p>2.Sway</p><p>原因Wayland，我用Nvidia显卡。<br>Sway现在输入法问题基本可以了，剩下的是xwayland在HiDPI有一点不清晰和一部分x的应用我比较习惯所以暂时不打算迁移到wayland</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N3YXl3bS9zd2F5L3B1bGwvNDc0MA==">https://github.com/swaywm/sway/pull/4740<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZjaXR4L2ZjaXR4NS9pc3N1ZXMvMzk=">https://github.com/fcitx/fcitx5/issues/39<i class="fa fa-external-link-alt"></i></span></p><p>3.Wayfire</p><p>Wayland的原因同上。<br>Wayfire主要还是堆叠窗口的操作，特效和流畅程度看宣传和演示视频可能是Wayland里面最棒的一个了，响应丝滑、特效也很棒。<br>不过Wayfire的那些炫酷的桌面效果我不太想用，我自己大概有blur和活动窗口变亮一点就可以了。<br>Wayfire关掉点特效用来做平铺和堆叠的混合桌面应该不错。因为像i3等对堆叠窗口的操作没有那么丰富，比如堆叠窗口只能放在平铺窗口的上面。</p><p>Wayfire目前是0.7版本，最近我看到依云在试水，HiDPI和输入法的问题patch得差不多了，我再等等吧。等1.0正式版，我迁移到Wayland和Wayfire。</p><ol start="4"><li>KDE的平铺选择？</li></ol><p>如果你对平铺操作的要求不太高，那么KDE自带的快捷键差不多就够了，如果要更多功能，推荐<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Jpc211dGgtRm9yZ2UvYmlzbXV0aA==">bismuth<i class="fa fa-external-link-alt"></i></span></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><span class="exturl" data-url="aHR0cHM6Ly90Lm1lL0FyY2hDTktERVZTR05PTUU=">迫害GNOME的频道<i class="fa fa-external-link-alt"></i></span> （仅供娱乐）<br><span class="exturl" data-url="aHR0cHM6Ly9pbnZlbnQua2RlLm9yZy9wbGFzbWEva3dpbi8tL21lcmdlX3JlcXVlc3RzLzEwODg=">https://invent.kde.org/plasma/kwin/-/merge_requests/1088<i class="fa fa-external-link-alt"></i></span> KDE在这个Merge移除了XRender混成器<br><span class="exturl" data-url="aHR0cHM6Ly9tYWlsLmtkZS5vcmcvcGlwZXJtYWlsL2t3aW4vMjAyMS1KdW5lLzAwNTIzMi5odG1s">https://mail.kde.org/pipermail/kwin/2021-June/005232.html<i class="fa fa-external-link-alt"></i></span> 讨论移除XRender的邮件列表<br><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2tkZS9jb21tZW50cy9xYW1sZmQvd2FzX3hyZW5kZXJfY29tcG9zaXRvcl9yZW1vdmVkX2luX3BsYXNtYV81MjMv">https://www.reddit.com/r/kde/comments/qamlfd/was_xrender_compositor_removed_in_plasma_523/<i class="fa fa-external-link-alt"></i></span> reddit上的移除XRender受害者（这位是i卡，不是N卡）</p><p>Vulkan<br><span class="exturl" data-url="aHR0cDovL2Jsb2cuZGF2aWRlZG11bmRzb24uY28udWsvYmxvZy9ydW5uaW5nLXBsYXNtYXNoZWxsLXdpdGgtdnVsa2FuLw==">http://blog.davidedmundson.co.uk/blog/running-plasmashell-with-vulkan/<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tERS9rd2luL2NvbW1pdC84MTFiZWI5NGUwYTdkZDU2NjY5MDZiMDdhNTFhODRlZmU1ZjFiYjUz">https://github.com/KDE/kwin/commit/811beb94e0a7dd5666906b07a51a84efe5f1bb53<i class="fa fa-external-link-alt"></i></span></p><p>Nvidia的问题（不是很懂为什么移除xrender）<br><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVkZGl0LmNvbS9yL2tkZS9jb21tZW50cy9xc2t2cjEvc2NyZWVuX2ZsaWNrZXJfcHJvYmxlbV93aXRoXzE0NGh6X29uX2tkZV9uZW9uX2FueS8=">https://www.reddit.com/r/kde/comments/qskvr1/screen_flicker_problem_with_144hz_on_kde_neon_any/<i class="fa fa-external-link-alt"></i></span></p><p>i3wm配置参考：</p><p><span class="exturl" data-url="aHR0cHM6Ly96anV5ay5naXRsYWIuaW8vcG9zdHMvaTN3bS1jb25maWcv">I3wm 配置思路<i class="fa fa-external-link-alt"></i></span></p><p>Polybar配置：</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FkaTEwOTB4L3BvbHliYXItdGhlbWVz">https://github.com/adi1090x/polybar-themes<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这样又将一部分鼠标干的活还给了键盘。&lt;/p&gt;</summary>
    
    
    
    
    <category term="KDE" scheme="https://zhangjk98.xyz/tags/KDE/"/>
    
    <category term="i3wm" scheme="https://zhangjk98.xyz/tags/i3wm/"/>
    
    <category term="kiss" scheme="https://zhangjk98.xyz/tags/kiss/"/>
    
  </entry>
  
  <entry>
    <title>又被Docker坑了（其实是被Yaml坑了</title>
    <link href="https://zhangjk98.xyz/aware-docker-yaml/"/>
    <id>https://zhangjk98.xyz/aware-docker-yaml/</id>
    <published>2021-11-08T11:50:24.000Z</published>
    <updated>2021-11-08T11:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>大聪明yaml将60以下的数字识别成60进制，所以需要用引号括起来。自作聪明程度直追Excel将身份证号识别成科学计数法然后直接末尾四位变零。<br>珍爱生命，远离yaml  </p><p>更新：发现了一个网站：<span class="exturl" data-url="aHR0cHM6Ly9ub3lhbWwuY29tLw==">https://noyaml.com/<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;大聪明yaml将60以下的数字识别成60进制，所以需要用引号括起来。自作聪明程度直追Excel将身份证号识别成科学计数法然后直接末尾四位变零。&lt;br&gt;珍爱生命，远离yaml  &lt;/p&gt;
&lt;p&gt;更新：发现了一个网站：&lt;span class=&quot;exturl&quot; data-url=</summary>
      
    
    
    
    
    <category term="Docker" scheme="https://zhangjk98.xyz/tags/Docker/"/>
    
    <category term="yaml" scheme="https://zhangjk98.xyz/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>Hackergame 2021 (中科大信安赛) Write Up</title>
    <link href="https://zhangjk98.xyz/hackergame-2021-write-up/"/>
    <id>https://zhangjk98.xyz/hackergame-2021-write-up/</id>
    <published>2021-10-30T04:00:01.000Z</published>
    <updated>2021-10-30T04:00:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>吃瓜群众第一次参赛，从LUG过来的，打酱油路过，没学过信安和密码学，然而很遗憾，跟Linux有关的那几个题全都没做出来。。。。<br>很意外自己能挤进200名的，事前完全没有准备，也没接触过CTF之类的东西，甚至比赛开始3天，进行到一半了我才突然发现这比赛它已经开始了，如果早知道 p😭q<br>对，今年这个Hackergame就是UTF-8比赛，对萌新可友好了（确信  </p><span id="more"></span><p>周二还在想今年中科大信安赛是不是要开始了，结果一看已经进行一半了，来划个水吧。由于太菜加上懒，math零蛋，只能流下数理基础不扎实的泪水p😭q 。 </p><p>作为一个纯萌新和老废物，第一次参加Hackergame，以前看到他们中科大LUG办的，就想着下次举办去参加一下玩。以前看到好多Web题和有意思的小题目，虽然我js也特别菜，好歹还能挣扎一下。结果几年一打开就是一堆binary糊脸，二进制和逆向pwm之类的完全不懂，罢了，就做点General吧。</p><p>结果？？？？进前200了？</p><p><img src="/hackergame-2021-write-up/image-20211030121230343.png" alt="image-20211030121230343"></p><p>看来Hackergame真的是萌新友好，明年一定再来玩。</p><h2 id="做出了来的的小题目"><a href="#做出了来的的小题目" class="headerlink" title="做出了来的的小题目"></a>做出了来的的小题目</h2><p>还是有不少对我很友好的题目的</p><h3 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h3><blockquote><p>为了能让大家顺利签到，命题组把每一秒的 flag 都记录下来制成了日记本的一页。你只需要打开日记，翻到 Hackergame 2021 比赛进行期间的任何一页就能得到 flag！</p></blockquote><p>打开题目，秒是从1970年开始计算的，这就是UNIX时间戳呗。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">date</span> +%s<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到<code>1635213339</code>，修改URL后缀，得到<code>flag&#123;HappyHacking2021-b0e5f6c9af&#125;</code>签到成功</p><h3 id="进制十六——参上"><a href="#进制十六——参上" class="headerlink" title="进制十六——参上"></a>进制十六——参上</h3><p>首先我们OCR识别一下</p><pre class="line-numbers language-none"><code class="language-none">456163682068657861646563696D616C20646967697420726570726573656E747320666F75722062697473202862696E61727920646967697473292C20616C736F206B6E6F776E2061732061206E6962626C6520286F72206E7962626C65292C20776869636820697320312F32206F66206120627974652E20666C61677B5930555F5348305531445F6B6E30775F4830575F74305F43306E763372745F4845585F746F5F546578547D20466F72206578616D706C652C20612073696E676C6520627974652063616E20686176652076616C7565732072616E67696E672066726F6D20303030303030303020746F20313131313131313120696E2062696E61727920666F726D2C2077686963682063616E20626520636F6E76656E69656E746C7920726570726573656E74656420617320303020746F20464620696E2068657861646563696D616C2E000000000000000000000000000000000000000000000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个好办，打开Bless Hex Editor之类的Hex编辑器, flag的16进制是<code>66 6C 61 67</code>, 找到相应位置，得到flag为<code>flag&#123;Y0U_SH0U1D_kn0w_H0W_t0_C0nv3rt_HEX_to_TexT&#125;</code></p><h3 id="卖瓜"><a href="#卖瓜" class="headerlink" title="卖瓜"></a>卖瓜</h3><p>F12想直接修改放瓜数量为负是不可以的，我们没有办法放上一个负数或者小数的瓜</p><pre class="line-numbers language-none"><code class="language-none">&lt;p&gt;放上 6 斤的瓜 &lt;input type&#x3D;&quot;number&quot; class&#x3D;&quot;number&quot; name&#x3D;&quot;b6&quot; value&#x3D;&quot;0&quot; min&#x3D;&quot;0&quot;&gt; 个&lt;&#x2F;p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后开始填一个很大的数尝试溢出，果然。</p><p><img src="/hackergame-2021-write-up/image-20211026131723641-16352255218271.png" alt="image-20211026131723641"></p><p>然后就是打开WolframAlpha, 一边算一边试，试出了一个正好二十。</p><h3 id="旅行照片"><a href="#旅行照片" class="headerlink" title="旅行照片"></a>旅行照片</h3><p>一开始没什么头绪，但是看到左下角那个彩色方块的小房子实在是太显眼了，可能是什么地标建筑。我们以图搜图找一下呗。</p><p>Google搜图没有结果，TineEye也没有。算了算了，打开我最讨厌的百度（毕竟这可能是一个国内的位置）</p><p><span class="exturl" data-url="aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcGNwYWdlL3NpbWlsYXI/b3JpZ2luU2lnbj0xMjZjMGQ1YjgyZjIzMmYzMDY5YjkwMTYzNTMxMTc1OSZzcmNwPWNyc19wY19zaW1pbGFyJnRuPXBjJmlkY3RhZz1neiZzaWRzPTEwMDA3XzEwNTEyXzEwNTIxXzEwOTE0XzEwOTEzXzExMDA2XzEwOTI0XzEwOTA1XzEwMDE4XzEwOTAxXzEwOTQyXzEwOTA3XzExMDEyXzEwOTcwXzEwOTY4XzEwOTc0XzExMDMyXzE3ODUxXzE3MDcwXzE4MDEzXzE4MTAxXzE3MjAwXzE3MjAyXzE4MzAxXzE4MzExXzE4MzMwXzE5MzAwXzE5MTkxXzE5MTYyXzE5MjIwXzE5MjEwXzE5MjEyXzE5MjE0XzE5MjE3XzE5MjE5XzE5MjU2XzE5MjMwXzE5MjY4XzE5MjgwXzE5NTUwXzE5NjcwXzEwMDAwJmxvZ2lkPTI0Mzg0MjcwMDgmZW50cmFuY2U9Z2VuZXJhbCZ0cGxfZnJvbT1wYyZwYWdlRnJvbT1ncmFwaF91cGxvYWRfcGNzaGl0dSZpbWFnZT1odHRwOi8vaW1nMS5iYWlkdS5jb20vaXQvdT0zODI1MzQwMjIwLDkyNzYwNTA0NiZmbT0yNTMmYXBwPTEzOCZmPUpQRUc/dz02NDAmaD00ODAmY2Fyb3VzZWw9NTAzJmluZGV4PTEmcGFnZT0xJnNoaXR1VG9rZW49YzkyM2Qz">百度搜图的结果<i class="fa fa-external-link-alt"></i></span></p><p><span class="exturl" data-url="aHR0cHM6Ly9ncmFwaC5iYWlkdS5jb20vcGNwYWdlL3NpbWlsYXI/b3JpZ2luU2lnbj0xMjZjMGQ1YjgyZjIzMmYzMDY5YjkwMTYzNTMxMTc1OSZzcmNwPWNyc19wY19zaW1pbGFyJnRuPXBjJmlkY3RhZz1neiZzaWRzPTEwMDA3XzEwNTEyXzEwNTIxXzEwOTE0XzEwOTEzXzExMDA2XzEwOTI0XzEwOTA1XzEwMDE4XzEwOTAxXzEwOTQyXzEwOTA3XzExMDEyXzEwOTcwXzEwOTY4XzEwOTc0XzExMDMyXzE3ODUxXzE3MDcwXzE4MDEzXzE4MTAxXzE3MjAwXzE3MjAyXzE4MzAxXzE4MzExXzE4MzMwXzE5MzAwXzE5MTkxXzE5MTYyXzE5MjIwXzE5MjEwXzE5MjEyXzE5MjE0XzE5MjE3XzE5MjE5XzE5MjU2XzE5MjMwXzE5MjY4XzE5MjgwXzE5NTUwXzE5NjcwXzEwMDAwJmxvZ2lkPTI0Mzg0MjcwMDgmZW50cmFuY2U9Z2VuZXJhbCZ0cGxfZnJvbT1wYyZwYWdlRnJvbT1ncmFwaF91cGxvYWRfcGNzaGl0dSZpbWFnZT1odHRwOi8vaW1nMi5iYWlkdS5jb20vaXQvdT0zMjUxMjkwNzY1LDE0NjUyMzc0ODkmZm09MjUzJmFwcD0xMzgmZj1KUEVHP3c9MjQ5Jmg9MjQ5JmNhcm91c2VsPTUwMyZpbmRleD01JnBhZ2U9MSZzaGl0dVRva2VuPTlkMDk3OA==">百度搜图的结果<i class="fa fa-external-link-alt"></i></span></p><p>搜到了，是秦皇岛西浴场。这个彩色方块的小房子是海边的救助亭。</p><p>秦皇岛西沙滩，附近有酒店和KFC，而且旁边就是海，应该就是这里了。</p><p>旁边甚至还有一个停车场。和一个秦皇岛国际大酒店（最后根据位置发现酒店应该不是这个）</p><p>然后查找一下周围的KFC（这种事情应该让馒狗来），果不其然有一个网红Tiffany KFC,一群人在小红书打卡。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cueGlhb2hvbmdzaHUuY29tL2Rpc2NvdmVyeS9pdGVtLzVlOTZjOTE5MDAwMDAwMDAwMTAwNTdjMQ==">https://www.xiaohongshu.com/discovery/item/5e96c91900000000010057c1<i class="fa fa-external-link-alt"></i></span></p><p>高德地图上可以找到电话：0335-7168800</p><p>大众点评的照片上可以看到左侧建筑的三个字为：<strong>海豚馆</strong></p><p><span class="exturl" data-url="aHR0cDovL3d3dy5kaWFucGluZy5jb20vc2hvcC8yNDQzNDA4Nw==">http://www.dianping.com/shop/24434087<i class="fa fa-external-link-alt"></i></span></p><p>从地图上看可能是东南方向，从阳光照射方向看可能是傍晚。</p><p>然后就剩下了楼层数，大概有15、16层左右的样子，随便试几个。结果是16，好的，得到flag</p><h3 id="去吧！追寻自由的电波"><a href="#去吧！追寻自由的电波" class="headerlink" title="去吧！追寻自由的电波"></a>去吧！追寻自由的电波</h3><p>这个是我精通八门乐器的校艺术团室友秒掉的，听了一遍就说修改采样率（大概从48000调到了18000的样子），就可以听到正常的声音了。<br>是一串北约音标字母。</p><p>真好，虽然找不到中科大少年班的神通口算口算RSA，但是我有精通乐理的室友。</p><h3 id="喵咪问答-Pro-Max"><a href="#喵咪问答-Pro-Max" class="headerlink" title="喵咪问答 Pro Max"></a>喵咪问答 Pro Max</h3><p>这个没啥好说的，Google搜就完事了（已经关闭的网站看Web Archive的快照就好了）</p><p>report地址是<code>/dev/null</code>可还行</p><h3 id="图之上的信息"><a href="#图之上的信息" class="headerlink" title="图之上的信息"></a>图之上的信息</h3><p>graphql查询，这个也比较简单，没做什么严格的限制去卡你，直接查就完事了</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    user(id<span class="token operator">:</span><span class="token number">1</span>)<span class="token punctuation">&#123;</span>        username        privateEmail    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>url接口是<code>/graphql?query=&#123;.....&#125;</code>, 会得到一个：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span><span class="token property">"data"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token property">"user"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token property">"username"</span><span class="token operator">:</span><span class="token string">"admin"</span><span class="token punctuation">,</span><span class="token property">"privateEmail"</span><span class="token operator">:</span><span class="token string">"flag&#123;dont_let_graphql_l3ak_data_dad4053dd4@hackergame.ustc&#125;"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>收工。。。</p><h3 id="Amnesia-轻度失忆（第一个flag）"><a href="#Amnesia-轻度失忆（第一个flag）" class="headerlink" title="Amnesia 轻度失忆（第一个flag）"></a>Amnesia 轻度失忆（第一个flag）</h3><blockquote><p>编译后 ELF 文件的 .data 和 .rodata 段会被清零。</p></blockquote><p>唯一整出来的binary题目（避免了binary和math双双爆零的惨状），虽然这个好像也不算binary，更像是在考我编译原理。使劲浑身解数。。。。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;malloc.h></span></span><span class="token keyword">char</span> <span class="token operator">*</span> hello<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    hello <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'H'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'e'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'l'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'l'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'o'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">','</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">' '</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'w'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'o'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'r'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'l'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'d'</span><span class="token punctuation">;</span>    hello<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'!'</span><span class="token punctuation">;</span>    <span class="token keyword">asm</span> <span class="token keyword">volatile</span> <span class="token punctuation">(</span>    <span class="token string">"mov $4,%eax;"</span>    <span class="token string">"mov $1,%ebx;"</span>    <span class="token string">"mov hello ,%ecx;"</span>    <span class="token string">"mov $13,%edx;"</span>    <span class="token string">"int $0x80"</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//free(hello);</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有个小问题是它会内存泄漏，但是想不出什么更好的解答了。</p><h3 id="赛博厨房"><a href="#赛博厨房" class="headerlink" title="赛博厨房"></a>赛博厨房</h3><p>level0 简单，level1 也简单，就是实现一个循环呗。</p><p>剩下两个给我整不会了，人都傻了。</p><h3 id="p😭q"><a href="#p😭q" class="headerlink" title="p😭q"></a>p😭q</h3><p>我也不知道这道题何德何能排在倒数第三个，甚至还有400分的分值。在学了信号与系统、数字信号处理、数字图像处理、生物医学信号处理的我看来，这应该属于送分题。（不过之前都是用matlab做的，python的库都没用过）</p><p>先将gif每一帧转成图像再转成numpy的array再转成一维数组得到功率谱，傅立叶反变换回去得到音频信号……</p><p>等等。。。。它只有功率谱的幅度没有相位信息我可怎么恢复。难道要我猜一个相位吗？</p><p>搜了一下librosa，有一个自带的恢复库，用的是一个迭代估计的算法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> PIL <span class="token keyword">import</span> Image<span class="token punctuation">,</span> ImageSequence<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> librosa<span class="token keyword">import</span> soundfile <span class="token keyword">as</span> sfsample_rate <span class="token operator">=</span> <span class="token number">22050</span>num_freqs <span class="token operator">=</span> <span class="token number">32</span>quantize <span class="token operator">=</span> <span class="token number">2</span>min_db <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">60</span>max_db <span class="token operator">=</span> <span class="token number">30</span>fft_window_size <span class="token operator">=</span> <span class="token number">2048</span>frame_step_size <span class="token operator">=</span> <span class="token number">512</span>window_function_type <span class="token operator">=</span> <span class="token string">'hann'</span>im <span class="token operator">=</span> Image<span class="token punctuation">.</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'flag.gif'</span><span class="token punctuation">)</span><span class="token builtin">iter</span> <span class="token operator">=</span> ImageSequence<span class="token punctuation">.</span>Iterator<span class="token punctuation">(</span>im<span class="token punctuation">)</span>index <span class="token operator">=</span> <span class="token number">1</span>spec <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">for</span> frame <span class="token keyword">in</span> <span class="token builtin">iter</span><span class="token punctuation">:</span>    <span class="token comment"># print("image %d: mode %s, size %s" % (index, frame.mode, frame.size))</span>    frame<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">"./imgs/frame%d.png"</span> <span class="token operator">%</span> index<span class="token punctuation">)</span>    index <span class="token operator">+=</span> <span class="token number">1</span>    image_arr <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>frame<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token builtin">int</span><span class="token punctuation">)</span>    image_list <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span>image_arr<span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># print(image_list)</span>    image_list <span class="token operator">=</span> image_list<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>    <span class="token comment"># print(image_list)</span>    <span class="token comment"># print(image_list.shape)</span>    spec <span class="token operator">=</span> np<span class="token punctuation">.</span>vstack<span class="token punctuation">(</span><span class="token punctuation">(</span>spec<span class="token punctuation">,</span> image_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>spec<span class="token punctuation">)</span>np<span class="token punctuation">.</span>savetxt<span class="token punctuation">(</span><span class="token string">'output1.txt'</span><span class="token punctuation">,</span> spec<span class="token punctuation">,</span> fmt<span class="token operator">=</span><span class="token string">"%d"</span><span class="token punctuation">)</span>spec <span class="token operator">=</span> np<span class="token punctuation">.</span>delete<span class="token punctuation">(</span>spec<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>melspectrogram <span class="token operator">=</span> librosa<span class="token punctuation">.</span>db_to_power<span class="token punctuation">(</span>spec<span class="token punctuation">.</span>T<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token comment"># print(melspectrogram.shape)</span>audio_signal <span class="token operator">=</span> librosa<span class="token punctuation">.</span>feature<span class="token punctuation">.</span>inverse<span class="token punctuation">.</span>mel_to_audio<span class="token punctuation">(</span>    melspectrogram<span class="token punctuation">,</span>    n_iter<span class="token operator">=</span><span class="token number">32</span><span class="token punctuation">,</span>    sr<span class="token operator">=</span>sample_rate<span class="token punctuation">,</span>    n_fft<span class="token operator">=</span>fft_window_size<span class="token punctuation">,</span>    hop_length<span class="token operator">=</span>frame_step_size<span class="token punctuation">,</span>    window<span class="token operator">=</span>window_function_type<span class="token punctuation">)</span><span class="token comment"># print(audio_signal, audio_signal.shape)</span>sf<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'test.wav'</span><span class="token punctuation">,</span> audio_signal<span class="token punctuation">,</span> sample_rate<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>好的，秒了。（怎么有种回到本科写课堂作业的感觉）</p><p>声音是有了，但是这个相位好像还是不太对的样子。我超，回声不绝于耳。。。</p><p>调一下参数，让他多迭代几轮<code>n_iter=8192,</code>，行了，现在清晰度有个高中大喇叭放英语早读听力的样子。</p><p><strong>衬衫的价格是九磅十五便士，现在你有十秒钟时间，将Flag填到输入框上</strong>…….</p><h2 id="看起来有点头绪但是没做的题目"><a href="#看起来有点头绪但是没做的题目" class="headerlink" title="看起来有点头绪但是没做的题目"></a>看起来有点头绪但是没做的题目</h2><p>懒癌又犯了，周六休息一会，周五天气太好了，还有其他事情要做，算了</p><h3 id="Easy-RSA"><a href="#Easy-RSA" class="headerlink" title="Easy RSA"></a>Easy RSA</h3><p>由于我找不到中科大少年班的神通，而我自己的数论还停留在高中水平（当年数竞还过了校队选拔，然后上来就听了好几节数论和组合，直接退出了（后悔，现在就是非常后悔））</p><p>只能找山大网安的大二学弟来帮帮我看看这个密码学的问题，问问这种形式该怎么解(已知n, p, q, c)</p><p>$$<br>a^n mod(p*q) &#x3D; c<br>$$</p><p>他当场就给我秒了，还随手写了3页。</p><p>然后问题是怎么跑出这个p来，这次学弟也没什么好办法了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    x <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span>    y <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span>    value_p <span class="token operator">=</span> sympy<span class="token punctuation">.</span>nextprime<span class="token punctuation">(</span><span class="token punctuation">(</span>math<span class="token punctuation">.</span>factorial<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span>                              x<span class="token punctuation">)</span>  <span class="token comment"># Hint：这里直接计算会溢出，请你仔细观察 x 和 y 的特征</span>    <span class="token keyword">return</span> value_p<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一开始我是这样跑的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">x <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span>y <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span><span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token builtin">sum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token operator">*</span>i<span class="token punctuation">)</span> <span class="token operator">%</span> x    <span class="token comment"># print(sum)</span>    <span class="token keyword">if</span> <span class="token builtin">sum</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sum的值是"</span><span class="token punctuation">,</span> <span class="token builtin">sum</span><span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sum的值是"</span><span class="token punctuation">,</span> <span class="token builtin">sum</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果一跑就是一天，看到我的5600g只有1个CPU在跑，我决定整个multiprocessing（本来想用Golang整一个，但是Golang的数值计算库不太行，还得去用那个难用的<code>math/big</code>包）</p><p>结果再次发现，甚至上了multiprocessing，反而更慢了。</p><p>于是我决定搜一下，结果就找到了这个网站的两种算法：<span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvY29tcHV0ZS1uLXVuZGVyLW1vZHVsby1wLw==">Compute n! under modulo p<i class="fa fa-external-link-alt"></i></span></p><p>哦，有个复杂度$O((p-n)*Logn)$的算法</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># Python3 program to comput</span><span class="token comment"># n! % p using Wilson's Theorem</span><span class="token comment"># Utility function to do modular</span><span class="token comment"># exponentiation. It returns (x^y) % p</span><span class="token keyword">def</span> <span class="token function">power</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>    res <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># Initialize result</span>    x <span class="token operator">=</span> x <span class="token operator">%</span> p  <span class="token comment"># Update x if it is more</span>    <span class="token comment"># than or equal to p</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>y <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment"># If y is odd, multiply</span>        <span class="token comment"># x with result</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">%</span> p        <span class="token comment"># y must be even now</span>        y <span class="token operator">=</span> y <span class="token operator">>></span> <span class="token number">1</span>  <span class="token comment"># y = y/2</span>        x <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token operator">%</span> p    <span class="token keyword">return</span> res<span class="token comment"># Function to find modular inverse</span><span class="token comment"># of a under modulo p using Fermat's</span><span class="token comment"># method. Assumption: p is prime</span><span class="token keyword">def</span> <span class="token function">modInverse</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> power<span class="token punctuation">(</span>a<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token comment"># Returns n! % p using</span><span class="token comment"># Wilson's Theorem</span><span class="token keyword">def</span> <span class="token function">modFact</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># n! % p is 0 if n >= p</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token number">0</span>    <span class="token comment"># Initialize result as (p-1)!</span>    <span class="token comment"># which is -1 or (p-1)</span>    res <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># Multiply modulo inverse of</span>    <span class="token comment"># all numbers from (n+1) to p</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">*</span> modInverse<span class="token punctuation">(</span>i<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> p    <span class="token keyword">return</span> res<span class="token comment"># Driver code</span>x <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451</span>y <span class="token operator">=</span> <span class="token number">11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439</span><span class="token comment"># y = 10</span>n <span class="token operator">=</span> yp <span class="token operator">=</span> x<span class="token keyword">print</span><span class="token punctuation">(</span>modFact<span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># This code is contributed by ihritik</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>只用了1分钟</strong>就跑了出来。这算法好强！</p><p>我把这个做法发给学弟，学弟表示：</p><p>“可以，回头我看看”<br>“<strong>我比较关心这个是怎么构造出来和怎么证明的</strong>”<br>“<strong>初等数论比较巧妙</strong>”<br>“<strong>可以看一下</strong>”  </p><p>听完学弟的话，接下来的内容我不太想做了。<br>我这样数理基础不扎实的菜狗（尤其是数论，一窍不通），做出来也<strong>改变不了我是个数论白痴的事实</strong>。都是些trival的东西了，<strong>有这个时间折腾这些应该去系统的补习一下数论</strong>。</p><h3 id="拼多多砍一刀"><a href="#拼多多砍一刀" class="headerlink" title="拼多多砍一刀"></a>拼多多砍一刀</h3><p>FLAG 助力大红包，这个东西应该挂一个爬虫代理池能做。但是这个方法好像太暴力了点，而且我不想再爬东西了，免费的那几个IP池都不太好用，要钱的又不想掏钱。</p><h3 id="minecraft"><a href="#minecraft" class="headerlink" title="minecraft"></a>minecraft</h3><p>随便乱走亮了两盏灯，还有一盏。看起来应该F12找找线索，有一个flag.js的东西，但是它一堆16进制的变量和函数名，看起来挺费劲，算了，不看了。</p><h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>应该就是根据奇偶校验和他给的打码过程的那个python文件。上一次做二维码和奇偶校验的东西还是大二上数字电路的时候。</p><p>看起来像是第十版二维码，结果打开qrazybox想手动修复一下最高只有ver.9</p><p>然后写了十几行发现好像这个东西要枚举遍历？？可能的二维码团还不止一种。（不知道是不是我漏了什么条件，但看起来还原出来确实不止一种）</p><p>周五周六天气真好，成都难得出太阳，不做了，出去玩。</p><h2 id="以为会做然而被乱杀到怀疑人生的题"><a href="#以为会做然而被乱杀到怀疑人生的题" class="headerlink" title="以为会做然而被乱杀到怀疑人生的题"></a>以为会做然而被乱杀到怀疑人生的题</h2><h3 id="Amnsia记忆清除"><a href="#Amnsia记忆清除" class="headerlink" title="Amnsia记忆清除"></a>Amnsia记忆清除</h3><p>抹除掉ELF文件的<code>.text</code>段，完全不会</p><h3 id="LUKS"><a href="#LUKS" class="headerlink" title="LUKS"></a>LUKS</h3><p>就觉得我这么长时间的Linux白用了，整不出来。我只会hashcat爆破，Hashcat爆破又没啥意思，算了，放弃。</p><h3 id="RAID修复"><a href="#RAID修复" class="headerlink" title="RAID修复"></a>RAID修复</h3><p>文件系统白学了，直接不会，白给。RAID-0做不出来，RAID-5也做不出来。</p><h3 id="赛博厨房后两问"><a href="#赛博厨房后两问" class="headerlink" title="赛博厨房后两问"></a>赛博厨房后两问</h3><p>直接人都傻了，找不到规律，根本找不到。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>现在是周六中午12点，总排名187&#x2F;2679，很幸运没有掉出200名。</p><blockquote><p>当前分数：1600， 总排名：187 &#x2F; 2679<br>binary：150 ， general：1050 ， math：0 ， web：400</p></blockquote><p>今年是第一次参见Hackergame，玩的很开心。binary的题比往年多了很多，不过我一个都不会，好在有个打印<code>Hello, world!</code>的题，很幸运没有爆零。  </p><p>当然，general和web题还是给了我一点信心，让我有种我上我也行的感觉，不过打开排行榜看到mcfx乱秒的样子，嗯，我是傻逼。</p><p>主要感想就是数理基础太差，数论是真的是一窍不通，这几个月正好有空，准备去恶补一下数学。    </p><p>当然进前100名和CTF师傅们以及天神下凡的mcfx合影留念是无望了，明年再来玩耍吧。欢度周末去了，再见。   </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;吃瓜群众第一次参赛，从LUG过来的，打酱油路过，没学过信安和密码学，然而很遗憾，跟Linux有关的那几个题全都没做出来。。。。&lt;br&gt;很意外自己能挤进200名的，事前完全没有准备，也没接触过CTF之类的东西，甚至比赛开始3天，进行到一半了我才突然发现这比赛它已经开始了，如果早知道 p😭q&lt;br&gt;对，今年这个Hackergame就是UTF-8比赛，对萌新可友好了（确信  &lt;/p&gt;</summary>
    
    
    
    <category term="不务正业系列" scheme="https://zhangjk98.xyz/categories/%E4%B8%8D%E5%8A%A1%E6%AD%A3%E4%B8%9A%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="hackergame" scheme="https://zhangjk98.xyz/tags/hackergame/"/>
    
    <category term="UTF-8" scheme="https://zhangjk98.xyz/tags/UTF-8/"/>
    
  </entry>
  
</feed>
